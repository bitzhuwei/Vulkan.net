using System;
using System.Runtime.InteropServices;

// hand-coded.
using VkAndroidSurfaceCreateFlagsKHR = System.UInt32;
using VkBufferViewCreateFlags = Vulkan.VkFlags;
using VkDescriptorUpdateTemplateCreateFlags = Vulkan.VkFlags;
using VkDeviceCreateFlags = Vulkan.VkFlags;
using VkEventCreateFlags = Vulkan.VkFlags;
using VkFramebufferCreateFlags = Vulkan.VkFlags;
using VkImageViewCreateFlags = Vulkan.VkFlags;
using VkInstanceCreateFlags = Vulkan.VkFlags;
using VkPipelineCacheCreateFlags = Vulkan.VkFlags;
using VkPipelineColorBlendStateCreateFlags = Vulkan.VkFlags;
using VkPipelineCoverageModulationStateCreateFlagsNV = Vulkan.VkFlags;
using VkPipelineCoverageToColorStateCreateFlagsNV = Vulkan.VkFlags;
using VkPipelineDepthStencilStateCreateFlags = Vulkan.VkFlags;
using VkPipelineDiscardRectangleStateCreateFlagsEXT = Vulkan.VkFlags;
using VkPipelineDynamicStateCreateFlags = Vulkan.VkFlags;
using VkPipelineInputAssemblyStateCreateFlags = Vulkan.VkFlags;
using VkPipelineLayoutCreateFlags = Vulkan.VkFlags;
using VkPipelineMultisampleStateCreateFlags = Vulkan.VkFlags;
using VkPipelineRasterizationConservativeStateCreateFlagsEXT = Vulkan.VkFlags;
using VkPipelineRasterizationDepthClipStateCreateFlagsEXT = Vulkan.VkFlags;
using VkPipelineRasterizationStateCreateFlags = Vulkan.VkFlags;
using VkPipelineRasterizationStateStreamCreateFlagsEXT = Vulkan.VkFlags;
using VkPipelineShaderStageCreateFlags = Vulkan.VkFlags;
using VkPipelineTessellationStateCreateFlags = Vulkan.VkFlags;
using VkPipelineVertexInputStateCreateFlags = Vulkan.VkFlags;
using VkPipelineViewportStateCreateFlags = Vulkan.VkFlags;
using VkPipelineViewportSwizzleStateCreateFlagsNV = Vulkan.VkFlags;
using VkQueryPoolCreateFlags = Vulkan.VkFlags;
using VkRenderPassCreateFlags = Vulkan.VkFlags;
using VkSamplerCreateFlags = Vulkan.VkFlags;
using VkSemaphoreCreateFlags = Vulkan.VkFlags;
using VkShaderModuleCreateFlags = Vulkan.VkFlags;
using VkValidationCacheCreateFlagsEXT = Vulkan.VkFlags;
using VkQueryResultFlags = Vulkan.VkFlags;
using VkStencilFaceFlags = Vulkan.VkFlags;
using VkMemoryRequirements2KHR = Vulkan.VkMemoryRequirements2;
using VkPeerMemoryFeatureFlags = Vulkan.VkFlags;
using HANDLE = System.IntPtr;
using VkMemoryMapFlags = Vulkan.VkFlags;
using VkCommandBufferResetFlags = Vulkan.VkFlags;
using VkCommandPoolResetFlags = Vulkan.VkFlags;
using VkDescriptorPoolResetFlags = Vulkan.VkFlags;
using VkCommandPoolTrimFlags = Vulkan.VkFlags;
//
using HINSTANCE = System.IntPtr;
using HWND = System.IntPtr;
using LPCWSTR = System.IntPtr;
using DWORD = System.UInt32;
using VkIOSSurfaceCreateFlagsMVK = System.UInt32;
using VkImagePipeSurfaceCreateFlagsFUCHSIA = System.UInt32;
using zx_handle_t = System.IntPtr;
using VkMacOSSurfaceCreateFlagsMVK = System.UInt32;
using VkMetalSurfaceCreateFlagsEXT = System.UInt32;
using GgpFrameToken = System.IntPtr;
using VkStreamDescriptorSurfaceCreateFlagsGGP = System.UInt32;
using GgpStreamDescriptor = System.IntPtr;
using HMONITOR = System.IntPtr;
using VkViSurfaceCreateFlagsNN = System.UInt32;
using VkWaylandSurfaceCreateFlagsKHR = System.UInt32;
//
// Generated by FlagsParser.
using VkAccessFlags = Vulkan.VkAccessFlagBits;
using VkAttachmentDescriptionFlags = Vulkan.VkAttachmentDescriptionFlagBits;
using VkBufferCreateFlags = Vulkan.VkBufferCreateFlagBits;
using VkBufferUsageFlags = Vulkan.VkBufferUsageFlagBits;
// VkBufferViewCreateFlags - Reserved for future use
using VkBuildAccelerationStructureFlagsNV = Vulkan.VkBuildAccelerationStructureFlagBitsNV;
using VkColorComponentFlags = Vulkan.VkColorComponentFlagBits;
using VkCommandBufferUsageFlags = Vulkan.VkCommandBufferUsageFlagBits;
using VkCommandPoolCreateFlags = Vulkan.VkCommandPoolCreateFlagBits;
// VkCommandPoolTrimFlags - Reserved for future use
using VkCompositeAlphaFlagsKHR = Vulkan.VkCompositeAlphaFlagBitsKHR;
using VkConditionalRenderingFlagsEXT = Vulkan.VkConditionalRenderingFlagBitsEXT;
using VkCullModeFlags = Vulkan.VkCullModeFlagBits;
using VkDebugReportFlagsEXT = Vulkan.VkDebugReportFlagBitsEXT;
using VkDebugUtilsMessageSeverityFlagsEXT = Vulkan.VkDebugUtilsMessageSeverityFlagBitsEXT;
using VkDebugUtilsMessageTypeFlagsEXT = Vulkan.VkDebugUtilsMessageTypeFlagBitsEXT;
using VkDependencyFlags = Vulkan.VkDependencyFlagBits;
using VkDescriptorBindingFlagsEXT = Vulkan.VkDescriptorBindingFlagBitsEXT;
using VkDescriptorPoolCreateFlags = Vulkan.VkDescriptorPoolCreateFlagBits;
// VkDescriptorPoolResetFlags - Reserved for future use
using VkDescriptorSetLayoutCreateFlags = Vulkan.VkDescriptorSetLayoutCreateFlagBits;
// VkDescriptorUpdateTemplateCreateFlags - Reserved for future use
// VkDeviceCreateFlags - Reserved for future use
using VkDeviceGroupPresentModeFlagsKHR = Vulkan.VkDeviceGroupPresentModeFlagBitsKHR;
using VkDeviceQueueCreateFlags = Vulkan.VkDeviceQueueCreateFlagBits;
using VkDisplayPlaneAlphaFlagsKHR = Vulkan.VkDisplayPlaneAlphaFlagBitsKHR;
// VkEventCreateFlags - Reserved for future use
using VkExternalFenceFeatureFlags = Vulkan.VkExternalFenceFeatureFlagBits;
using VkExternalFenceHandleTypeFlags = Vulkan.VkExternalFenceHandleTypeFlagBits;
using VkExternalMemoryFeatureFlags = Vulkan.VkExternalMemoryFeatureFlagBits;
using VkExternalMemoryFeatureFlagsNV = Vulkan.VkExternalMemoryFeatureFlagBitsNV;
using VkExternalMemoryHandleTypeFlags = Vulkan.VkExternalMemoryHandleTypeFlagBits;
using VkExternalMemoryHandleTypeFlagsNV = Vulkan.VkExternalMemoryHandleTypeFlagBitsNV;
using VkExternalSemaphoreFeatureFlags = Vulkan.VkExternalSemaphoreFeatureFlagBits;
using VkExternalSemaphoreHandleTypeFlags = Vulkan.VkExternalSemaphoreHandleTypeFlagBits;
using VkFenceCreateFlags = Vulkan.VkFenceCreateFlagBits;
using VkFenceImportFlags = Vulkan.VkFenceImportFlagBits;
using VkFormatFeatureFlags = Vulkan.VkFormatFeatureFlagBits;
// VkFramebufferCreateFlags - Reserved for future use
using VkGeometryFlagsNV = Vulkan.VkGeometryFlagBitsNV;
using VkImageAspectFlags = Vulkan.VkImageAspectFlagBits;
using VkImageCreateFlags = Vulkan.VkImageCreateFlagBits;
using VkImageUsageFlags = Vulkan.VkImageUsageFlagBits;
// VkImageViewCreateFlags - Reserved for future use
using VkIndirectCommandsLayoutUsageFlagsNVX = Vulkan.VkIndirectCommandsLayoutUsageFlagBitsNVX;
// VkInstanceCreateFlags - Reserved for future use
using VkMemoryAllocateFlags = Vulkan.VkMemoryAllocateFlagBits;
using VkMemoryHeapFlags = Vulkan.VkMemoryHeapFlagBits;
// VkMemoryMapFlags - Reserved for future use
using VkMemoryPropertyFlags = Vulkan.VkMemoryPropertyFlagBits;
using VkObjectEntryUsageFlagsNVX = Vulkan.VkObjectEntryUsageFlagBitsNVX;
// VkPipelineCacheCreateFlags - Reserved for future use
// VkPipelineColorBlendStateCreateFlags - Reserved for future use
// VkPipelineCoverageModulationStateCreateFlagsNV - Reserved for future use
// VkPipelineCoverageToColorStateCreateFlagsNV - Reserved for future use
using VkPipelineCreateFlags = Vulkan.VkPipelineCreateFlagBits;
using VkPipelineCreationFeedbackFlagsEXT = Vulkan.VkPipelineCreationFeedbackFlagBitsEXT;
// VkPipelineDepthStencilStateCreateFlags - Reserved for future use
// VkPipelineDiscardRectangleStateCreateFlagsEXT - Reserved for future use
// VkPipelineDynamicStateCreateFlags - Reserved for future use
// VkPipelineInputAssemblyStateCreateFlags - Reserved for future use
// VkPipelineLayoutCreateFlags - Reserved for future use
// VkPipelineMultisampleStateCreateFlags - Reserved for future use
// VkPipelineRasterizationConservativeStateCreateFlagsEXT - Reserved for future use
// VkPipelineRasterizationDepthClipStateCreateFlagsEXT - Reserved for future use
// VkPipelineRasterizationStateCreateFlags - Reserved for future use
// VkPipelineRasterizationStateStreamCreateFlagsEXT - Reserved for future use
// VkPipelineShaderStageCreateFlags - Reserved for future use
using VkPipelineStageFlags = Vulkan.VkPipelineStageFlagBits;
// VkPipelineTessellationStateCreateFlags - Reserved for future use
// VkPipelineVertexInputStateCreateFlags - Reserved for future use
// VkPipelineViewportStateCreateFlags - Reserved for future use
// VkPipelineViewportSwizzleStateCreateFlagsNV - Reserved for future use
using VkQueryControlFlags = Vulkan.VkQueryControlFlagBits;
using VkQueryPipelineStatisticFlags = Vulkan.VkQueryPipelineStatisticFlagBits;
// VkQueryPoolCreateFlags - Reserved for future use
using VkQueueFlags = Vulkan.VkQueueFlagBits;
// VkRenderPassCreateFlags - Reserved for future use
using VkResolveModeFlagsKHR = Vulkan.VkResolveModeFlagBitsKHR;
using VkSampleCountFlags = Vulkan.VkSampleCountFlagBits;
// VkSamplerCreateFlags - Reserved for future use
// VkSemaphoreCreateFlags - Reserved for future use
using VkSemaphoreImportFlags = Vulkan.VkSemaphoreImportFlagBits;
// VkShaderModuleCreateFlags - Reserved for future use
using VkShaderStageFlags = Vulkan.VkShaderStageFlagBits;
using VkSparseImageFormatFlags = Vulkan.VkSparseImageFormatFlagBits;
using VkSparseMemoryBindFlags = Vulkan.VkSparseMemoryBindFlagBits;
using VkSubgroupFeatureFlags = Vulkan.VkSubgroupFeatureFlagBits;
using VkSubpassDescriptionFlags = Vulkan.VkSubpassDescriptionFlagBits;
using VkSurfaceCounterFlagsEXT = Vulkan.VkSurfaceCounterFlagBitsEXT;
using VkSurfaceTransformFlagsKHR = Vulkan.VkSurfaceTransformFlagBitsKHR;
using VkSwapchainCreateFlagsKHR = Vulkan.VkSwapchainCreateFlagBitsKHR;
using System.Collections.Generic;
// VkValidationCacheCreateFlagsEXT - Reserved for future use

namespace Vulkan {
    public unsafe static partial class vkAPI {
        // Command: 0
        // GetInstanceProcAddr: 0
        /// <summary>vkAcquireFullScreenExclusiveModeEXT - Acquire full-screen exclusive mode for a swapchain
        /// </summary>
        /// <param name="device">device is the device associated with swapchain.</param>
        /// <param name="swapchain">swapchain is the swapchain to acquire exclusive full-screen access
        /// for.</param>
        public static VkResult AcquireFullScreenExclusiveModeEXT(
        this VkInstance instance,
        VkDevice device,
        VkSwapchainKHR swapchain) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkAcquireFullScreenExclusiveModeEXT");
            var func = (vkAcquireFullScreenExclusiveModeEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkAcquireFullScreenExclusiveModeEXT));

            if (func != null) {
                return func(device, swapchain);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 3
        // GetInstanceProcAddr: 1
        /// <summary>vkAcquireXlibDisplayEXT - Acquire access to a VkDisplayKHR using Xlib
        /// </summary>
        /// <param name="physicalDevice">physicalDevice The physical device the display is on.</param>
        /// <param name="dpy">dpy A connection to the X11 server that currently owns
        /// display.</param>
        /// <param name="display">display The display the caller wishes to control in Vulkan.</param>
        public static VkResult AcquireXlibDisplayEXT(
            this VkInstance instance,
            VkPhysicalDevice physicalDevice,
            /*Display*-*/IntPtr dpy,
            VkDisplayKHR display) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkAcquireXlibDisplayEXT");
            var func = (vkAcquireXlibDisplayEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkAcquireXlibDisplayEXT));

            if (func != null) {
                return func(physicalDevice, dpy, display);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 13
        // GetInstanceProcAddr: 2
        /// <summary>vkCmdBeginConditionalRenderingEXT - Define the beginning of a conditional rendering block
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which this command will
        /// be recorded.</param>
        /// <param name="pConditionalRenderingBegin">pConditionalRenderingBegin is a pointer to an instance of the
        /// VkConditionalRenderingBeginInfoEXT structure specifying the
        /// parameters of conditional rendering.</param>
        public static void CmdBeginConditionalRenderingEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer,
            /*-const-*/ VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdBeginConditionalRenderingEXT");
            var func = (vkCmdBeginConditionalRenderingEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdBeginConditionalRenderingEXT));

            if (func != null) {
                func(commandBuffer, pConditionalRenderingBegin);
            }
        }

        // Command: 14
        // GetInstanceProcAddr: 3
        /// <summary>vkCmdBeginDebugUtilsLabelEXT - Open a command buffer debug label region
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="pLabelInfo">pLabelInfo is a pointer to an instance of the
        /// VkDebugUtilsLabelEXT structure specifying the parameters of the
        /// label region to open.</param>
        public static void CmdBeginDebugUtilsLabelEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer,
            /*-const-*/ VkDebugUtilsLabelEXT* pLabelInfo) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdBeginDebugUtilsLabelEXT");
            var func = (vkCmdBeginDebugUtilsLabelEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdBeginDebugUtilsLabelEXT));

            if (func != null) {
                func(commandBuffer, pLabelInfo);
            }
        }

        // Command: 16
        // GetInstanceProcAddr: 4
        /// <summary>vkCmdBeginQueryIndexedEXT - Begin an indexed query
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which this command will
        /// be recorded.</param>
        /// <param name="queryPool">queryPool is the query pool that will manage the results of the
        /// query.</param>
        /// <param name="query">query is the query index within the query pool that will contain
        /// the results.</param>
        /// <param name="flags">flags is a bitmask of VkQueryControlFlagBits specifying
        /// constraints on the types of queries that can be performed.</param>
        /// <param name="index">index is the query type specific index.
        /// When the query type is VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT
        /// the index represents the vertex stream.</param>
        public static void CmdBeginQueryIndexedEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer,
            VkQueryPool queryPool,
            UInt32 query,
            VkQueryControlFlags flags,
            UInt32 index) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdBeginQueryIndexedEXT");
            var func = (vkCmdBeginQueryIndexedEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdBeginQueryIndexedEXT));

            if (func != null) {
                func(commandBuffer, queryPool, query, flags, index);
            }
        }

        // Command: 19
        // GetInstanceProcAddr: 5
        /// <summary>vkCmdBeginTransformFeedbackEXT - Make transform feedback active in the command buffer
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="firstCounterBuffer">firstCounterBuffer is the index of the first transform feedback
        /// buffer corresponding to pCounterBuffers[0] and
        /// pCounterBufferOffsets[0].</param>
        /// <param name="counterBufferCount">counterBufferCount is the size of the pCounterBuffers and
        /// pCounterBufferOffsets arrays.</param>
        /// <param name="pCounterBuffers">pCounterBuffers is an optional array of buffer handles to the
        /// counter buffers which contain a 4 byte integer value representing the
        /// byte offset from the start of the corresponding transform feedback
        /// buffer from where to start capturing vertex data.
        /// If the byte offset stored to the counter buffer location was done using
        /// vkCmdEndTransformFeedbackEXT it can be used to resume transform
        /// feedback from the previous location.
        /// If pCounterBuffers is NULL, then transform feedback will start
        /// capturing vertex data to byte offset zero in all bound transform
        /// feedback buffers.
        /// For each element of pCounterBuffers that is VK_NULL_HANDLE,
        /// transform feedback will start capturing vertex data to byte zero in the
        /// corresponding bound transform feedback buffer.</param>
        /// <param name="pCounterBufferOffsets">pCounterBufferOffsets is an optional array of offsets within each
        /// of the pCounterBuffers where the counter values were previously
        /// written.
        /// The location in each counter buffer at these offsets must be large
        /// enough to contain 4 bytes of data.
        /// This data is the number of bytes captured by the previous transform
        /// feedback to this buffer.
        /// If pCounterBufferOffsets is NULL, then it is assumed the offsets
        /// are zero.</param>
        public static void CmdBeginTransformFeedbackEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer,
            UInt32 firstCounterBuffer,
            UInt32 counterBufferCount,
            /*-const-*/ VkBuffer* pCounterBuffers,
            /*-const-*/ VkDeviceSize* pCounterBufferOffsets) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdBeginTransformFeedbackEXT");
            var func = (vkCmdBeginTransformFeedbackEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdBeginTransformFeedbackEXT));

            if (func != null) {
                func(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
            }
        }

        // Command: 24
        // GetInstanceProcAddr: 6
        /// <summary>vkCmdBindTransformFeedbackBuffersEXT - Bind transform feedback buffers to a command buffer
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="firstBinding">firstBinding is the index of the first transform feedback binding
        /// whose state is updated by the command.</param>
        /// <param name="bindingCount">bindingCount is the number of transform feedback bindings whose
        /// state is updated by the command.</param>
        /// <param name="pBuffers">pBuffers is a pointer to an array of buffer handles.</param>
        /// <param name="pOffsets">pOffsets is a pointer to an array of buffer offsets.</param>
        /// <param name="pSizes">pSizes is an optional array of buffer sizes, which specifies the
        /// maximum number of bytes to capture to the corresponding transform
        /// feedback buffer.
        /// If pSizes is NULL, or the value of the pSizes array
        /// element is VK_WHOLE_SIZE, then the maximum bytes captured will be
        /// the size of the corresponding buffer minus the buffer offset.</param>
        public static void CmdBindTransformFeedbackBuffersEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer,
            UInt32 firstBinding,
            UInt32 bindingCount,
            /*-const-*/ VkBuffer* pBuffers,
            /*-const-*/ VkDeviceSize* pOffsets,
            /*-const-*/ VkDeviceSize* pSizes) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdBindTransformFeedbackBuffersEXT");
            var func = (vkCmdBindTransformFeedbackBuffersEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdBindTransformFeedbackBuffersEXT));

            if (func != null) {
                func(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
            }
        }

        // Command: 37
        // GetInstanceProcAddr: 7
        /// <summary>vkCmdDebugMarkerBeginEXT - Open a command buffer marker region
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="pMarkerInfo">pMarkerInfo is a pointer to an instance of the
        /// VkDebugMarkerMarkerInfoEXT structure specifying the parameters of
        /// the marker region to open.</param>
        public static void CmdDebugMarkerBeginEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer,
            /*-const-*/ VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerBeginEXT");
            var func = (vkCmdDebugMarkerBeginEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdDebugMarkerBeginEXT));

            if (func != null) {
                func(commandBuffer, pMarkerInfo);
            }
        }

        // Command: 38
        // GetInstanceProcAddr: 8
        /// <summary>vkCmdDebugMarkerEndEXT - Close a command buffer marker region
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        public static void CmdDebugMarkerEndEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerEndEXT");
            var func = (vkCmdDebugMarkerEndEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdDebugMarkerEndEXT));

            if (func != null) {
                func(commandBuffer);
            }
        }

        // Command: 39
        // GetInstanceProcAddr: 9
        /// <summary>vkCmdDebugMarkerInsertEXT - Insert a marker label into a command buffer
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="pMarkerInfo">pMarkerInfo is a pointer to an instance of the
        /// VkDebugMarkerMarkerInfoEXT structure specifying the parameters of
        /// the marker to insert.</param>
        public static void CmdDebugMarkerInsertEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer,
            /*-const-*/ VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerInsertEXT");
            var func = (vkCmdDebugMarkerInsertEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdDebugMarkerInsertEXT));

            if (func != null) {
                func(commandBuffer, pMarkerInfo);
            }
        }

        // Command: 49
        // GetInstanceProcAddr: 10
        /// <summary>vkCmdDrawIndirectByteCountEXT - Draw primitives where the vertex count is derived from the counter byte value in the counter buffer
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="instanceCount">instanceCount is the number of instances to draw.</param>
        /// <param name="firstInstance">firstInstance is the instance ID of the first instance to draw.</param>
        /// <param name="counterBuffer">counterBuffer is the buffer handle from where the byte count is
        /// read.</param>
        /// <param name="counterBufferOffset">counterBufferOffset is the offset into the buffer used to read the
        /// byte count, which is used to calculate the vertex count for this draw
        /// call.</param>
        /// <param name="counterOffset">counterOffset is subtracted from the byte count read from the
        /// counterBuffer at the counterBufferOffset</param>
        /// <param name="vertexStride">vertexStride is the stride in bytes between each element of the
        /// vertex data that is used to calculate the vertex count from the counter
        /// value.
        /// This value is typically the same value that was used in the graphics
        /// pipeline state when the transform feedback was captured as the
        /// XfbStride.</param>
        public static void CmdDrawIndirectByteCountEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer,
            UInt32 instanceCount,
            UInt32 firstInstance,
            VkBuffer counterBuffer,
            VkDeviceSize counterBufferOffset,
            UInt32 counterOffset,
            UInt32 vertexStride) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdDrawIndirectByteCountEXT");
            var func = (vkCmdDrawIndirectByteCountEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdDrawIndirectByteCountEXT));

            if (func != null) {
                func(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
            }
        }

        // Command: 55
        // GetInstanceProcAddr: 11
        /// <summary>vkCmdEndConditionalRenderingEXT - Define the end of a conditional rendering block
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which this command will
        /// be recorded.</param>
        public static void CmdEndConditionalRenderingEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdEndConditionalRenderingEXT");
            var func = (vkCmdEndConditionalRenderingEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdEndConditionalRenderingEXT));

            if (func != null) {
                func(commandBuffer);
            }
        }

        // Command: 56
        // GetInstanceProcAddr: 12
        /// <summary>vkCmdEndDebugUtilsLabelEXT - Close a command buffer label region
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        public static void CmdEndDebugUtilsLabelEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdEndDebugUtilsLabelEXT");
            var func = (vkCmdEndDebugUtilsLabelEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdEndDebugUtilsLabelEXT));

            if (func != null) {
                func(commandBuffer);
            }
        }

        // Command: 58
        // GetInstanceProcAddr: 13
        /// <summary>vkCmdEndQueryIndexedEXT - Ends a query
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which this command will
        /// be recorded.</param>
        /// <param name="queryPool">queryPool is the query pool that is managing the results of the
        /// query.</param>
        /// <param name="query">query is the query index within the query pool where the result is
        /// stored.</param>
        /// <param name="index">index is the query type specific index.</param>
        public static void CmdEndQueryIndexedEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer,
            VkQueryPool queryPool,
            UInt32 query,
            UInt32 index) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdEndQueryIndexedEXT");
            var func = (vkCmdEndQueryIndexedEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdEndQueryIndexedEXT));

            if (func != null) {
                func(commandBuffer, queryPool, query, index);
            }
        }

        // Command: 61
        // GetInstanceProcAddr: 14
        /// <summary>vkCmdEndTransformFeedbackEXT - Make transform feedback inactive in the command buffer
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="firstCounterBuffer">firstCounterBuffer is the index of the first transform feedback
        /// buffer corresponding to pCounterBuffers[0] and
        /// pCounterBufferOffsets[0].</param>
        /// <param name="counterBufferCount">counterBufferCount is the size of the pCounterBuffers and
        /// pCounterBufferOffsets arrays.</param>
        /// <param name="pCounterBuffers">pCounterBuffers is an optional array of buffer handles to the
        /// counter buffers used to record the current byte positions of each
        /// transform feedback buffer where the next vertex output data would be
        /// captured.
        /// This can be used by a subsequent vkCmdBeginTransformFeedbackEXT
        /// call to resume transform feedback capture from this position.
        /// It can also be used by vkCmdDrawIndirectByteCountEXT to determine
        /// the vertex count of the draw call.</param>
        /// <param name="pCounterBufferOffsets">pCounterBufferOffsets is an optional array of offsets within each
        /// of the pCounterBuffers where the counter values can be written.
        /// The location in each counter buffer at these offsets must be large
        /// enough to contain 4 bytes of data.
        /// The data stored at this location is the byte offset from the start of
        /// the transform feedback buffer binding where the next vertex data would
        /// be written.
        /// If pCounterBufferOffsets is NULL, then it is assumed the offsets
        /// are zero.</param>
        public static void CmdEndTransformFeedbackEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer,
            UInt32 firstCounterBuffer,
            UInt32 counterBufferCount,
            /*-const-*/ VkBuffer* pCounterBuffers,
            /*-const-*/ VkDeviceSize* pCounterBufferOffsets) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdEndTransformFeedbackEXT");
            var func = (vkCmdEndTransformFeedbackEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdEndTransformFeedbackEXT));

            if (func != null) {
                func(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
            }
        }

        // Command: 64
        // GetInstanceProcAddr: 15
        /// <summary>vkCmdInsertDebugUtilsLabelEXT - Insert a label into a command buffer
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        public static void CmdInsertDebugUtilsLabelEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer,
            /*-const-*/ VkDebugUtilsLabelEXT* pLabelInfo) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdInsertDebugUtilsLabelEXT");
            var func = (vkCmdInsertDebugUtilsLabelEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdInsertDebugUtilsLabelEXT));

            if (func != null) {
                func(commandBuffer, pLabelInfo);
            }
        }

        // Command: 82
        // GetInstanceProcAddr: 16
        /// <summary>vkCmdSetDiscardRectangleEXT - Set discard rectangles dynamically
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command will be
        /// recorded.</param>
        /// <param name="firstDiscardRectangle">firstDiscardRectangle is the index of the first discard rectangle
        /// whose state is updated by the command.</param>
        /// <param name="discardRectangleCount">discardRectangleCount is the number of discard rectangles whose
        /// state are updated by the command.</param>
        /// <param name="pDiscardRectangles">pDiscardRectangles is a pointer to an array of VkRect2D
        /// structures specifying discard rectangles.</param>
        public static void CmdSetDiscardRectangleEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer,
            UInt32 firstDiscardRectangle,
            UInt32 discardRectangleCount,
            /*-const-*/ VkRect2D* pDiscardRectangles) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdSetDiscardRectangleEXT");
            var func = (vkCmdSetDiscardRectangleEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdSetDiscardRectangleEXT));

            if (func != null) {
                func(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
            }
        }

        // Command: 86
        // GetInstanceProcAddr: 17
        /// <summary>vkCmdSetSampleLocationsEXT - Set the dynamic sample locations state
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command will be
        /// recorded.</param>
        /// <param name="pSampleLocationsInfo">pSampleLocationsInfo is the sample locations state to set.</param>
        public static void CmdSetSampleLocationsEXT(
            this VkInstance instance,
            VkCommandBuffer commandBuffer,
            /*-const-*/ VkSampleLocationsInfoEXT* pSampleLocationsInfo) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdSetSampleLocationsEXT");
            var func = (vkCmdSetSampleLocationsEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdSetSampleLocationsEXT));

            if (func != null) {
                func(commandBuffer, pSampleLocationsInfo);
            }
        }

        // Command: 107
        // GetInstanceProcAddr: 18
        /// <summary>vkCreateDebugReportCallbackEXT - Create a debug report callback object
        /// </summary>
        /// <param name="instance">instance the instance the callback will be logged on.</param>
        /// <param name="pCreateInfo">pCreateInfo points to a VkDebugReportCallbackCreateInfoEXT
        /// structure which defines the conditions under which this callback will be
        /// called.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        /// <param name="pCallback">pCallback is a pointer to record the
        /// VkDebugReportCallbackEXT object created.</param>
        public static VkResult CreateDebugReportCallbackEXT(
            this VkInstance instance,
            /*-const-*/ VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
            /*-const-*/ VkAllocationCallbacks* pAllocator,
            VkDebugReportCallbackEXT* pCallback) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCreateDebugReportCallbackEXT");
            var func = (vkCreateDebugReportCallbackEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCreateDebugReportCallbackEXT));

            if (func != null) {
                return func(instance, pCreateInfo, pAllocator, pCallback);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 108
        // GetInstanceProcAddr: 19
        /// <summary>vkCreateDebugUtilsMessengerEXT - Create a debug messenger object
        /// </summary>
        /// <param name="instance">instance the instance the messenger will be used with.</param>
        /// <param name="pCreateInfo">pCreateInfo points to a VkDebugUtilsMessengerCreateInfoEXT
        /// structure which contains the callback pointer as well as defines the
        /// conditions under which this messenger will trigger the callback.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        /// <param name="pMessenger">pMessenger is a pointer to record the
        /// VkDebugUtilsMessengerEXT object created.</param>
        public static VkResult CreateDebugUtilsMessengerEXT(
            this VkInstance instance,
            /*-const-*/ VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
            /*-const-*/ VkAllocationCallbacks* pAllocator,
            VkDebugUtilsMessengerEXT* pMessenger) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCreateDebugUtilsMessengerEXT");
            var func = (vkCreateDebugUtilsMessengerEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCreateDebugUtilsMessengerEXT));

            if (func != null) {
                return func(instance, pCreateInfo, pAllocator, pMessenger);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 126
        // GetInstanceProcAddr: 20
        /// <summary>vkCreateMetalSurfaceEXT - Create a VkSurfaceKHR object for CAMetalLayer
        /// </summary>
        /// <param name="instance">instance is the instance with which to associate the surface.</param>
        /// <param name="pCreateInfo">pCreateInfo is a pointer to an instance of the
        /// VkMetalSurfaceCreateInfoEXT structure containing the parameters
        /// affecting the creation of the surface object.</param>
        /// <param name="pAllocator">pAllocator is the allocator used for host memory allocated for the
        /// surface object when there is no more specific allocator available (see
        /// Memory Allocation).</param>
        /// <param name="pSurface">pSurface points to a VkSurfaceKHR handle in which the
        /// created surface object is returned.</param>
        public static VkResult CreateMetalSurfaceEXT(
            this VkInstance instance,
            /*-const-*/ VkMetalSurfaceCreateInfoEXT* pCreateInfo,
            /*-const-*/ VkAllocationCallbacks* pAllocator,
            VkSurfaceKHR* pSurface) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCreateMetalSurfaceEXT");
            var func = (vkCreateMetalSurfaceEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCreateMetalSurfaceEXT));

            if (func != null) {
                return func(instance, pCreateInfo, pAllocator, pSurface);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 141
        // GetInstanceProcAddr: 21
        /// <summary>vkCreateValidationCacheEXT - Creates a new validation cache
        /// </summary>
        /// <param name="device">device is the logical device that creates the validation cache
        /// object.</param>
        /// <param name="pCreateInfo">pCreateInfo is a pointer to a VkValidationCacheCreateInfoEXT
        /// structure that contains the initial parameters for the validation cache
        /// object.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        /// <param name="pValidationCache">pValidationCache is a pointer to a VkValidationCacheEXT
        /// handle in which the resulting validation cache object is returned.</param>
        public static VkResult CreateValidationCacheEXT(
            this VkInstance instance,
            VkDevice device,
            /*-const-*/ VkValidationCacheCreateInfoEXT* pCreateInfo,
            /*-const-*/ VkAllocationCallbacks* pAllocator,
            VkValidationCacheEXT* pValidationCache) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCreateValidationCacheEXT");
            var func = (vkCreateValidationCacheEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCreateValidationCacheEXT));

            if (func != null) {
                return func(device, pCreateInfo, pAllocator, pValidationCache);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 147
        // GetInstanceProcAddr: 22
        /// <summary>vkDebugMarkerSetObjectNameEXT - Give a user-friendly name to an object
        /// </summary>
        /// <param name="device">device is the device that created the object.</param>
        /// <param name="pNameInfo">pNameInfo is a pointer to an instance of the
        /// VkDebugMarkerObjectNameInfoEXT structure specifying the parameters
        /// of the name to set on the object.</param>
        public static VkResult DebugMarkerSetObjectNameEXT(
            this VkInstance instance,
            VkDevice device,
            /*-const-*/ VkDebugMarkerObjectNameInfoEXT* pNameInfo) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDebugMarkerSetObjectNameEXT");
            var func = (vkDebugMarkerSetObjectNameEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDebugMarkerSetObjectNameEXT));

            if (func != null) {
                return func(device, pNameInfo);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 148
        // GetInstanceProcAddr: 23
        /// <summary>vkDebugMarkerSetObjectTagEXT - Attach arbitrary data to an object
        /// </summary>
        /// <param name="device">device is the device that created the object.</param>
        /// <param name="pTagInfo">pTagInfo is a pointer to an instance of the
        /// VkDebugMarkerObjectTagInfoEXT structure specifying the parameters
        /// of the tag to attach to the object.</param>
        public static VkResult DebugMarkerSetObjectTagEXT(
            this VkInstance instance,
            VkDevice device,
            /*-const-*/ VkDebugMarkerObjectTagInfoEXT* pTagInfo) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDebugMarkerSetObjectTagEXT");
            var func = (vkDebugMarkerSetObjectTagEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDebugMarkerSetObjectTagEXT));

            if (func != null) {
                return func(device, pTagInfo);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 149
        // GetInstanceProcAddr: 24
        /// <summary>vkDebugReportMessageEXT - Inject a message into a debug stream
        /// </summary>
        /// <param name="instance">instance is the debug streamâ€™s VkInstance.</param>
        /// <param name="flags">flags specifies the VkDebugReportFlagBitsEXT classification
        /// of this event/message.</param>
        /// <param name="objectType">objectType is a VkDebugReportObjectTypeEXT specifying the
        /// type of object being used or created at the time the event was
        /// triggered.</param>
        /// <param name="object">object this is the object where the issue was detected.
        /// objectcan be VK_NULL_HANDLE if there is no object
        /// associated with the event.</param>
        /// <param name="location">location is an application defined value.</param>
        /// <param name="messageCode">messageCode is an application defined value.</param>
        /// <param name="pLayerPrefix">pLayerPrefix is the abbreviation of the component making this
        /// event/message.</param>
        /// <param name="pMessage">pMessage is a null-terminated string detailing the trigger
        /// conditions.</param>
        public static void DebugReportMessageEXT(
            this VkInstance instance,
            VkDebugReportFlagsEXT flags,
            VkDebugReportObjectTypeEXT _objectType,
            UInt64 _object,
            Int32 location,
            Int32 messageCode,
            IntPtr pLayerPrefix,
            IntPtr pMessage) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDebugReportMessageEXT");
            var func = (vkDebugReportMessageEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDebugReportMessageEXT));

            if (func != null) {
                func(instance, flags, _objectType, _object, location, messageCode, pLayerPrefix, pMessage);
            }
        }

        // Command: 154
        // GetInstanceProcAddr: 25
        /// <summary>vkDestroyDebugReportCallbackEXT - Destroy a debug report callback object
        /// </summary>
        /// <param name="instance">instance the instance where the callback was created.</param>
        /// <param name="callback">callback the VkDebugReportCallbackEXT object to destroy.
        /// callback is an externally synchronized object and must not be
        /// used on more than one thread at a time.
        /// This means that vkDestroyDebugReportCallbackEXTmust not be
        /// called when a callback is active.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        public static void DestroyDebugReportCallbackEXT(
            this VkInstance instance,
            VkDebugReportCallbackEXT callback,
            /*-const-*/ VkAllocationCallbacks* pAllocator) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDestroyDebugReportCallbackEXT");
            var func = (vkDestroyDebugReportCallbackEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDestroyDebugReportCallbackEXT));

            if (func != null) {
                func(instance, callback, pAllocator);
            }
        }

        // Command: 155
        // GetInstanceProcAddr: 26
        /// <summary>vkDestroyDebugUtilsMessengerEXT - Destroy a debug messenger object
        /// </summary>
        /// <param name="instance">instance the instance where the callback was created.</param>
        /// <param name="messenger">messenger the VkDebugUtilsMessengerEXT object to destroy.
        /// messenger is an externally synchronized object and must not be
        /// used on more than one thread at a time.
        /// This means that vkDestroyDebugUtilsMessengerEXTmust not be
        /// called when a callback is active.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        public static void DestroyDebugUtilsMessengerEXT(
            this VkInstance instance,
            VkDebugUtilsMessengerEXT messenger,
            /*-const-*/ VkAllocationCallbacks* pAllocator) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDestroyDebugUtilsMessengerEXT");
            var func = (vkDestroyDebugUtilsMessengerEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDestroyDebugUtilsMessengerEXT));

            if (func != null) {
                func(instance, messenger, pAllocator);
            }
        }

        // Command: 179
        // GetInstanceProcAddr: 27
        /// <summary>vkDestroyValidationCacheEXT - Destroy a validation cache object
        /// </summary>
        /// <param name="device">device is the logical device that destroys the validation cache
        /// object.</param>
        /// <param name="validationCache">validationCache is the handle of the validation cache to destroy.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        public static void DestroyValidationCacheEXT(
            this VkInstance instance,
            VkDevice device,
            VkValidationCacheEXT validationCache,
            /*-const-*/ VkAllocationCallbacks* pAllocator) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDestroyValidationCacheEXT");
            var func = (vkDestroyValidationCacheEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDestroyValidationCacheEXT));

            if (func != null) {
                func(device, validationCache, pAllocator);
            }
        }

        // Command: 181
        // GetInstanceProcAddr: 28
        /// <summary>vkDisplayPowerControlEXT - Set the power state of a display
        /// </summary>
        /// <param name="device">device is a logical device associated with display.</param>
        /// <param name="display">display is the display whose power state is modified.</param>
        /// <param name="pDisplayPowerInfo">pDisplayPowerInfo is an instance of VkDisplayPowerInfoEXT
        /// specifying the new power state of display.</param>
        public static VkResult DisplayPowerControlEXT(
            this VkInstance instance,
            VkDevice device,
            VkDisplayKHR display,
            /*-const-*/ VkDisplayPowerInfoEXT* pDisplayPowerInfo) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDisplayPowerControlEXT");
            var func = (vkDisplayPowerControlEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDisplayPowerControlEXT));

            if (func != null) {
                return func(device, display, pDisplayPowerInfo);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 197
        // GetInstanceProcAddr: 29
        /// <summary>vkGetBufferDeviceAddressEXT - Query an address of a buffer
        /// </summary>
        /// <param name="device">device is the logical device that the buffer was created on.</param>
        /// <param name="pInfo">pInfo is a pointer to an instance of the
        /// VkBufferDeviceAddressInfoEXT structure specifying the buffer to
        /// retrieve an address for.</param>
        public static VkDeviceAddress GetBufferDeviceAddressEXT(
            this VkInstance instance,
            VkDevice device,
            /*-const-*/ VkBufferDeviceAddressInfoEXT* pInfo) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetBufferDeviceAddressEXT");
            var func = (vkGetBufferDeviceAddressEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetBufferDeviceAddressEXT));

            if (func != null) {
                return func(device, pInfo);
            }
            else {
                return 0;
            }
        }

        // Command: 200
        // GetInstanceProcAddr: 30
        /// <summary>vkGetCalibratedTimestampsEXT - Query calibrated timestamps
        /// </summary>
        /// <param name="device">device is the logical device used to perform the query.</param>
        /// <param name="timestampCount">timestampCount is the number of timestamps to query.</param>
        /// <param name="pTimestampInfos">pTimestampInfos is a pointer to an array of timestampCount
        /// number of structures of type VkCalibratedTimestampInfoEXT,
        /// describing the time domains the calibrated timestamps should be captured
        /// from.</param>
        /// <param name="pTimestamps">pTimestamps is a pointer to an array of timestampCount
        /// number of 64-bit unsigned integer values in which the requested
        /// calibrated timestamp values are returned.</param>
        /// <param name="pMaxDeviation">pMaxDeviation is a pointer to a 64-bit unsigned integer value in
        /// which the strictly positive maximum deviation, in nanoseconds, of the
        /// calibrated timestamp values is returned.</param>
        public static VkResult GetCalibratedTimestampsEXT(
            this VkInstance instance,
            VkDevice device,
            UInt32 timestampCount,
            /*-const-*/ VkCalibratedTimestampInfoEXT* pTimestampInfos,
            UInt64* pTimestamps,
            UInt64* pMaxDeviation) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetCalibratedTimestampsEXT");
            var func = (vkGetCalibratedTimestampsEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetCalibratedTimestampsEXT));

            if (func != null) {
                return func(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 204
        // GetInstanceProcAddr: 31
        /// <summary>vkGetDeviceGroupSurfacePresentModes2EXT - Query device group present capabilities for a surface
        /// </summary>
        /// <param name="device">device is the logical device.</param>
        /// <param name="pSurfaceInfo">pSurfaceInfo points to an instance of the
        /// VkPhysicalDeviceSurfaceInfo2KHR structure, describing the surface and
        /// other fixed parameters that would be consumed by vkCreateSwapchainKHR.</param>
        /// <param name="pModes">pModes is a pointer to a value of type
        /// VkDeviceGroupPresentModeFlagsKHR that is filled with the supported
        /// device group present modes for the surface.</param>
        public static VkResult GetDeviceGroupSurfacePresentModes2EXT(
            this VkInstance instance,
            VkDevice device,
            /*-const-*/ VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
            VkDeviceGroupPresentModeFlagsKHR* pModes) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetDeviceGroupSurfacePresentModes2EXT");
            var func = (vkGetDeviceGroupSurfacePresentModes2EXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetDeviceGroupSurfacePresentModes2EXT));

            if (func != null) {
                return func(device, pSurfaceInfo, pModes);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 219
        // GetInstanceProcAddr: 32
        /// <summary>vkGetImageDrmFormatModifierPropertiesEXT - Returns an imageâ€™s DRM format modifier
        /// </summary>
        /// <param name="device">device is the logical device that owns the image.</param>
        /// <param name="image">image is the queried image.</param>
        /// <param name="pProperties">pProperties will return properties of the imageâ€™s DRM format
        /// modifier.</param>
        public static VkResult GetImageDrmFormatModifierPropertiesEXT(
            this VkInstance instance,
            VkDevice device,
            VkImage image,
            VkImageDrmFormatModifierPropertiesEXT* pProperties) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetImageDrmFormatModifierPropertiesEXT");
            var func = (vkGetImageDrmFormatModifierPropertiesEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetImageDrmFormatModifierPropertiesEXT));

            if (func != null) {
                return func(device, image, pProperties);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 230
        // GetInstanceProcAddr: 33
        /// <summary>vkGetMemoryHostPointerPropertiesEXT - Get properties of external memory host pointer
        /// </summary>
        /// <param name="device">device is the logical device that will be importing
        /// pHostPointer.</param>
        /// <param name="handleType">handleType is the type of the handle pHostPointer.</param>
        /// <param name="pHostPointer">pHostPointer is the host pointer to import from.</param>
        /// <param name="pMemoryHostPointerProperties">pMemoryHostPointerProperties is a pointer to a
        /// VkMemoryHostPointerPropertiesEXT structure in which the host
        /// pointer properties are returned.</param>
        public static VkResult GetMemoryHostPointerPropertiesEXT(
            this VkInstance instance,
            VkDevice device,
            VkExternalMemoryHandleTypeFlagBits handleType,
            /*-const-*/ void* pHostPointer,
            VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetMemoryHostPointerPropertiesEXT");
            var func = (vkGetMemoryHostPointerPropertiesEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetMemoryHostPointerPropertiesEXT));

            if (func != null) {
                return func(device, handleType, pHostPointer, pMemoryHostPointerProperties);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 235
        // GetInstanceProcAddr: 34
        /// <summary>vkGetPhysicalDeviceCalibrateableTimeDomainsEXT - Query calibrateable time domains
        /// </summary>
        /// <param name="physicalDevice">physicalDevice is the physical device from which to query the set
        /// of calibrateable time domains.</param>
        /// <param name="pTimeDomainCount">pTimeDomainCount is a pointer to an integer related to the number
        /// of calibrateable time domains available or queried, as described below.</param>
        /// <param name="pTimeDomains">pTimeDomains is either NULL or a pointer to an array of
        /// VkTimeDomainEXT values, indicating the supported calibrateable
        /// time domains.</param>
        public static VkResult GetPhysicalDeviceCalibrateableTimeDomainsEXT(
            this VkInstance instance,
            VkPhysicalDevice physicalDevice,
            UInt32* pTimeDomainCount,
            VkTimeDomainEXT* pTimeDomains) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
            var func = (vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetPhysicalDeviceCalibrateableTimeDomainsEXT));

            if (func != null) {
                return func(physicalDevice, pTimeDomainCount, pTimeDomains);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 254
        // GetInstanceProcAddr: 35
        /// <summary>vkGetPhysicalDeviceMultisamplePropertiesEXT - Report sample count specific multisampling capabilities of a physical device
        /// </summary>
        /// <param name="physicalDevice">physicalDevice is the physical device from which to query the
        /// additional multisampling capabilities.</param>
        /// <param name="samples">samples is the sample count to query the capabilities for.</param>
        /// <param name="pMultisampleProperties">pMultisampleProperties is a pointer to a structure of type
        /// VkMultisamplePropertiesEXT, in which information about the
        /// additional multisampling capabilities specific to the sample count is
        /// returned.</param>
        public static void GetPhysicalDeviceMultisamplePropertiesEXT(
            this VkInstance instance,
            VkPhysicalDevice physicalDevice,
            VkSampleCountFlagBits samples,
            VkMultisamplePropertiesEXT* pMultisampleProperties) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMultisamplePropertiesEXT");
            var func = (vkGetPhysicalDeviceMultisamplePropertiesEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetPhysicalDeviceMultisamplePropertiesEXT));

            if (func != null) {
                func(physicalDevice, samples, pMultisampleProperties);
            }
        }

        // Command: 262
        // GetInstanceProcAddr: 36
        /// <summary>vkGetPhysicalDeviceSurfaceCapabilities2EXT - Query surface capabilities
        /// </summary>
        /// <param name="physicalDevice">physicalDevice is the physical device that will be associated with
        /// the swapchain to be created, as described for
        /// vkCreateSwapchainKHR.</param>
        /// <param name="surface">surface is the surface that will be associated with the swapchain.</param>
        /// <param name="pSurfaceCapabilities">pSurfaceCapabilities is a pointer to an instance of the
        /// VkSurfaceCapabilities2EXT structure in which the capabilities are
        /// returned.</param>
        public static VkResult GetPhysicalDeviceSurfaceCapabilities2EXT(
            this VkInstance instance,
            VkPhysicalDevice physicalDevice,
            VkSurfaceKHR surface,
            VkSurfaceCapabilities2EXT* pSurfaceCapabilities) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2EXT");
            var func = (vkGetPhysicalDeviceSurfaceCapabilities2EXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetPhysicalDeviceSurfaceCapabilities2EXT));

            if (func != null) {
                return func(physicalDevice, surface, pSurfaceCapabilities);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 267
        // GetInstanceProcAddr: 37
        /// <summary>vkGetPhysicalDeviceSurfacePresentModes2EXT - Query supported presentation modes
        /// </summary>
        /// <param name="physicalDevice">physicalDevice is the physical device that will be associated with
        /// the swapchain to be created, as described for
        /// vkCreateSwapchainKHR.</param>
        /// <param name="pSurfaceInfo">pSurfaceInfo points to an instance of the
        /// VkPhysicalDeviceSurfaceInfo2KHR structure, describing the surface
        /// and other fixed parameters that would be consumed by
        /// vkCreateSwapchainKHR.</param>
        /// <param name="pPresentModeCount">pPresentModeCount is a pointer to an integer related to the number
        /// of presentation modes available or queried, as described below.</param>
        /// <param name="pPresentModes">pPresentModes is either NULL or a pointer to an array of
        /// VkPresentModeKHR values, indicating the supported presentation
        /// modes.</param>
        public static VkResult GetPhysicalDeviceSurfacePresentModes2EXT(
            this VkInstance instance,
            VkPhysicalDevice physicalDevice,
            /*-const-*/ VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
            UInt32* pPresentModeCount,
            VkPresentModeKHR* pPresentModes) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfacePresentModes2EXT");
            var func = (vkGetPhysicalDeviceSurfacePresentModes2EXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetPhysicalDeviceSurfacePresentModes2EXT));

            if (func != null) {
                return func(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 277
        // GetInstanceProcAddr: 38
        /// <summary>vkGetRandROutputDisplayEXT - Query the VkDisplayKHR corresponding to an X11 RandR Output
        /// </summary>
        /// <param name="physicalDevice">physicalDevice The physical device to query the display handle on.</param>
        /// <param name="dpy">dpy A connection to the X11 server from which rrOutput was
        /// queried.</param>
        /// <param name="rrOutput">rrOutput An X11 RandR output ID.</param>
        /// <param name="pDisplay">pDisplay The corresponding VkDisplayKHR handle will be
        /// returned here.</param>
        public static VkResult GetRandROutputDisplayEXT(
            this VkInstance instance,
            VkPhysicalDevice physicalDevice,
            /*Display*-*/IntPtr dpy,
            /*RROutput*/IntPtr rrOutput,
            VkDisplayKHR* pDisplay) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetRandROutputDisplayEXT");
            var func = (vkGetRandROutputDisplayEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetRandROutputDisplayEXT));

            if (func != null) {
                return func(physicalDevice, dpy, rrOutput, pDisplay);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 284
        // GetInstanceProcAddr: 39
        /// <summary>vkGetSwapchainCounterEXT - Query the current value of a surface counter
        /// </summary>
        /// <param name="device">device is the VkDevice associated with swapchain.</param>
        /// <param name="swapchain">swapchain is the swapchain from which to query the counter value.</param>
        /// <param name="counter">counter is the counter to query.</param>
        /// <param name="pCounterValue">pCounterValue will return the current value of the counter.</param>
        public static VkResult GetSwapchainCounterEXT(
            this VkInstance instance,
            VkDevice device,
            VkSwapchainKHR swapchain,
            VkSurfaceCounterFlagBitsEXT counter,
            UInt64* pCounterValue) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetSwapchainCounterEXT");
            var func = (vkGetSwapchainCounterEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetSwapchainCounterEXT));

            if (func != null) {
                return func(device, swapchain, counter, pCounterValue);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 287
        // GetInstanceProcAddr: 40
        /// <summary>vkGetValidationCacheDataEXT - Get the data store from a validation cache
        /// </summary>
        /// <param name="device">device is the logical device that owns the validation cache.</param>
        /// <param name="validationCache">validationCache is the validation cache to retrieve data from.</param>
        /// <param name="pDataSize">pDataSize is a pointer to a value related to the amount of data in
        /// the validation cache, as described below.</param>
        /// <param name="pData">pData is either NULL or a pointer to a buffer.</param>
        public static VkResult GetValidationCacheDataEXT(
            this VkInstance instance,
            VkDevice device,
            VkValidationCacheEXT validationCache,
            Int32* pDataSize,
            void* pData) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetValidationCacheDataEXT");
            var func = (vkGetValidationCacheDataEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetValidationCacheDataEXT));

            if (func != null) {
                return func(device, validationCache, pDataSize, pData);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 295
        // GetInstanceProcAddr: 41
        /// <summary>vkMergeValidationCachesEXT - Combine the data stores of validation caches
        /// </summary>
        /// <param name="device">device is the logical device that owns the validation cache
        /// objects.</param>
        /// <param name="dstCache">dstCache is the handle of the validation cache to merge results
        /// into.</param>
        /// <param name="srcCacheCount">srcCacheCount is the length of the pSrcCaches array.</param>
        /// <param name="pSrcCaches">pSrcCaches is an array of validation cache handles, which will be
        /// merged into dstCache.
        /// The previous contents of dstCache are included after the merge.</param>
        public static VkResult MergeValidationCachesEXT(
            this VkInstance instance,
            VkDevice device,
            VkValidationCacheEXT dstCache,
            UInt32 srcCacheCount,
            /*-const-*/ VkValidationCacheEXT* pSrcCaches) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkMergeValidationCachesEXT");
            var func = (vkMergeValidationCachesEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkMergeValidationCachesEXT));

            if (func != null) {
                return func(device, dstCache, srcCacheCount, pSrcCaches);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 296
        // GetInstanceProcAddr: 42
        /// <summary>vkQueueBeginDebugUtilsLabelEXT - Open a queue debug label region
        /// </summary>
        /// <param name="queue">queue is the queue in which to start a debug label region.</param>
        /// <param name="pLabelInfo">pLabelInfo is a pointer to an instance of the
        /// VkDebugUtilsLabelEXT structure specifying the parameters of the
        /// label region to open.</param>
        public static void QueueBeginDebugUtilsLabelEXT(
            this VkInstance instance,
            VkQueue queue,
            /*-const-*/ VkDebugUtilsLabelEXT* pLabelInfo) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkQueueBeginDebugUtilsLabelEXT");
            var func = (vkQueueBeginDebugUtilsLabelEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkQueueBeginDebugUtilsLabelEXT));

            if (func != null) {
                func(queue, pLabelInfo);
            }
        }

        // Command: 298
        // GetInstanceProcAddr: 43
        /// <summary>vkQueueEndDebugUtilsLabelEXT - Close a queue debug label region
        /// </summary>
        /// <param name="queue">queue is the queue in which a debug label region should be closed.</param>
        public static void QueueEndDebugUtilsLabelEXT(
            this VkInstance instance,
            VkQueue queue) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkQueueEndDebugUtilsLabelEXT");
            var func = (vkQueueEndDebugUtilsLabelEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkQueueEndDebugUtilsLabelEXT));

            if (func != null) {
                func(queue);
            }
        }

        // Command: 299
        // GetInstanceProcAddr: 44
        /// <summary>vkQueueInsertDebugUtilsLabelEXT - Insert a label into a queue
        /// </summary>
        /// <param name="queue">queue is the queue into which a debug label will be inserted.</param>
        /// <param name="pLabelInfo">pLabelInfo is a pointer to an instance of the
        /// VkDebugUtilsLabelEXT structure specifying the parameters of the
        /// label to insert.</param>
        public static void QueueInsertDebugUtilsLabelEXT(
            this VkInstance instance,
            VkQueue queue,
            /*-const-*/ VkDebugUtilsLabelEXT* pLabelInfo) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkQueueInsertDebugUtilsLabelEXT");
            var func = (vkQueueInsertDebugUtilsLabelEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkQueueInsertDebugUtilsLabelEXT));

            if (func != null) {
                func(queue, pLabelInfo);
            }
        }

        // Command: 303
        // GetInstanceProcAddr: 45
        /// <summary>vkRegisterDeviceEventEXT - Signal a fence when a device event occurs
        /// </summary>
        /// <param name="device">device is a logical device on which the event may occur.</param>
        /// <param name="pDeviceEventInfo">pDeviceEventInfo is a pointer to an instance of the
        /// VkDeviceEventInfoEXT structure describing the event of interest to
        /// the application.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        /// <param name="pFence">pFence points to a handle in which the resulting fence object is
        /// returned.</param>
        public static VkResult RegisterDeviceEventEXT(
            this VkInstance instance,
            VkDevice device,
            /*-const-*/ VkDeviceEventInfoEXT* pDeviceEventInfo,
            /*-const-*/ VkAllocationCallbacks* pAllocator,
            VkFence* pFence) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkRegisterDeviceEventEXT");
            var func = (vkRegisterDeviceEventEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkRegisterDeviceEventEXT));

            if (func != null) {
                return func(device, pDeviceEventInfo, pAllocator, pFence);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 304
        // GetInstanceProcAddr: 46
        /// <summary>vkRegisterDisplayEventEXT - Signal a fence when a display event occurs
        /// </summary>
        /// <param name="device">device is a logical device associated with display</param>
        /// <param name="display">display is the display on which the event may occur.</param>
        /// <param name="pDisplayEventInfo">pDisplayEventInfo is a pointer to an instance of the
        /// VkDisplayEventInfoEXT structure describing the event of interest
        /// to the application.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        /// <param name="pFence">pFence points to a handle in which the resulting fence object is
        /// returned.</param>
        public static VkResult RegisterDisplayEventEXT(
            this VkInstance instance,
            VkDevice device,
            VkDisplayKHR display,
            /*-const-*/ VkDisplayEventInfoEXT* pDisplayEventInfo,
            /*-const-*/ VkAllocationCallbacks* pAllocator,
            VkFence* pFence) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkRegisterDisplayEventEXT");
            var func = (vkRegisterDisplayEventEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkRegisterDisplayEventEXT));

            if (func != null) {
                return func(device, display, pDisplayEventInfo, pAllocator, pFence);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 306
        // GetInstanceProcAddr: 47
        /// <summary>vkReleaseDisplayEXT - Release access to an acquired VkDisplayKHR
        /// </summary>
        /// <param name="physicalDevice">physicalDevice The physical device the display is on.</param>
        /// <param name="display">display The display to release control of.</param>
        public static VkResult ReleaseDisplayEXT(
            this VkInstance instance,
            VkPhysicalDevice physicalDevice,
            VkDisplayKHR display) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkReleaseDisplayEXT");
            var func = (vkReleaseDisplayEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkReleaseDisplayEXT));

            if (func != null) {
                return func(physicalDevice, display);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 307
        // GetInstanceProcAddr: 48
        /// <summary>vkReleaseFullScreenExclusiveModeEXT - Release full-screen exclusive mode from a swapchain
        /// </summary>
        /// <param name="device">device is the device associated with swapchain.</param>
        /// <param name="swapchain">swapchain is the swapchain to release exclusive full-screen access
        /// from.</param>
        public static VkResult ReleaseFullScreenExclusiveModeEXT(
            this VkInstance instance,
            VkDevice device,
            VkSwapchainKHR swapchain) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkReleaseFullScreenExclusiveModeEXT");
            var func = (vkReleaseFullScreenExclusiveModeEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkReleaseFullScreenExclusiveModeEXT));

            if (func != null) {
                return func(device, swapchain);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 313
        // GetInstanceProcAddr: 49
        /// <summary>vkResetQueryPoolEXT - Reset queries in a query pool
        /// </summary>
        /// <param name="queryPool">queryPool is the handle of the query pool managing the queries
        /// being reset.</param>
        /// <param name="firstQuery">firstQuery is the initial query index to reset.</param>
        /// <param name="queryCount">queryCount is the number of queries to reset.</param>
        public static void ResetQueryPoolEXT(
            this VkInstance instance,
            VkDevice device,
            VkQueryPool queryPool,
            UInt32 firstQuery,
            UInt32 queryCount) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkResetQueryPoolEXT");
            var func = (vkResetQueryPoolEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkResetQueryPoolEXT));

            if (func != null) {
                func(device, queryPool, firstQuery, queryCount);
            }
        }

        // Command: 314
        // GetInstanceProcAddr: 50
        /// <summary>vkSetDebugUtilsObjectNameEXT - Give a user-friendly name to an object
        /// </summary>
        /// <param name="device">device is the device that created the object.</param>
        /// <param name="pNameInfo">pNameInfo is a pointer to an instance of the
        /// VkDebugUtilsObjectNameInfoEXT structure specifying the parameters
        /// of the name to set on the object.</param>
        public static VkResult SetDebugUtilsObjectNameEXT(
            this VkInstance instance,
            VkDevice device,
            /*-const-*/ VkDebugUtilsObjectNameInfoEXT* pNameInfo) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkSetDebugUtilsObjectNameEXT");
            var func = (vkSetDebugUtilsObjectNameEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkSetDebugUtilsObjectNameEXT));

            if (func != null) {
                return func(device, pNameInfo);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 315
        // GetInstanceProcAddr: 51
        /// <summary>vkSetDebugUtilsObjectTagEXT - Attach arbitrary data to an object
        /// </summary>
        /// <param name="device">device is the device that created the object.</param>
        /// <param name="pTagInfo">pTagInfo is a pointer to an instance of the
        /// VkDebugUtilsObjectTagInfoEXT structure specifying the parameters
        /// of the tag to attach to the object.</param>
        public static VkResult SetDebugUtilsObjectTagEXT(
            this VkInstance instance,
            VkDevice device,
            /*-const-*/ VkDebugUtilsObjectTagInfoEXT* pTagInfo) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkSetDebugUtilsObjectTagEXT");
            var func = (vkSetDebugUtilsObjectTagEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkSetDebugUtilsObjectTagEXT));

            if (func != null) {
                return func(device, pTagInfo);
            }
            else {
                return VkResult.ErrorExtensionNotPresent;
            }
        }

        // Command: 317
        // GetInstanceProcAddr: 52
        /// <summary>vkSetHdrMetadataEXT - function to set Hdr metadata
        /// </summary>
        /// <param name="device">device is the logical device where the swapchain(s) were created.</param>
        /// <param name="swapchainCount">swapchainCount is the number of swapchains included in
        /// pSwapchains.</param>
        /// <param name="pSwapchains">pSwapchains is a pointer to the array of swapchainCountVkSwapchainKHR handles.</param>
        /// <param name="pMetadata">pMetadata is a pointer to the array of swapchainCountVkHdrMetadataEXT structures.</param>
        public static void SetHdrMetadataEXT(
            this VkInstance instance,
            VkDevice device,
            UInt32 swapchainCount,
            /*-const-*/ VkSwapchainKHR* pSwapchains,
            /*-const-*/ VkHdrMetadataEXT* pMetadata) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkSetHdrMetadataEXT");
            var func = (vkSetHdrMetadataEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkSetHdrMetadataEXT));

            if (func != null) {
                func(device, swapchainCount, pSwapchains, pMetadata);
            }
        }

        // Command: 319
        // GetInstanceProcAddr: 53
        /// <summary>vkSubmitDebugUtilsMessageEXT - Inject a message into a debug stream
        /// </summary>
        /// <param name="instance">instance is the debug streamâ€™s VkInstance.</param>
        /// <param name="messageSeverity">messageSeverity is the
        /// VkDebugUtilsMessageSeverityFlagBitsEXT severity of this
        /// event/message.</param>
        /// <param name="messageTypes">messageTypes is a bitmask of
        /// VkDebugUtilsMessageTypeFlagBitsEXT specifying which type of
        /// event(s) to identify with this message.</param>
        /// <param name="pCallbackData">pCallbackData contains all the callback related data in the
        /// VkDebugUtilsMessengerCallbackDataEXT structure.</param>
        public static void SubmitDebugUtilsMessageEXT(
            this VkInstance instance,
            VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
            VkDebugUtilsMessageTypeFlagsEXT messageTypes,
            /*-const-*/ VkDebugUtilsMessengerCallbackDataEXT* pCallbackData) {
            IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkSubmitDebugUtilsMessageEXT");
            var func = (vkSubmitDebugUtilsMessageEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkSubmitDebugUtilsMessageEXT));

            if (func != null) {
                func(instance, messageSeverity, messageTypes, pCallbackData);
            }
        }

    }
}
