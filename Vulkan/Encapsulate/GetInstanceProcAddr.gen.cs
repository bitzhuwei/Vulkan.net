//using System;
//using System.Runtime.InteropServices;

//// hand-coded.
//using VkAndroidSurfaceCreateFlagsKHR = System.UInt32;
//using VkBufferViewCreateFlags = Vulkan.VkFlags;
//using VkDescriptorUpdateTemplateCreateFlags = Vulkan.VkFlags;
//using VkDeviceCreateFlags = Vulkan.VkFlags;
//using VkEventCreateFlags = Vulkan.VkFlags;
//using VkFramebufferCreateFlags = Vulkan.VkFlags;
//using VkImageViewCreateFlags = Vulkan.VkFlags;
//using VkInstanceCreateFlags = Vulkan.VkFlags;
//using VkPipelineCacheCreateFlags = Vulkan.VkFlags;
//using VkPipelineColorBlendStateCreateFlags = Vulkan.VkFlags;
//using VkPipelineCoverageModulationStateCreateFlagsNV = Vulkan.VkFlags;
//using VkPipelineCoverageToColorStateCreateFlagsNV = Vulkan.VkFlags;
//using VkPipelineDepthStencilStateCreateFlags = Vulkan.VkFlags;
//using VkPipelineDiscardRectangleStateCreateFlagsEXT = Vulkan.VkFlags;
//using VkPipelineDynamicStateCreateFlags = Vulkan.VkFlags;
//using VkPipelineInputAssemblyStateCreateFlags = Vulkan.VkFlags;
//using VkPipelineLayoutCreateFlags = Vulkan.VkFlags;
//using VkPipelineMultisampleStateCreateFlags = Vulkan.VkFlags;
//using VkPipelineRasterizationConservativeStateCreateFlagsEXT = Vulkan.VkFlags;
//using VkPipelineRasterizationDepthClipStateCreateFlagsEXT = Vulkan.VkFlags;
//using VkPipelineRasterizationStateCreateFlags = Vulkan.VkFlags;
//using VkPipelineRasterizationStateStreamCreateFlagsEXT = Vulkan.VkFlags;
//using VkPipelineShaderStageCreateFlags = Vulkan.VkFlags;
//using VkPipelineTessellationStateCreateFlags = Vulkan.VkFlags;
//using VkPipelineVertexInputStateCreateFlags = Vulkan.VkFlags;
//using VkPipelineViewportStateCreateFlags = Vulkan.VkFlags;
//using VkPipelineViewportSwizzleStateCreateFlagsNV = Vulkan.VkFlags;
//using VkQueryPoolCreateFlags = Vulkan.VkFlags;
//using VkRenderPassCreateFlags = Vulkan.VkFlags;
//using VkSamplerCreateFlags = Vulkan.VkFlags;
//using VkSemaphoreCreateFlags = Vulkan.VkFlags;
//using VkShaderModuleCreateFlags = Vulkan.VkFlags;
//using VkValidationCacheCreateFlagsEXT = Vulkan.VkFlags;
//using VkQueryResultFlags = Vulkan.VkFlags;
//using VkStencilFaceFlags = Vulkan.VkFlags;
//using VkMemoryRequirements2KHR = Vulkan.VkMemoryRequirements2;
//using VkPeerMemoryFeatureFlags = Vulkan.VkFlags;
//using HANDLE = System.IntPtr;
//using VkMemoryMapFlags = Vulkan.VkFlags;
//using VkCommandBufferResetFlags = Vulkan.VkFlags;
//using VkCommandPoolResetFlags = Vulkan.VkFlags;
//using VkDescriptorPoolResetFlags = Vulkan.VkFlags;
//using VkCommandPoolTrimFlags = Vulkan.VkFlags;
////
//using HINSTANCE = System.IntPtr;
//using HWND = System.IntPtr;
//using LPCWSTR = System.IntPtr;
//using DWORD = System.UInt32;
//using VkIOSSurfaceCreateFlagsMVK = System.UInt32;
//using VkImagePipeSurfaceCreateFlagsFUCHSIA = System.UInt32;
//using zx_handle_t = System.IntPtr;
//using VkMacOSSurfaceCreateFlagsMVK = System.UInt32;
//using VkMetalSurfaceCreateFlagsEXT = System.UInt32;
//using GgpFrameToken = System.IntPtr;
//using VkStreamDescriptorSurfaceCreateFlagsGGP = System.UInt32;
//using GgpStreamDescriptor = System.IntPtr;
//using HMONITOR = System.IntPtr;
//using VkViSurfaceCreateFlagsNN = System.UInt32;
//using VkWaylandSurfaceCreateFlagsKHR = System.UInt32;
////
//// Generated by FlagsParser.
//using VkAccessFlags = Vulkan.VkAccessFlagBits;
//using VkAttachmentDescriptionFlags = Vulkan.VkAttachmentDescriptionFlagBits;
//using VkBufferCreateFlags = Vulkan.VkBufferCreateFlagBits;
//using VkBufferUsageFlags = Vulkan.VkBufferUsageFlagBits;
//// VkBufferViewCreateFlags - Reserved for future use
//using VkBuildAccelerationStructureFlagsNV = Vulkan.VkBuildAccelerationStructureFlagBitsNV;
//using VkColorComponentFlags = Vulkan.VkColorComponentFlagBits;
//using VkCommandBufferUsageFlags = Vulkan.VkCommandBufferUsageFlagBits;
//using VkCommandPoolCreateFlags = Vulkan.VkCommandPoolCreateFlagBits;
//// VkCommandPoolTrimFlags - Reserved for future use
//using VkCompositeAlphaFlagsKHR = Vulkan.VkCompositeAlphaFlagBitsKHR;
//using VkConditionalRenderingFlagsEXT = Vulkan.VkConditionalRenderingFlagBitsEXT;
//using VkCullModeFlags = Vulkan.VkCullModeFlagBits;
//using VkDebugReportFlagsEXT = Vulkan.VkDebugReportFlagBitsEXT;
//using VkDebugUtilsMessageSeverityFlagsEXT = Vulkan.VkDebugUtilsMessageSeverityFlagBitsEXT;
//using VkDebugUtilsMessageTypeFlagsEXT = Vulkan.VkDebugUtilsMessageTypeFlagBitsEXT;
//using VkDependencyFlags = Vulkan.VkDependencyFlagBits;
//using VkDescriptorBindingFlagsEXT = Vulkan.VkDescriptorBindingFlagBitsEXT;
//using VkDescriptorPoolCreateFlags = Vulkan.VkDescriptorPoolCreateFlagBits;
//// VkDescriptorPoolResetFlags - Reserved for future use
//using VkDescriptorSetLayoutCreateFlags = Vulkan.VkDescriptorSetLayoutCreateFlagBits;
//// VkDescriptorUpdateTemplateCreateFlags - Reserved for future use
//// VkDeviceCreateFlags - Reserved for future use
//using VkDeviceGroupPresentModeFlagsKHR = Vulkan.VkDeviceGroupPresentModeFlagBitsKHR;
//using VkDeviceQueueCreateFlags = Vulkan.VkDeviceQueueCreateFlagBits;
//using VkDisplayPlaneAlphaFlagsKHR = Vulkan.VkDisplayPlaneAlphaFlagBitsKHR;
//// VkEventCreateFlags - Reserved for future use
//using VkExternalFenceFeatureFlags = Vulkan.VkExternalFenceFeatureFlagBits;
//using VkExternalFenceHandleTypeFlags = Vulkan.VkExternalFenceHandleTypeFlagBits;
//using VkExternalMemoryFeatureFlags = Vulkan.VkExternalMemoryFeatureFlagBits;
//using VkExternalMemoryFeatureFlagsNV = Vulkan.VkExternalMemoryFeatureFlagBitsNV;
//using VkExternalMemoryHandleTypeFlags = Vulkan.VkExternalMemoryHandleTypeFlagBits;
//using VkExternalMemoryHandleTypeFlagsNV = Vulkan.VkExternalMemoryHandleTypeFlagBitsNV;
//using VkExternalSemaphoreFeatureFlags = Vulkan.VkExternalSemaphoreFeatureFlagBits;
//using VkExternalSemaphoreHandleTypeFlags = Vulkan.VkExternalSemaphoreHandleTypeFlagBits;
//using VkFenceCreateFlags = Vulkan.VkFenceCreateFlagBits;
//using VkFenceImportFlags = Vulkan.VkFenceImportFlagBits;
//using VkFormatFeatureFlags = Vulkan.VkFormatFeatureFlagBits;
//// VkFramebufferCreateFlags - Reserved for future use
//using VkGeometryFlagsNV = Vulkan.VkGeometryFlagBitsNV;
//using VkImageAspectFlags = Vulkan.VkImageAspectFlagBits;
//using VkImageCreateFlags = Vulkan.VkImageCreateFlagBits;
//using VkImageUsageFlags = Vulkan.VkImageUsageFlagBits;
//// VkImageViewCreateFlags - Reserved for future use
//using VkIndirectCommandsLayoutUsageFlagsNVX = Vulkan.VkIndirectCommandsLayoutUsageFlagBitsNVX;
//// VkInstanceCreateFlags - Reserved for future use
//using VkMemoryAllocateFlags = Vulkan.VkMemoryAllocateFlagBits;
//using VkMemoryHeapFlags = Vulkan.VkMemoryHeapFlagBits;
//// VkMemoryMapFlags - Reserved for future use
//using VkMemoryPropertyFlags = Vulkan.VkMemoryPropertyFlagBits;
//using VkObjectEntryUsageFlagsNVX = Vulkan.VkObjectEntryUsageFlagBitsNVX;
//// VkPipelineCacheCreateFlags - Reserved for future use
//// VkPipelineColorBlendStateCreateFlags - Reserved for future use
//// VkPipelineCoverageModulationStateCreateFlagsNV - Reserved for future use
//// VkPipelineCoverageToColorStateCreateFlagsNV - Reserved for future use
//using VkPipelineCreateFlags = Vulkan.VkPipelineCreateFlagBits;
//using VkPipelineCreationFeedbackFlagsEXT = Vulkan.VkPipelineCreationFeedbackFlagBitsEXT;
//// VkPipelineDepthStencilStateCreateFlags - Reserved for future use
//// VkPipelineDiscardRectangleStateCreateFlagsEXT - Reserved for future use
//// VkPipelineDynamicStateCreateFlags - Reserved for future use
//// VkPipelineInputAssemblyStateCreateFlags - Reserved for future use
//// VkPipelineLayoutCreateFlags - Reserved for future use
//// VkPipelineMultisampleStateCreateFlags - Reserved for future use
//// VkPipelineRasterizationConservativeStateCreateFlagsEXT - Reserved for future use
//// VkPipelineRasterizationDepthClipStateCreateFlagsEXT - Reserved for future use
//// VkPipelineRasterizationStateCreateFlags - Reserved for future use
//// VkPipelineRasterizationStateStreamCreateFlagsEXT - Reserved for future use
//// VkPipelineShaderStageCreateFlags - Reserved for future use
//using VkPipelineStageFlags = Vulkan.VkPipelineStageFlagBits;
//// VkPipelineTessellationStateCreateFlags - Reserved for future use
//// VkPipelineVertexInputStateCreateFlags - Reserved for future use
//// VkPipelineViewportStateCreateFlags - Reserved for future use
//// VkPipelineViewportSwizzleStateCreateFlagsNV - Reserved for future use
//using VkQueryControlFlags = Vulkan.VkQueryControlFlagBits;
//using VkQueryPipelineStatisticFlags = Vulkan.VkQueryPipelineStatisticFlagBits;
//// VkQueryPoolCreateFlags - Reserved for future use
//using VkQueueFlags = Vulkan.VkQueueFlagBits;
//// VkRenderPassCreateFlags - Reserved for future use
//using VkResolveModeFlagsKHR = Vulkan.VkResolveModeFlagBitsKHR;
//using VkSampleCountFlags = Vulkan.VkSampleCountFlagBits;
//// VkSamplerCreateFlags - Reserved for future use
//// VkSemaphoreCreateFlags - Reserved for future use
//using VkSemaphoreImportFlags = Vulkan.VkSemaphoreImportFlagBits;
//// VkShaderModuleCreateFlags - Reserved for future use
//using VkShaderStageFlags = Vulkan.VkShaderStageFlagBits;
//using VkSparseImageFormatFlags = Vulkan.VkSparseImageFormatFlagBits;
//using VkSparseMemoryBindFlags = Vulkan.VkSparseMemoryBindFlagBits;
//using VkSubgroupFeatureFlags = Vulkan.VkSubgroupFeatureFlagBits;
//using VkSubpassDescriptionFlags = Vulkan.VkSubpassDescriptionFlagBits;
//using VkSurfaceCounterFlagsEXT = Vulkan.VkSurfaceCounterFlagBitsEXT;
//using VkSurfaceTransformFlagsKHR = Vulkan.VkSurfaceTransformFlagBitsKHR;
//using VkSwapchainCreateFlagsKHR = Vulkan.VkSwapchainCreateFlagBitsKHR;
//using System.Collections.Generic;
//// VkValidationCacheCreateFlagsEXT - Reserved for future use

//namespace Vulkan {
//    public unsafe partial class vkAPI {
//        // Command: 0
//        // GetInstanceProcAddr: 0
//        /// <summary>vkAcquireFullScreenExclusiveModeEXT - Acquire full-screen exclusive mode for a swapchain
//        /// </summary>
//        /// <param name="device">device is the device associated with swapchain.</param>
//        /// <param name="swapchain">swapchain is the swapchain to acquire exclusive full-screen access
//        /// for.</param>
//        public static VkResult AcquireFullScreenExclusiveModeEXT(
//            this VkInstance instance,
//            VkDevice device,
//            VkSwapchainKHR swapchain) {
//            if (delvkAcquireFullScreenExclusiveModeEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkAcquireFullScreenExclusiveModeEXT");
//                delvkAcquireFullScreenExclusiveModeEXT = (vkAcquireFullScreenExclusiveModeEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkAcquireFullScreenExclusiveModeEXT));
//            }

//            if (delvkAcquireFullScreenExclusiveModeEXT != null) {
//                return delvkAcquireFullScreenExclusiveModeEXT(device, swapchain);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkAcquireFullScreenExclusiveModeEXT delvkAcquireFullScreenExclusiveModeEXT;

//        // Command: 3
//        // GetInstanceProcAddr: 1
//        /// <summary>vkAcquireXlibDisplayEXT - Acquire access to a VkDisplayKHR using Xlib
//        /// </summary>
//        /// <param name="physicalDevice">physicalDevice The physical device the display is on.</param>
//        /// <param name="dpy">dpy A connection to the X11 server that currently owns
//        /// display.</param>
//        /// <param name="display">display The display the caller wishes to control in Vulkan.</param>
//        public static VkResult AcquireXlibDisplayEXT(
//            this VkInstance instance,
//            VkPhysicalDevice physicalDevice,
//            /*Display*-*/IntPtr dpy,
//            VkDisplayKHR display) {
//            if (delvkAcquireXlibDisplayEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkAcquireXlibDisplayEXT");
//                delvkAcquireXlibDisplayEXT = (vkAcquireXlibDisplayEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkAcquireXlibDisplayEXT));
//            }

//            if (delvkAcquireXlibDisplayEXT != null) {
//                return delvkAcquireXlibDisplayEXT(physicalDevice, dpy, display);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkAcquireXlibDisplayEXT delvkAcquireXlibDisplayEXT;

//        // Command: 13
//        // GetInstanceProcAddr: 2
//        /// <summary>vkCmdBeginConditionalRenderingEXT - Define the beginning of a conditional rendering block
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which this command will
//        /// be recorded.</param>
//        /// <param name="pConditionalRenderingBegin">pConditionalRenderingBegin is a pointer to an instance of the
//        /// VkConditionalRenderingBeginInfoEXT structure specifying the
//        /// parameters of conditional rendering.</param>
//        public static void CmdBeginConditionalRenderingEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer,
//            /*-const-*/ VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin) {
//            if (delvkCmdBeginConditionalRenderingEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdBeginConditionalRenderingEXT");
//                delvkCmdBeginConditionalRenderingEXT = (vkCmdBeginConditionalRenderingEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdBeginConditionalRenderingEXT));
//            }

//            if (delvkCmdBeginConditionalRenderingEXT != null) {
//                delvkCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin);
//            }
//        }
//        private static vkCmdBeginConditionalRenderingEXT delvkCmdBeginConditionalRenderingEXT;

//        // Command: 14
//        // GetInstanceProcAddr: 3
//        /// <summary>vkCmdBeginDebugUtilsLabelEXT - Open a command buffer debug label region
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
//        /// recorded.</param>
//        /// <param name="pLabelInfo">pLabelInfo is a pointer to an instance of the
//        /// VkDebugUtilsLabelEXT structure specifying the parameters of the
//        /// label region to open.</param>
//        public static void CmdBeginDebugUtilsLabelEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer,
//            /*-const-*/ VkDebugUtilsLabelEXT* pLabelInfo) {
//            if (delvkCmdBeginDebugUtilsLabelEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdBeginDebugUtilsLabelEXT");
//                delvkCmdBeginDebugUtilsLabelEXT = (vkCmdBeginDebugUtilsLabelEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdBeginDebugUtilsLabelEXT));
//            }

//            if (delvkCmdBeginDebugUtilsLabelEXT != null) {
//                delvkCmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
//            }
//        }
//        private static vkCmdBeginDebugUtilsLabelEXT delvkCmdBeginDebugUtilsLabelEXT;

//        // Command: 16
//        // GetInstanceProcAddr: 4
//        /// <summary>vkCmdBeginQueryIndexedEXT - Begin an indexed query
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which this command will
//        /// be recorded.</param>
//        /// <param name="queryPool">queryPool is the query pool that will manage the results of the
//        /// query.</param>
//        /// <param name="query">query is the query index within the query pool that will contain
//        /// the results.</param>
//        /// <param name="flags">flags is a bitmask of VkQueryControlFlagBits specifying
//        /// constraints on the types of queries that can be performed.</param>
//        /// <param name="index">index is the query type specific index.
//        /// When the query type is VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT
//        /// the index represents the vertex stream.</param>
//        public static void CmdBeginQueryIndexedEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer,
//            VkQueryPool queryPool,
//            UInt32 query,
//            VkQueryControlFlags flags,
//            UInt32 index) {
//            if (delvkCmdBeginQueryIndexedEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdBeginQueryIndexedEXT");
//                delvkCmdBeginQueryIndexedEXT = (vkCmdBeginQueryIndexedEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdBeginQueryIndexedEXT));
//            }

//            if (delvkCmdBeginQueryIndexedEXT != null) {
//                delvkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index);
//            }
//        }
//        private static vkCmdBeginQueryIndexedEXT delvkCmdBeginQueryIndexedEXT;

//        // Command: 19
//        // GetInstanceProcAddr: 5
//        /// <summary>vkCmdBeginTransformFeedbackEXT - Make transform feedback active in the command buffer
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
//        /// recorded.</param>
//        /// <param name="firstCounterBuffer">firstCounterBuffer is the index of the first transform feedback
//        /// buffer corresponding to pCounterBuffers[0] and
//        /// pCounterBufferOffsets[0].</param>
//        /// <param name="counterBufferCount">counterBufferCount is the size of the pCounterBuffers and
//        /// pCounterBufferOffsets arrays.</param>
//        /// <param name="pCounterBuffers">pCounterBuffers is an optional array of buffer handles to the
//        /// counter buffers which contain a 4 byte integer value representing the
//        /// byte offset from the start of the corresponding transform feedback
//        /// buffer from where to start capturing vertex data.
//        /// If the byte offset stored to the counter buffer location was done using
//        /// vkCmdEndTransformFeedbackEXT it can be used to resume transform
//        /// feedback from the previous location.
//        /// If pCounterBuffers is NULL, then transform feedback will start
//        /// capturing vertex data to byte offset zero in all bound transform
//        /// feedback buffers.
//        /// For each element of pCounterBuffers that is VK_NULL_HANDLE,
//        /// transform feedback will start capturing vertex data to byte zero in the
//        /// corresponding bound transform feedback buffer.</param>
//        /// <param name="pCounterBufferOffsets">pCounterBufferOffsets is an optional array of offsets within each
//        /// of the pCounterBuffers where the counter values were previously
//        /// written.
//        /// The location in each counter buffer at these offsets must be large
//        /// enough to contain 4 bytes of data.
//        /// This data is the number of bytes captured by the previous transform
//        /// feedback to this buffer.
//        /// If pCounterBufferOffsets is NULL, then it is assumed the offsets
//        /// are zero.</param>
//        public static void CmdBeginTransformFeedbackEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer,
//            UInt32 firstCounterBuffer,
//            UInt32 counterBufferCount,
//            /*-const-*/ VkBuffer* pCounterBuffers,
//            /*-const-*/ VkDeviceSize* pCounterBufferOffsets) {
//            if (delvkCmdBeginTransformFeedbackEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdBeginTransformFeedbackEXT");
//                delvkCmdBeginTransformFeedbackEXT = (vkCmdBeginTransformFeedbackEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdBeginTransformFeedbackEXT));
//            }

//            if (delvkCmdBeginTransformFeedbackEXT != null) {
//                delvkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
//            }
//        }
//        private static vkCmdBeginTransformFeedbackEXT delvkCmdBeginTransformFeedbackEXT;

//        // Command: 24
//        // GetInstanceProcAddr: 6
//        /// <summary>vkCmdBindTransformFeedbackBuffersEXT - Bind transform feedback buffers to a command buffer
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
//        /// recorded.</param>
//        /// <param name="firstBinding">firstBinding is the index of the first transform feedback binding
//        /// whose state is updated by the command.</param>
//        /// <param name="bindingCount">bindingCount is the number of transform feedback bindings whose
//        /// state is updated by the command.</param>
//        /// <param name="pBuffers">pBuffers is a pointer to an array of buffer handles.</param>
//        /// <param name="pOffsets">pOffsets is a pointer to an array of buffer offsets.</param>
//        /// <param name="pSizes">pSizes is an optional array of buffer sizes, which specifies the
//        /// maximum number of bytes to capture to the corresponding transform
//        /// feedback buffer.
//        /// If pSizes is NULL, or the value of the pSizes array
//        /// element is VK_WHOLE_SIZE, then the maximum bytes captured will be
//        /// the size of the corresponding buffer minus the buffer offset.</param>
//        public static void CmdBindTransformFeedbackBuffersEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer,
//            UInt32 firstBinding,
//            UInt32 bindingCount,
//            /*-const-*/ VkBuffer* pBuffers,
//            /*-const-*/ VkDeviceSize* pOffsets,
//            /*-const-*/ VkDeviceSize* pSizes) {
//            if (delvkCmdBindTransformFeedbackBuffersEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdBindTransformFeedbackBuffersEXT");
//                delvkCmdBindTransformFeedbackBuffersEXT = (vkCmdBindTransformFeedbackBuffersEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdBindTransformFeedbackBuffersEXT));
//            }

//            if (delvkCmdBindTransformFeedbackBuffersEXT != null) {
//                delvkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
//            }
//        }
//        private static vkCmdBindTransformFeedbackBuffersEXT delvkCmdBindTransformFeedbackBuffersEXT;

//        // Command: 37
//        // GetInstanceProcAddr: 7
//        /// <summary>vkCmdDebugMarkerBeginEXT - Open a command buffer marker region
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
//        /// recorded.</param>
//        /// <param name="pMarkerInfo">pMarkerInfo is a pointer to an instance of the
//        /// VkDebugMarkerMarkerInfoEXT structure specifying the parameters of
//        /// the marker region to open.</param>
//        public static void CmdDebugMarkerBeginEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer,
//            /*-const-*/ VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
//            if (delvkCmdDebugMarkerBeginEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerBeginEXT");
//                delvkCmdDebugMarkerBeginEXT = (vkCmdDebugMarkerBeginEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdDebugMarkerBeginEXT));
//            }

//            if (delvkCmdDebugMarkerBeginEXT != null) {
//                delvkCmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo);
//            }
//        }
//        private static vkCmdDebugMarkerBeginEXT delvkCmdDebugMarkerBeginEXT;

//        // Command: 38
//        // GetInstanceProcAddr: 8
//        /// <summary>vkCmdDebugMarkerEndEXT - Close a command buffer marker region
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
//        /// recorded.</param>
//        public static void CmdDebugMarkerEndEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer) {
//            if (delvkCmdDebugMarkerEndEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerEndEXT");
//                delvkCmdDebugMarkerEndEXT = (vkCmdDebugMarkerEndEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdDebugMarkerEndEXT));
//            }

//            if (delvkCmdDebugMarkerEndEXT != null) {
//                delvkCmdDebugMarkerEndEXT(commandBuffer);
//            }
//        }
//        private static vkCmdDebugMarkerEndEXT delvkCmdDebugMarkerEndEXT;

//        // Command: 39
//        // GetInstanceProcAddr: 9
//        /// <summary>vkCmdDebugMarkerInsertEXT - Insert a marker label into a command buffer
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
//        /// recorded.</param>
//        /// <param name="pMarkerInfo">pMarkerInfo is a pointer to an instance of the
//        /// VkDebugMarkerMarkerInfoEXT structure specifying the parameters of
//        /// the marker to insert.</param>
//        public static void CmdDebugMarkerInsertEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer,
//            /*-const-*/ VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
//            if (delvkCmdDebugMarkerInsertEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdDebugMarkerInsertEXT");
//                delvkCmdDebugMarkerInsertEXT = (vkCmdDebugMarkerInsertEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdDebugMarkerInsertEXT));
//            }

//            if (delvkCmdDebugMarkerInsertEXT != null) {
//                delvkCmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo);
//            }
//        }
//        private static vkCmdDebugMarkerInsertEXT delvkCmdDebugMarkerInsertEXT;

//        // Command: 49
//        // GetInstanceProcAddr: 10
//        /// <summary>vkCmdDrawIndirectByteCountEXT - Draw primitives where the vertex count is derived from the counter byte value in the counter buffer
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
//        /// recorded.</param>
//        /// <param name="instanceCount">instanceCount is the number of instances to draw.</param>
//        /// <param name="firstInstance">firstInstance is the instance ID of the first instance to draw.</param>
//        /// <param name="counterBuffer">counterBuffer is the buffer handle from where the byte count is
//        /// read.</param>
//        /// <param name="counterBufferOffset">counterBufferOffset is the offset into the buffer used to read the
//        /// byte count, which is used to calculate the vertex count for this draw
//        /// call.</param>
//        /// <param name="counterOffset">counterOffset is subtracted from the byte count read from the
//        /// counterBuffer at the counterBufferOffset</param>
//        /// <param name="vertexStride">vertexStride is the stride in bytes between each element of the
//        /// vertex data that is used to calculate the vertex count from the counter
//        /// value.
//        /// This value is typically the same value that was used in the graphics
//        /// pipeline state when the transform feedback was captured as the
//        /// XfbStride.</param>
//        public static void CmdDrawIndirectByteCountEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer,
//            UInt32 instanceCount,
//            UInt32 firstInstance,
//            VkBuffer counterBuffer,
//            VkDeviceSize counterBufferOffset,
//            UInt32 counterOffset,
//            UInt32 vertexStride) {
//            if (delvkCmdDrawIndirectByteCountEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdDrawIndirectByteCountEXT");
//                delvkCmdDrawIndirectByteCountEXT = (vkCmdDrawIndirectByteCountEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdDrawIndirectByteCountEXT));
//            }

//            if (delvkCmdDrawIndirectByteCountEXT != null) {
//                delvkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
//            }
//        }
//        private static vkCmdDrawIndirectByteCountEXT delvkCmdDrawIndirectByteCountEXT;

//        // Command: 55
//        // GetInstanceProcAddr: 11
//        /// <summary>vkCmdEndConditionalRenderingEXT - Define the end of a conditional rendering block
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which this command will
//        /// be recorded.</param>
//        public static void CmdEndConditionalRenderingEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer) {
//            if (delvkCmdEndConditionalRenderingEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdEndConditionalRenderingEXT");
//                delvkCmdEndConditionalRenderingEXT = (vkCmdEndConditionalRenderingEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdEndConditionalRenderingEXT));
//            }

//            if (delvkCmdEndConditionalRenderingEXT != null) {
//                delvkCmdEndConditionalRenderingEXT(commandBuffer);
//            }
//        }
//        private static vkCmdEndConditionalRenderingEXT delvkCmdEndConditionalRenderingEXT;

//        // Command: 56
//        // GetInstanceProcAddr: 12
//        /// <summary>vkCmdEndDebugUtilsLabelEXT - Close a command buffer label region
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
//        /// recorded.</param>
//        public static void CmdEndDebugUtilsLabelEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer) {
//            if (delvkCmdEndDebugUtilsLabelEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdEndDebugUtilsLabelEXT");
//                delvkCmdEndDebugUtilsLabelEXT = (vkCmdEndDebugUtilsLabelEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdEndDebugUtilsLabelEXT));
//            }

//            if (delvkCmdEndDebugUtilsLabelEXT != null) {
//                delvkCmdEndDebugUtilsLabelEXT(commandBuffer);
//            }
//        }
//        private static vkCmdEndDebugUtilsLabelEXT delvkCmdEndDebugUtilsLabelEXT;

//        // Command: 58
//        // GetInstanceProcAddr: 13
//        /// <summary>vkCmdEndQueryIndexedEXT - Ends a query
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which this command will
//        /// be recorded.</param>
//        /// <param name="queryPool">queryPool is the query pool that is managing the results of the
//        /// query.</param>
//        /// <param name="query">query is the query index within the query pool where the result is
//        /// stored.</param>
//        /// <param name="index">index is the query type specific index.</param>
//        public static void CmdEndQueryIndexedEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer,
//            VkQueryPool queryPool,
//            UInt32 query,
//            UInt32 index) {
//            if (delvkCmdEndQueryIndexedEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdEndQueryIndexedEXT");
//                delvkCmdEndQueryIndexedEXT = (vkCmdEndQueryIndexedEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdEndQueryIndexedEXT));
//            }

//            if (delvkCmdEndQueryIndexedEXT != null) {
//                delvkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index);
//            }
//        }
//        private static vkCmdEndQueryIndexedEXT delvkCmdEndQueryIndexedEXT;

//        // Command: 61
//        // GetInstanceProcAddr: 14
//        /// <summary>vkCmdEndTransformFeedbackEXT - Make transform feedback inactive in the command buffer
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
//        /// recorded.</param>
//        /// <param name="firstCounterBuffer">firstCounterBuffer is the index of the first transform feedback
//        /// buffer corresponding to pCounterBuffers[0] and
//        /// pCounterBufferOffsets[0].</param>
//        /// <param name="counterBufferCount">counterBufferCount is the size of the pCounterBuffers and
//        /// pCounterBufferOffsets arrays.</param>
//        /// <param name="pCounterBuffers">pCounterBuffers is an optional array of buffer handles to the
//        /// counter buffers used to record the current byte positions of each
//        /// transform feedback buffer where the next vertex output data would be
//        /// captured.
//        /// This can be used by a subsequent vkCmdBeginTransformFeedbackEXT
//        /// call to resume transform feedback capture from this position.
//        /// It can also be used by vkCmdDrawIndirectByteCountEXT to determine
//        /// the vertex count of the draw call.</param>
//        /// <param name="pCounterBufferOffsets">pCounterBufferOffsets is an optional array of offsets within each
//        /// of the pCounterBuffers where the counter values can be written.
//        /// The location in each counter buffer at these offsets must be large
//        /// enough to contain 4 bytes of data.
//        /// The data stored at this location is the byte offset from the start of
//        /// the transform feedback buffer binding where the next vertex data would
//        /// be written.
//        /// If pCounterBufferOffsets is NULL, then it is assumed the offsets
//        /// are zero.</param>
//        public static void CmdEndTransformFeedbackEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer,
//            UInt32 firstCounterBuffer,
//            UInt32 counterBufferCount,
//            /*-const-*/ VkBuffer* pCounterBuffers,
//            /*-const-*/ VkDeviceSize* pCounterBufferOffsets) {
//            if (delvkCmdEndTransformFeedbackEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdEndTransformFeedbackEXT");
//                delvkCmdEndTransformFeedbackEXT = (vkCmdEndTransformFeedbackEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdEndTransformFeedbackEXT));
//            }

//            if (delvkCmdEndTransformFeedbackEXT != null) {
//                delvkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
//            }
//        }
//        private static vkCmdEndTransformFeedbackEXT delvkCmdEndTransformFeedbackEXT;

//        // Command: 64
//        // GetInstanceProcAddr: 15
//        /// <summary>vkCmdInsertDebugUtilsLabelEXT - Insert a label into a command buffer
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
//        /// recorded.</param>
//        public static void CmdInsertDebugUtilsLabelEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer,
//            /*-const-*/ VkDebugUtilsLabelEXT* pLabelInfo) {
//            if (delvkCmdInsertDebugUtilsLabelEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdInsertDebugUtilsLabelEXT");
//                delvkCmdInsertDebugUtilsLabelEXT = (vkCmdInsertDebugUtilsLabelEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdInsertDebugUtilsLabelEXT));
//            }

//            if (delvkCmdInsertDebugUtilsLabelEXT != null) {
//                delvkCmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
//            }
//        }
//        private static vkCmdInsertDebugUtilsLabelEXT delvkCmdInsertDebugUtilsLabelEXT;

//        // Command: 82
//        // GetInstanceProcAddr: 16
//        /// <summary>vkCmdSetDiscardRectangleEXT - Set discard rectangles dynamically
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command will be
//        /// recorded.</param>
//        /// <param name="firstDiscardRectangle">firstDiscardRectangle is the index of the first discard rectangle
//        /// whose state is updated by the command.</param>
//        /// <param name="discardRectangleCount">discardRectangleCount is the number of discard rectangles whose
//        /// state are updated by the command.</param>
//        /// <param name="pDiscardRectangles">pDiscardRectangles is a pointer to an array of VkRect2D
//        /// structures specifying discard rectangles.</param>
//        public static void CmdSetDiscardRectangleEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer,
//            UInt32 firstDiscardRectangle,
//            UInt32 discardRectangleCount,
//            /*-const-*/ VkRect2D* pDiscardRectangles) {
//            if (delvkCmdSetDiscardRectangleEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdSetDiscardRectangleEXT");
//                delvkCmdSetDiscardRectangleEXT = (vkCmdSetDiscardRectangleEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdSetDiscardRectangleEXT));
//            }

//            if (delvkCmdSetDiscardRectangleEXT != null) {
//                delvkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
//            }
//        }
//        private static vkCmdSetDiscardRectangleEXT delvkCmdSetDiscardRectangleEXT;

//        // Command: 86
//        // GetInstanceProcAddr: 17
//        /// <summary>vkCmdSetSampleLocationsEXT - Set the dynamic sample locations state
//        /// </summary>
//        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command will be
//        /// recorded.</param>
//        /// <param name="pSampleLocationsInfo">pSampleLocationsInfo is the sample locations state to set.</param>
//        public static void CmdSetSampleLocationsEXT(
//            this VkInstance instance,
//            VkCommandBuffer commandBuffer,
//            /*-const-*/ VkSampleLocationsInfoEXT* pSampleLocationsInfo) {
//            if (delvkCmdSetSampleLocationsEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCmdSetSampleLocationsEXT");
//                delvkCmdSetSampleLocationsEXT = (vkCmdSetSampleLocationsEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCmdSetSampleLocationsEXT));
//            }

//            if (delvkCmdSetSampleLocationsEXT != null) {
//                delvkCmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo);
//            }
//        }
//        private static vkCmdSetSampleLocationsEXT delvkCmdSetSampleLocationsEXT;

//        // Command: 107
//        // GetInstanceProcAddr: 18
//        /// <summary>vkCreateDebugReportCallbackEXT - Create a debug report callback object
//        /// </summary>
//        /// <param name="instance">instance the instance the callback will be logged on.</param>
//        /// <param name="pCreateInfo">pCreateInfo points to a VkDebugReportCallbackCreateInfoEXT
//        /// structure which defines the conditions under which this callback will be
//        /// called.</param>
//        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
//        /// Memory Allocation chapter.</param>
//        /// <param name="pCallback">pCallback is a pointer to record the
//        /// VkDebugReportCallbackEXT object created.</param>
//        public static VkResult CreateDebugReportCallbackEXT(
//            this VkInstance instance,
//            /*-const-*/ VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
//            /*-const-*/ VkAllocationCallbacks* pAllocator,
//            VkDebugReportCallbackEXT* pCallback) {
//            if (delvkCreateDebugReportCallbackEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCreateDebugReportCallbackEXT");
//                delvkCreateDebugReportCallbackEXT = (vkCreateDebugReportCallbackEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCreateDebugReportCallbackEXT));
//            }

//            if (delvkCreateDebugReportCallbackEXT != null) {
//                return delvkCreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkCreateDebugReportCallbackEXT delvkCreateDebugReportCallbackEXT;

//        // Command: 108
//        // GetInstanceProcAddr: 19
//        /// <summary>vkCreateDebugUtilsMessengerEXT - Create a debug messenger object
//        /// </summary>
//        /// <param name="instance">instance the instance the messenger will be used with.</param>
//        /// <param name="pCreateInfo">pCreateInfo points to a VkDebugUtilsMessengerCreateInfoEXT
//        /// structure which contains the callback pointer as well as defines the
//        /// conditions under which this messenger will trigger the callback.</param>
//        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
//        /// Memory Allocation chapter.</param>
//        /// <param name="pMessenger">pMessenger is a pointer to record the
//        /// VkDebugUtilsMessengerEXT object created.</param>
//        public static VkResult CreateDebugUtilsMessengerEXT(
//            this VkInstance instance,
//            /*-const-*/ VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
//            /*-const-*/ VkAllocationCallbacks* pAllocator,
//            VkDebugUtilsMessengerEXT* pMessenger) {
//            if (delvkCreateDebugUtilsMessengerEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCreateDebugUtilsMessengerEXT");
//                delvkCreateDebugUtilsMessengerEXT = (vkCreateDebugUtilsMessengerEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCreateDebugUtilsMessengerEXT));
//            }

//            if (delvkCreateDebugUtilsMessengerEXT != null) {
//                return delvkCreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkCreateDebugUtilsMessengerEXT delvkCreateDebugUtilsMessengerEXT;

//        // Command: 126
//        // GetInstanceProcAddr: 20
//        /// <summary>vkCreateMetalSurfaceEXT - Create a VkSurfaceKHR object for CAMetalLayer
//        /// </summary>
//        /// <param name="instance">instance is the instance with which to associate the surface.</param>
//        /// <param name="pCreateInfo">pCreateInfo is a pointer to an instance of the
//        /// VkMetalSurfaceCreateInfoEXT structure containing the parameters
//        /// affecting the creation of the surface object.</param>
//        /// <param name="pAllocator">pAllocator is the allocator used for host memory allocated for the
//        /// surface object when there is no more specific allocator available (see
//        /// Memory Allocation).</param>
//        /// <param name="pSurface">pSurface points to a VkSurfaceKHR handle in which the
//        /// created surface object is returned.</param>
//        public static VkResult CreateMetalSurfaceEXT(
//            this VkInstance instance,
//            /*-const-*/ VkMetalSurfaceCreateInfoEXT* pCreateInfo,
//            /*-const-*/ VkAllocationCallbacks* pAllocator,
//            VkSurfaceKHR* pSurface) {
//            if (delvkCreateMetalSurfaceEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCreateMetalSurfaceEXT");
//                delvkCreateMetalSurfaceEXT = (vkCreateMetalSurfaceEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCreateMetalSurfaceEXT));
//            }

//            if (delvkCreateMetalSurfaceEXT != null) {
//                return delvkCreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkCreateMetalSurfaceEXT delvkCreateMetalSurfaceEXT;

//        // Command: 141
//        // GetInstanceProcAddr: 21
//        /// <summary>vkCreateValidationCacheEXT - Creates a new validation cache
//        /// </summary>
//        /// <param name="device">device is the logical device that creates the validation cache
//        /// object.</param>
//        /// <param name="pCreateInfo">pCreateInfo is a pointer to a VkValidationCacheCreateInfoEXT
//        /// structure that contains the initial parameters for the validation cache
//        /// object.</param>
//        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
//        /// Memory Allocation chapter.</param>
//        /// <param name="pValidationCache">pValidationCache is a pointer to a VkValidationCacheEXT
//        /// handle in which the resulting validation cache object is returned.</param>
//        public static VkResult CreateValidationCacheEXT(
//            this VkInstance instance,
//            VkDevice device,
//            /*-const-*/ VkValidationCacheCreateInfoEXT* pCreateInfo,
//            /*-const-*/ VkAllocationCallbacks* pAllocator,
//            VkValidationCacheEXT* pValidationCache) {
//            if (delvkCreateValidationCacheEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkCreateValidationCacheEXT");
//                delvkCreateValidationCacheEXT = (vkCreateValidationCacheEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkCreateValidationCacheEXT));
//            }

//            if (delvkCreateValidationCacheEXT != null) {
//                return delvkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkCreateValidationCacheEXT delvkCreateValidationCacheEXT;

//        // Command: 147
//        // GetInstanceProcAddr: 22
//        /// <summary>vkDebugMarkerSetObjectNameEXT - Give a user-friendly name to an object
//        /// </summary>
//        /// <param name="device">device is the device that created the object.</param>
//        /// <param name="pNameInfo">pNameInfo is a pointer to an instance of the
//        /// VkDebugMarkerObjectNameInfoEXT structure specifying the parameters
//        /// of the name to set on the object.</param>
//        public static VkResult DebugMarkerSetObjectNameEXT(
//            this VkInstance instance,
//            VkDevice device,
//            /*-const-*/ VkDebugMarkerObjectNameInfoEXT* pNameInfo) {
//            if (delvkDebugMarkerSetObjectNameEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDebugMarkerSetObjectNameEXT");
//                delvkDebugMarkerSetObjectNameEXT = (vkDebugMarkerSetObjectNameEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDebugMarkerSetObjectNameEXT));
//            }

//            if (delvkDebugMarkerSetObjectNameEXT != null) {
//                return delvkDebugMarkerSetObjectNameEXT(device, pNameInfo);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkDebugMarkerSetObjectNameEXT delvkDebugMarkerSetObjectNameEXT;

//        // Command: 148
//        // GetInstanceProcAddr: 23
//        /// <summary>vkDebugMarkerSetObjectTagEXT - Attach arbitrary data to an object
//        /// </summary>
//        /// <param name="device">device is the device that created the object.</param>
//        /// <param name="pTagInfo">pTagInfo is a pointer to an instance of the
//        /// VkDebugMarkerObjectTagInfoEXT structure specifying the parameters
//        /// of the tag to attach to the object.</param>
//        public static VkResult DebugMarkerSetObjectTagEXT(
//            this VkInstance instance,
//            VkDevice device,
//            /*-const-*/ VkDebugMarkerObjectTagInfoEXT* pTagInfo) {
//            if (delvkDebugMarkerSetObjectTagEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDebugMarkerSetObjectTagEXT");
//                delvkDebugMarkerSetObjectTagEXT = (vkDebugMarkerSetObjectTagEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDebugMarkerSetObjectTagEXT));
//            }

//            if (delvkDebugMarkerSetObjectTagEXT != null) {
//                return delvkDebugMarkerSetObjectTagEXT(device, pTagInfo);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkDebugMarkerSetObjectTagEXT delvkDebugMarkerSetObjectTagEXT;

//        // Command: 149
//        // GetInstanceProcAddr: 24
//        /// <summary>vkDebugReportMessageEXT - Inject a message into a debug stream
//        /// </summary>
//        /// <param name="instance">instance is the debug streams VkInstance.</param>
//        /// <param name="flags">flags specifies the VkDebugReportFlagBitsEXT classification
//        /// of this event/message.</param>
//        /// <param name="objectType">objectType is a VkDebugReportObjectTypeEXT specifying the
//        /// type of object being used or created at the time the event was
//        /// triggered.</param>
//        /// <param name="object">object this is the object where the issue was detected.
//        /// objectcan be VK_NULL_HANDLE if there is no object
//        /// associated with the event.</param>
//        /// <param name="location">location is an application defined value.</param>
//        /// <param name="messageCode">messageCode is an application defined value.</param>
//        /// <param name="pLayerPrefix">pLayerPrefix is the abbreviation of the component making this
//        /// event/message.</param>
//        /// <param name="pMessage">pMessage is a null-terminated string detailing the trigger
//        /// conditions.</param>
//        public static void DebugReportMessageEXT(
//            this VkInstance instance,
//            VkDebugReportFlagsEXT flags,
//            VkDebugReportObjectTypeEXT _objectType,
//            UInt64 _object,
//            Int32 location,
//            Int32 messageCode,
//            IntPtr pLayerPrefix,
//            IntPtr pMessage) {
//            if (delvkDebugReportMessageEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDebugReportMessageEXT");
//                delvkDebugReportMessageEXT = (vkDebugReportMessageEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDebugReportMessageEXT));
//            }

//            if (delvkDebugReportMessageEXT != null) {
//                delvkDebugReportMessageEXT(instance, flags, _objectType, _object, location, messageCode, pLayerPrefix, pMessage);
//            }
//        }
//        private static vkDebugReportMessageEXT delvkDebugReportMessageEXT;

//        // Command: 154
//        // GetInstanceProcAddr: 25
//        /// <summary>vkDestroyDebugReportCallbackEXT - Destroy a debug report callback object
//        /// </summary>
//        /// <param name="instance">instance the instance where the callback was created.</param>
//        /// <param name="callback">callback the VkDebugReportCallbackEXT object to destroy.
//        /// callback is an externally synchronized object and must not be
//        /// used on more than one thread at a time.
//        /// This means that vkDestroyDebugReportCallbackEXTmust not be
//        /// called when a callback is active.</param>
//        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
//        /// Memory Allocation chapter.</param>
//        public static void DestroyDebugReportCallbackEXT(
//            this VkInstance instance,
//            VkDebugReportCallbackEXT callback,
//            /*-const-*/ VkAllocationCallbacks* pAllocator) {
//            if (delvkDestroyDebugReportCallbackEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDestroyDebugReportCallbackEXT");
//                delvkDestroyDebugReportCallbackEXT = (vkDestroyDebugReportCallbackEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDestroyDebugReportCallbackEXT));
//            }

//            if (delvkDestroyDebugReportCallbackEXT != null) {
//                delvkDestroyDebugReportCallbackEXT(instance, callback, pAllocator);
//            }
//        }
//        private static vkDestroyDebugReportCallbackEXT delvkDestroyDebugReportCallbackEXT;

//        // Command: 155
//        // GetInstanceProcAddr: 26
//        /// <summary>vkDestroyDebugUtilsMessengerEXT - Destroy a debug messenger object
//        /// </summary>
//        /// <param name="instance">instance the instance where the callback was created.</param>
//        /// <param name="messenger">messenger the VkDebugUtilsMessengerEXT object to destroy.
//        /// messenger is an externally synchronized object and must not be
//        /// used on more than one thread at a time.
//        /// This means that vkDestroyDebugUtilsMessengerEXTmust not be
//        /// called when a callback is active.</param>
//        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
//        /// Memory Allocation chapter.</param>
//        public static void DestroyDebugUtilsMessengerEXT(
//            this VkInstance instance,
//            VkDebugUtilsMessengerEXT messenger,
//            /*-const-*/ VkAllocationCallbacks* pAllocator) {
//            if (delvkDestroyDebugUtilsMessengerEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDestroyDebugUtilsMessengerEXT");
//                delvkDestroyDebugUtilsMessengerEXT = (vkDestroyDebugUtilsMessengerEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDestroyDebugUtilsMessengerEXT));
//            }

//            if (delvkDestroyDebugUtilsMessengerEXT != null) {
//                delvkDestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator);
//            }
//        }
//        private static vkDestroyDebugUtilsMessengerEXT delvkDestroyDebugUtilsMessengerEXT;

//        // Command: 179
//        // GetInstanceProcAddr: 27
//        /// <summary>vkDestroyValidationCacheEXT - Destroy a validation cache object
//        /// </summary>
//        /// <param name="device">device is the logical device that destroys the validation cache
//        /// object.</param>
//        /// <param name="validationCache">validationCache is the handle of the validation cache to destroy.</param>
//        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
//        /// Memory Allocation chapter.</param>
//        public static void DestroyValidationCacheEXT(
//            this VkInstance instance,
//            VkDevice device,
//            VkValidationCacheEXT validationCache,
//            /*-const-*/ VkAllocationCallbacks* pAllocator) {
//            if (delvkDestroyValidationCacheEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDestroyValidationCacheEXT");
//                delvkDestroyValidationCacheEXT = (vkDestroyValidationCacheEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDestroyValidationCacheEXT));
//            }

//            if (delvkDestroyValidationCacheEXT != null) {
//                delvkDestroyValidationCacheEXT(device, validationCache, pAllocator);
//            }
//        }
//        private static vkDestroyValidationCacheEXT delvkDestroyValidationCacheEXT;

//        // Command: 181
//        // GetInstanceProcAddr: 28
//        /// <summary>vkDisplayPowerControlEXT - Set the power state of a display
//        /// </summary>
//        /// <param name="device">device is a logical device associated with display.</param>
//        /// <param name="display">display is the display whose power state is modified.</param>
//        /// <param name="pDisplayPowerInfo">pDisplayPowerInfo is an instance of VkDisplayPowerInfoEXT
//        /// specifying the new power state of display.</param>
//        public static VkResult DisplayPowerControlEXT(
//            this VkInstance instance,
//            VkDevice device,
//            VkDisplayKHR display,
//            /*-const-*/ VkDisplayPowerInfoEXT* pDisplayPowerInfo) {
//            if (delvkDisplayPowerControlEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkDisplayPowerControlEXT");
//                delvkDisplayPowerControlEXT = (vkDisplayPowerControlEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkDisplayPowerControlEXT));
//            }

//            if (delvkDisplayPowerControlEXT != null) {
//                return delvkDisplayPowerControlEXT(device, display, pDisplayPowerInfo);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkDisplayPowerControlEXT delvkDisplayPowerControlEXT;

//        // Command: 197
//        // GetInstanceProcAddr: 29
//        /// <summary>vkGetBufferDeviceAddressEXT - Query an address of a buffer
//        /// </summary>
//        /// <param name="device">device is the logical device that the buffer was created on.</param>
//        /// <param name="pInfo">pInfo is a pointer to an instance of the
//        /// VkBufferDeviceAddressInfoEXT structure specifying the buffer to
//        /// retrieve an address for.</param>
//        public static VkDeviceAddress GetBufferDeviceAddressEXT(
//            this VkInstance instance,
//            VkDevice device,
//            /*-const-*/ VkBufferDeviceAddressInfoEXT* pInfo) {
//            if (delvkGetBufferDeviceAddressEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetBufferDeviceAddressEXT");
//                delvkGetBufferDeviceAddressEXT = (vkGetBufferDeviceAddressEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetBufferDeviceAddressEXT));
//            }

//            if (delvkGetBufferDeviceAddressEXT != null) {
//                return delvkGetBufferDeviceAddressEXT(device, pInfo);
//            }
//            else {
//                return 0;
//            }
//        }
//        private static vkGetBufferDeviceAddressEXT delvkGetBufferDeviceAddressEXT;

//        // Command: 200
//        // GetInstanceProcAddr: 30
//        /// <summary>vkGetCalibratedTimestampsEXT - Query calibrated timestamps
//        /// </summary>
//        /// <param name="device">device is the logical device used to perform the query.</param>
//        /// <param name="timestampCount">timestampCount is the number of timestamps to query.</param>
//        /// <param name="pTimestampInfos">pTimestampInfos is a pointer to an array of timestampCount
//        /// number of structures of type VkCalibratedTimestampInfoEXT,
//        /// describing the time domains the calibrated timestamps should be captured
//        /// from.</param>
//        /// <param name="pTimestamps">pTimestamps is a pointer to an array of timestampCount
//        /// number of 64-bit unsigned integer values in which the requested
//        /// calibrated timestamp values are returned.</param>
//        /// <param name="pMaxDeviation">pMaxDeviation is a pointer to a 64-bit unsigned integer value in
//        /// which the strictly positive maximum deviation, in nanoseconds, of the
//        /// calibrated timestamp values is returned.</param>
//        public static VkResult GetCalibratedTimestampsEXT(
//            this VkInstance instance,
//            VkDevice device,
//            UInt32 timestampCount,
//            /*-const-*/ VkCalibratedTimestampInfoEXT* pTimestampInfos,
//            UInt64* pTimestamps,
//            UInt64* pMaxDeviation) {
//            if (delvkGetCalibratedTimestampsEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetCalibratedTimestampsEXT");
//                delvkGetCalibratedTimestampsEXT = (vkGetCalibratedTimestampsEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetCalibratedTimestampsEXT));
//            }

//            if (delvkGetCalibratedTimestampsEXT != null) {
//                return delvkGetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkGetCalibratedTimestampsEXT delvkGetCalibratedTimestampsEXT;

//        // Command: 204
//        // GetInstanceProcAddr: 31
//        /// <summary>vkGetDeviceGroupSurfacePresentModes2EXT - Query device group present capabilities for a surface
//        /// </summary>
//        /// <param name="device">device is the logical device.</param>
//        /// <param name="pSurfaceInfo">pSurfaceInfo points to an instance of the
//        /// VkPhysicalDeviceSurfaceInfo2KHR structure, describing the surface and
//        /// other fixed parameters that would be consumed by vkCreateSwapchainKHR.</param>
//        /// <param name="pModes">pModes is a pointer to a value of type
//        /// VkDeviceGroupPresentModeFlagsKHR that is filled with the supported
//        /// device group present modes for the surface.</param>
//        public static VkResult GetDeviceGroupSurfacePresentModes2EXT(
//            this VkInstance instance,
//            VkDevice device,
//            /*-const-*/ VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
//            VkDeviceGroupPresentModeFlagsKHR* pModes) {
//            if (delvkGetDeviceGroupSurfacePresentModes2EXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetDeviceGroupSurfacePresentModes2EXT");
//                delvkGetDeviceGroupSurfacePresentModes2EXT = (vkGetDeviceGroupSurfacePresentModes2EXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetDeviceGroupSurfacePresentModes2EXT));
//            }

//            if (delvkGetDeviceGroupSurfacePresentModes2EXT != null) {
//                return delvkGetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkGetDeviceGroupSurfacePresentModes2EXT delvkGetDeviceGroupSurfacePresentModes2EXT;

//        // Command: 219
//        // GetInstanceProcAddr: 32
//        /// <summary>vkGetImageDrmFormatModifierPropertiesEXT - Returns an images DRM format modifier
//        /// </summary>
//        /// <param name="device">device is the logical device that owns the image.</param>
//        /// <param name="image">image is the queried image.</param>
//        /// <param name="pProperties">pProperties will return properties of the images DRM format
//        /// modifier.</param>
//        public static VkResult GetImageDrmFormatModifierPropertiesEXT(
//            this VkInstance instance,
//            VkDevice device,
//            VkImage image,
//            VkImageDrmFormatModifierPropertiesEXT* pProperties) {
//            if (delvkGetImageDrmFormatModifierPropertiesEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetImageDrmFormatModifierPropertiesEXT");
//                delvkGetImageDrmFormatModifierPropertiesEXT = (vkGetImageDrmFormatModifierPropertiesEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetImageDrmFormatModifierPropertiesEXT));
//            }

//            if (delvkGetImageDrmFormatModifierPropertiesEXT != null) {
//                return delvkGetImageDrmFormatModifierPropertiesEXT(device, image, pProperties);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkGetImageDrmFormatModifierPropertiesEXT delvkGetImageDrmFormatModifierPropertiesEXT;

//        // Command: 230
//        // GetInstanceProcAddr: 33
//        /// <summary>vkGetMemoryHostPointerPropertiesEXT - Get properties of external memory host pointer
//        /// </summary>
//        /// <param name="device">device is the logical device that will be importing
//        /// pHostPointer.</param>
//        /// <param name="handleType">handleType is the type of the handle pHostPointer.</param>
//        /// <param name="pHostPointer">pHostPointer is the host pointer to import from.</param>
//        /// <param name="pMemoryHostPointerProperties">pMemoryHostPointerProperties is a pointer to a
//        /// VkMemoryHostPointerPropertiesEXT structure in which the host
//        /// pointer properties are returned.</param>
//        public static VkResult GetMemoryHostPointerPropertiesEXT(
//            this VkInstance instance,
//            VkDevice device,
//            VkExternalMemoryHandleTypeFlagBits handleType,
//            /*-const-*/ void* pHostPointer,
//            VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties) {
//            if (delvkGetMemoryHostPointerPropertiesEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetMemoryHostPointerPropertiesEXT");
//                delvkGetMemoryHostPointerPropertiesEXT = (vkGetMemoryHostPointerPropertiesEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetMemoryHostPointerPropertiesEXT));
//            }

//            if (delvkGetMemoryHostPointerPropertiesEXT != null) {
//                return delvkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkGetMemoryHostPointerPropertiesEXT delvkGetMemoryHostPointerPropertiesEXT;

//        // Command: 235
//        // GetInstanceProcAddr: 34
//        /// <summary>vkGetPhysicalDeviceCalibrateableTimeDomainsEXT - Query calibrateable time domains
//        /// </summary>
//        /// <param name="physicalDevice">physicalDevice is the physical device from which to query the set
//        /// of calibrateable time domains.</param>
//        /// <param name="pTimeDomainCount">pTimeDomainCount is a pointer to an integer related to the number
//        /// of calibrateable time domains available or queried, as described below.</param>
//        /// <param name="pTimeDomains">pTimeDomains is either NULL or a pointer to an array of
//        /// VkTimeDomainEXT values, indicating the supported calibrateable
//        /// time domains.</param>
//        public static VkResult GetPhysicalDeviceCalibrateableTimeDomainsEXT(
//            this VkInstance instance,
//            VkPhysicalDevice physicalDevice,
//            UInt32* pTimeDomainCount,
//            VkTimeDomainEXT* pTimeDomains) {
//            if (delvkGetPhysicalDeviceCalibrateableTimeDomainsEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
//                delvkGetPhysicalDeviceCalibrateableTimeDomainsEXT = (vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetPhysicalDeviceCalibrateableTimeDomainsEXT));
//            }

//            if (delvkGetPhysicalDeviceCalibrateableTimeDomainsEXT != null) {
//                return delvkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkGetPhysicalDeviceCalibrateableTimeDomainsEXT delvkGetPhysicalDeviceCalibrateableTimeDomainsEXT;

//        // Command: 254
//        // GetInstanceProcAddr: 35
//        /// <summary>vkGetPhysicalDeviceMultisamplePropertiesEXT - Report sample count specific multisampling capabilities of a physical device
//        /// </summary>
//        /// <param name="physicalDevice">physicalDevice is the physical device from which to query the
//        /// additional multisampling capabilities.</param>
//        /// <param name="samples">samples is the sample count to query the capabilities for.</param>
//        /// <param name="pMultisampleProperties">pMultisampleProperties is a pointer to a structure of type
//        /// VkMultisamplePropertiesEXT, in which information about the
//        /// additional multisampling capabilities specific to the sample count is
//        /// returned.</param>
//        public static void GetPhysicalDeviceMultisamplePropertiesEXT(
//            this VkInstance instance,
//            VkPhysicalDevice physicalDevice,
//            VkSampleCountFlagBits samples,
//            VkMultisamplePropertiesEXT* pMultisampleProperties) {
//            if (delvkGetPhysicalDeviceMultisamplePropertiesEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMultisamplePropertiesEXT");
//                delvkGetPhysicalDeviceMultisamplePropertiesEXT = (vkGetPhysicalDeviceMultisamplePropertiesEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetPhysicalDeviceMultisamplePropertiesEXT));
//            }

//            if (delvkGetPhysicalDeviceMultisamplePropertiesEXT != null) {
//                delvkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties);
//            }
//        }
//        private static vkGetPhysicalDeviceMultisamplePropertiesEXT delvkGetPhysicalDeviceMultisamplePropertiesEXT;

//        // Command: 262
//        // GetInstanceProcAddr: 36
//        /// <summary>vkGetPhysicalDeviceSurfaceCapabilities2EXT - Query surface capabilities
//        /// </summary>
//        /// <param name="physicalDevice">physicalDevice is the physical device that will be associated with
//        /// the swapchain to be created, as described for
//        /// vkCreateSwapchainKHR.</param>
//        /// <param name="surface">surface is the surface that will be associated with the swapchain.</param>
//        /// <param name="pSurfaceCapabilities">pSurfaceCapabilities is a pointer to an instance of the
//        /// VkSurfaceCapabilities2EXT structure in which the capabilities are
//        /// returned.</param>
//        public static VkResult GetPhysicalDeviceSurfaceCapabilities2EXT(
//            this VkInstance instance,
//            VkPhysicalDevice physicalDevice,
//            VkSurfaceKHR surface,
//            VkSurfaceCapabilities2EXT* pSurfaceCapabilities) {
//            if (delvkGetPhysicalDeviceSurfaceCapabilities2EXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2EXT");
//                delvkGetPhysicalDeviceSurfaceCapabilities2EXT = (vkGetPhysicalDeviceSurfaceCapabilities2EXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetPhysicalDeviceSurfaceCapabilities2EXT));
//            }

//            if (delvkGetPhysicalDeviceSurfaceCapabilities2EXT != null) {
//                return delvkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkGetPhysicalDeviceSurfaceCapabilities2EXT delvkGetPhysicalDeviceSurfaceCapabilities2EXT;

//        // Command: 267
//        // GetInstanceProcAddr: 37
//        /// <summary>vkGetPhysicalDeviceSurfacePresentModes2EXT - Query supported presentation modes
//        /// </summary>
//        /// <param name="physicalDevice">physicalDevice is the physical device that will be associated with
//        /// the swapchain to be created, as described for
//        /// vkCreateSwapchainKHR.</param>
//        /// <param name="pSurfaceInfo">pSurfaceInfo points to an instance of the
//        /// VkPhysicalDeviceSurfaceInfo2KHR structure, describing the surface
//        /// and other fixed parameters that would be consumed by
//        /// vkCreateSwapchainKHR.</param>
//        /// <param name="pPresentModeCount">pPresentModeCount is a pointer to an integer related to the number
//        /// of presentation modes available or queried, as described below.</param>
//        /// <param name="pPresentModes">pPresentModes is either NULL or a pointer to an array of
//        /// VkPresentModeKHR values, indicating the supported presentation
//        /// modes.</param>
//        public static VkResult GetPhysicalDeviceSurfacePresentModes2EXT(
//            this VkInstance instance,
//            VkPhysicalDevice physicalDevice,
//            /*-const-*/ VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
//            UInt32* pPresentModeCount,
//            VkPresentModeKHR* pPresentModes) {
//            if (delvkGetPhysicalDeviceSurfacePresentModes2EXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfacePresentModes2EXT");
//                delvkGetPhysicalDeviceSurfacePresentModes2EXT = (vkGetPhysicalDeviceSurfacePresentModes2EXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetPhysicalDeviceSurfacePresentModes2EXT));
//            }

//            if (delvkGetPhysicalDeviceSurfacePresentModes2EXT != null) {
//                return delvkGetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkGetPhysicalDeviceSurfacePresentModes2EXT delvkGetPhysicalDeviceSurfacePresentModes2EXT;

//        // Command: 277
//        // GetInstanceProcAddr: 38
//        /// <summary>vkGetRandROutputDisplayEXT - Query the VkDisplayKHR corresponding to an X11 RandR Output
//        /// </summary>
//        /// <param name="physicalDevice">physicalDevice The physical device to query the display handle on.</param>
//        /// <param name="dpy">dpy A connection to the X11 server from which rrOutput was
//        /// queried.</param>
//        /// <param name="rrOutput">rrOutput An X11 RandR output ID.</param>
//        /// <param name="pDisplay">pDisplay The corresponding VkDisplayKHR handle will be
//        /// returned here.</param>
//        public static VkResult GetRandROutputDisplayEXT(
//            this VkInstance instance,
//            VkPhysicalDevice physicalDevice,
//            /*Display*-*/IntPtr dpy,
//            /*RROutput*/IntPtr rrOutput,
//            VkDisplayKHR* pDisplay) {
//            if (delvkGetRandROutputDisplayEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetRandROutputDisplayEXT");
//                delvkGetRandROutputDisplayEXT = (vkGetRandROutputDisplayEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetRandROutputDisplayEXT));
//            }

//            if (delvkGetRandROutputDisplayEXT != null) {
//                return delvkGetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkGetRandROutputDisplayEXT delvkGetRandROutputDisplayEXT;

//        // Command: 284
//        // GetInstanceProcAddr: 39
//        /// <summary>vkGetSwapchainCounterEXT - Query the current value of a surface counter
//        /// </summary>
//        /// <param name="device">device is the VkDevice associated with swapchain.</param>
//        /// <param name="swapchain">swapchain is the swapchain from which to query the counter value.</param>
//        /// <param name="counter">counter is the counter to query.</param>
//        /// <param name="pCounterValue">pCounterValue will return the current value of the counter.</param>
//        public static VkResult GetSwapchainCounterEXT(
//            this VkInstance instance,
//            VkDevice device,
//            VkSwapchainKHR swapchain,
//            VkSurfaceCounterFlagBitsEXT counter,
//            UInt64* pCounterValue) {
//            if (delvkGetSwapchainCounterEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetSwapchainCounterEXT");
//                delvkGetSwapchainCounterEXT = (vkGetSwapchainCounterEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetSwapchainCounterEXT));
//            }

//            if (delvkGetSwapchainCounterEXT != null) {
//                return delvkGetSwapchainCounterEXT(device, swapchain, counter, pCounterValue);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkGetSwapchainCounterEXT delvkGetSwapchainCounterEXT;

//        // Command: 287
//        // GetInstanceProcAddr: 40
//        /// <summary>vkGetValidationCacheDataEXT - Get the data store from a validation cache
//        /// </summary>
//        /// <param name="device">device is the logical device that owns the validation cache.</param>
//        /// <param name="validationCache">validationCache is the validation cache to retrieve data from.</param>
//        /// <param name="pDataSize">pDataSize is a pointer to a value related to the amount of data in
//        /// the validation cache, as described below.</param>
//        /// <param name="pData">pData is either NULL or a pointer to a buffer.</param>
//        public static VkResult GetValidationCacheDataEXT(
//            this VkInstance instance,
//            VkDevice device,
//            VkValidationCacheEXT validationCache,
//            Int32* pDataSize,
//            void* pData) {
//            if (delvkGetValidationCacheDataEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkGetValidationCacheDataEXT");
//                delvkGetValidationCacheDataEXT = (vkGetValidationCacheDataEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkGetValidationCacheDataEXT));
//            }

//            if (delvkGetValidationCacheDataEXT != null) {
//                return delvkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkGetValidationCacheDataEXT delvkGetValidationCacheDataEXT;

//        // Command: 295
//        // GetInstanceProcAddr: 41
//        /// <summary>vkMergeValidationCachesEXT - Combine the data stores of validation caches
//        /// </summary>
//        /// <param name="device">device is the logical device that owns the validation cache
//        /// objects.</param>
//        /// <param name="dstCache">dstCache is the handle of the validation cache to merge results
//        /// into.</param>
//        /// <param name="srcCacheCount">srcCacheCount is the length of the pSrcCaches array.</param>
//        /// <param name="pSrcCaches">pSrcCaches is an array of validation cache handles, which will be
//        /// merged into dstCache.
//        /// The previous contents of dstCache are included after the merge.</param>
//        public static VkResult MergeValidationCachesEXT(
//            this VkInstance instance,
//            VkDevice device,
//            VkValidationCacheEXT dstCache,
//            UInt32 srcCacheCount,
//            /*-const-*/ VkValidationCacheEXT* pSrcCaches) {
//            if (delvkMergeValidationCachesEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkMergeValidationCachesEXT");
//                delvkMergeValidationCachesEXT = (vkMergeValidationCachesEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkMergeValidationCachesEXT));
//            }

//            if (delvkMergeValidationCachesEXT != null) {
//                return delvkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkMergeValidationCachesEXT delvkMergeValidationCachesEXT;

//        // Command: 296
//        // GetInstanceProcAddr: 42
//        /// <summary>vkQueueBeginDebugUtilsLabelEXT - Open a queue debug label region
//        /// </summary>
//        /// <param name="queue">queue is the queue in which to start a debug label region.</param>
//        /// <param name="pLabelInfo">pLabelInfo is a pointer to an instance of the
//        /// VkDebugUtilsLabelEXT structure specifying the parameters of the
//        /// label region to open.</param>
//        public static void QueueBeginDebugUtilsLabelEXT(
//            this VkInstance instance,
//            VkQueue queue,
//            /*-const-*/ VkDebugUtilsLabelEXT* pLabelInfo) {
//            if (delvkQueueBeginDebugUtilsLabelEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkQueueBeginDebugUtilsLabelEXT");
//                delvkQueueBeginDebugUtilsLabelEXT = (vkQueueBeginDebugUtilsLabelEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkQueueBeginDebugUtilsLabelEXT));
//            }

//            if (delvkQueueBeginDebugUtilsLabelEXT != null) {
//                delvkQueueBeginDebugUtilsLabelEXT(queue, pLabelInfo);
//            }
//        }
//        private static vkQueueBeginDebugUtilsLabelEXT delvkQueueBeginDebugUtilsLabelEXT;

//        // Command: 298
//        // GetInstanceProcAddr: 43
//        /// <summary>vkQueueEndDebugUtilsLabelEXT - Close a queue debug label region
//        /// </summary>
//        /// <param name="queue">queue is the queue in which a debug label region should be closed.</param>
//        public static void QueueEndDebugUtilsLabelEXT(
//            this VkInstance instance,
//            VkQueue queue) {
//            if (delvkQueueEndDebugUtilsLabelEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkQueueEndDebugUtilsLabelEXT");
//                delvkQueueEndDebugUtilsLabelEXT = (vkQueueEndDebugUtilsLabelEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkQueueEndDebugUtilsLabelEXT));
//            }

//            if (delvkQueueEndDebugUtilsLabelEXT != null) {
//                delvkQueueEndDebugUtilsLabelEXT(queue);
//            }
//        }
//        private static vkQueueEndDebugUtilsLabelEXT delvkQueueEndDebugUtilsLabelEXT;

//        // Command: 299
//        // GetInstanceProcAddr: 44
//        /// <summary>vkQueueInsertDebugUtilsLabelEXT - Insert a label into a queue
//        /// </summary>
//        /// <param name="queue">queue is the queue into which a debug label will be inserted.</param>
//        /// <param name="pLabelInfo">pLabelInfo is a pointer to an instance of the
//        /// VkDebugUtilsLabelEXT structure specifying the parameters of the
//        /// label to insert.</param>
//        public static void QueueInsertDebugUtilsLabelEXT(
//            this VkInstance instance,
//            VkQueue queue,
//            /*-const-*/ VkDebugUtilsLabelEXT* pLabelInfo) {
//            if (delvkQueueInsertDebugUtilsLabelEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkQueueInsertDebugUtilsLabelEXT");
//                delvkQueueInsertDebugUtilsLabelEXT = (vkQueueInsertDebugUtilsLabelEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkQueueInsertDebugUtilsLabelEXT));
//            }

//            if (delvkQueueInsertDebugUtilsLabelEXT != null) {
//                delvkQueueInsertDebugUtilsLabelEXT(queue, pLabelInfo);
//            }
//        }
//        private static vkQueueInsertDebugUtilsLabelEXT delvkQueueInsertDebugUtilsLabelEXT;

//        // Command: 303
//        // GetInstanceProcAddr: 45
//        /// <summary>vkRegisterDeviceEventEXT - Signal a fence when a device event occurs
//        /// </summary>
//        /// <param name="device">device is a logical device on which the event may occur.</param>
//        /// <param name="pDeviceEventInfo">pDeviceEventInfo is a pointer to an instance of the
//        /// VkDeviceEventInfoEXT structure describing the event of interest to
//        /// the application.</param>
//        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
//        /// Memory Allocation chapter.</param>
//        /// <param name="pFence">pFence points to a handle in which the resulting fence object is
//        /// returned.</param>
//        public static VkResult RegisterDeviceEventEXT(
//            this VkInstance instance,
//            VkDevice device,
//            /*-const-*/ VkDeviceEventInfoEXT* pDeviceEventInfo,
//            /*-const-*/ VkAllocationCallbacks* pAllocator,
//            VkFence* pFence) {
//            if (delvkRegisterDeviceEventEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkRegisterDeviceEventEXT");
//                delvkRegisterDeviceEventEXT = (vkRegisterDeviceEventEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkRegisterDeviceEventEXT));
//            }

//            if (delvkRegisterDeviceEventEXT != null) {
//                return delvkRegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkRegisterDeviceEventEXT delvkRegisterDeviceEventEXT;

//        // Command: 304
//        // GetInstanceProcAddr: 46
//        /// <summary>vkRegisterDisplayEventEXT - Signal a fence when a display event occurs
//        /// </summary>
//        /// <param name="device">device is a logical device associated with display</param>
//        /// <param name="display">display is the display on which the event may occur.</param>
//        /// <param name="pDisplayEventInfo">pDisplayEventInfo is a pointer to an instance of the
//        /// VkDisplayEventInfoEXT structure describing the event of interest
//        /// to the application.</param>
//        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
//        /// Memory Allocation chapter.</param>
//        /// <param name="pFence">pFence points to a handle in which the resulting fence object is
//        /// returned.</param>
//        public static VkResult RegisterDisplayEventEXT(
//            this VkInstance instance,
//            VkDevice device,
//            VkDisplayKHR display,
//            /*-const-*/ VkDisplayEventInfoEXT* pDisplayEventInfo,
//            /*-const-*/ VkAllocationCallbacks* pAllocator,
//            VkFence* pFence) {
//            if (delvkRegisterDisplayEventEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkRegisterDisplayEventEXT");
//                delvkRegisterDisplayEventEXT = (vkRegisterDisplayEventEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkRegisterDisplayEventEXT));
//            }

//            if (delvkRegisterDisplayEventEXT != null) {
//                return delvkRegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkRegisterDisplayEventEXT delvkRegisterDisplayEventEXT;

//        // Command: 306
//        // GetInstanceProcAddr: 47
//        /// <summary>vkReleaseDisplayEXT - Release access to an acquired VkDisplayKHR
//        /// </summary>
//        /// <param name="physicalDevice">physicalDevice The physical device the display is on.</param>
//        /// <param name="display">display The display to release control of.</param>
//        public static VkResult ReleaseDisplayEXT(
//            this VkInstance instance,
//            VkPhysicalDevice physicalDevice,
//            VkDisplayKHR display) {
//            if (delvkReleaseDisplayEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkReleaseDisplayEXT");
//                delvkReleaseDisplayEXT = (vkReleaseDisplayEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkReleaseDisplayEXT));
//            }

//            if (delvkReleaseDisplayEXT != null) {
//                return delvkReleaseDisplayEXT(physicalDevice, display);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkReleaseDisplayEXT delvkReleaseDisplayEXT;

//        // Command: 307
//        // GetInstanceProcAddr: 48
//        /// <summary>vkReleaseFullScreenExclusiveModeEXT - Release full-screen exclusive mode from a swapchain
//        /// </summary>
//        /// <param name="device">device is the device associated with swapchain.</param>
//        /// <param name="swapchain">swapchain is the swapchain to release exclusive full-screen access
//        /// from.</param>
//        public static VkResult ReleaseFullScreenExclusiveModeEXT(
//            this VkInstance instance,
//            VkDevice device,
//            VkSwapchainKHR swapchain) {
//            if (delvkReleaseFullScreenExclusiveModeEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkReleaseFullScreenExclusiveModeEXT");
//                delvkReleaseFullScreenExclusiveModeEXT = (vkReleaseFullScreenExclusiveModeEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkReleaseFullScreenExclusiveModeEXT));
//            }

//            if (delvkReleaseFullScreenExclusiveModeEXT != null) {
//                return delvkReleaseFullScreenExclusiveModeEXT(device, swapchain);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkReleaseFullScreenExclusiveModeEXT delvkReleaseFullScreenExclusiveModeEXT;

//        // Command: 313
//        // GetInstanceProcAddr: 49
//        /// <summary>vkResetQueryPoolEXT - Reset queries in a query pool
//        /// </summary>
//        /// <param name="queryPool">queryPool is the handle of the query pool managing the queries
//        /// being reset.</param>
//        /// <param name="firstQuery">firstQuery is the initial query index to reset.</param>
//        /// <param name="queryCount">queryCount is the number of queries to reset.</param>
//        public static void ResetQueryPoolEXT(
//            this VkInstance instance,
//            VkDevice device,
//            VkQueryPool queryPool,
//            UInt32 firstQuery,
//            UInt32 queryCount) {
//            if (delvkResetQueryPoolEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkResetQueryPoolEXT");
//                delvkResetQueryPoolEXT = (vkResetQueryPoolEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkResetQueryPoolEXT));
//            }

//            if (delvkResetQueryPoolEXT != null) {
//                delvkResetQueryPoolEXT(device, queryPool, firstQuery, queryCount);
//            }
//        }
//        private static vkResetQueryPoolEXT delvkResetQueryPoolEXT;

//        // Command: 314
//        // GetInstanceProcAddr: 50
//        /// <summary>vkSetDebugUtilsObjectNameEXT - Give a user-friendly name to an object
//        /// </summary>
//        /// <param name="device">device is the device that created the object.</param>
//        /// <param name="pNameInfo">pNameInfo is a pointer to an instance of the
//        /// VkDebugUtilsObjectNameInfoEXT structure specifying the parameters
//        /// of the name to set on the object.</param>
//        public static VkResult SetDebugUtilsObjectNameEXT(
//            this VkInstance instance,
//            VkDevice device,
//            /*-const-*/ VkDebugUtilsObjectNameInfoEXT* pNameInfo) {
//            if (delvkSetDebugUtilsObjectNameEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkSetDebugUtilsObjectNameEXT");
//                delvkSetDebugUtilsObjectNameEXT = (vkSetDebugUtilsObjectNameEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkSetDebugUtilsObjectNameEXT));
//            }

//            if (delvkSetDebugUtilsObjectNameEXT != null) {
//                return delvkSetDebugUtilsObjectNameEXT(device, pNameInfo);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkSetDebugUtilsObjectNameEXT delvkSetDebugUtilsObjectNameEXT;

//        // Command: 315
//        // GetInstanceProcAddr: 51
//        /// <summary>vkSetDebugUtilsObjectTagEXT - Attach arbitrary data to an object
//        /// </summary>
//        /// <param name="device">device is the device that created the object.</param>
//        /// <param name="pTagInfo">pTagInfo is a pointer to an instance of the
//        /// VkDebugUtilsObjectTagInfoEXT structure specifying the parameters
//        /// of the tag to attach to the object.</param>
//        public static VkResult SetDebugUtilsObjectTagEXT(
//            this VkInstance instance,
//            VkDevice device,
//            /*-const-*/ VkDebugUtilsObjectTagInfoEXT* pTagInfo) {
//            if (delvkSetDebugUtilsObjectTagEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkSetDebugUtilsObjectTagEXT");
//                delvkSetDebugUtilsObjectTagEXT = (vkSetDebugUtilsObjectTagEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkSetDebugUtilsObjectTagEXT));
//            }

//            if (delvkSetDebugUtilsObjectTagEXT != null) {
//                return delvkSetDebugUtilsObjectTagEXT(device, pTagInfo);
//            }
//            else {
//                return VkResult.ErrorExtensionNotPresent;
//            }
//        }
//        private static vkSetDebugUtilsObjectTagEXT delvkSetDebugUtilsObjectTagEXT;

//        // Command: 317
//        // GetInstanceProcAddr: 52
//        /// <summary>vkSetHdrMetadataEXT - function to set Hdr metadata
//        /// </summary>
//        /// <param name="device">device is the logical device where the swapchain(s) were created.</param>
//        /// <param name="swapchainCount">swapchainCount is the number of swapchains included in
//        /// pSwapchains.</param>
//        /// <param name="pSwapchains">pSwapchains is a pointer to the array of swapchainCountVkSwapchainKHR handles.</param>
//        /// <param name="pMetadata">pMetadata is a pointer to the array of swapchainCountVkHdrMetadataEXT structures.</param>
//        public static void SetHdrMetadataEXT(
//            this VkInstance instance,
//            VkDevice device,
//            UInt32 swapchainCount,
//            /*-const-*/ VkSwapchainKHR* pSwapchains,
//            /*-const-*/ VkHdrMetadataEXT* pMetadata) {
//            if (delvkSetHdrMetadataEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkSetHdrMetadataEXT");
//                delvkSetHdrMetadataEXT = (vkSetHdrMetadataEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkSetHdrMetadataEXT));
//            }

//            if (delvkSetHdrMetadataEXT != null) {
//                delvkSetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata);
//            }
//        }
//        private static vkSetHdrMetadataEXT delvkSetHdrMetadataEXT;

//        // Command: 319
//        // GetInstanceProcAddr: 53
//        /// <summary>vkSubmitDebugUtilsMessageEXT - Inject a message into a debug stream
//        /// </summary>
//        /// <param name="instance">instance is the debug streams VkInstance.</param>
//        /// <param name="messageSeverity">messageSeverity is the
//        /// VkDebugUtilsMessageSeverityFlagBitsEXT severity of this
//        /// event/message.</param>
//        /// <param name="messageTypes">messageTypes is a bitmask of
//        /// VkDebugUtilsMessageTypeFlagBitsEXT specifying which type of
//        /// event(s) to identify with this message.</param>
//        /// <param name="pCallbackData">pCallbackData contains all the callback related data in the
//        /// VkDebugUtilsMessengerCallbackDataEXT structure.</param>
//        public static void SubmitDebugUtilsMessageEXT(
//            this VkInstance instance,
//            VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
//            VkDebugUtilsMessageTypeFlagsEXT messageTypes,
//            /*-const-*/ VkDebugUtilsMessengerCallbackDataEXT* pCallbackData) {
//            if (delvkSubmitDebugUtilsMessageEXT == null) {
//                IntPtr addr = vkAPI.vkGetInstanceProcAddr(instance, "vkSubmitDebugUtilsMessageEXT");
//                delvkSubmitDebugUtilsMessageEXT = (vkSubmitDebugUtilsMessageEXT)Marshal.GetDelegateForFunctionPointer(addr, typeof(vkSubmitDebugUtilsMessageEXT));
//            }

//            if (delvkSubmitDebugUtilsMessageEXT != null) {
//                delvkSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData);
//            }
//        }
//        private static vkSubmitDebugUtilsMessageEXT delvkSubmitDebugUtilsMessageEXT;

//    }
//}
