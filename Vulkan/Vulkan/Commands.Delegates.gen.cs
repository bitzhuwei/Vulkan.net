using System;
using System.Runtime.InteropServices;

// hand-coded.
using VkAndroidSurfaceCreateFlagsKHR = System.UInt32;
using VkBufferViewCreateFlags = Vulkan.VkFlags;
using VkDescriptorUpdateTemplateCreateFlags = Vulkan.VkFlags;
using VkDeviceCreateFlags = Vulkan.VkFlags;
using VkEventCreateFlags = Vulkan.VkFlags;
using VkFramebufferCreateFlags = Vulkan.VkFlags;
using VkImageViewCreateFlags = Vulkan.VkFlags;
using VkInstanceCreateFlags = Vulkan.VkFlags;
using VkPipelineCacheCreateFlags = Vulkan.VkFlags;
using VkPipelineColorBlendStateCreateFlags = Vulkan.VkFlags;
using VkPipelineCoverageModulationStateCreateFlagsNV = Vulkan.VkFlags;
using VkPipelineCoverageToColorStateCreateFlagsNV = Vulkan.VkFlags;
using VkPipelineDepthStencilStateCreateFlags = Vulkan.VkFlags;
using VkPipelineDiscardRectangleStateCreateFlagsEXT = Vulkan.VkFlags;
using VkPipelineDynamicStateCreateFlags = Vulkan.VkFlags;
using VkPipelineInputAssemblyStateCreateFlags = Vulkan.VkFlags;
using VkPipelineLayoutCreateFlags = Vulkan.VkFlags;
using VkPipelineMultisampleStateCreateFlags = Vulkan.VkFlags;
using VkPipelineRasterizationConservativeStateCreateFlagsEXT = Vulkan.VkFlags;
using VkPipelineRasterizationDepthClipStateCreateFlagsEXT = Vulkan.VkFlags;
using VkPipelineRasterizationStateCreateFlags = Vulkan.VkFlags;
using VkPipelineRasterizationStateStreamCreateFlagsEXT = Vulkan.VkFlags;
using VkPipelineShaderStageCreateFlags = Vulkan.VkFlags;
using VkPipelineTessellationStateCreateFlags = Vulkan.VkFlags;
using VkPipelineVertexInputStateCreateFlags = Vulkan.VkFlags;
using VkPipelineViewportStateCreateFlags = Vulkan.VkFlags;
using VkPipelineViewportSwizzleStateCreateFlagsNV = Vulkan.VkFlags;
using VkQueryPoolCreateFlags = Vulkan.VkFlags;
using VkRenderPassCreateFlags = Vulkan.VkFlags;
using VkSamplerCreateFlags = Vulkan.VkFlags;
using VkSemaphoreCreateFlags = Vulkan.VkFlags;
using VkShaderModuleCreateFlags = Vulkan.VkFlags;
using VkValidationCacheCreateFlagsEXT = Vulkan.VkFlags;
using VkQueryResultFlags = Vulkan.VkFlags;
using VkStencilFaceFlags = Vulkan.VkFlags;
using VkMemoryRequirements2KHR = Vulkan.VkMemoryRequirements2;
using VkPeerMemoryFeatureFlags = Vulkan.VkFlags;
using HANDLE = System.IntPtr;
using VkMemoryMapFlags = Vulkan.VkFlags;
using VkCommandBufferResetFlags = Vulkan.VkFlags;
using VkCommandPoolResetFlags = Vulkan.VkFlags;
using VkDescriptorPoolResetFlags = Vulkan.VkFlags;
using VkCommandPoolTrimFlags = Vulkan.VkFlags;
//
using HINSTANCE = System.IntPtr;
using HWND = System.IntPtr;
using LPCWSTR = System.IntPtr;
using DWORD = System.UInt32;
using VkIOSSurfaceCreateFlagsMVK = System.UInt32;
using VkImagePipeSurfaceCreateFlagsFUCHSIA = System.UInt32;
using zx_handle_t = System.IntPtr;
using VkMacOSSurfaceCreateFlagsMVK = System.UInt32;
using VkMetalSurfaceCreateFlagsEXT = System.UInt32;
using GgpFrameToken = System.IntPtr;
using VkStreamDescriptorSurfaceCreateFlagsGGP = System.UInt32;
using GgpStreamDescriptor = System.IntPtr;
using HMONITOR = System.IntPtr;
using VkViSurfaceCreateFlagsNN = System.UInt32;
using VkWaylandSurfaceCreateFlagsKHR = System.UInt32;
//
// Generated by FlagsParser.
using VkAccessFlags = Vulkan.VkAccessFlagBits;
using VkAttachmentDescriptionFlags = Vulkan.VkAttachmentDescriptionFlagBits;
using VkBufferCreateFlags = Vulkan.VkBufferCreateFlagBits;
using VkBufferUsageFlags = Vulkan.VkBufferUsageFlagBits;
// VkBufferViewCreateFlags - Reserved for future use
using VkBuildAccelerationStructureFlagsNV = Vulkan.VkBuildAccelerationStructureFlagBitsNV;
using VkColorComponentFlags = Vulkan.VkColorComponentFlagBits;
using VkCommandBufferUsageFlags = Vulkan.VkCommandBufferUsageFlagBits;
using VkCommandPoolCreateFlags = Vulkan.VkCommandPoolCreateFlagBits;
// VkCommandPoolTrimFlags - Reserved for future use
using VkCompositeAlphaFlagsKHR = Vulkan.VkCompositeAlphaFlagBitsKHR;
using VkConditionalRenderingFlagsEXT = Vulkan.VkConditionalRenderingFlagBitsEXT;
using VkCullModeFlags = Vulkan.VkCullModeFlagBits;
using VkDebugReportFlagsEXT = Vulkan.VkDebugReportFlagBitsEXT;
using VkDebugUtilsMessageSeverityFlagsEXT = Vulkan.VkDebugUtilsMessageSeverityFlagBitsEXT;
using VkDebugUtilsMessageTypeFlagsEXT = Vulkan.VkDebugUtilsMessageTypeFlagBitsEXT;
using VkDependencyFlags = Vulkan.VkDependencyFlagBits;
using VkDescriptorBindingFlagsEXT = Vulkan.VkDescriptorBindingFlagBitsEXT;
using VkDescriptorPoolCreateFlags = Vulkan.VkDescriptorPoolCreateFlagBits;
// VkDescriptorPoolResetFlags - Reserved for future use
using VkDescriptorSetLayoutCreateFlags = Vulkan.VkDescriptorSetLayoutCreateFlagBits;
// VkDescriptorUpdateTemplateCreateFlags - Reserved for future use
// VkDeviceCreateFlags - Reserved for future use
using VkDeviceGroupPresentModeFlagsKHR = Vulkan.VkDeviceGroupPresentModeFlagBitsKHR;
using VkDeviceQueueCreateFlags = Vulkan.VkDeviceQueueCreateFlagBits;
using VkDisplayPlaneAlphaFlagsKHR = Vulkan.VkDisplayPlaneAlphaFlagBitsKHR;
// VkEventCreateFlags - Reserved for future use
using VkExternalFenceFeatureFlags = Vulkan.VkExternalFenceFeatureFlagBits;
using VkExternalFenceHandleTypeFlags = Vulkan.VkExternalFenceHandleTypeFlagBits;
using VkExternalMemoryFeatureFlags = Vulkan.VkExternalMemoryFeatureFlagBits;
using VkExternalMemoryFeatureFlagsNV = Vulkan.VkExternalMemoryFeatureFlagBitsNV;
using VkExternalMemoryHandleTypeFlags = Vulkan.VkExternalMemoryHandleTypeFlagBits;
using VkExternalMemoryHandleTypeFlagsNV = Vulkan.VkExternalMemoryHandleTypeFlagBitsNV;
using VkExternalSemaphoreFeatureFlags = Vulkan.VkExternalSemaphoreFeatureFlagBits;
using VkExternalSemaphoreHandleTypeFlags = Vulkan.VkExternalSemaphoreHandleTypeFlagBits;
using VkFenceCreateFlags = Vulkan.VkFenceCreateFlagBits;
using VkFenceImportFlags = Vulkan.VkFenceImportFlagBits;
using VkFormatFeatureFlags = Vulkan.VkFormatFeatureFlagBits;
// VkFramebufferCreateFlags - Reserved for future use
using VkGeometryFlagsNV = Vulkan.VkGeometryFlagBitsNV;
using VkImageAspectFlags = Vulkan.VkImageAspectFlagBits;
using VkImageCreateFlags = Vulkan.VkImageCreateFlagBits;
using VkImageUsageFlags = Vulkan.VkImageUsageFlagBits;
// VkImageViewCreateFlags - Reserved for future use
using VkIndirectCommandsLayoutUsageFlagsNVX = Vulkan.VkIndirectCommandsLayoutUsageFlagBitsNVX;
// VkInstanceCreateFlags - Reserved for future use
using VkMemoryAllocateFlags = Vulkan.VkMemoryAllocateFlagBits;
using VkMemoryHeapFlags = Vulkan.VkMemoryHeapFlagBits;
// VkMemoryMapFlags - Reserved for future use
using VkMemoryPropertyFlags = Vulkan.VkMemoryPropertyFlagBits;
using VkObjectEntryUsageFlagsNVX = Vulkan.VkObjectEntryUsageFlagBitsNVX;
// VkPipelineCacheCreateFlags - Reserved for future use
// VkPipelineColorBlendStateCreateFlags - Reserved for future use
// VkPipelineCoverageModulationStateCreateFlagsNV - Reserved for future use
// VkPipelineCoverageToColorStateCreateFlagsNV - Reserved for future use
using VkPipelineCreateFlags = Vulkan.VkPipelineCreateFlagBits;
using VkPipelineCreationFeedbackFlagsEXT = Vulkan.VkPipelineCreationFeedbackFlagBitsEXT;
// VkPipelineDepthStencilStateCreateFlags - Reserved for future use
// VkPipelineDiscardRectangleStateCreateFlagsEXT - Reserved for future use
// VkPipelineDynamicStateCreateFlags - Reserved for future use
// VkPipelineInputAssemblyStateCreateFlags - Reserved for future use
// VkPipelineLayoutCreateFlags - Reserved for future use
// VkPipelineMultisampleStateCreateFlags - Reserved for future use
// VkPipelineRasterizationConservativeStateCreateFlagsEXT - Reserved for future use
// VkPipelineRasterizationDepthClipStateCreateFlagsEXT - Reserved for future use
// VkPipelineRasterizationStateCreateFlags - Reserved for future use
// VkPipelineRasterizationStateStreamCreateFlagsEXT - Reserved for future use
// VkPipelineShaderStageCreateFlags - Reserved for future use
using VkPipelineStageFlags = Vulkan.VkPipelineStageFlagBits;
// VkPipelineTessellationStateCreateFlags - Reserved for future use
// VkPipelineVertexInputStateCreateFlags - Reserved for future use
// VkPipelineViewportStateCreateFlags - Reserved for future use
// VkPipelineViewportSwizzleStateCreateFlagsNV - Reserved for future use
using VkQueryControlFlags = Vulkan.VkQueryControlFlagBits;
using VkQueryPipelineStatisticFlags = Vulkan.VkQueryPipelineStatisticFlagBits;
// VkQueryPoolCreateFlags - Reserved for future use
using VkQueueFlags = Vulkan.VkQueueFlagBits;
// VkRenderPassCreateFlags - Reserved for future use
using VkResolveModeFlagsKHR = Vulkan.VkResolveModeFlagBitsKHR;
using VkSampleCountFlags = Vulkan.VkSampleCountFlagBits;
// VkSamplerCreateFlags - Reserved for future use
// VkSemaphoreCreateFlags - Reserved for future use
using VkSemaphoreImportFlags = Vulkan.VkSemaphoreImportFlagBits;
// VkShaderModuleCreateFlags - Reserved for future use
using VkShaderStageFlags = Vulkan.VkShaderStageFlagBits;
using VkSparseImageFormatFlags = Vulkan.VkSparseImageFormatFlagBits;
using VkSparseMemoryBindFlags = Vulkan.VkSparseMemoryBindFlagBits;
using VkSubgroupFeatureFlags = Vulkan.VkSubgroupFeatureFlagBits;
using VkSubpassDescriptionFlags = Vulkan.VkSubpassDescriptionFlagBits;
using VkSurfaceCounterFlagsEXT = Vulkan.VkSurfaceCounterFlagBitsEXT;
using VkSurfaceTransformFlagsKHR = Vulkan.VkSurfaceTransformFlagBitsKHR;
using VkSwapchainCreateFlagsKHR = Vulkan.VkSwapchainCreateFlagBitsKHR;
// VkValidationCacheCreateFlagsEXT - Reserved for future use

namespace Vulkan {
    public unsafe static partial class vkAPI {
        // Command: 0
        // Delegate: 0
        /// <summary>vkAcquireFullScreenExclusiveModeEXT - Acquire full-screen exclusive mode for a swapchain
        /// </summary>
        /// <param name="device">device is the device associated with swapchain.</param>
        /// <param name="swapchain">swapchain is the swapchain to acquire exclusive full-screen access
        /// for.</param>
        public delegate VkResult vkAcquireFullScreenExclusiveModeEXT(
            VkDevice device,
            VkSwapchainKHR swapchain);
        // Command: 3
        // Delegate: 1
        /// <summary>vkAcquireXlibDisplayEXT - Acquire access to a VkDisplayKHR using Xlib
        /// </summary>
        /// <param name="physicalDevice">physicalDevice The physical device the display is on.</param>
        /// <param name="dpy">dpy A connection to the X11 server that currently owns
        /// display.</param>
        /// <param name="display">display The display the caller wishes to control in Vulkan.</param>
        public delegate VkResult vkAcquireXlibDisplayEXT(
            VkPhysicalDevice physicalDevice,
            /*Display*-*/IntPtr dpy,
            VkDisplayKHR display);
        // Command: 13
        // Delegate: 2
        /// <summary>vkCmdBeginConditionalRenderingEXT - Define the beginning of a conditional rendering block
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which this command will
        /// be recorded.</param>
        /// <param name="pConditionalRenderingBegin">pConditionalRenderingBegin is a pointer to an instance of the
        /// VkConditionalRenderingBeginInfoEXT structure specifying the
        /// parameters of conditional rendering.</param>
        public delegate void vkCmdBeginConditionalRenderingEXT(
            VkCommandBuffer commandBuffer,
            /*-const-*/ VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin);
        // Command: 14
        // Delegate: 3
        /// <summary>vkCmdBeginDebugUtilsLabelEXT - Open a command buffer debug label region
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="pLabelInfo">pLabelInfo is a pointer to an instance of the
        /// VkDebugUtilsLabelEXT structure specifying the parameters of the
        /// label region to open.</param>
        public delegate void vkCmdBeginDebugUtilsLabelEXT(
            VkCommandBuffer commandBuffer,
            /*-const-*/ VkDebugUtilsLabelEXT* pLabelInfo);
        // Command: 16
        // Delegate: 4
        /// <summary>vkCmdBeginQueryIndexedEXT - Begin an indexed query
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which this command will
        /// be recorded.</param>
        /// <param name="queryPool">queryPool is the query pool that will manage the results of the
        /// query.</param>
        /// <param name="query">query is the query index within the query pool that will contain
        /// the results.</param>
        /// <param name="flags">flags is a bitmask of VkQueryControlFlagBits specifying
        /// constraints on the types of queries that can be performed.</param>
        /// <param name="index">index is the query type specific index.
        /// When the query type is VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT
        /// the index represents the vertex stream.</param>
        public delegate void vkCmdBeginQueryIndexedEXT(
            VkCommandBuffer commandBuffer,
            VkQueryPool queryPool,
            UInt32 query,
            VkQueryControlFlags flags,
            UInt32 index);
        // Command: 19
        // Delegate: 5
        /// <summary>vkCmdBeginTransformFeedbackEXT - Make transform feedback active in the command buffer
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="firstCounterBuffer">firstCounterBuffer is the index of the first transform feedback
        /// buffer corresponding to pCounterBuffers[0] and
        /// pCounterBufferOffsets[0].</param>
        /// <param name="counterBufferCount">counterBufferCount is the size of the pCounterBuffers and
        /// pCounterBufferOffsets arrays.</param>
        /// <param name="pCounterBuffers">pCounterBuffers is an optional array of buffer handles to the
        /// counter buffers which contain a 4 byte integer value representing the
        /// byte offset from the start of the corresponding transform feedback
        /// buffer from where to start capturing vertex data.
        /// If the byte offset stored to the counter buffer location was done using
        /// vkCmdEndTransformFeedbackEXT it can be used to resume transform
        /// feedback from the previous location.
        /// If pCounterBuffers is NULL, then transform feedback will start
        /// capturing vertex data to byte offset zero in all bound transform
        /// feedback buffers.
        /// For each element of pCounterBuffers that is VK_NULL_HANDLE,
        /// transform feedback will start capturing vertex data to byte zero in the
        /// corresponding bound transform feedback buffer.</param>
        /// <param name="pCounterBufferOffsets">pCounterBufferOffsets is an optional array of offsets within each
        /// of the pCounterBuffers where the counter values were previously
        /// written.
        /// The location in each counter buffer at these offsets must be large
        /// enough to contain 4 bytes of data.
        /// This data is the number of bytes captured by the previous transform
        /// feedback to this buffer.
        /// If pCounterBufferOffsets is NULL, then it is assumed the offsets
        /// are zero.</param>
        public delegate void vkCmdBeginTransformFeedbackEXT(
            VkCommandBuffer commandBuffer,
            UInt32 firstCounterBuffer,
            UInt32 counterBufferCount,
            /*-const-*/ VkBuffer* pCounterBuffers,
            /*-const-*/ VkDeviceSize* pCounterBufferOffsets);
        // Command: 24
        // Delegate: 6
        /// <summary>vkCmdBindTransformFeedbackBuffersEXT - Bind transform feedback buffers to a command buffer
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="firstBinding">firstBinding is the index of the first transform feedback binding
        /// whose state is updated by the command.</param>
        /// <param name="bindingCount">bindingCount is the number of transform feedback bindings whose
        /// state is updated by the command.</param>
        /// <param name="pBuffers">pBuffers is a pointer to an array of buffer handles.</param>
        /// <param name="pOffsets">pOffsets is a pointer to an array of buffer offsets.</param>
        /// <param name="pSizes">pSizes is an optional array of buffer sizes, which specifies the
        /// maximum number of bytes to capture to the corresponding transform
        /// feedback buffer.
        /// If pSizes is NULL, or the value of the pSizes array
        /// element is VK_WHOLE_SIZE, then the maximum bytes captured will be
        /// the size of the corresponding buffer minus the buffer offset.</param>
        public delegate void vkCmdBindTransformFeedbackBuffersEXT(
            VkCommandBuffer commandBuffer,
            UInt32 firstBinding,
            UInt32 bindingCount,
            /*-const-*/ VkBuffer* pBuffers,
            /*-const-*/ VkDeviceSize* pOffsets,
            /*-const-*/ VkDeviceSize* pSizes);
        // Command: 37
        // Delegate: 7
        /// <summary>vkCmdDebugMarkerBeginEXT - Open a command buffer marker region
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="pMarkerInfo">pMarkerInfo is a pointer to an instance of the
        /// VkDebugMarkerMarkerInfoEXT structure specifying the parameters of
        /// the marker region to open.</param>
        public delegate void vkCmdDebugMarkerBeginEXT(
            VkCommandBuffer commandBuffer,
            /*-const-*/ VkDebugMarkerMarkerInfoEXT* pMarkerInfo);
        // Command: 38
        // Delegate: 8
        /// <summary>vkCmdDebugMarkerEndEXT - Close a command buffer marker region
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        public delegate void vkCmdDebugMarkerEndEXT(
            VkCommandBuffer commandBuffer);
        // Command: 39
        // Delegate: 9
        /// <summary>vkCmdDebugMarkerInsertEXT - Insert a marker label into a command buffer
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="pMarkerInfo">pMarkerInfo is a pointer to an instance of the
        /// VkDebugMarkerMarkerInfoEXT structure specifying the parameters of
        /// the marker to insert.</param>
        public delegate void vkCmdDebugMarkerInsertEXT(
            VkCommandBuffer commandBuffer,
            /*-const-*/ VkDebugMarkerMarkerInfoEXT* pMarkerInfo);
        // Command: 49
        // Delegate: 10
        /// <summary>vkCmdDrawIndirectByteCountEXT - Draw primitives where the vertex count is derived from the counter byte value in the counter buffer
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="instanceCount">instanceCount is the number of instances to draw.</param>
        /// <param name="firstInstance">firstInstance is the instance ID of the first instance to draw.</param>
        /// <param name="counterBuffer">counterBuffer is the buffer handle from where the byte count is
        /// read.</param>
        /// <param name="counterBufferOffset">counterBufferOffset is the offset into the buffer used to read the
        /// byte count, which is used to calculate the vertex count for this draw
        /// call.</param>
        /// <param name="counterOffset">counterOffset is subtracted from the byte count read from the
        /// counterBuffer at the counterBufferOffset</param>
        /// <param name="vertexStride">vertexStride is the stride in bytes between each element of the
        /// vertex data that is used to calculate the vertex count from the counter
        /// value.
        /// This value is typically the same value that was used in the graphics
        /// pipeline state when the transform feedback was captured as the
        /// XfbStride.</param>
        public delegate void vkCmdDrawIndirectByteCountEXT(
            VkCommandBuffer commandBuffer,
            UInt32 instanceCount,
            UInt32 firstInstance,
            VkBuffer counterBuffer,
            VkDeviceSize counterBufferOffset,
            UInt32 counterOffset,
            UInt32 vertexStride);
        // Command: 55
        // Delegate: 11
        /// <summary>vkCmdEndConditionalRenderingEXT - Define the end of a conditional rendering block
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which this command will
        /// be recorded.</param>
        public delegate void vkCmdEndConditionalRenderingEXT(
            VkCommandBuffer commandBuffer);
        // Command: 56
        // Delegate: 12
        /// <summary>vkCmdEndDebugUtilsLabelEXT - Close a command buffer label region
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        public delegate void vkCmdEndDebugUtilsLabelEXT(
            VkCommandBuffer commandBuffer);
        // Command: 58
        // Delegate: 13
        /// <summary>vkCmdEndQueryIndexedEXT - Ends a query
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which this command will
        /// be recorded.</param>
        /// <param name="queryPool">queryPool is the query pool that is managing the results of the
        /// query.</param>
        /// <param name="query">query is the query index within the query pool where the result is
        /// stored.</param>
        /// <param name="index">index is the query type specific index.</param>
        public delegate void vkCmdEndQueryIndexedEXT(
            VkCommandBuffer commandBuffer,
            VkQueryPool queryPool,
            UInt32 query,
            UInt32 index);
        // Command: 61
        // Delegate: 14
        /// <summary>vkCmdEndTransformFeedbackEXT - Make transform feedback inactive in the command buffer
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        /// <param name="firstCounterBuffer">firstCounterBuffer is the index of the first transform feedback
        /// buffer corresponding to pCounterBuffers[0] and
        /// pCounterBufferOffsets[0].</param>
        /// <param name="counterBufferCount">counterBufferCount is the size of the pCounterBuffers and
        /// pCounterBufferOffsets arrays.</param>
        /// <param name="pCounterBuffers">pCounterBuffers is an optional array of buffer handles to the
        /// counter buffers used to record the current byte positions of each
        /// transform feedback buffer where the next vertex output data would be
        /// captured.
        /// This can be used by a subsequent vkCmdBeginTransformFeedbackEXT
        /// call to resume transform feedback capture from this position.
        /// It can also be used by vkCmdDrawIndirectByteCountEXT to determine
        /// the vertex count of the draw call.</param>
        /// <param name="pCounterBufferOffsets">pCounterBufferOffsets is an optional array of offsets within each
        /// of the pCounterBuffers where the counter values can be written.
        /// The location in each counter buffer at these offsets must be large
        /// enough to contain 4 bytes of data.
        /// The data stored at this location is the byte offset from the start of
        /// the transform feedback buffer binding where the next vertex data would
        /// be written.
        /// If pCounterBufferOffsets is NULL, then it is assumed the offsets
        /// are zero.</param>
        public delegate void vkCmdEndTransformFeedbackEXT(
            VkCommandBuffer commandBuffer,
            UInt32 firstCounterBuffer,
            UInt32 counterBufferCount,
            /*-const-*/ VkBuffer* pCounterBuffers,
            /*-const-*/ VkDeviceSize* pCounterBufferOffsets);
        // Command: 64
        // Delegate: 15
        /// <summary>vkCmdInsertDebugUtilsLabelEXT - Insert a label into a command buffer
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command is
        /// recorded.</param>
        public delegate void vkCmdInsertDebugUtilsLabelEXT(
            VkCommandBuffer commandBuffer,
            /*-const-*/ VkDebugUtilsLabelEXT* pLabelInfo);
        // Command: 82
        // Delegate: 16
        /// <summary>vkCmdSetDiscardRectangleEXT - Set discard rectangles dynamically
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command will be
        /// recorded.</param>
        /// <param name="firstDiscardRectangle">firstDiscardRectangle is the index of the first discard rectangle
        /// whose state is updated by the command.</param>
        /// <param name="discardRectangleCount">discardRectangleCount is the number of discard rectangles whose
        /// state are updated by the command.</param>
        /// <param name="pDiscardRectangles">pDiscardRectangles is a pointer to an array of VkRect2D
        /// structures specifying discard rectangles.</param>
        public delegate void vkCmdSetDiscardRectangleEXT(
            VkCommandBuffer commandBuffer,
            UInt32 firstDiscardRectangle,
            UInt32 discardRectangleCount,
            /*-const-*/ VkRect2D* pDiscardRectangles);
        // Command: 86
        // Delegate: 17
        /// <summary>vkCmdSetSampleLocationsEXT - Set the dynamic sample locations state
        /// </summary>
        /// <param name="commandBuffer">commandBuffer is the command buffer into which the command will be
        /// recorded.</param>
        /// <param name="pSampleLocationsInfo">pSampleLocationsInfo is the sample locations state to set.</param>
        public delegate void vkCmdSetSampleLocationsEXT(
            VkCommandBuffer commandBuffer,
            /*-const-*/ VkSampleLocationsInfoEXT* pSampleLocationsInfo);
        // Command: 107
        // Delegate: 18
        /// <summary>vkCreateDebugReportCallbackEXT - Create a debug report callback object
        /// </summary>
        /// <param name="instance">instance the instance the callback will be logged on.</param>
        /// <param name="pCreateInfo">pCreateInfo points to a VkDebugReportCallbackCreateInfoEXT
        /// structure which defines the conditions under which this callback will be
        /// called.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        /// <param name="pCallback">pCallback is a pointer to record the
        /// VkDebugReportCallbackEXT object created.</param>
        public delegate VkResult vkCreateDebugReportCallbackEXT(
            VkInstance instance,
            /*-const-*/ VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
            /*-const-*/ VkAllocationCallbacks* pAllocator,
            VkDebugReportCallbackEXT* pCallback);
        // Command: 108
        // Delegate: 19
        /// <summary>vkCreateDebugUtilsMessengerEXT - Create a debug messenger object
        /// </summary>
        /// <param name="instance">instance the instance the messenger will be used with.</param>
        /// <param name="pCreateInfo">pCreateInfo points to a VkDebugUtilsMessengerCreateInfoEXT
        /// structure which contains the callback pointer as well as defines the
        /// conditions under which this messenger will trigger the callback.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        /// <param name="pMessenger">pMessenger is a pointer to record the
        /// VkDebugUtilsMessengerEXT object created.</param>
        public delegate VkResult vkCreateDebugUtilsMessengerEXT(
            VkInstance instance,
            /*-const-*/ VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
            /*-const-*/ VkAllocationCallbacks* pAllocator,
            VkDebugUtilsMessengerEXT* pMessenger);
        // Command: 126
        // Delegate: 20
        /// <summary>vkCreateMetalSurfaceEXT - Create a VkSurfaceKHR object for CAMetalLayer
        /// </summary>
        /// <param name="instance">instance is the instance with which to associate the surface.</param>
        /// <param name="pCreateInfo">pCreateInfo is a pointer to an instance of the
        /// VkMetalSurfaceCreateInfoEXT structure containing the parameters
        /// affecting the creation of the surface object.</param>
        /// <param name="pAllocator">pAllocator is the allocator used for host memory allocated for the
        /// surface object when there is no more specific allocator available (see
        /// Memory Allocation).</param>
        /// <param name="pSurface">pSurface points to a VkSurfaceKHR handle in which the
        /// created surface object is returned.</param>
        public delegate VkResult vkCreateMetalSurfaceEXT(
            VkInstance instance,
            /*-const-*/ VkMetalSurfaceCreateInfoEXT* pCreateInfo,
            /*-const-*/ VkAllocationCallbacks* pAllocator,
            VkSurfaceKHR* pSurface);
        // Command: 141
        // Delegate: 21
        /// <summary>vkCreateValidationCacheEXT - Creates a new validation cache
        /// </summary>
        /// <param name="device">device is the logical device that creates the validation cache
        /// object.</param>
        /// <param name="pCreateInfo">pCreateInfo is a pointer to a VkValidationCacheCreateInfoEXT
        /// structure that contains the initial parameters for the validation cache
        /// object.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        /// <param name="pValidationCache">pValidationCache is a pointer to a VkValidationCacheEXT
        /// handle in which the resulting validation cache object is returned.</param>
        public delegate VkResult vkCreateValidationCacheEXT(
            VkDevice device,
            /*-const-*/ VkValidationCacheCreateInfoEXT* pCreateInfo,
            /*-const-*/ VkAllocationCallbacks* pAllocator,
            VkValidationCacheEXT* pValidationCache);
        // Command: 147
        // Delegate: 22
        /// <summary>vkDebugMarkerSetObjectNameEXT - Give a user-friendly name to an object
        /// </summary>
        /// <param name="device">device is the device that created the object.</param>
        /// <param name="pNameInfo">pNameInfo is a pointer to an instance of the
        /// VkDebugMarkerObjectNameInfoEXT structure specifying the parameters
        /// of the name to set on the object.</param>
        public delegate VkResult vkDebugMarkerSetObjectNameEXT(
            VkDevice device,
            /*-const-*/ VkDebugMarkerObjectNameInfoEXT* pNameInfo);
        // Command: 148
        // Delegate: 23
        /// <summary>vkDebugMarkerSetObjectTagEXT - Attach arbitrary data to an object
        /// </summary>
        /// <param name="device">device is the device that created the object.</param>
        /// <param name="pTagInfo">pTagInfo is a pointer to an instance of the
        /// VkDebugMarkerObjectTagInfoEXT structure specifying the parameters
        /// of the tag to attach to the object.</param>
        public delegate VkResult vkDebugMarkerSetObjectTagEXT(
            VkDevice device,
            /*-const-*/ VkDebugMarkerObjectTagInfoEXT* pTagInfo);
        // Command: 149
        // Delegate: 24
        /// <summary>vkDebugReportMessageEXT - Inject a message into a debug stream
        /// </summary>
        /// <param name="instance">instance is the debug stream¡¯s VkInstance.</param>
        /// <param name="flags">flags specifies the VkDebugReportFlagBitsEXT classification
        /// of this event/message.</param>
        /// <param name="objectType">objectType is a VkDebugReportObjectTypeEXT specifying the
        /// type of object being used or created at the time the event was
        /// triggered.</param>
        /// <param name="object">object this is the object where the issue was detected.
        /// objectcan be VK_NULL_HANDLE if there is no object
        /// associated with the event.</param>
        /// <param name="location">location is an application defined value.</param>
        /// <param name="messageCode">messageCode is an application defined value.</param>
        /// <param name="pLayerPrefix">pLayerPrefix is the abbreviation of the component making this
        /// event/message.</param>
        /// <param name="pMessage">pMessage is a null-terminated string detailing the trigger
        /// conditions.</param>
        public delegate void vkDebugReportMessageEXT(
            VkInstance instance,
            VkDebugReportFlagsEXT flags,
            VkDebugReportObjectTypeEXT _objectType,
            UInt64 _object,
            Int32 location,
            Int32 messageCode,
            IntPtr pLayerPrefix,
            IntPtr pMessage);
        // Command: 154
        // Delegate: 25
        /// <summary>vkDestroyDebugReportCallbackEXT - Destroy a debug report callback object
        /// </summary>
        /// <param name="instance">instance the instance where the callback was created.</param>
        /// <param name="callback">callback the VkDebugReportCallbackEXT object to destroy.
        /// callback is an externally synchronized object and must not be
        /// used on more than one thread at a time.
        /// This means that vkDestroyDebugReportCallbackEXTmust not be
        /// called when a callback is active.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        public delegate void vkDestroyDebugReportCallbackEXT(
            VkInstance instance,
            VkDebugReportCallbackEXT callback,
            /*-const-*/ VkAllocationCallbacks* pAllocator);
        // Command: 155
        // Delegate: 26
        /// <summary>vkDestroyDebugUtilsMessengerEXT - Destroy a debug messenger object
        /// </summary>
        /// <param name="instance">instance the instance where the callback was created.</param>
        /// <param name="messenger">messenger the VkDebugUtilsMessengerEXT object to destroy.
        /// messenger is an externally synchronized object and must not be
        /// used on more than one thread at a time.
        /// This means that vkDestroyDebugUtilsMessengerEXTmust not be
        /// called when a callback is active.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        public delegate void vkDestroyDebugUtilsMessengerEXT(
            VkInstance instance,
            VkDebugUtilsMessengerEXT messenger,
            /*-const-*/ VkAllocationCallbacks* pAllocator);
        // Command: 179
        // Delegate: 27
        /// <summary>vkDestroyValidationCacheEXT - Destroy a validation cache object
        /// </summary>
        /// <param name="device">device is the logical device that destroys the validation cache
        /// object.</param>
        /// <param name="validationCache">validationCache is the handle of the validation cache to destroy.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        public delegate void vkDestroyValidationCacheEXT(
            VkDevice device,
            VkValidationCacheEXT validationCache,
            /*-const-*/ VkAllocationCallbacks* pAllocator);
        // Command: 181
        // Delegate: 28
        /// <summary>vkDisplayPowerControlEXT - Set the power state of a display
        /// </summary>
        /// <param name="device">device is a logical device associated with display.</param>
        /// <param name="display">display is the display whose power state is modified.</param>
        /// <param name="pDisplayPowerInfo">pDisplayPowerInfo is an instance of VkDisplayPowerInfoEXT
        /// specifying the new power state of display.</param>
        public delegate VkResult vkDisplayPowerControlEXT(
            VkDevice device,
            VkDisplayKHR display,
            /*-const-*/ VkDisplayPowerInfoEXT* pDisplayPowerInfo);
        // Command: 197
        // Delegate: 29
        /// <summary>vkGetBufferDeviceAddressEXT - Query an address of a buffer
        /// </summary>
        /// <param name="device">device is the logical device that the buffer was created on.</param>
        /// <param name="pInfo">pInfo is a pointer to an instance of the
        /// VkBufferDeviceAddressInfoEXT structure specifying the buffer to
        /// retrieve an address for.</param>
        public delegate VkDeviceAddress vkGetBufferDeviceAddressEXT(
            VkDevice device,
            /*-const-*/ VkBufferDeviceAddressInfoEXT* pInfo);
        // Command: 200
        // Delegate: 30
        /// <summary>vkGetCalibratedTimestampsEXT - Query calibrated timestamps
        /// </summary>
        /// <param name="device">device is the logical device used to perform the query.</param>
        /// <param name="timestampCount">timestampCount is the number of timestamps to query.</param>
        /// <param name="pTimestampInfos">pTimestampInfos is a pointer to an array of timestampCount
        /// number of structures of type VkCalibratedTimestampInfoEXT,
        /// describing the time domains the calibrated timestamps should be captured
        /// from.</param>
        /// <param name="pTimestamps">pTimestamps is a pointer to an array of timestampCount
        /// number of 64-bit unsigned integer values in which the requested
        /// calibrated timestamp values are returned.</param>
        /// <param name="pMaxDeviation">pMaxDeviation is a pointer to a 64-bit unsigned integer value in
        /// which the strictly positive maximum deviation, in nanoseconds, of the
        /// calibrated timestamp values is returned.</param>
        public delegate VkResult vkGetCalibratedTimestampsEXT(
            VkDevice device,
            UInt32 timestampCount,
            /*-const-*/ VkCalibratedTimestampInfoEXT* pTimestampInfos,
            UInt64* pTimestamps,
            UInt64* pMaxDeviation);
        // Command: 204
        // Delegate: 31
        /// <summary>vkGetDeviceGroupSurfacePresentModes2EXT - Query device group present capabilities for a surface
        /// </summary>
        /// <param name="device">device is the logical device.</param>
        /// <param name="pSurfaceInfo">pSurfaceInfo points to an instance of the
        /// VkPhysicalDeviceSurfaceInfo2KHR structure, describing the surface and
        /// other fixed parameters that would be consumed by vkCreateSwapchainKHR.</param>
        /// <param name="pModes">pModes is a pointer to a value of type
        /// VkDeviceGroupPresentModeFlagsKHR that is filled with the supported
        /// device group present modes for the surface.</param>
        public delegate VkResult vkGetDeviceGroupSurfacePresentModes2EXT(
            VkDevice device,
            /*-const-*/ VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
            VkDeviceGroupPresentModeFlagsKHR* pModes);
        // Command: 219
        // Delegate: 32
        /// <summary>vkGetImageDrmFormatModifierPropertiesEXT - Returns an image¡¯s DRM format modifier
        /// </summary>
        /// <param name="device">device is the logical device that owns the image.</param>
        /// <param name="image">image is the queried image.</param>
        /// <param name="pProperties">pProperties will return properties of the image¡¯s DRM format
        /// modifier.</param>
        public delegate VkResult vkGetImageDrmFormatModifierPropertiesEXT(
            VkDevice device,
            VkImage image,
            VkImageDrmFormatModifierPropertiesEXT* pProperties);
        // Command: 230
        // Delegate: 33
        /// <summary>vkGetMemoryHostPointerPropertiesEXT - Get properties of external memory host pointer
        /// </summary>
        /// <param name="device">device is the logical device that will be importing
        /// pHostPointer.</param>
        /// <param name="handleType">handleType is the type of the handle pHostPointer.</param>
        /// <param name="pHostPointer">pHostPointer is the host pointer to import from.</param>
        /// <param name="pMemoryHostPointerProperties">pMemoryHostPointerProperties is a pointer to a
        /// VkMemoryHostPointerPropertiesEXT structure in which the host
        /// pointer properties are returned.</param>
        public delegate VkResult vkGetMemoryHostPointerPropertiesEXT(
            VkDevice device,
            VkExternalMemoryHandleTypeFlagBits handleType,
            /*-const-*/ void* pHostPointer,
            VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties);
        // Command: 235
        // Delegate: 34
        /// <summary>vkGetPhysicalDeviceCalibrateableTimeDomainsEXT - Query calibrateable time domains
        /// </summary>
        /// <param name="physicalDevice">physicalDevice is the physical device from which to query the set
        /// of calibrateable time domains.</param>
        /// <param name="pTimeDomainCount">pTimeDomainCount is a pointer to an integer related to the number
        /// of calibrateable time domains available or queried, as described below.</param>
        /// <param name="pTimeDomains">pTimeDomains is either NULL or a pointer to an array of
        /// VkTimeDomainEXT values, indicating the supported calibrateable
        /// time domains.</param>
        public delegate VkResult vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
            VkPhysicalDevice physicalDevice,
            UInt32* pTimeDomainCount,
            VkTimeDomainEXT* pTimeDomains);
        // Command: 254
        // Delegate: 35
        /// <summary>vkGetPhysicalDeviceMultisamplePropertiesEXT - Report sample count specific multisampling capabilities of a physical device
        /// </summary>
        /// <param name="physicalDevice">physicalDevice is the physical device from which to query the
        /// additional multisampling capabilities.</param>
        /// <param name="samples">samples is the sample count to query the capabilities for.</param>
        /// <param name="pMultisampleProperties">pMultisampleProperties is a pointer to a structure of type
        /// VkMultisamplePropertiesEXT, in which information about the
        /// additional multisampling capabilities specific to the sample count is
        /// returned.</param>
        public delegate void vkGetPhysicalDeviceMultisamplePropertiesEXT(
            VkPhysicalDevice physicalDevice,
            VkSampleCountFlagBits samples,
            VkMultisamplePropertiesEXT* pMultisampleProperties);
        // Command: 262
        // Delegate: 36
        /// <summary>vkGetPhysicalDeviceSurfaceCapabilities2EXT - Query surface capabilities
        /// </summary>
        /// <param name="physicalDevice">physicalDevice is the physical device that will be associated with
        /// the swapchain to be created, as described for
        /// vkCreateSwapchainKHR.</param>
        /// <param name="surface">surface is the surface that will be associated with the swapchain.</param>
        /// <param name="pSurfaceCapabilities">pSurfaceCapabilities is a pointer to an instance of the
        /// VkSurfaceCapabilities2EXT structure in which the capabilities are
        /// returned.</param>
        public delegate VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT(
            VkPhysicalDevice physicalDevice,
            VkSurfaceKHR surface,
            VkSurfaceCapabilities2EXT* pSurfaceCapabilities);
        // Command: 267
        // Delegate: 37
        /// <summary>vkGetPhysicalDeviceSurfacePresentModes2EXT - Query supported presentation modes
        /// </summary>
        /// <param name="physicalDevice">physicalDevice is the physical device that will be associated with
        /// the swapchain to be created, as described for
        /// vkCreateSwapchainKHR.</param>
        /// <param name="pSurfaceInfo">pSurfaceInfo points to an instance of the
        /// VkPhysicalDeviceSurfaceInfo2KHR structure, describing the surface
        /// and other fixed parameters that would be consumed by
        /// vkCreateSwapchainKHR.</param>
        /// <param name="pPresentModeCount">pPresentModeCount is a pointer to an integer related to the number
        /// of presentation modes available or queried, as described below.</param>
        /// <param name="pPresentModes">pPresentModes is either NULL or a pointer to an array of
        /// VkPresentModeKHR values, indicating the supported presentation
        /// modes.</param>
        public delegate VkResult vkGetPhysicalDeviceSurfacePresentModes2EXT(
            VkPhysicalDevice physicalDevice,
            /*-const-*/ VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
            UInt32* pPresentModeCount,
            VkPresentModeKHR* pPresentModes);
        // Command: 277
        // Delegate: 38
        /// <summary>vkGetRandROutputDisplayEXT - Query the VkDisplayKHR corresponding to an X11 RandR Output
        /// </summary>
        /// <param name="physicalDevice">physicalDevice The physical device to query the display handle on.</param>
        /// <param name="dpy">dpy A connection to the X11 server from which rrOutput was
        /// queried.</param>
        /// <param name="rrOutput">rrOutput An X11 RandR output ID.</param>
        /// <param name="pDisplay">pDisplay The corresponding VkDisplayKHR handle will be
        /// returned here.</param>
        public delegate VkResult vkGetRandROutputDisplayEXT(
            VkPhysicalDevice physicalDevice,
            /*Display*-*/IntPtr dpy,
            /*RROutput*/IntPtr rrOutput,
            VkDisplayKHR* pDisplay);
        // Command: 284
        // Delegate: 39
        /// <summary>vkGetSwapchainCounterEXT - Query the current value of a surface counter
        /// </summary>
        /// <param name="device">device is the VkDevice associated with swapchain.</param>
        /// <param name="swapchain">swapchain is the swapchain from which to query the counter value.</param>
        /// <param name="counter">counter is the counter to query.</param>
        /// <param name="pCounterValue">pCounterValue will return the current value of the counter.</param>
        public delegate VkResult vkGetSwapchainCounterEXT(
            VkDevice device,
            VkSwapchainKHR swapchain,
            VkSurfaceCounterFlagBitsEXT counter,
            UInt64* pCounterValue);
        // Command: 287
        // Delegate: 40
        /// <summary>vkGetValidationCacheDataEXT - Get the data store from a validation cache
        /// </summary>
        /// <param name="device">device is the logical device that owns the validation cache.</param>
        /// <param name="validationCache">validationCache is the validation cache to retrieve data from.</param>
        /// <param name="pDataSize">pDataSize is a pointer to a value related to the amount of data in
        /// the validation cache, as described below.</param>
        /// <param name="pData">pData is either NULL or a pointer to a buffer.</param>
        public delegate VkResult vkGetValidationCacheDataEXT(
            VkDevice device,
            VkValidationCacheEXT validationCache,
            Int32* pDataSize,
            void* pData);
        // Command: 295
        // Delegate: 41
        /// <summary>vkMergeValidationCachesEXT - Combine the data stores of validation caches
        /// </summary>
        /// <param name="device">device is the logical device that owns the validation cache
        /// objects.</param>
        /// <param name="dstCache">dstCache is the handle of the validation cache to merge results
        /// into.</param>
        /// <param name="srcCacheCount">srcCacheCount is the length of the pSrcCaches array.</param>
        /// <param name="pSrcCaches">pSrcCaches is an array of validation cache handles, which will be
        /// merged into dstCache.
        /// The previous contents of dstCache are included after the merge.</param>
        public delegate VkResult vkMergeValidationCachesEXT(
            VkDevice device,
            VkValidationCacheEXT dstCache,
            UInt32 srcCacheCount,
            /*-const-*/ VkValidationCacheEXT* pSrcCaches);
        // Command: 296
        // Delegate: 42
        /// <summary>vkQueueBeginDebugUtilsLabelEXT - Open a queue debug label region
        /// </summary>
        /// <param name="queue">queue is the queue in which to start a debug label region.</param>
        /// <param name="pLabelInfo">pLabelInfo is a pointer to an instance of the
        /// VkDebugUtilsLabelEXT structure specifying the parameters of the
        /// label region to open.</param>
        public delegate void vkQueueBeginDebugUtilsLabelEXT(
            VkQueue queue,
            /*-const-*/ VkDebugUtilsLabelEXT* pLabelInfo);
        // Command: 298
        // Delegate: 43
        /// <summary>vkQueueEndDebugUtilsLabelEXT - Close a queue debug label region
        /// </summary>
        /// <param name="queue">queue is the queue in which a debug label region should be closed.</param>
        public delegate void vkQueueEndDebugUtilsLabelEXT(
            VkQueue queue);
        // Command: 299
        // Delegate: 44
        /// <summary>vkQueueInsertDebugUtilsLabelEXT - Insert a label into a queue
        /// </summary>
        /// <param name="queue">queue is the queue into which a debug label will be inserted.</param>
        /// <param name="pLabelInfo">pLabelInfo is a pointer to an instance of the
        /// VkDebugUtilsLabelEXT structure specifying the parameters of the
        /// label to insert.</param>
        public delegate void vkQueueInsertDebugUtilsLabelEXT(
            VkQueue queue,
            /*-const-*/ VkDebugUtilsLabelEXT* pLabelInfo);
        // Command: 303
        // Delegate: 45
        /// <summary>vkRegisterDeviceEventEXT - Signal a fence when a device event occurs
        /// </summary>
        /// <param name="device">device is a logical device on which the event may occur.</param>
        /// <param name="pDeviceEventInfo">pDeviceEventInfo is a pointer to an instance of the
        /// VkDeviceEventInfoEXT structure describing the event of interest to
        /// the application.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        /// <param name="pFence">pFence points to a handle in which the resulting fence object is
        /// returned.</param>
        public delegate VkResult vkRegisterDeviceEventEXT(
            VkDevice device,
            /*-const-*/ VkDeviceEventInfoEXT* pDeviceEventInfo,
            /*-const-*/ VkAllocationCallbacks* pAllocator,
            VkFence* pFence);
        // Command: 304
        // Delegate: 46
        /// <summary>vkRegisterDisplayEventEXT - Signal a fence when a display event occurs
        /// </summary>
        /// <param name="device">device is a logical device associated with display</param>
        /// <param name="display">display is the display on which the event may occur.</param>
        /// <param name="pDisplayEventInfo">pDisplayEventInfo is a pointer to an instance of the
        /// VkDisplayEventInfoEXT structure describing the event of interest
        /// to the application.</param>
        /// <param name="pAllocator">pAllocator controls host memory allocation as described in the
        /// Memory Allocation chapter.</param>
        /// <param name="pFence">pFence points to a handle in which the resulting fence object is
        /// returned.</param>
        public delegate VkResult vkRegisterDisplayEventEXT(
            VkDevice device,
            VkDisplayKHR display,
            /*-const-*/ VkDisplayEventInfoEXT* pDisplayEventInfo,
            /*-const-*/ VkAllocationCallbacks* pAllocator,
            VkFence* pFence);
        // Command: 306
        // Delegate: 47
        /// <summary>vkReleaseDisplayEXT - Release access to an acquired VkDisplayKHR
        /// </summary>
        /// <param name="physicalDevice">physicalDevice The physical device the display is on.</param>
        /// <param name="display">display The display to release control of.</param>
        public delegate VkResult vkReleaseDisplayEXT(
            VkPhysicalDevice physicalDevice,
            VkDisplayKHR display);
        // Command: 307
        // Delegate: 48
        /// <summary>vkReleaseFullScreenExclusiveModeEXT - Release full-screen exclusive mode from a swapchain
        /// </summary>
        /// <param name="device">device is the device associated with swapchain.</param>
        /// <param name="swapchain">swapchain is the swapchain to release exclusive full-screen access
        /// from.</param>
        public delegate VkResult vkReleaseFullScreenExclusiveModeEXT(
            VkDevice device,
            VkSwapchainKHR swapchain);
        // Command: 313
        // Delegate: 49
        /// <summary>vkResetQueryPoolEXT - Reset queries in a query pool
        /// </summary>
        /// <param name="queryPool">queryPool is the handle of the query pool managing the queries
        /// being reset.</param>
        /// <param name="firstQuery">firstQuery is the initial query index to reset.</param>
        /// <param name="queryCount">queryCount is the number of queries to reset.</param>
        public delegate void vkResetQueryPoolEXT(
            VkDevice device,
            VkQueryPool queryPool,
            UInt32 firstQuery,
            UInt32 queryCount);
        // Command: 314
        // Delegate: 50
        /// <summary>vkSetDebugUtilsObjectNameEXT - Give a user-friendly name to an object
        /// </summary>
        /// <param name="device">device is the device that created the object.</param>
        /// <param name="pNameInfo">pNameInfo is a pointer to an instance of the
        /// VkDebugUtilsObjectNameInfoEXT structure specifying the parameters
        /// of the name to set on the object.</param>
        public delegate VkResult vkSetDebugUtilsObjectNameEXT(
            VkDevice device,
            /*-const-*/ VkDebugUtilsObjectNameInfoEXT* pNameInfo);
        // Command: 315
        // Delegate: 51
        /// <summary>vkSetDebugUtilsObjectTagEXT - Attach arbitrary data to an object
        /// </summary>
        /// <param name="device">device is the device that created the object.</param>
        /// <param name="pTagInfo">pTagInfo is a pointer to an instance of the
        /// VkDebugUtilsObjectTagInfoEXT structure specifying the parameters
        /// of the tag to attach to the object.</param>
        public delegate VkResult vkSetDebugUtilsObjectTagEXT(
            VkDevice device,
            /*-const-*/ VkDebugUtilsObjectTagInfoEXT* pTagInfo);
        // Command: 317
        // Delegate: 52
        /// <summary>vkSetHdrMetadataEXT - function to set Hdr metadata
        /// </summary>
        /// <param name="device">device is the logical device where the swapchain(s) were created.</param>
        /// <param name="swapchainCount">swapchainCount is the number of swapchains included in
        /// pSwapchains.</param>
        /// <param name="pSwapchains">pSwapchains is a pointer to the array of swapchainCountVkSwapchainKHR handles.</param>
        /// <param name="pMetadata">pMetadata is a pointer to the array of swapchainCountVkHdrMetadataEXT structures.</param>
        public delegate void vkSetHdrMetadataEXT(
            VkDevice device,
            UInt32 swapchainCount,
            /*-const-*/ VkSwapchainKHR* pSwapchains,
            /*-const-*/ VkHdrMetadataEXT* pMetadata);
        // Command: 319
        // Delegate: 53
        /// <summary>vkSubmitDebugUtilsMessageEXT - Inject a message into a debug stream
        /// </summary>
        /// <param name="instance">instance is the debug stream¡¯s VkInstance.</param>
        /// <param name="messageSeverity">messageSeverity is the
        /// VkDebugUtilsMessageSeverityFlagBitsEXT severity of this
        /// event/message.</param>
        /// <param name="messageTypes">messageTypes is a bitmask of
        /// VkDebugUtilsMessageTypeFlagBitsEXT specifying which type of
        /// event(s) to identify with this message.</param>
        /// <param name="pCallbackData">pCallbackData contains all the callback related data in the
        /// VkDebugUtilsMessengerCallbackDataEXT structure.</param>
        public delegate void vkSubmitDebugUtilsMessageEXT(
            VkInstance instance,
            VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
            VkDebugUtilsMessageTypeFlagsEXT messageTypes,
            /*-const-*/ VkDebugUtilsMessengerCallbackDataEXT* pCallbackData);
    }
}
