// Struct: 0
/// <summary>VkAccelerationStructureCreateInfoNV - Structure specifying the parameters of a newly created acceleration structure object
/// <para>  If compactedSize is not 0 then both info.geometryCount andinfo.instanceCount must be 0 </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV </para>
/// <para>   pNext must be NULL </para>
/// <para>   info must be a valid VkAccelerationStructureInfoNV structure</para>
/// </summary>
public unsafe struct VkAccelerationStructureCreateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                  sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                      pNext;
    /// <summary> compactedSize is the size from the result of
    /// vkCmdWriteAccelerationStructuresPropertiesNV if this acceleration
    /// structure is going to be the target of a compacting copy.</summary>
    public VkDeviceSize                     compactedSize;
    /// <summary> info is the VkAccelerationStructureInfoNV structure that
    /// specifies further parameters of the created acceleration structure.</summary>
    public VkAccelerationStructureInfoNV    info;
}
// Struct: 1
/// <summary>VkAccelerationStructureInfoNV - Structure specifying the parameters of acceleration structure object
/// <para> VkAccelerationStructureInfoNV contains information that is used bothfor acceleration structure creation withvkCreateAccelerationStructureNV and in combination with the actualgeometric data to build the acceleration structure withvkCmdBuildAccelerationStructureNV.</para>
/// <para>   geometryCount must be less than or equal toVkPhysicalDeviceRayTracingPropertiesNV::maxGeometryCount </para>
/// <para>   instanceCount must be less than or equal toVkPhysicalDeviceRayTracingPropertiesNV::maxInstanceCount </para>
/// <para>  The total number of triangles in all geometries must be less than orequal toVkPhysicalDeviceRayTracingPropertiesNV::maxTriangleCount </para>
/// <para>  If type is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV thengeometryCount must be 0 </para>
/// <para>  If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NVthen instanceCount must be 0 </para>
/// <para>  If flags has theVK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV bit set,then it must not have theVK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV bit set</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV </para>
/// <para>   pNext must be NULL </para>
/// <para>   type must be a valid VkAccelerationStructureTypeNV value</para>
/// <para>   flags must be a valid combination of VkBuildAccelerationStructureFlagBitsNV values</para>
/// <para>   If geometryCount is not 0, pGeometries must be a valid pointer to an array of geometryCount valid VkGeometryNV structures</para>
/// </summary>
public unsafe struct VkAccelerationStructureInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                        sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                            pNext;
    /// <summary> type is a VkAccelerationStructureTypeNV value specifying the
    /// type of acceleration structure that will be created.</summary>
    public VkAccelerationStructureTypeNV          type;
    /// <summary> flags is a bitmask of VkBuildAccelerationStructureFlagBitsNV
    /// specifying additional parameters of the acceleration structure.</summary>
    public VkBuildAccelerationStructureFlagsNV    flags;
    /// <summary> instanceCount specifies the number of instances that will be in
    /// the new acceleration structure.</summary>
    public UInt32                               instanceCount;
    /// <summary> geometryCount specifies the number of geometries that will be in
    /// the new acceleration structure.</summary>
    public UInt32                               geometryCount;
    /// <summary> pGeometries is an array of VkGeometryNV structures, which
    /// contain the scene data being passed into the acceleration structure.</summary>
    public /* const */ VkGeometryNV*                    pGeometries;
}
// Struct: 2
/// <summary>VkAccelerationStructureMemoryRequirementsInfoNV - Structure specifying acceleration to query for memory requirements
/// <para>   sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV </para>
/// <para>   pNext must be NULL </para>
/// <para>   type must be a valid VkAccelerationStructureMemoryRequirementsTypeNV value</para>
/// <para>   accelerationStructure must be a valid VkAccelerationStructureNV handle</para>
/// </summary>
public unsafe struct VkAccelerationStructureMemoryRequirementsInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                                    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                        pNext;
    /// <summary> type selects the type of memory requirement being queried.
    /// VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV
    /// returns the memory requirements for the object itself.
    /// VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV
    /// returns the memory requirements for the scratch memory when doing a
    /// build.
    /// VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV
    /// returns the memory requirements for the scratch memory when doing an
    /// update.</summary>
    public VkAccelerationStructureMemoryRequirementsTypeNV    type;
    /// <summary> accelerationStructure is the acceleration structure to be queried
    /// for memory requirements.</summary>
    public VkAccelerationStructureNV                          accelerationStructure;
}
// Struct: 3
/// <summary>VkAcquireNextImageInfoKHR - Structure specifying parameters of the acquire
/// <para>If vkAcquireNextImageKHR is used, the device mask is considered toinclude all physical devices in the logical device.</para>
/// <para> vkAcquireNextImage2KHR signals at most one semaphore, even if theapplication requests waiting for multiple physical devices to be ready viathe deviceMask.However, only a single physical device can wait on that semaphore, sincethe semaphore becomes unsignaled when the wait succeeds.For other physical devices to wait for the image to be ready, it isnecessary for the application to submit semaphore signal operation(s) tothat first physical device to signal additional semaphore(s) after the waitsucceeds, which the other physical device(s) can wait upon.</para>
/// <para>   swapchain must not be in the retired state</para>
/// <para>  If semaphore is not VK_NULL_HANDLE it must be unsignaled</para>
/// <para>  If semaphore is not VK_NULL_HANDLE it must not have anyuncompleted signal or wait operations pending</para>
/// <para>  If fence is not VK_NULL_HANDLE it must be unsignaled andmust not be associated with any other queue command that has not yetcompleted execution on that queue</para>
/// <para>   semaphore and fence must not both be equal toVK_NULL_HANDLE </para>
/// <para>   deviceMask must be a valid device mask</para>
/// <para>   deviceMask must not be zero</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   swapchain must be a valid VkSwapchainKHR handle</para>
/// <para>   If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle</para>
/// <para>   If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle</para>
/// <para>   Each of fence, semaphore, and swapchain that are valid handles must have been created, allocated, or retrieved from the same VkInstance </para>
/// <para>Host access to swapchain must be externally synchronized</para>
/// <para>Host access to semaphore must be externally synchronized</para>
/// <para>Host access to fence must be externally synchronized</para>
/// </summary>
public unsafe struct VkAcquireNextImageInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> swapchain is a non-retired swapchain from which an image is
    /// acquired.</summary>
    public VkSwapchainKHR     swapchain;
    /// <summary> timeout specifies how long the function waits, in nanoseconds, if
    /// no image is available.</summary>
    public UInt64           timeout;
    /// <summary> semaphore is VK_NULL_HANDLE or a semaphore to signal.</summary>
    public VkSemaphore        semaphore;
    /// <summary> fence is VK_NULL_HANDLE or a fence to signal.</summary>
    public VkFence            fence;
    /// <summary> deviceMask is a mask of physical devices for which the swapchain
    /// image will be ready to use when the semaphore or fence is signaled.</summary>
    public UInt32           deviceMask;
}
// Struct: 4
/// <summary>VkAllocationCallbacks - Structure containing callback function pointers for memory allocation
/// <para>   pfnAllocation must be a valid pointer to a valid user-definedPFN_vkAllocationFunction </para>
/// <para>   pfnReallocation must be a valid pointer to a valid user-definedPFN_vkReallocationFunction </para>
/// <para>   pfnFree must be a valid pointer to a valid user-definedPFN_vkFreeFunction </para>
/// <para>  If either of pfnInternalAllocation or pfnInternalFree is notNULL, both must be valid callbacks</para>
/// </summary>
public unsafe struct VkAllocationCallbacks {
    /// <summary> pUserData is a value to be interpreted by the implementation of
    /// the callbacks.
    /// When any of the callbacks in VkAllocationCallbacks are called, the
    /// Vulkan implementation will pass this value as the first parameter to the
    /// callback.
    /// This value can vary each time an allocator is passed into a command,
    /// even when the same object takes an allocator in multiple commands.</summary>
    public void*                                   pUserData;
    /// <summary> pfnAllocation is a pointer to an application-defined memory
    /// allocation function of type PFN_vkAllocationFunction.</summary>
    public PFN_vkAllocationFunction                pfnAllocation;
    /// <summary> pfnReallocation is a pointer to an application-defined memory
    /// reallocation function of type PFN_vkReallocationFunction.</summary>
    public PFN_vkReallocationFunction              pfnReallocation;
    /// <summary> pfnFree is a pointer to an application-defined memory free
    /// function of type PFN_vkFreeFunction.</summary>
    public PFN_vkFreeFunction                      pfnFree;
    /// <summary> pfnInternalAllocation is a pointer to an application-defined
    /// function that is called by the implementation when the implementation
    /// makes internal allocations, and it is of type
    /// PFN_vkInternalAllocationNotification.</summary>
    public PFN_vkInternalAllocationNotification    pfnInternalAllocation;
    /// <summary> pfnInternalFree is a pointer to an application-defined function
    /// that is called by the implementation when the implementation frees
    /// internal allocations, and it is of type
    /// PFN_vkInternalFreeNotification.</summary>
    public PFN_vkInternalFreeNotification          pfnInternalFree;
}
// Struct: 5
/// <summary>VkAndroidHardwareBufferFormatPropertiesANDROID - Structure describing the image format properties of an Android hardware buffer
/// <para>If the Android hardware buffer has one of the formats listed in theFormat Equivalencetable, then format must have the equivalent Vulkan format listed inthe table.Otherwise, format may be VK_FORMAT_UNDEFINED, indicating theAndroid hardware buffer can only be used with an external format.</para>
/// <para>The formatFeatures member must includeVK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT and at least one ofVK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT orVK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT, and should includeVK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT andVK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT.</para>
/// <para>The formatFeatures member only indicates the features available whenusing anexternal-formatimage created from the Android hardware buffer.Images from Android hardware buffers with a format other thanVK_FORMAT_UNDEFINED are subject to the format capabilities obtainedfrom vkGetPhysicalDeviceFormatProperties2, andvkGetPhysicalDeviceImageFormatProperties2 with appropriate parameters.These sets of features are independent of each other, e.g. the externalformat will support sampler Y’CBCR conversion even if the non-externalformat does not, and writing to non-external format images is possible butwriting to external format images is not.</para>
/// <para>Android hardware buffers with the same external format must have the samesupport for VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,andVK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT.in formatFeatures.Other format features may differ between Android hardware buffers that havethe same external format.This allows applications to use the same VkSamplerYcbcrConversionobject (and samplers and pipelines created from them) for any Androidhardware buffers that have the same external format.</para>
/// <para>If format is not VK_FORMAT_UNDEFINED, then the value ofsamplerYcbcrConversionComponents must be valid when used as thecomponents member of VkSamplerYcbcrConversionCreateInfo withthat format.If format is VK_FORMAT_UNDEFINED, all members ofsamplerYcbcrConversionComponents must beVK_COMPONENT_SWIZZLE_IDENTITY.</para>
/// <para>Implementations may not always be able to determine the color model,numerical range, or chroma offsets of the image contents, so the values inVkAndroidHardwareBufferFormatPropertiesANDROID are only suggestions.Applications should treat these values as sensible defaults to use in theabsence of more reliable information obtained through some other means.If the underlying physical device is also usable via OpenGL ES with the GL_OES_EGL_image_external extension, the implementation should suggest values that will producesimilar sampled values as would be obtained by sampling the same externalimage via samplerExternalOES in OpenGL ES using equivalent samplerparameters.</para>
/// <para>Since GL_OES_EGL_image_external does not require the same sampling and conversion calculations as Vulkandoes, achieving identical results between APIs may not be possible on someimplementations.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID </para>
/// </summary>
public unsafe struct VkAndroidHardwareBufferFormatPropertiesANDROID {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                  sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                            pNext;
    /// <summary> format is the Vulkan format corresponding to the Android hardware
    /// buffer’s format, or VK_FORMAT_UNDEFINED if there is not an
    /// equivalent Vulkan format.</summary>
    public VkFormat                         format;
    /// <summary> externalFormat is an implementation-defined external format
    /// identifier for use with VkExternalFormatANDROID.
    /// It must not be zero.</summary>
    public UInt64                         externalFormat;
    /// <summary> formatFeatures describes the capabilities of this external format
    /// when used with an image bound to memory imported from buffer.</summary>
    public VkFormatFeatureFlags             formatFeatures;
    /// <summary> samplerYcbcrConversionComponents is the component swizzle that
    /// should be used in VkSamplerYcbcrConversionCreateInfo.</summary>
    public VkComponentMapping               samplerYcbcrConversionComponents;
    /// <summary> suggestedYcbcrModel is a suggested color model to use in the
    /// VkSamplerYcbcrConversionCreateInfo.</summary>
    public VkSamplerYcbcrModelConversion    suggestedYcbcrModel;
    /// <summary> suggestedYcbcrRange is a suggested numerical value range to use in
    /// VkSamplerYcbcrConversionCreateInfo.</summary>
    public VkSamplerYcbcrRange              suggestedYcbcrRange;
    /// <summary> suggestedXChromaOffset is a suggested X chroma offset to use in
    /// VkSamplerYcbcrConversionCreateInfo.</summary>
    public VkChromaLocation                 suggestedXChromaOffset;
    /// <summary> suggestedYChromaOffset is a suggested Y chroma offset to use in
    /// VkSamplerYcbcrConversionCreateInfo.</summary>
    public VkChromaLocation                 suggestedYChromaOffset;
}
// Struct: 6
/// <summary>VkAndroidHardwareBufferPropertiesANDROID - Properties of External Memory Android Hardware Buffers
/// <para>   sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkAndroidHardwareBufferFormatPropertiesANDROID </para>
/// </summary>
public unsafe struct VkAndroidHardwareBufferPropertiesANDROID {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> allocationSize is the size of the external memory</summary>
    public VkDeviceSize       allocationSize;
    /// <summary> memoryTypeBits is a bitmask containing one bit set for every
    /// memory type which the specified Android hardware buffer can be imported
    /// as.</summary>
    public UInt32           memoryTypeBits;
}
// Struct: 7
/// <summary>VkAndroidHardwareBufferUsageANDROID - Struct containing Android hardware buffer usage flags
/// <para>The androidHardwareBufferUsage field must include Android hardwarebuffer usage flags listed in theAHardwareBuffer UsageEquivalence table when the corresponding Vulkan image usage or imagecreation flags are included in the usage or flags fields ofVkPhysicalDeviceImageFormatInfo2.It must include at least one GPU usage flag(AHARDWAREBUFFER_USAGE_GPU_*), even if none of the corresponding Vulkanusages or flags are requested.</para>
/// <para>Requiring at least one GPU usage flag ensures that Android hardware buffermemory will be allocated in a memory pool accessible to the Vulkanimplementation, and that specializing the memory layout based on usage flagsdoes not prevent it from being compatible with Vulkan.Implementations may avoid unnecessary restrictions caused by thisrequirement by using vendor usage flags to indicate that only the Vulkanuses indicated in VkImageFormatProperties2 are required.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID </para>
/// </summary>
public unsafe struct VkAndroidHardwareBufferUsageANDROID {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> androidHardwareBufferUsage returns the Android hardware buffer
    /// usage flags.</summary>
    public UInt64           androidHardwareBufferUsage;
}
// Struct: 8
/// <summary>VkAndroidSurfaceCreateInfoKHR - Structure specifying parameters of a newly created Android surface object
/// <para>   window must point to a valid Android ANativeWindow.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkAndroidSurfaceCreateInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                   sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                       pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkAndroidSurfaceCreateFlagsKHR    flags;
    /// <summary> window is a pointer to the ANativeWindow to associate the
    /// surface with.</summary>
    public /* struct */ ANativeWindow*             window;
}
// Struct: 9
/// <summary>VkApplicationInfo - Structure specifying application info
/// <para>Vulkan 1.0 implementations were required to returnVK_ERROR_INCOMPATIBLE_DRIVER if apiVersion was larger than 1.0.Implementations that support Vulkan 1.1 or later must not returnVK_ERROR_INCOMPATIBLE_DRIVER for any value of apiVersion.</para>
/// <para>Because Vulkan 1.0 implementations may fail withVK_ERROR_INCOMPATIBLE_DRIVER, applications should determine theversion of Vulkan available before calling vkCreateInstance.If the vkGetInstanceProcAddr returns NULL forvkEnumerateInstanceVersion, it is a Vulkan 1.0 implementation.Otherwise, the application can call vkEnumerateInstanceVersion todetermine the version of Vulkan.</para>
/// <para>As long as the instance supports at least Vulkan 1.1, an application canuse different versions of Vulkan with an instance than it does with a deviceor physical device.</para>
/// <para>The Khronos validation layers will treat apiVersion as the highest APIversion the application targets, and will validate API usage against theminimum of that version and the implementation version (instance or device,depending on context).If an application tries to use functionality from a greater version thanthis, a validation error will be triggered.</para>
/// <para>For example, if the instance supports Vulkan 1.1 and three physical devicessupport Vulkan 1.0, Vulkan 1.1, and a hypothetical Vulkan 1.2, respectively,and if the application sets apiVersion to 1.2, the application canuse the following versions of Vulkan:</para>
/// <para>Vulkan 1.0 can be used with the instance and with all physical devices.</para>
/// <para>Vulkan 1.1 can be used with the instance and with the physical devicesthat support Vulkan 1.1 and Vulkan 1.2.</para>
/// <para>Vulkan 1.2 can be used with the physical device that supports Vulkan1.2.</para>
/// <para>If we modify the above example so that the application sets apiVersionto 1.1, then the application must not use Vulkan 1.2 functionality on thephysical device that supports Vulkan 1.2.</para>
/// <para>Implicit layers must be disabled if they do not support a version at leastas high as apiVersion.See the Vulkan Loader Specification andArchitecture Overview document for additional information.</para>
/// <para>Providing a NULL VkInstanceCreateInfo::pApplicationInfo orproviding an apiVersion of 0 is equivalent to providing anapiVersion of VK_MAKE_VERSION(1,0,0).</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_APPLICATION_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   If pApplicationName is not NULL, pApplicationName must be a null-terminated UTF-8 string</para>
/// <para>   If pEngineName is not NULL, pEngineName must be a null-terminated UTF-8 string</para>
/// </summary>
public unsafe struct VkApplicationInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> pApplicationName is NULL or is a pointer to a null-terminated
    /// UTF-8 string containing the name of the application.</summary>
    public IntPtr        pApplicationName;
    /// <summary> applicationVersion is an unsigned integer variable containing the
    /// developer-supplied version number of the application.</summary>
    public UInt32           applicationVersion;
    /// <summary> pEngineName is NULL or is a pointer to a null-terminated UTF-8
    /// string containing the name of the engine (if any) used to create the
    /// application.</summary>
    public IntPtr        pEngineName;
    /// <summary> engineVersion is an unsigned integer variable containing the
    /// developer-supplied version number of the engine used to create the
    /// application.</summary>
    public UInt32           engineVersion;
    /// <summary> apiVersion
    ///   must be the highest version of Vulkan that the
    /// application is designed to use, encoded as described in
    /// html/vkspec.html#extendingvulkan-coreversions-versionnumbers.
    /// The patch version number specified in apiVersion is ignored when
    /// creating an instance object.
    /// Only the major and minor versions of the instance must match those
    /// requested in apiVersion.</summary>
    public UInt32           apiVersion;
}
// Struct: 10
/// <summary>VkAttachmentDescription - Structure specifying an attachment description
/// <para>If the attachment uses a color format, then loadOp and storeOpare used, and stencilLoadOp and stencilStoreOp are ignored.If the format has depth and/or stencil components, loadOp andstoreOp apply only to the depth data, while stencilLoadOp andstencilStoreOp define how the stencil data is handled.loadOp and stencilLoadOp define the load operations thatexecute as part of the first subpass that uses the attachment.storeOp and stencilStoreOp define the store operations thatexecute as part of the last subpass that uses the attachment.</para>
/// <para>The load operation for each sample in an attachment happens-before anyrecorded command which accesses the sample in the first subpass where theattachment is used.Load operations for attachments with a depth/stencil format execute in theVK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT pipeline stage.Load operations for attachments with a color format execute in theVK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT pipeline stage.</para>
/// <para>The store operation for each sample in an attachment happens-after anyrecorded command which accesses the sample in the last subpass where theattachment is used.Store operations for attachments with a depth/stencil format execute in theVK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT pipeline stage.Store operations for attachments with a color format execute in theVK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT pipeline stage.</para>
/// <para>If an attachment is not used by any subpass, then loadOp,storeOp, stencilStoreOp, and stencilLoadOp are ignored,and the attachment’s memory contents will not be modified by execution of arender pass instance.</para>
/// <para>The load and store operations apply on the first and last use of each viewin the render pass, respectively.If a view index of an attachment is not included in the view mask in anysubpass that uses it, then the load and store operations are ignored, andthe attachment’s memory contents will not be modified by execution of arender pass instance.</para>
/// <para>During a render pass instance, input/color attachments with color formatsthat have a component size of 8, 16, or 32 bits must be represented in theattachment’s format throughout the instance.Attachments with other floating- or fixed-point color formats, or with depthcomponents may be represented in a format with a precision higher than theattachment format, but must be represented with the same range.When such a component is loaded via the loadOp, it will be convertedinto an implementation-dependent format used by the render pass.Such components must be converted from the render pass format, to theformat of the attachment, before they are resolved or stored at the end of arender pass instance via storeOp.Conversions occur as described in NumericRepresentation and Computation and Fixed-PointData Conversions.</para>
/// <para>If flags includes VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT, thenthe attachment is treated as if it shares physical memory with anotherattachment in the same render pass.This information limits the ability of the implementation to reorder certainoperations (like layout transitions and the loadOp) such that it isnot improperly reordered against other uses of the same physical memory viaa different attachment.This is described in more detail below.</para>
/// <para>   finalLayout must not be VK_IMAGE_LAYOUT_UNDEFINED orVK_IMAGE_LAYOUT_PREINITIALIZED </para>
/// <para>   flags must be a valid combination of VkAttachmentDescriptionFlagBits values</para>
/// <para>   format must be a valid VkFormat value</para>
/// <para>   samples must be a valid VkSampleCountFlagBits value</para>
/// <para>   loadOp must be a valid VkAttachmentLoadOp value</para>
/// <para>   storeOp must be a valid VkAttachmentStoreOp value</para>
/// <para>   stencilLoadOp must be a valid VkAttachmentLoadOp value</para>
/// <para>   stencilStoreOp must be a valid VkAttachmentStoreOp value</para>
/// <para>   initialLayout must be a valid VkImageLayout value</para>
/// <para>   finalLayout must be a valid VkImageLayout value</para>
/// </summary>
public unsafe struct VkAttachmentDescription {
    /// <summary> flags is a bitmask of VkAttachmentDescriptionFlagBits
    /// specifying additional properties of the attachment.</summary>
    public VkAttachmentDescriptionFlags    flags;
    /// <summary> format is a VkFormat value specifying the format of the
    /// image view that will be used for the attachment.</summary>
    public VkFormat                        format;
    /// <summary> samples is the number of samples of the image as defined in
    /// VkSampleCountFlagBits.</summary>
    public VkSampleCountFlagBits           samples;
    /// <summary> loadOp is a VkAttachmentLoadOp value specifying how the
    /// contents of color and depth components of the attachment are treated at
    /// the beginning of the subpass where it is first used.</summary>
    public VkAttachmentLoadOp              loadOp;
    /// <summary> storeOp is a VkAttachmentStoreOp value specifying how the
    /// contents of color and depth components of the attachment are treated at
    /// the end of the subpass where it is last used.</summary>
    public VkAttachmentStoreOp             storeOp;
    /// <summary> stencilLoadOp is a VkAttachmentLoadOp value specifying how
    /// the contents of stencil components of the attachment are treated at the
    /// beginning of the subpass where it is first used.</summary>
    public VkAttachmentLoadOp              stencilLoadOp;
    /// <summary> stencilStoreOp is a VkAttachmentStoreOp value specifying how
    /// the contents of stencil components of the attachment are treated at the
    /// end of the last subpass where it is used.</summary>
    public VkAttachmentStoreOp             stencilStoreOp;
    /// <summary> initialLayout is the layout the attachment image subresource will
    /// be in when a render pass instance begins.</summary>
    public VkImageLayout                   initialLayout;
    /// <summary> finalLayout is the layout the attachment image subresource will be
    /// transitioned to when a render pass instance ends.</summary>
    public VkImageLayout                   finalLayout;
}
// Struct: 11
/// <summary>VkAttachmentDescription2KHR - Structure specifying an attachment description
/// <para>Parameters defined by this structure with the same name as those inVkAttachmentDescription have the identical effect to those parameters.</para>
/// <para>   finalLayout must not be VK_IMAGE_LAYOUT_UNDEFINED orVK_IMAGE_LAYOUT_PREINITIALIZED </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR </para>
/// <para>   flags must be a valid combination of VkAttachmentDescriptionFlagBits values</para>
/// <para>   format must be a valid VkFormat value</para>
/// <para>   samples must be a valid VkSampleCountFlagBits value</para>
/// <para>   loadOp must be a valid VkAttachmentLoadOp value</para>
/// <para>   storeOp must be a valid VkAttachmentStoreOp value</para>
/// <para>   stencilLoadOp must be a valid VkAttachmentLoadOp value</para>
/// <para>   stencilStoreOp must be a valid VkAttachmentStoreOp value</para>
/// <para>   initialLayout must be a valid VkImageLayout value</para>
/// <para>   finalLayout must be a valid VkImageLayout value</para>
/// </summary>
public unsafe struct VkAttachmentDescription2KHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                 sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                     pNext;
    /// <summary> flags is a bitmask of VkAttachmentDescriptionFlagBits
    /// specifying additional properties of the attachment.</summary>
    public VkAttachmentDescriptionFlags    flags;
    /// <summary> format is a VkFormat value specifying the format of the
    /// image that will be used for the attachment.</summary>
    public VkFormat                        format;
    /// <summary> samples is the number of samples of the image as defined in
    /// VkSampleCountFlagBits.</summary>
    public VkSampleCountFlagBits           samples;
    /// <summary> loadOp is a VkAttachmentLoadOp value specifying how the
    /// contents of color and depth components of the attachment are treated at
    /// the beginning of the subpass where it is first used.</summary>
    public VkAttachmentLoadOp              loadOp;
    /// <summary> storeOp is a VkAttachmentStoreOp value specifying how the
    /// contents of color and depth components of the attachment are treated at
    /// the end of the subpass where it is last used.</summary>
    public VkAttachmentStoreOp             storeOp;
    /// <summary> stencilLoadOp is a VkAttachmentLoadOp value specifying how
    /// the contents of stencil components of the attachment are treated at the
    /// beginning of the subpass where it is first used.</summary>
    public VkAttachmentLoadOp              stencilLoadOp;
    /// <summary> stencilStoreOp is a VkAttachmentStoreOp value specifying how
    /// the contents of stencil components of the attachment are treated at the
    /// end of the last subpass where it is used.</summary>
    public VkAttachmentStoreOp             stencilStoreOp;
    /// <summary> initialLayout is the layout the attachment image subresource will
    /// be in when a render pass instance begins.</summary>
    public VkImageLayout                   initialLayout;
    /// <summary> finalLayout is the layout the attachment image subresource will be
    /// transitioned to when a render pass instance ends.</summary>
    public VkImageLayout                   finalLayout;
}
// Struct: 12
/// <summary>VkAttachmentReference - Structure specifying an attachment reference
/// <para>  If attachment is not VK_ATTACHMENT_UNUSED, layout must not be VK_IMAGE_LAYOUT_UNDEFINED orVK_IMAGE_LAYOUT_PREINITIALIZED </para>
/// <para>   layout must be a valid VkImageLayout value</para>
/// </summary>
public unsafe struct VkAttachmentReference {
    /// <summary> attachment is either an integer value identifying an attachment at
    /// the corresponding index in
    /// VkRenderPassCreateInfo::pAttachments, or
    /// VK_ATTACHMENT_UNUSED to signify that this attachment is not used.</summary>
    public UInt32         attachment;
    /// <summary> layout is a VkImageLayout value specifying the layout the
    /// attachment uses during the subpass.</summary>
    public VkImageLayout    layout;
}
// Struct: 13
/// <summary>VkAttachmentReference2KHR - Structure specifying an attachment reference
/// <para>Parameters defined by this structure with the same name as those inVkAttachmentReference have the identical effect to those parameters.</para>
/// <para> aspectMask has the same effect for the described attachment asVkInputAttachmentAspectReference::aspectMask has on eachcorresponding attachment.It is ignored when this structure is used to describe anything other than aninput attachment reference.</para>
/// <para>  If attachment is not VK_ATTACHMENT_UNUSED, layout must not be VK_IMAGE_LAYOUT_UNDEFINED orVK_IMAGE_LAYOUT_PREINITIALIZED </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR </para>
/// <para>   layout must be a valid VkImageLayout value</para>
/// </summary>
public unsafe struct VkAttachmentReference2KHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*           pNext;
    /// <summary> attachment is either an integer value identifying an attachment at
    /// the corresponding index in
    /// VkRenderPassCreateInfo::pAttachments, or
    /// VK_ATTACHMENT_UNUSED to signify that this attachment is not used.</summary>
    public UInt32              attachment;
    /// <summary> layout is a VkImageLayout value specifying the layout the
    /// attachment uses during the subpass.</summary>
    public VkImageLayout         layout;
    /// <summary> aspectMask is a mask of which aspect(s) can be accessed within
    /// the specified subpass as an input attachment.</summary>
    public VkImageAspectFlags    aspectMask;
}
// Struct: 14
/// <summary>VkAttachmentSampleLocationsEXT - Structure specifying the sample locations state to use in the initial layout transition of attachments
/// <para>If the image referenced by the framebuffer attachment at indexattachmentIndex was not created withVK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT then thevalues specified in sampleLocationsInfo are ignored.</para>
/// <para>   attachmentIndex must be less than the attachmentCountspecified in VkRenderPassCreateInfo the render pass specified byVkRenderPassBeginInfo::renderPass was created with</para>
/// <para>   sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure</para>
/// </summary>
public unsafe struct VkAttachmentSampleLocationsEXT {
    /// <summary> attachmentIndex is the index of the attachment for which the
    /// sample locations state is provided.</summary>
    public UInt32                    attachmentIndex;
    /// <summary> sampleLocationsInfo is the sample locations state to use for the
    /// layout transition of the given attachment from the initial layout of the
    /// attachment to the image layout specified for the attachment in the first
    /// subpass using it.</summary>
    public VkSampleLocationsInfoEXT    sampleLocationsInfo;
}
// Struct: 15
/// <summary>VkBaseInStructure - Base structure for a read-only pointer chain
/// <para> VkBaseInStructure can be used to facilitate iterating through aread-only structure pointer chain.</para>
/// </summary>
public unsafe struct VkBaseInStructure {
    /// <summary> sType is the structure type of the structure being iterated
    /// through.</summary>
    public VkStructureType                    sType;
    /// <summary> pNext is NULL or a pointer to the next structure in a structure
    /// chain.</summary>
    public /* const */ /* struct */ VkBaseInStructure*    pNext;
}
// Struct: 16
/// <summary>VkBaseOutStructure - Base structure for a read-only pointer chain
/// <para> VkBaseOutStructure can be used to facilitate iterating through astructure pointer chain that returns data back to the application.</para>
/// </summary>
public unsafe struct VkBaseOutStructure {
    /// <summary> sType is the structure type of the structure being iterated
    /// through.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to the next structure in a structure
    /// chain.</summary>
    public /* struct */ VkBaseOutStructure*    pNext;
}
// Struct: 17
/// <summary>VkBindAccelerationStructureMemoryInfoNV - Structure specifying acceleration structure memory binding
/// <para>   accelerationStructure must not already be backed by a memoryobject</para>
/// <para>   memoryOffset must be less than the size of memory </para>
/// <para>   memory must have been allocated using one of the memory typesallowed in the memoryTypeBits member of theVkMemoryRequirements structure returned from a call tovkGetAccelerationStructureMemoryRequirementsNV withaccelerationStructure and type ofVK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV </para>
/// <para>   memoryOffset must be an integer multiple of the alignmentmember of the VkMemoryRequirements structure returned from a callto vkGetAccelerationStructureMemoryRequirementsNV withaccelerationStructure and type ofVK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV </para>
/// <para>  The size member of the VkMemoryRequirements structurereturned from a call tovkGetAccelerationStructureMemoryRequirementsNV withaccelerationStructure and type ofVK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV mustbe less than or equal to the size of memory minusmemoryOffset </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV </para>
/// <para>   pNext must be NULL </para>
/// <para>   accelerationStructure must be a valid VkAccelerationStructureNV handle</para>
/// <para>   memory must be a valid VkDeviceMemory handle</para>
/// <para>   If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values</para>
/// <para>   Both of accelerationStructure, and memory must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkBindAccelerationStructureMemoryInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType              sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                  pNext;
    /// <summary> accelerationStructure is the acceleration structure to be attached
    /// to memory.</summary>
    public VkAccelerationStructureNV    accelerationStructure;
    /// <summary> memory is a VkDeviceMemory object describing the device
    /// memory to attach.</summary>
    public VkDeviceMemory               memory;
    /// <summary> memoryOffset is the start offset of the region of memory that is
    /// to be bound to the acceleration structure.
    /// The number of bytes returned in the
    /// VkMemoryRequirements::size member in memory, starting
    /// from memoryOffset bytes, will be bound to the specified
    /// acceleration structure.</summary>
    public VkDeviceSize                 memoryOffset;
    /// <summary> deviceIndexCount is the number of elements in
    /// pDeviceIndices.</summary>
    public UInt32                     deviceIndexCount;
    /// <summary> pDeviceIndices is a pointer to an array of device indices.</summary>
    public /* const */ UInt32*              pDeviceIndices;
}
// Struct: 18
/// <summary>VkBindBufferMemoryDeviceGroupInfo - Structure specifying device within a group to bind to
/// <para>The VkBindBufferMemoryDeviceGroupInfo structure is defined as:</para>
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para> deviceIndexCount is the number of elements inpDeviceIndices.</para>
/// <para> pDeviceIndices is a pointer to an array of device indices.</para>
/// <para>If deviceIndexCount is greater than zero, then on device index ithe buffer is attached to the instance of memory on the physicaldevice with device index pDeviceIndices[i].</para>
/// <para>If deviceIndexCount is zero and memory comes from a memory heapwith the VK_MEMORY_HEAP_MULTI_INSTANCE_BIT bit set, then it is as ifpDeviceIndices contains consecutive indices from zero to the number ofphysical devices in the logical device, minus one.In other words, by default each physical device attaches to its own instanceof memory.</para>
/// <para>If deviceIndexCount is zero and memory comes from a memory heapwithout the VK_MEMORY_HEAP_MULTI_INSTANCE_BIT bit set, then it is asif pDeviceIndices contains an array of zeros.In other words, by default each physical device attaches to instance zero.</para>
/// <para>   deviceIndexCount must either be zero or equal to the number ofphysical devices in the logical device</para>
/// <para>  All elements of pDeviceIndices must be valid device indices</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO </para>
/// <para>   If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values</para>
/// </summary>
public unsafe struct VkBindBufferMemoryDeviceGroupInfo {
    public VkStructureType    sType;
    /// <summary>If the pNext list of VkBindBufferMemoryInfo includes a
    /// VkBindBufferMemoryDeviceGroupInfo structure, then that structure
    /// determines how memory is bound to buffers across multiple devices in a
    /// device group.</summary>
    public /* const */ void*        pNext;
    public UInt32           deviceIndexCount;
    public /* const */ UInt32*    pDeviceIndices;
}
// Struct: 19
/// <summary>VkBindBufferMemoryInfo - Structure specifying how to bind a buffer to memory
/// <para>   buffer must not already be backed by a memory object</para>
/// <para>   buffer must not have been created with any sparse memory bindingflags</para>
/// <para>   memoryOffset must be less than the size of memory </para>
/// <para>   memory must have been allocated using one of the memory typesallowed in the memoryTypeBits member of theVkMemoryRequirements structure returned from a call tovkGetBufferMemoryRequirements with buffer </para>
/// <para>   memoryOffset must be an integer multiple of the alignmentmember of the VkMemoryRequirements structure returned from a callto vkGetBufferMemoryRequirements with buffer </para>
/// <para>  The size member of the VkMemoryRequirements structurereturned from a call to vkGetBufferMemoryRequirements withbuffer must be less than or equal to the size of memoryminus memoryOffset </para>
/// <para>  If buffer requires a dedicated allocation(as reported byvkGetBufferMemoryRequirements2 inVkMemoryDedicatedRequirements::requiresDedicatedAllocation forbuffer), memory must have been created withVkMemoryDedicatedAllocateInfo::buffer equal to bufferand memoryOffset must be zero</para>
/// <para>  If the VkMemoryAllocateInfo provided when memory wasallocated included an instance of VkMemoryDedicatedAllocateInfo inits pNext chain, andVkMemoryDedicatedAllocateInfo::buffer was notVK_NULL_HANDLE, then buffer must equalVkMemoryDedicatedAllocateInfo::buffer and memoryOffset must be zero.</para>
/// <para>  If buffer was created withVkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocationequal to VK_TRUE, memory must have been created withVkDedicatedAllocationMemoryAllocateInfoNV::buffer equal tobuffer and memoryOffset must be zero</para>
/// <para>  If the pNext chain includesVkBindBufferMemoryDeviceGroupInfo, all instances of memoryspecified byVkBindBufferMemoryDeviceGroupInfo::pDeviceIndices must havebeen allocated</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkBindBufferMemoryDeviceGroupInfo </para>
/// <para>   buffer must be a valid VkBuffer handle</para>
/// <para>   memory must be a valid VkDeviceMemory handle</para>
/// <para>   Both of buffer, and memory must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkBindBufferMemoryInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> buffer is the buffer to be attached to memory.</summary>
    public VkBuffer           buffer;
    /// <summary> memory is a VkDeviceMemory object describing the device
    /// memory to attach.</summary>
    public VkDeviceMemory     memory;
    /// <summary> memoryOffset is the start offset of the region of memory
    /// which is to be bound to the buffer.
    /// The number of bytes returned in the
    /// VkMemoryRequirements::size member in memory, starting
    /// from memoryOffset bytes, will be bound to the specified buffer.</summary>
    public VkDeviceSize       memoryOffset;
}
// Struct: 20
/// <summary>VkBindImageMemoryDeviceGroupInfo - Structure specifying device within a group to bind to
/// <para>The VkBindImageMemoryDeviceGroupInfo structure is defined as:</para>
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para> deviceIndexCount is the number of elements inpDeviceIndices.</para>
/// <para> pDeviceIndices is a pointer to an array of device indices.</para>
/// <para> splitInstanceBindRegionCount is the number of elements inpSplitInstanceBindRegions.</para>
/// <para> pSplitInstanceBindRegions is a pointer to an array of rectanglesdescribing which regions of the image are attached to each instance ofmemory.</para>
/// <para>If deviceIndexCount is greater than zero, then on device index i image is attached to the instance of the memory on the physical devicewith device index pDeviceIndices[i].</para>
/// <para>Let N be the number of physical devices in the logical device.If splitInstanceBindRegionCount is greater than zero, thenpSplitInstanceBindRegions is an array of N2  rectangles, wherethe image region specified by the rectangle at element i*N+j inresource instance i is bound to the memory instance j.The blocks of the memory that are bound to each sparse image block regionuse an offset in memory, relative to memoryOffset, computed as if thewhole image were being bound to a contiguous range of memory.In other words, horizontally adjacent image blocks use consecutive blocks ofmemory, vertically adjacent image blocks are separated by the number ofbytes per block multiplied by the width in blocks of image, and theblock at (0,0) corresponds to memory starting at memoryOffset.</para>
/// <para>If splitInstanceBindRegionCount and deviceIndexCount are zeroand the memory comes from a memory heap with theVK_MEMORY_HEAP_MULTI_INSTANCE_BIT bit set, then it is as ifpDeviceIndices contains consecutive indices from zero to the number ofphysical devices in the logical device, minus one.In other words, by default each physical device attaches to its own instanceof the memory.</para>
/// <para>If splitInstanceBindRegionCount and deviceIndexCount are zeroand the memory comes from a memory heap without theVK_MEMORY_HEAP_MULTI_INSTANCE_BIT bit set, then it is as ifpDeviceIndices contains an array of zeros.In other words, by default each physical device attaches to instance zero.</para>
/// <para>  At least one of deviceIndexCount andsplitInstanceBindRegionCount must be zero.</para>
/// <para>   deviceIndexCount must either be zero or equal to the number ofphysical devices in the logical device</para>
/// <para>  All elements of pDeviceIndices must be valid device indices.</para>
/// <para>   splitInstanceBindRegionCount must either be zero or equal to thenumber of physical devices in the logical device squared</para>
/// <para>  Elements of pSplitInstanceBindRegions that correspond to the sameinstance of an image must not overlap.</para>
/// <para>  The offset.x member of any element ofpSplitInstanceBindRegions must be a multiple of the sparse imageblock width(VkSparseImageFormatProperties::imageGranularity.width) ofall non-metadata aspects of the image</para>
/// <para>  The offset.y member of any element ofpSplitInstanceBindRegions must be a multiple of the sparse imageblock height(VkSparseImageFormatProperties::imageGranularity.height) ofall non-metadata aspects of the image</para>
/// <para>  The extent.width member of any element ofpSplitInstanceBindRegions must either be a multiple of the sparseimage block width of all non-metadata aspects of the image, or elseextent.width + offset.x must equal the width of the imagesubresource</para>
/// <para>  The extent.height member of any element ofpSplitInstanceBindRegions must either be a multiple of the sparseimage block height of all non-metadata aspects of the image, or elseextent.height  offset.y must equal the width of the image subresource</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO </para>
/// <para>   If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values</para>
/// <para>   If splitInstanceBindRegionCount is not 0, pSplitInstanceBindRegions must be a valid pointer to an array of splitInstanceBindRegionCount VkRect2D structures</para>
/// </summary>
public unsafe struct VkBindImageMemoryDeviceGroupInfo {
    public VkStructureType    sType;
    /// <summary>If the pNext list of VkBindImageMemoryInfo includes a
    /// VkBindImageMemoryDeviceGroupInfo structure, then that structure
    /// determines how memory is bound to images across multiple devices in a device
    /// group.</summary>
    public /* const */ void*        pNext;
    public UInt32           deviceIndexCount;
    public /* const */ UInt32*    pDeviceIndices;
    public UInt32           splitInstanceBindRegionCount;
    public /* const */ VkRect2D*    pSplitInstanceBindRegions;
}
// Struct: 21
/// <summary>VkBindImageMemoryInfo - Structure specifying how to bind an image to memory
/// <para>   image must not already be backed by a memory object</para>
/// <para>   image must not have been created with any sparse memory bindingflags</para>
/// <para>   memoryOffset must be less than the size of memory </para>
/// <para>  If the pNext chain does not include an instance of theVkBindImagePlaneMemoryInfo structure, memory must have beenallocated using one of the memory types allowed in thememoryTypeBits member of the VkMemoryRequirements structurereturned from a call to vkGetImageMemoryRequirements2 withimage </para>
/// <para>  If the pNext chain does not include an instance of theVkBindImagePlaneMemoryInfo structure, memoryOffset must bean integer multiple of the alignment member of theVkMemoryRequirements structure returned from a call tovkGetImageMemoryRequirements2 with image </para>
/// <para>  If the pNext chain does not include an instance of theVkBindImagePlaneMemoryInfo structure, the difference of the sizeof memory and memoryOffset must be greater than or equal tothe size member of the VkMemoryRequirements structurereturned from a call to vkGetImageMemoryRequirements2 with thesame image </para>
/// <para>  If the pNext chain includes an instance of theVkBindImagePlaneMemoryInfo structure, image must have beencreated with the VK_IMAGE_CREATE_DISJOINT_BIT bit set.</para>
/// <para>  If the pNext chain includes an instance of theVkBindImagePlaneMemoryInfo structure, memory must have beenallocated using one of the memory types allowed in thememoryTypeBits member of the VkMemoryRequirements structurereturned from a call to vkGetImageMemoryRequirements2 withimage and the correct planeAspect for this plane in theVkImagePlaneMemoryRequirementsInfo structure attached to theVkImageMemoryRequirementsInfo2’s pNext chain</para>
/// <para>  If the pNext chain includes an instance of theVkBindImagePlaneMemoryInfo structure, memoryOffset must bean integer multiple of the alignment member of theVkMemoryRequirements structure returned from a call tovkGetImageMemoryRequirements2 with image and the correctplaneAspect for this plane in theVkImagePlaneMemoryRequirementsInfo structure attached to theVkImageMemoryRequirementsInfo2’s pNext chain</para>
/// <para>  If the pNext chain includes an instance of theVkBindImagePlaneMemoryInfo structure, the difference of the sizeof memory and memoryOffset must be greater than or equal tothe size member of the VkMemoryRequirements structurereturned from a call to vkGetImageMemoryRequirements2 with thesame image and the correct planeAspect for this plane in theVkImagePlaneMemoryRequirementsInfo structure attached to theVkImageMemoryRequirementsInfo2’s pNext chain</para>
/// <para>  If image requires a dedicated allocation (as reported byvkGetImageMemoryRequirements2 inVkMemoryDedicatedRequirements::requiresDedicatedAllocation forimage), memory must have been created withVkMemoryDedicatedAllocateInfo::image equal to imageand memoryOffset must be zero</para>
/// <para>  If the dedicated allocationimage aliasing feature is not enabled, and theVkMemoryAllocateInfo provided when memory was allocatedincluded an instance of VkMemoryDedicatedAllocateInfo in itspNext chain, and VkMemoryDedicatedAllocateInfo::imagewas not VK_NULL_HANDLE, then image must equalVkMemoryDedicatedAllocateInfo::image and memoryOffset must be zero.</para>
/// <para>  If the dedicated allocationimage aliasing feature is enabled, and the VkMemoryAllocateInfoprovided when memory was allocated included an instance ofVkMemoryDedicatedAllocateInfo in its pNext chain, andVkMemoryDedicatedAllocateInfo::image was notVK_NULL_HANDLE, then memoryOffset must be zero, andimage must be either equal toVkMemoryDedicatedAllocateInfo::image or an image that wascreated using the same parameters in VkImageCreateInfo, with theexception that extent and arrayLayers may differ subject tothe following restrictions: every dimension in the extentparameter of the image being bound must be equal to or smaller than theoriginal image for which the allocation was created; and thearrayLayers parameter of the image being bound must be equal toor smaller than the original image for which the allocation was created.</para>
/// <para>  If image was created withVkDedicatedAllocationImageCreateInfoNV::dedicatedAllocationequal to VK_TRUE, memory must have been created withVkDedicatedAllocationMemoryAllocateInfoNV::image equal toimage and memoryOffset must be zero</para>
/// <para>  If the pNext chain includesVkBindImageMemoryDeviceGroupInfo, all instances of memoryspecified byVkBindImageMemoryDeviceGroupInfo::pDeviceIndices must havebeen allocated</para>
/// <para>  If the pNext chain includesVkBindImageMemoryDeviceGroupInfo, andVkBindImageMemoryDeviceGroupInfo::splitInstanceBindRegionCountis not zero, then image must have been created with theVK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT bit set</para>
/// <para>  If the pNext chain includesVkBindImageMemoryDeviceGroupInfo, all elements ofVkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions must be valid rectangles contained within the dimensions of image </para>
/// <para>  If the pNext chain includesVkBindImageMemoryDeviceGroupInfo, the union of the areas of allelements ofVkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegionsthat correspond to the same instance of image must cover theentire image.</para>
/// <para>  If image was created with a valid swapchain handle inVkImageSwapchainCreateInfoKHR::swapchain, then thepNext chain must include a valid instance ofVkBindImageMemorySwapchainInfoKHR </para>
/// <para>  If the pNext chain includes an instance ofVkBindImageMemorySwapchainInfoKHR, memory must beVK_NULL_HANDLE </para>
/// <para>  If the pNext chain does not include an instance ofVkBindImageMemorySwapchainInfoKHR, memory must be a validVkDeviceMemory handle</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkBindImageMemoryDeviceGroupInfo, VkBindImageMemorySwapchainInfoKHR, or VkBindImagePlaneMemoryInfo </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   image must be a valid VkImage handle</para>
/// <para>   Both of image, and memory that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkBindImageMemoryInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> image is the image to be attached to memory.</summary>
    public VkImage            image;
    /// <summary> memory is a VkDeviceMemory object describing the device
    /// memory to attach.</summary>
    public VkDeviceMemory     memory;
    /// <summary> memoryOffset is the start offset of the region of memory
    /// which is to be bound to the image.
    /// The number of bytes returned in the
    /// VkMemoryRequirements::size member in memory, starting
    /// from memoryOffset bytes, will be bound to the specified image.</summary>
    public VkDeviceSize       memoryOffset;
}
// Struct: 22
/// <summary>VkBindImageMemorySwapchainInfoKHR - Structure specifying swapchain image memory to bind to
/// <para>If swapchain is not NULL, the swapchain and imageIndexare used to determine the memory that the image is bound to, instead ofmemory and memoryOffset.</para>
/// <para>Memory can be bound to a swapchain and use the pDeviceIndices orpSplitInstanceBindRegions members ofVkBindImageMemoryDeviceGroupInfo.</para>
/// <para>   imageIndex must be less than the number of images inswapchain </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR </para>
/// <para>   swapchain must be a valid VkSwapchainKHR handle</para>
/// <para>Host access to swapchain must be externally synchronized</para>
/// </summary>
public unsafe struct VkBindImageMemorySwapchainInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> swapchain is VK_NULL_HANDLE or a swapchain handle.</summary>
    public VkSwapchainKHR     swapchain;
    /// <summary> imageIndex is an image index within swapchain.</summary>
    public UInt32           imageIndex;
}
// Struct: 23
/// <summary>VkBindImagePlaneMemoryInfo - Structure specifying how to bind an image plane to memory
/// <para>  If the image’s tiling is VK_IMAGE_TILING_LINEAR orVK_IMAGE_TILING_OPTIMAL, then planeAspect must be a singlevalid format plane for the image.(That is, planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BITor VK_IMAGE_ASPECT_PLANE_1_BIT for “_2PLANE” formats andplaneAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT,VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BITfor “_3PLANE” formats.)</para>
/// <para>   If the image’s tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then planeAspect must be a single valid memory plane for the image. (That is, aspectMask must specify a plane index that is less than the  drmFormatModifierPlaneCount  associated with the image’s format  and drmFormatModifier .)</para>
/// <para>  A single call to vkBindImageMemory2 must bind all or none of theplanes of an image (i.e. bindings to all planes of an image must bemade in a single vkBindImageMemory2 call), as separate bindings</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO </para>
/// <para>   planeAspect must be a valid VkImageAspectFlagBits value</para>
/// </summary>
public unsafe struct VkBindImagePlaneMemoryInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*              pNext;
    /// <summary> planeAspect is the aspect of the disjoint image plane to bind.</summary>
    public VkImageAspectFlagBits    planeAspect;
}
// Struct: 24
/// <summary>VkBindSparseInfo - Structure specifying a sparse binding operation
/// <para>   sType must be VK_STRUCTURE_TYPE_BIND_SPARSE_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkDeviceGroupBindSparseInfo </para>
/// <para>   If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles</para>
/// <para>   If bufferBindCount is not 0, pBufferBinds must be a valid pointer to an array of bufferBindCount valid VkSparseBufferMemoryBindInfo structures</para>
/// <para>   If imageOpaqueBindCount is not 0, pImageOpaqueBinds must be a valid pointer to an array of imageOpaqueBindCount valid VkSparseImageOpaqueMemoryBindInfo structures</para>
/// <para>   If imageBindCount is not 0, pImageBinds must be a valid pointer to an array of imageBindCount valid VkSparseImageMemoryBindInfo structures</para>
/// <para>   If signalSemaphoreCount is not 0, pSignalSemaphores must be a valid pointer to an array of signalSemaphoreCount valid VkSemaphore handles</para>
/// <para>   Both of the elements of pSignalSemaphores, and the elements of pWaitSemaphores that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkBindSparseInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                 pNext;
    /// <summary> waitSemaphoreCount is the number of semaphores upon which to wait
    /// before executing the sparse binding operations for the batch.</summary>
    public UInt32                                    waitSemaphoreCount;
    /// <summary> pWaitSemaphores is a pointer to an array of semaphores upon which
    /// to wait on before the sparse binding operations for this batch begin
    /// execution.
    /// If semaphores to wait on are provided, they define a
    /// semaphore wait operation.</summary>
    public /* const */ VkSemaphore*                          pWaitSemaphores;
    /// <summary> bufferBindCount is the number of sparse buffer bindings to perform
    /// in the batch.</summary>
    public UInt32                                    bufferBindCount;
    /// <summary> pBufferBinds is a pointer to an array of
    /// VkSparseBufferMemoryBindInfo structures.</summary>
    public /* const */ VkSparseBufferMemoryBindInfo*         pBufferBinds;
    /// <summary> imageOpaqueBindCount is the number of opaque sparse image bindings
    /// to perform.</summary>
    public UInt32                                    imageOpaqueBindCount;
    /// <summary> pImageOpaqueBinds is a pointer to an array of
    /// VkSparseImageOpaqueMemoryBindInfo structures, indicating opaque
    /// sparse image bindings to perform.</summary>
    public /* const */ VkSparseImageOpaqueMemoryBindInfo*    pImageOpaqueBinds;
    /// <summary> imageBindCount is the number of sparse image bindings to perform.</summary>
    public UInt32                                    imageBindCount;
    /// <summary> pImageBinds is a pointer to an array of
    /// VkSparseImageMemoryBindInfo structures, indicating sparse image
    /// bindings to perform.</summary>
    public /* const */ VkSparseImageMemoryBindInfo*          pImageBinds;
    /// <summary> signalSemaphoreCount is the number of semaphores to be signaled
    /// once the sparse binding operations specified by the structure have
    /// completed execution.</summary>
    public UInt32                                    signalSemaphoreCount;
    /// <summary> pSignalSemaphores is a pointer to an array of semaphores which
    /// will be signaled when the sparse binding operations for this batch have
    /// completed execution.
    /// If semaphores to be signaled are provided, they define a
    /// semaphore signal operation.</summary>
    public /* const */ VkSemaphore*                          pSignalSemaphores;
}
// Struct: 25
/// <summary>VkBufferCopy - Structure specifying a buffer copy operation
/// <para>  The size must be greater than 0 </para>
/// </summary>
public unsafe struct VkBufferCopy {
    /// <summary> srcOffset is the starting offset in bytes from the start of
    /// srcBuffer.</summary>
    public VkDeviceSize    srcOffset;
    /// <summary> dstOffset is the starting offset in bytes from the start of
    /// dstBuffer.</summary>
    public VkDeviceSize    dstOffset;
    /// <summary> size is the number of bytes to copy.</summary>
    public VkDeviceSize    size;
}
// Struct: 26
/// <summary>VkBufferCreateInfo - Structure specifying the parameters of a newly created buffer object
/// <para>(Jon) Should the constraint on usage != 0 be converted to a Valid Usagestatement? See gitlab #854.</para>
/// <para>   size must be greater than 0 </para>
/// <para>  If sharingMode is VK_SHARING_MODE_CONCURRENT,pQueueFamilyIndices must be a valid pointer to an array ofqueueFamilyIndexCount uint32_t values</para>
/// <para>  If sharingMode is VK_SHARING_MODE_CONCURRENT,queueFamilyIndexCount must be greater than 1 </para>
/// <para>  If sharingMode is VK_SHARING_MODE_CONCURRENT, each elementof pQueueFamilyIndices must be unique and must be less thanpQueueFamilyPropertyCount returned by eithervkGetPhysicalDeviceQueueFamilyProperties orvkGetPhysicalDeviceQueueFamilyProperties2 for thephysicalDevice that was used to create device </para>
/// <para>  If the sparse bindings feature is notenabled, flags must not containVK_BUFFER_CREATE_SPARSE_BINDING_BIT </para>
/// <para>  If the sparse buffer residencyfeature is not enabled, flags must not containVK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT </para>
/// <para>  If the sparse aliased residencyfeature is not enabled, flags must not containVK_BUFFER_CREATE_SPARSE_ALIASED_BIT </para>
/// <para>  If flags contains VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT orVK_BUFFER_CREATE_SPARSE_ALIASED_BIT, it must also containVK_BUFFER_CREATE_SPARSE_BINDING_BIT </para>
/// <para>  If the pNext chain contains an instance ofVkExternalMemoryBufferCreateInfo, its handleTypes membermust only contain bits that are also inVkExternalBufferProperties::externalMemoryProperties.compatibleHandleTypes,as returned by vkGetPhysicalDeviceExternalBufferProperties withpExternalBufferInfo-&gt;handleType equal to any one of thehandle types specified inVkExternalMemoryBufferCreateInfo::handleTypes </para>
/// <para>  If the protected memory feature is not enabled, flags must notcontain VK_BUFFER_CREATE_PROTECTED_BIT </para>
/// <para>  If any of the bits VK_BUFFER_CREATE_SPARSE_BINDING_BIT,VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, orVK_BUFFER_CREATE_SPARSE_ALIASED_BIT are set,VK_BUFFER_CREATE_PROTECTED_BIT must not also be set</para>
/// <para>  If the pNext chain contains an instance ofVkDedicatedAllocationBufferCreateInfoNV, and thededicatedAllocation member of the chained structure isVK_TRUE, then flags must not includeVK_BUFFER_CREATE_SPARSE_BINDING_BIT,VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, orVK_BUFFER_CREATE_SPARSE_ALIASED_BIT </para>
/// <para>  If VkBufferDeviceAddressCreateInfoEXT::deviceAddress is notzero, flags must includeVK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT </para>
/// <para>  If flags includesVK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT, thebufferDeviceAddressCaptureReplayfeature must be enabled</para>
/// <para>  If usage includesVK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT, thebufferDeviceAddress feature must beenabled</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkBufferDeviceAddressCreateInfoEXT, VkDedicatedAllocationBufferCreateInfoNV, or VkExternalMemoryBufferCreateInfo </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   flags must be a valid combination of VkBufferCreateFlagBits values</para>
/// <para>   usage must be a valid combination of VkBufferUsageFlagBits values</para>
/// <para>   usage must not be 0 </para>
/// <para>   sharingMode must be a valid VkSharingMode value</para>
/// </summary>
public unsafe struct VkBufferCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType        sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*            pNext;
    /// <summary> flags is a bitmask of VkBufferCreateFlagBits specifying
    /// additional parameters of the buffer.</summary>
    public VkBufferCreateFlags    flags;
    /// <summary> size is the size in bytes of the buffer to be created.</summary>
    public VkDeviceSize           size;
    /// <summary> usage is a bitmask of VkBufferUsageFlagBits specifying
    /// allowed usages of the buffer.</summary>
    public VkBufferUsageFlags     usage;
    /// <summary> sharingMode is a VkSharingMode value specifying the sharing
    /// mode of the buffer when it will be accessed by multiple queue families.</summary>
    public VkSharingMode          sharingMode;
    /// <summary> queueFamilyIndexCount is the number of entries in the
    /// pQueueFamilyIndices array.</summary>
    public UInt32               queueFamilyIndexCount;
    /// <summary> pQueueFamilyIndices is a list of queue families that will access
    /// this buffer (ignored if sharingMode is not
    /// VK_SHARING_MODE_CONCURRENT).</summary>
    public /* const */ UInt32*        pQueueFamilyIndices;
}
// Struct: 27
/// <summary>VkBufferDeviceAddressCreateInfoEXT - Request a specific address for a buffer
/// <para>If deviceAddress is zero, no specific address is requested.</para>
/// <para>If deviceAddress is not zero, deviceAddress must be an addressretrieved from an identically created buffer on the same implementation.The buffer must also be bound to an identically createdVkDeviceMemory object.</para>
/// <para>If this structure is not present, it is as if deviceAddress is zero.</para>
/// <para>Apps should avoid creating buffers with app-provided addresses andimplementation-provided addresses in the same process, to reduce thelikelihood of VK_ERROR_INVALID_DEVICE_ADDRESS_EXT errors.</para>
/// <para>The expected usage for this is that a trace capture/replay tool will add theVK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT flag to allbuffers that use VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT, andduring capture will save the queried device addresses in the trace.During replay, the buffers will be created specifying the original addressso any address values stored in the trace data will remain valid.</para>
/// <para>Implementations are expected to separate such buffers in the GPU addressspace so normal allocations will avoid using these addresses.Apps/tools should avoid mixing app-provided and implementation-providedaddresses for buffers created withVK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT, to avoidaddress space allocation conflicts.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT </para>
/// </summary>
public unsafe struct VkBufferDeviceAddressCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> deviceAddress is the device address requested for the buffer.</summary>
    public VkDeviceAddress    deviceAddress;
}
// Struct: 28
/// <summary>VkBufferDeviceAddressInfoEXT - Structure specifying the buffer to query an address for
/// <para>  If buffer is non-sparse and was not created with theVK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT flag, thenit must be bound completely and contiguously to a singleVkDeviceMemory object</para>
/// <para>   buffer must have been created withVK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   buffer must be a valid VkBuffer handle</para>
/// </summary>
public unsafe struct VkBufferDeviceAddressInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> buffer specifies the buffer whose address is being queried.</summary>
    public VkBuffer           buffer;
}
// Struct: 29
/// <summary>VkBufferImageCopy - Structure specifying a buffer image copy operation
/// <para>When copying to or from a depth or stencil aspect, the data in buffer memoryuses a layout that is a (mostly) tightly packed representation of the depthor stencil data.Specifically:</para>
/// <para>data copied to or from the stencil aspect of any depth/stencil format istightly packed with one VK_FORMAT_S8_UINT value per texel.</para>
/// <para>data copied to or from the depth aspect of a VK_FORMAT_D16_UNORMor VK_FORMAT_D16_UNORM_S8_UINT format is tightly packed with oneVK_FORMAT_D16_UNORM value per texel.</para>
/// <para>data copied to or from the depth aspect of a VK_FORMAT_D32_SFLOATor VK_FORMAT_D32_SFLOAT_S8_UINT format is tightly packed with oneVK_FORMAT_D32_SFLOAT value per texel.</para>
/// <para>data copied to or from the depth aspect of aVK_FORMAT_X8_D24_UNORM_PACK32 or VK_FORMAT_D24_UNORM_S8_UINTformat is packed with one 32-bit word per texel with the D24 value inthe LSBs of the word, and undefined values in the eight MSBs.</para>
/// <para>To copy both the depth and stencil aspects of a depth/stencil format, twoentries in pRegions can be used, where one specifies the depth aspectin imageSubresource, and the other specifies the stencil aspect.</para>
/// <para>Because depth or stencil aspect buffer to image copies may require formatconversions on some implementations, they are not supported on queues thatdo not support graphics.</para>
/// <para>Copies are done layer by layer starting with image layerbaseArrayLayer member of imageSubresource.layerCount layers are copied from the source image or to thedestination image.</para>
/// <para>  If the calling command’s VkImage parameter’s format is not adepth/stencil format or amulti-planar format, thenbufferOffset must be a multiple of the format’s texel block size.</para>
/// <para>  If the calling command’s VkImage parameter’s format is amulti-planar format, thenbufferOffset must be a multiple of the element size of thecompatible format for the format and the aspectMask of theimageSubresource as defined in html/vkspec.html#formats-compatible-planes </para>
/// <para>   bufferOffset must be a multiple of 4 </para>
/// <para>   bufferRowLength must be 0, or greater than or equal to thewidth member of imageExtent </para>
/// <para>   bufferImageHeight must be 0, or greater than or equal to theheight member of imageExtent </para>
/// <para>   imageOffset.x and (imageExtent.width + imageOffset.x) must both be greater than or equal to 0 andless than or equal to the image subresource widthwhere this refers to the width of the plane of the image involved inthe copy in the case of amulti-planar format </para>
/// <para>   imageOffset.y and (imageExtent.height + imageOffset.y) must both be greater than or equal to 0 andless than or equal to the image subresource heightwhere this refers to the height of the plane of the image involved inthe copy in the case of amulti-planar format </para>
/// <para>  If the calling command’s srcImage (vkCmdCopyImageToBuffer)or dstImage (vkCmdCopyBufferToImage) is of typeVK_IMAGE_TYPE_1D, then imageOffset.y must be 0 andimageExtent.height must be 1.</para>
/// <para>   imageOffset.z and (imageExtent.depth + imageOffset.z) must both be greater than or equal to 0 andless than or equal to the image subresource depth</para>
/// <para>  If the calling command’s srcImage (vkCmdCopyImageToBuffer)or dstImage (vkCmdCopyBufferToImage) is of typeVK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, thenimageOffset.z must be 0 and imageExtent.depth must be1 </para>
/// <para>  If the calling command’s VkImage parameter is a compressed image,or a single-plane, “_422” image format,bufferRowLength must be a multiple of the compressed texel blockwidth</para>
/// <para>  If the calling command’s VkImage parameter is a compressed image,or a single-plane, “_422” image format,bufferImageHeight must be a multiple of the compressed texelblock height</para>
/// <para>  If the calling command’s VkImage parameter is a compressed image,or a single-plane, “_422” image format,all members of imageOffset must be a multiple of thecorresponding dimensions of the compressed texel block</para>
/// <para>  If the calling command’s VkImage parameter is a compressed image,or a single-plane, “_422” image format,bufferOffset must be a multiple of the compressed texel blocksize in bytes</para>
/// <para>  If the calling command’s VkImage parameter is a compressed image,or a single-plane, “_422” image format,imageExtent.width must be a multiple of the compressed texelblock width or (imageExtent.width + imageOffset.x) must equal the image subresource width</para>
/// <para>  If the calling command’s VkImage parameter is a compressed image,or a single-plane, “_422” image format,imageExtent.height must be a multiple of the compressed texelblock height or (imageExtent.height + imageOffset.y) must equal the image subresource height</para>
/// <para>  If the calling command’s VkImage parameter is a compressed image,or a single-plane, “_422” image format,imageExtent.depth must be a multiple of the compressed texelblock depth or (imageExtent.depth + imageOffset.z) must equal the image subresource depth</para>
/// <para>  The aspectMask member of imageSubresource must specifyaspects present in the calling command’s VkImage parameter</para>
/// <para>  If the calling command’s VkImage parameter’s format is amulti-planar format, thenthe aspectMask member of imageSubresource must beVK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, orVK_IMAGE_ASPECT_PLANE_2_BIT (withVK_IMAGE_ASPECT_PLANE_2_BIT valid only for image formats withthree planes)</para>
/// <para>  The aspectMask member of imageSubresource must only have asingle bit set</para>
/// <para>  If the calling command’s VkImage parameter is of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCountmembers of imageSubresource must be 0 and 1, respectively</para>
/// <para>   imageSubresource must be a valid VkImageSubresourceLayers structure</para>
/// </summary>
public unsafe struct VkBufferImageCopy {
    /// <summary> bufferOffset is the offset in bytes from the start of the buffer
    /// object where the image data is copied from or to.</summary>
    public VkDeviceSize                bufferOffset;
    /// <summary> bufferRowLength and bufferImageHeight specify in texels a
    /// subregion of a larger two- or three-dimensional image in buffer memory,
    /// and control the addressing calculations.
    /// If either of these values is zero, that aspect of the buffer memory is
    /// considered to be tightly packed according to the imageExtent.</summary>
    public UInt32                    bufferRowLength;
    public UInt32                    bufferImageHeight;
    /// <summary> imageSubresource is a VkImageSubresourceLayers used to
    /// specify the specific image subresources of the image used for the source
    /// or destination image data.</summary>
    public VkImageSubresourceLayers    imageSubresource;
    /// <summary> imageOffset selects the initial x, y, z offsets
    /// in texels of the sub-region of the source or destination image data.</summary>
    public VkOffset3D                  imageOffset;
    /// <summary> imageExtent is the size in texels of the image to copy in
    /// width, height and depth.</summary>
    public VkExtent3D                  imageExtent;
}
// Struct: 30
/// <summary>VkBufferMemoryBarrier - Structure specifying a buffer memory barrier
/// <para>The first access scope islimited to access to memory through the specified buffer range, via accesstypes in the source access mask specifiedby srcAccessMask.If srcAccessMask includes VK_ACCESS_HOST_WRITE_BIT, memorywrites performed by that access type are also made visible, as that accesstype is not performed through a resource.</para>
/// <para>The second access scope islimited to access to memory through the specified buffer range, via accesstypes in the destination access mask.specified by dstAccessMask.If dstAccessMask includes VK_ACCESS_HOST_WRITE_BIT orVK_ACCESS_HOST_READ_BIT, available memory writes are also made visibleto accesses of those types, as those access types are not performed througha resource.</para>
/// <para>If srcQueueFamilyIndex is not equal to dstQueueFamilyIndex, andsrcQueueFamilyIndex is equal to the current queue family, then thememory barrier defines a queuefamily release operation for the specified buffer range, and the secondaccess scope includes no access, as if dstAccessMask was 0.</para>
/// <para>If dstQueueFamilyIndex is not equal to srcQueueFamilyIndex, anddstQueueFamilyIndex is equal to the current queue family, then thememory barrier defines a queuefamily acquire operation for the specified buffer range, and the firstaccess scope includes no access, as if srcAccessMask was 0.</para>
/// <para>   offset must be less than the size of buffer </para>
/// <para>  If size is not equal to VK_WHOLE_SIZE, size must begreater than 0 </para>
/// <para>  If size is not equal to VK_WHOLE_SIZE, size must beless than or equal to than the size of buffer minus offset </para>
/// <para>  If buffer was created with a sharing mode ofVK_SHARING_MODE_CONCURRENT, at least one ofsrcQueueFamilyIndex and dstQueueFamilyIndex must beVK_QUEUE_FAMILY_IGNORED </para>
/// <para>  If buffer was created with a sharing mode ofVK_SHARING_MODE_CONCURRENT, and one of srcQueueFamilyIndexand dstQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, theother must be VK_QUEUE_FAMILY_IGNORED or a special queue familyreserved for external memory ownership transfers, as described inhtml/vkspec.html#synchronization-queue-transfers.</para>
/// <para>  If buffer was created with a sharing mode ofVK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex isVK_QUEUE_FAMILY_IGNORED, dstQueueFamilyIndex must also beVK_QUEUE_FAMILY_IGNORED </para>
/// <para>  If buffer was created with a sharing mode ofVK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is notVK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or aspecial queue family reserved for external memory transfers, asdescribed in html/vkspec.html#synchronization-queue-transfers.</para>
/// <para>  If buffer was created with a sharing mode ofVK_SHARING_MODE_EXCLUSIVE and dstQueueFamilyIndex is notVK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or aspecial queue family reserved for external memory transfers, asdescribed in html/vkspec.html#synchronization-queue-transfers.</para>
/// <para>  If buffer was created with a sharing mode ofVK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex anddstQueueFamilyIndex are not VK_QUEUE_FAMILY_IGNORED, atleast one of them must be the same as the family of the queue that willexecute this barrier</para>
/// <para>  If buffer is non-sparse then it must be bound completely andcontiguously to a single VkDeviceMemory object</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER </para>
/// <para>   pNext must be NULL </para>
/// <para>   srcAccessMask must be a valid combination of VkAccessFlagBits values</para>
/// <para>   dstAccessMask must be a valid combination of VkAccessFlagBits values</para>
/// <para>   buffer must be a valid VkBuffer handle</para>
/// </summary>
public unsafe struct VkBufferMemoryBarrier {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> srcAccessMask is a bitmask of VkAccessFlagBits specifying a
    /// source access mask.</summary>
    public VkAccessFlags      srcAccessMask;
    /// <summary> dstAccessMask is a bitmask of VkAccessFlagBits specifying a
    /// destination access mask.</summary>
    public VkAccessFlags      dstAccessMask;
    /// <summary> srcQueueFamilyIndex is the source queue family for a
    /// queue family ownership transfer.</summary>
    public UInt32           srcQueueFamilyIndex;
    /// <summary> dstQueueFamilyIndex is the destination queue family for a
    /// queue family ownership transfer.</summary>
    public UInt32           dstQueueFamilyIndex;
    /// <summary> buffer is a handle to the buffer whose backing memory is affected
    /// by the barrier.</summary>
    public VkBuffer           buffer;
    /// <summary> offset is an offset in bytes into the backing memory for
    /// buffer; this is relative to the base offset as bound to the buffer
    /// (see vkBindBufferMemory).</summary>
    public VkDeviceSize       offset;
    /// <summary> size is a size in bytes of the affected area of backing memory for
    /// buffer, or VK_WHOLE_SIZE to use the range from offset
    /// to the end of the buffer.</summary>
    public VkDeviceSize       size;
}
// Struct: 31
/// <summary>VkBufferMemoryRequirementsInfo2 - (None)
/// <para>   sType must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 </para>
/// <para>   pNext must be NULL </para>
/// <para>   buffer must be a valid VkBuffer handle</para>
/// </summary>
public unsafe struct VkBufferMemoryRequirementsInfo2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> buffer is the buffer to query.</summary>
    public VkBuffer           buffer;
}
// Struct: 32
/// <summary>VkBufferViewCreateInfo - Structure specifying parameters of a newly created buffer view
/// <para>   offset must be less than the size of buffer </para>
/// <para>   offset must be a multiple ofVkPhysicalDeviceLimits::minTexelBufferOffsetAlignment </para>
/// <para>  If range is not equal to VK_WHOLE_SIZE, range must begreater than 0 </para>
/// <para>  If range is not equal to VK_WHOLE_SIZE, range must bean integer multiple of the texel block size of format </para>
/// <para>  If range is not equal to VK_WHOLE_SIZE, range dividedby the texel block size of format, multiplied by the number oftexels per texel block for that format (as defined in theCompatible Formats table), must be less thanor equal to VkPhysicalDeviceLimits::maxTexelBufferElements </para>
/// <para>  If range is not equal to VK_WHOLE_SIZE, the sum ofoffset and range must be less than or equal to the size ofbuffer </para>
/// <para>   buffer must have been created with a usage value containingat least one of VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT orVK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT </para>
/// <para>  If buffer was created with usage containingVK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT, format must besupported for uniform texel buffers, as specified by theVK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT flag inVkFormatProperties::bufferFeatures returned byvkGetPhysicalDeviceFormatProperties </para>
/// <para>  If buffer was created with usage containingVK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, format must besupported for storage texel buffers, as specified by theVK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT flag inVkFormatProperties::bufferFeatures returned byvkGetPhysicalDeviceFormatProperties </para>
/// <para>  If buffer is non-sparse then it must be bound completely andcontiguously to a single VkDeviceMemory object</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   buffer must be a valid VkBuffer handle</para>
/// <para>   format must be a valid VkFormat value</para>
/// </summary>
public unsafe struct VkBufferViewCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkBufferViewCreateFlags    flags;
    /// <summary> buffer is a VkBuffer on which the view will be created.</summary>
    public VkBuffer                   buffer;
    /// <summary> format is a VkFormat describing the format of the data
    /// elements in the buffer.</summary>
    public VkFormat                   format;
    /// <summary> offset is an offset in bytes from the base address of the buffer.
    /// Accesses to the buffer view from shaders use addressing that is relative
    /// to this starting offset.</summary>
    public VkDeviceSize               offset;
    /// <summary> range is a size in bytes of the buffer view.
    /// If range is equal to VK_WHOLE_SIZE, the range from
    /// offset to the end of the buffer is used.
    /// If VK_WHOLE_SIZE is used and the remaining size of the buffer is
    /// not a multiple of the texel block size of
    /// format, the nearest smaller multiple is used.</summary>
    public VkDeviceSize               range;
}
// Struct: 33
/// <summary>VkCalibratedTimestampInfoEXT - Structure specifying the input parameters of a calibrated timestamp query
/// <para>   timeDomain must be one of the VkTimeDomainEXT valuesreturned by vkGetPhysicalDeviceCalibrateableTimeDomainsEXT </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   timeDomain must be a valid VkTimeDomainEXT value</para>
/// </summary>
public unsafe struct VkCalibratedTimestampInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> timeDomain is a VkTimeDomainEXT value specifying the time
    /// domain from which the calibrated timestamp value should be returned.</summary>
    public VkTimeDomainEXT    timeDomain;
}
// Struct: 34
/// <summary>VkCheckpointDataNV - return structure for command buffer checkpoint data
/// <para>   sType must be VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV </para>
/// <para>   pNext must be NULL </para>
/// <para>Note that the stages at which a checkpoint marker can be executed areimplementation-defined and can be queried by callingvkGetPhysicalDeviceQueueFamilyProperties2.</para>
/// </summary>
public unsafe struct VkCheckpointDataNV {
    /// <summary> sType is the type of this structure</summary>
    public VkStructureType            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                      pNext;
    /// <summary> stage indicates which pipeline stage the checkpoint marker data
    /// refers to.</summary>
    public VkPipelineStageFlagBits    stage;
    /// <summary> pCheckpointMarker contains the value of the last checkpoint marker
    /// executed in the stage that stage refers to.</summary>
    public void*                      pCheckpointMarker;
}
// Struct: 35
/// <summary>VkClearAttachment - Structure specifying a clear attachment
/// <para>No memory barriers are needed between vkCmdClearAttachments andpreceding or subsequent draw or attachment clear commands in the samesubpass.</para>
/// <para>The vkCmdClearAttachments command is not affected by the boundpipeline state.</para>
/// <para>Attachments can also be cleared at the beginning of a render pass instanceby setting loadOp (or stencilLoadOp) ofVkAttachmentDescription to VK_ATTACHMENT_LOAD_OP_CLEAR, asdescribed for vkCreateRenderPass.</para>
/// <para>  If aspectMask includes VK_IMAGE_ASPECT_COLOR_BIT, it mustnot include VK_IMAGE_ASPECT_DEPTH_BIT orVK_IMAGE_ASPECT_STENCIL_BIT </para>
/// <para>   aspectMask must not include VK_IMAGE_ASPECT_METADATA_BIT </para>
/// <para>   aspectMask must not includeVK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i.</para>
/// <para>   clearValue must be a valid VkClearValue union</para>
/// <para>   aspectMask must be a valid combination of VkImageAspectFlagBits values</para>
/// <para>   aspectMask must not be 0 </para>
/// </summary>
public unsafe struct VkClearAttachment {
    /// <summary> aspectMask is a mask selecting the color, depth and/or stencil
    /// aspects of the attachment to be cleared.</summary>
    public VkImageAspectFlags    aspectMask;
    /// <summary> colorAttachment is only meaningful if
    /// VK_IMAGE_ASPECT_COLOR_BIT is set in aspectMask, in which
    /// case it is an index to the pColorAttachments array in the
    /// VkSubpassDescription structure of the current subpass which
    /// selects the color attachment to clear.</summary>
    public UInt32              colorAttachment;
    /// <summary> clearValue is the color or depth/stencil value to clear the
    /// attachment to, as described in Clear Values below.</summary>
    public VkClearValue          clearValue;
}
// Struct: 36
/// <summary>VkClearColorValue - Structure specifying a clear color value
/// <para>The four array elements of the clear color map to R, G, B, and A componentsof image formats, in order.</para>
/// <para>If the image has more than one sample, the same value is written to allsamples for any pixels being cleared.</para>
/// </summary>
/*union*/[StructLayout(LayoutKind.Explicit)] public struct VkClearColorValue {
    [FieldOffset(0)] public fixed float       float32[4];
    [FieldOffset(0)] public fixed Int32     int32[4];
    [FieldOffset(0)] public fixed UInt32    uint32[4];
}
// Struct: 37
/// <summary>VkClearDepthStencilValue - Structure specifying a clear depth stencil value
/// <para>  Unless the  html/vkspec.html#VK_EXT_depth_range_unrestricted  extension is enableddepth must be between 0.0 and 1.0, inclusive</para>
/// </summary>
public unsafe struct VkClearDepthStencilValue {
    /// <summary> depth is the clear value for the depth aspect of the depth/stencil
    /// attachment.
    /// It is a floating-point value which is automatically converted to the
    /// attachment’s format.</summary>
    public float       depth;
    /// <summary> stencil is the clear value for the stencil aspect of the
    /// depth/stencil attachment.
    /// It is a 32-bit integer value which is converted to the attachment’s
    /// format by taking the appropriate number of LSBs.</summary>
    public UInt32    stencil;
}
// Struct: 38
/// <summary>VkClearRect - Structure specifying a clear rectangle
/// <para>The layers [baseArrayLayer, baseArrayLayer + layerCount) counting from the base layer of the attachment image vieware cleared.</para>
/// </summary>
public unsafe struct VkClearRect {
    /// <summary> rect is the two-dimensional region to be cleared.</summary>
    public VkRect2D    rect;
    /// <summary> baseArrayLayer is the first layer to be cleared.</summary>
    public UInt32    baseArrayLayer;
    /// <summary> layerCount is the number of layers to clear.</summary>
    public UInt32    layerCount;
}
// Struct: 39
/// <summary>VkClearValue - Structure specifying a clear value
/// <para>This union is used where part of the API requires either color ordepth/stencil clear values, depending on the attachment, and defines theinitial clear values in the VkRenderPassBeginInfo structure.</para>
/// </summary>
/*union*/[StructLayout(LayoutKind.Explicit)] public struct VkClearValue {
    /// <summary> color specifies the color image clear values to use when clearing
    /// a color image or attachment.</summary>
    [FieldOffset(0)] public VkClearColorValue           color;
    /// <summary> depthStencil specifies the depth and stencil clear values to use
    /// when clearing a depth/stencil image or attachment.</summary>
    [FieldOffset(0)] public VkClearDepthStencilValue    depthStencil;
}
// Struct: 40
/// <summary>VkCmdProcessCommandsInfoNVX - Structure specifying parameters for the generation of commands
/// <para>  The provided objectTable must include all objects referenced bythe generation process</para>
/// <para>   indirectCommandsTokenCount must match theindirectCommandsLayout’s tokenCount </para>
/// <para>  The tokenType member of each entry in thepIndirectCommandsTokens array must match the values used atcreation time of indirectCommandsLayout </para>
/// <para>  If targetCommandBuffer is provided, it must have reserved commandspace</para>
/// <para>  If targetCommandBuffer is provided, the objectTable mustmatch the reservation’s objectTable and must have had allreferenced objects registered at reservation time</para>
/// <para>  If targetCommandBuffer is provided, theindirectCommandsLayout must match the reservation’sindirectCommandsLayout </para>
/// <para>  If targetCommandBuffer is provided, the maxSequencesCount must not exceed the reservation’s maxSequencesCount </para>
/// <para>  If sequencesCountBuffer is used, its usage flag must have theVK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</para>
/// <para>  If sequencesCountBuffer is used, sequencesCountOffset mustbe aligned toVkDeviceGeneratedCommandsLimitsNVX::minSequenceCountBufferOffsetAlignment </para>
/// <para>  If sequencesIndexBuffer is used, its usage flag must have theVK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set</para>
/// <para>  If sequencesIndexBuffer is used, sequencesIndexOffset mustbe aligned toVkDeviceGeneratedCommandsLimitsNVX::minSequenceIndexBufferOffsetAlignment </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX </para>
/// <para>   pNext must be NULL </para>
/// <para>   objectTable must be a valid VkObjectTableNVX handle</para>
/// <para>   indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNVX handle</para>
/// <para>   pIndirectCommandsTokens must be a valid pointer to an array of indirectCommandsTokenCount valid VkIndirectCommandsTokenNVX structures</para>
/// <para>   If targetCommandBuffer is not NULL, targetCommandBuffer must be a valid VkCommandBuffer handle</para>
/// <para>   If sequencesCountBuffer is not VK_NULL_HANDLE, sequencesCountBuffer must be a valid VkBuffer handle</para>
/// <para>   If sequencesIndexBuffer is not VK_NULL_HANDLE, sequencesIndexBuffer must be a valid VkBuffer handle</para>
/// <para>   indirectCommandsTokenCount must be greater than 0 </para>
/// <para>   Each of indirectCommandsLayout, objectTable, sequencesCountBuffer, sequencesIndexBuffer, and targetCommandBuffer that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// <para>Host access to objectTable must be externally synchronized</para>
/// <para>Host access to targetCommandBuffer must be externally synchronized</para>
/// </summary>
public unsafe struct VkCmdProcessCommandsInfoNVX {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                          pNext;
    /// <summary> objectTable is the VkObjectTableNVX to be used for the
    /// generation process.
    /// Only registered objects at the time
    /// vkCmdReserveSpaceForCommandsNVX is called, will be taken into
    /// account for the reservation.</summary>
    public VkObjectTableNVX                     objectTable;
    /// <summary> indirectCommandsLayout is the VkIndirectCommandsLayoutNVX
    /// that provides the command sequence to generate.</summary>
    public VkIndirectCommandsLayoutNVX          indirectCommandsLayout;
    /// <summary> indirectCommandsTokenCount defines the number of input tokens
    /// used.</summary>
    public UInt32                             indirectCommandsTokenCount;
    /// <summary> pIndirectCommandsTokens provides an array of
    /// VkIndirectCommandsTokenNVX that reference the input data for each
    /// token command.</summary>
    public /* const */ VkIndirectCommandsTokenNVX*    pIndirectCommandsTokens;
    /// <summary> maxSequencesCount is the maximum number of sequences for which
    /// command buffer space will be reserved.
    /// If sequencesCountBuffer is VK_NULL_HANDLE, this is also the
    /// actual number of sequences generated.</summary>
    public UInt32                             maxSequencesCount;
    /// <summary> targetCommandBuffer
    ///   can be the secondary VkCommandBuffer in
    /// which the commands should be recorded.
    /// If targetCommandBuffer is NULL an implicit reservation as well
    /// as execution takes place on the processing VkCommandBuffer.</summary>
    public VkCommandBuffer                      targetCommandBuffer;
    /// <summary> sequencesCountBuffer
    ///   can be VkBuffer from which the actual
    /// amount of sequences is sourced from as uint32_t value.</summary>
    public VkBuffer                             sequencesCountBuffer;
    /// <summary> sequencesCountOffset is the byte offset into
    /// sequencesCountBuffer where the count value is stored.</summary>
    public VkDeviceSize                         sequencesCountOffset;
    /// <summary> sequencesIndexBuffer
    ///   must be set if
    /// indirectCommandsLayout’s
    /// VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX is set
    /// and provides the used sequence indices as uint32_t array.
    /// Otherwise it must be VK_NULL_HANDLE.</summary>
    public VkBuffer                             sequencesIndexBuffer;
    /// <summary> sequencesIndexOffset is the byte offset into
    /// sequencesIndexBuffer where the index values start.</summary>
    public VkDeviceSize                         sequencesIndexOffset;
}
// Struct: 41
/// <summary>VkCmdReserveSpaceForCommandsInfoNVX - Structure specifying parameters for the reservation of command buffer space
/// <para>   sType must be VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX </para>
/// <para>   pNext must be NULL </para>
/// <para>   objectTable must be a valid VkObjectTableNVX handle</para>
/// <para>   indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNVX handle</para>
/// <para>   Both of indirectCommandsLayout, and objectTable must have been created, allocated, or retrieved from the same VkDevice </para>
/// <para>Host access to objectTable must be externally synchronized</para>
/// </summary>
public unsafe struct VkCmdReserveSpaceForCommandsInfoNVX {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                    pNext;
    /// <summary> objectTable is the VkObjectTableNVX to be used for the
    /// generation process.
    /// Only registered objects at the time
    /// vkCmdReserveSpaceForCommandsNVX is called, will be taken into
    /// account for the reservation.</summary>
    public VkObjectTableNVX               objectTable;
    /// <summary> indirectCommandsLayout is the VkIndirectCommandsLayoutNVX
    /// that must also be used at generation time.</summary>
    public VkIndirectCommandsLayoutNVX    indirectCommandsLayout;
    /// <summary> maxSequencesCount is the maximum number of sequences for which
    /// command buffer space will be reserved.</summary>
    public UInt32                       maxSequencesCount;
}
// Struct: 42
/// <summary>VkCoarseSampleLocationNV - Structure specifying parameters controlling shading rate image usage
/// <para>   pixelX must be less than the width (in pixels) of the fragment.</para>
/// <para>   pixelY must be less than the height (in pixels) of the fragment.</para>
/// <para>   sample must be less than the number of coverage samples in eachpixel belonging to the fragment.</para>
/// </summary>
public unsafe struct VkCoarseSampleLocationNV {
    /// <summary> pixelX is added to the x coordinate of the upper-leftmost pixel of
    /// each fragment to identify the pixel containing the coverage sample.</summary>
    public UInt32    pixelX;
    /// <summary> pixelY is added to the y coordinate of the upper-leftmost pixel of
    /// each fragment to identify the pixel containing the coverage sample.</summary>
    public UInt32    pixelY;
    /// <summary> sample is the number of the coverage sample in the pixel
    /// identified by pixelX and pixelY.</summary>
    public UInt32    sample;
}
// Struct: 43
/// <summary>VkCoarseSampleOrderCustomNV - Structure specifying parameters controlling shading rate image usage
/// <para>When using a custom sample ordering, element i in pSampleLocationsspecifies a specific pixel and per-pixel coverage sample number thatcorresponds to the coverage sample numbered i in the multi-pixel fragment.</para>
/// <para>   shadingRate must be a shading rate that generates fragments withmore than one pixel.</para>
/// <para>   sampleCount must correspond to a sample count enumerated inVkSampleCountFlags whose corresponding bit is set inVkPhysicalDeviceLimits::framebufferNoAttachmentsSampleCounts.</para>
/// <para>   sampleLocationCount must be equal to the product ofsampleCount, the fragment width for shadingRate, and thefragment height for shadingRate.</para>
/// <para>   sampleLocationCount must be less than or equal to the value ofVkPhysicalDeviceShadingRateImagePropertiesNV::shadingRateMaxCoarseSamples.</para>
/// <para>  The array pSampleLocations must contain exactly one entry forevery combination of valid values for pixelX, pixelY, andsample in the structure VkCoarseSampleOrderCustomNV.</para>
/// <para>   shadingRate must be a valid VkShadingRatePaletteEntryNV value</para>
/// <para>   pSampleLocations must be a valid pointer to an array of sampleLocationCount VkCoarseSampleLocationNV structures</para>
/// <para>   sampleLocationCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkCoarseSampleOrderCustomNV {
    /// <summary> shadingRate is a shading rate palette entry that identifies the
    /// fragment width and height for the combination of fragment area and
    /// per-pixel coverage sample count to control.</summary>
    public VkShadingRatePaletteEntryNV        shadingRate;
    /// <summary> sampleCount identifies the per-pixel coverage sample count for the
    /// combination of fragment area and coverage sample count to control.</summary>
    public UInt32                           sampleCount;
    /// <summary> sampleLocationCount specifies the number of sample locations in
    /// the custom ordering.</summary>
    public UInt32                           sampleLocationCount;
    /// <summary> pSampleLocations is a pointer to an array of
    /// VkCoarseSampleOrderCustomNV structures that specifies the location
    /// of each sample in the custom ordering.</summary>
    public /* const */ VkCoarseSampleLocationNV*    pSampleLocations;
}
// Struct: 44
/// <summary>VkCommandBufferAllocateInfo - Structure specifying the allocation parameters for command buffer object
/// <para>   commandBufferCount must be greater than 0 </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   commandPool must be a valid VkCommandPool handle</para>
/// <para>   level must be a valid VkCommandBufferLevel value</para>
/// </summary>
public unsafe struct VkCommandBufferAllocateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType         sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*             pNext;
    /// <summary> commandPool is the command pool from which the command buffers are
    /// allocated.</summary>
    public VkCommandPool           commandPool;
    /// <summary> level is a VkCommandBufferLevel value specifying the command
    /// buffer level.</summary>
    public VkCommandBufferLevel    level;
    /// <summary> commandBufferCount is the number of command buffers to allocate
    /// from the pool.</summary>
    public UInt32                commandBufferCount;
}
// Struct: 45
/// <summary>VkCommandBufferBeginInfo - Structure specifying a command buffer begin operation
/// <para>  If flags containsVK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, therenderPass member of pInheritanceInfo must be a validVkRenderPass </para>
/// <para>  If flags containsVK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, thesubpass member of pInheritanceInfo must be a valid subpassindex within the renderPass member of pInheritanceInfo </para>
/// <para>  If flags containsVK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, theframebuffer member of pInheritanceInfo must be eitherVK_NULL_HANDLE, or a valid VkFramebuffer that is compatiblewith the renderPass member of pInheritanceInfo </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkDeviceGroupCommandBufferBeginInfo </para>
/// <para>   flags must be a valid combination of VkCommandBufferUsageFlagBits values</para>
/// </summary>
public unsafe struct VkCommandBufferBeginInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                              pNext;
    /// <summary> flags is a bitmask of VkCommandBufferUsageFlagBits
    /// specifying usage behavior for the command buffer.</summary>
    public VkCommandBufferUsageFlags                flags;
    /// <summary> pInheritanceInfo is a pointer to a
    /// VkCommandBufferInheritanceInfo structure, which is used if
    /// commandBuffer is a secondary command buffer.
    /// If this is a primary command buffer, then this value is ignored.</summary>
    public /* const */ VkCommandBufferInheritanceInfo*    pInheritanceInfo;
}
// Struct: 46
/// <summary>VkCommandBufferInheritanceConditionalRenderingInfoEXT - Structure specifying command buffer inheritance info
/// <para>If this structure is not present, the behavior is as ifconditionalRenderingEnable is VK_FALSE.</para>
/// <para>  If the inherited conditionalrendering feature is not enabled, conditionalRenderingEnable must be VK_FALSE </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT </para>
/// </summary>
public unsafe struct VkCommandBufferInheritanceConditionalRenderingInfoEXT {
    /// <summary> sType is the type of this structure</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure</summary>
    public /* const */ void*        pNext;
    /// <summary> conditionalRenderingEnable specifies whether the command buffer
    /// can be executed while conditional rendering is active in the primary
    /// command buffer.
    /// If this is VK_TRUE, then this command buffer can be executed
    /// whether the primary command buffer has active conditional rendering or
    /// not.
    /// If this is VK_FALSE, then the primary command buffer must not
    /// have conditional rendering active.</summary>
    public VkBool32           conditionalRenderingEnable;
}
// Struct: 47
/// <summary>VkCommandBufferInheritanceInfo - Structure specifying command buffer inheritance info
/// <para>  If the inherited queries feature is notenabled, occlusionQueryEnable must be VK_FALSE </para>
/// <para>  If the inherited queries feature isenabled, queryFlags must be a valid combination ofVkQueryControlFlagBits values</para>
/// <para>  If the pipeline statistics queriesfeature is not enabled, pipelineStatistics must be 0 </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkCommandBufferInheritanceConditionalRenderingInfoEXT </para>
/// <para>   Both of framebuffer, and renderPass that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkCommandBufferInheritanceInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                  sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                      pNext;
    /// <summary> renderPass is a VkRenderPass object defining which render
    /// passes the VkCommandBuffer will be compatible with and can be executed within.
    /// If the VkCommandBuffer will not be executed within a render pass
    /// instance, renderPass is ignored.</summary>
    public VkRenderPass                     renderPass;
    /// <summary> subpass is the index of the subpass within the render pass
    /// instance that the VkCommandBuffer will be executed within.
    /// If the VkCommandBuffer will not be executed within a render pass
    /// instance, subpass is ignored.</summary>
    public UInt32                         subpass;
    /// <summary> framebuffer optionally refers to the VkFramebuffer object
    /// that the VkCommandBuffer will be rendering to if it is executed
    /// within a render pass instance.
    /// It can be VK_NULL_HANDLE if the framebuffer is not known, or if
    /// the VkCommandBuffer will not be executed within a render pass
    /// instance.</summary>
    public VkFramebuffer                    framebuffer;
    /// <summary> occlusionQueryEnable specifies whether the command buffer can be
    /// executed while an occlusion query is active in the primary command
    /// buffer.
    /// If this is VK_TRUE, then this command buffer can be executed
    /// whether the primary command buffer has an occlusion query active or not.
    /// If this is VK_FALSE, then the primary command buffer must not
    /// have an occlusion query active.</summary>
    public VkBool32                         occlusionQueryEnable;
    /// <summary> queryFlags specifies the query flags that can be used by an
    /// active occlusion query in the primary command buffer when this secondary
    /// command buffer is executed.
    /// If this value includes the VK_QUERY_CONTROL_PRECISE_BIT bit, then
    /// the active query can return boolean results or actual sample counts.
    /// If this bit is not set, then the active query must not use the
    /// VK_QUERY_CONTROL_PRECISE_BIT bit.</summary>
    public VkQueryControlFlags              queryFlags;
    /// <summary> pipelineStatistics is a bitmask of
    /// VkQueryPipelineStatisticFlagBits specifying the set of pipeline
    /// statistics that can be counted by an active query in the primary
    /// command buffer when this secondary command buffer is executed.
    /// If this value includes a given bit, then this command buffer can be
    /// executed whether the primary command buffer has a pipeline statistics
    /// query active that includes this bit or not.
    /// If this value excludes a given bit, then the active pipeline statistics
    /// query must not be from a query pool that counts that statistic.</summary>
    public VkQueryPipelineStatisticFlags    pipelineStatistics;
}
// Struct: 48
/// <summary>VkCommandPoolCreateInfo - Structure specifying parameters of a newly created command pool
/// <para>   sType must be VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be a valid combination of VkCommandPoolCreateFlagBits values</para>
/// </summary>
public unsafe struct VkCommandPoolCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                 pNext;
    /// <summary> flags is a bitmask of VkCommandPoolCreateFlagBits indicating
    /// usage behavior for the pool and command buffers allocated from it.</summary>
    public VkCommandPoolCreateFlags    flags;
    /// <summary> queueFamilyIndex designates a queue family as described in section
    /// Queue Family Properties.
    /// All command buffers allocated from this command pool must be submitted
    /// on queues from the same queue family.</summary>
    public UInt32                    queueFamilyIndex;
}
// Struct: 49
/// <summary>VkComponentMapping - Structure specifying a color component mapping
/// <para>   r must be a valid VkComponentSwizzle value</para>
/// <para>   g must be a valid VkComponentSwizzle value</para>
/// <para>   b must be a valid VkComponentSwizzle value</para>
/// <para>   a must be a valid VkComponentSwizzle value</para>
/// </summary>
public unsafe struct VkComponentMapping {
    /// <summary> r is a VkComponentSwizzle specifying the component value
    /// placed in the R component of the output vector.</summary>
    public VkComponentSwizzle    r;
    /// <summary> g is a VkComponentSwizzle specifying the component value
    /// placed in the G component of the output vector.</summary>
    public VkComponentSwizzle    g;
    /// <summary> b is a VkComponentSwizzle specifying the component value
    /// placed in the B component of the output vector.</summary>
    public VkComponentSwizzle    b;
    /// <summary> a is a VkComponentSwizzle specifying the component value
    /// placed in the A component of the output vector.</summary>
    public VkComponentSwizzle    a;
}
// Struct: 50
/// <summary>VkComputePipelineCreateInfo - Structure specifying parameters of a newly created compute pipeline
/// <para>The parameters basePipelineHandle and basePipelineIndex aredescribed in more detail in PipelineDerivatives.</para>
/// <para> stage points to a structure of typeVkPipelineShaderStageCreateInfo.</para>
/// <para>  If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BITflag, and basePipelineIndex is -1, basePipelineHandle mustbe a valid handle to a compute VkPipeline </para>
/// <para>  If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BITflag, and basePipelineHandle is VK_NULL_HANDLE,basePipelineIndex must be a valid index into the callingcommand’s pCreateInfos parameter</para>
/// <para>  If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BITflag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE </para>
/// <para>  If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BITflag, and basePipelineHandle is not VK_NULL_HANDLE,basePipelineIndex must be -1</para>
/// <para>  The stage member of stage must beVK_SHADER_STAGE_COMPUTE_BIT </para>
/// <para>  The shader code for the entry point identified by stage and therest of the state identified by this structure must adhere to thepipeline linking rules described in the Shader Interfaceschapter</para>
/// <para>   layout must beconsistent with the layoutof the compute shader specified in stage </para>
/// <para>  The number of resources in layout accessible to the compute shaderstage must be less than or equal toVkPhysicalDeviceLimits::maxPerStageResources </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkPipelineCreationFeedbackCreateInfoEXT </para>
/// <para>   flags must be a valid combination of VkPipelineCreateFlagBits values</para>
/// <para>   stage must be a valid VkPipelineShaderStageCreateInfo structure</para>
/// <para>   layout must be a valid VkPipelineLayout handle</para>
/// <para>   Both of basePipelineHandle, and layout that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkComputePipelineCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                        pNext;
    /// <summary> flags is a bitmask of VkPipelineCreateFlagBits specifying
    /// how the pipeline will be generated.</summary>
    public VkPipelineCreateFlags              flags;
    /// <summary> stage is a VkPipelineShaderStageCreateInfo describing the
    /// compute shader.</summary>
    public VkPipelineShaderStageCreateInfo    stage;
    /// <summary> layout is the description of binding locations used by both the
    /// pipeline and descriptor sets used with the pipeline.</summary>
    public VkPipelineLayout                   layout;
    /// <summary> basePipelineHandle is a pipeline to derive from</summary>
    public VkPipeline                         basePipelineHandle;
    /// <summary> basePipelineIndex is an index into the pCreateInfos
    /// parameter to use as a pipeline to derive from</summary>
    public Int32                            basePipelineIndex;
}
// Struct: 51
/// <summary>VkConditionalRenderingBeginInfoEXT - Structure specifying conditional rendering begin info
/// <para>If the 32-bit value at offset in buffer memory is zero, then therendering commands are discarded, otherwise they are executed as normal.If the value of the predicate in buffer memory changes while conditionalrendering is active, the rendering commands may be discarded in animplementation-dependent way.Some implementations may latch the value of the predicate upon beginningconditional rendering while others may read it before every renderingcommand.</para>
/// <para>  If buffer is non-sparse then it must be bound completely andcontiguously to a single VkDeviceMemory object</para>
/// <para>   buffer must have been created with theVK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT bit set</para>
/// <para>   offset must be less than the size of buffer by at least 32bits.</para>
/// <para>   offset must be a multiple of 4</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   buffer must be a valid VkBuffer handle</para>
/// <para>   flags must be a valid combination of VkConditionalRenderingFlagBitsEXT values</para>
/// </summary>
public unsafe struct VkConditionalRenderingBeginInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                   sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                       pNext;
    /// <summary> buffer is a buffer containing the predicate for conditional
    /// rendering.</summary>
    public VkBuffer                          buffer;
    /// <summary> offset is the byte offset into buffer where the predicate is
    /// located.</summary>
    public VkDeviceSize                      offset;
    /// <summary> flags is a bitmask of VkConditionalRenderingFlagsEXT
    /// specifying the behavior of conditional rendering.</summary>
    public VkConditionalRenderingFlagsEXT    flags;
}
// Struct: 52
/// <summary>VkConformanceVersionKHR - Structure containing the conformance test suite version the implementation is compliant with
/// </summary>
public unsafe struct VkConformanceVersionKHR {
    /// <summary> major is the major version number of the conformance test suite.</summary>
    public byte    major;
    /// <summary> minor is the minor version number of the conformance test suite.</summary>
    public byte    minor;
    /// <summary> subminor is the subminor version number of the conformance test
    /// suite.</summary>
    public byte    subminor;
    /// <summary> patch is the patch version number of the conformance test suite.</summary>
    public byte    patch;
}
// Struct: 53
/// <summary>VkCooperativeMatrixPropertiesNV - Structure specifying cooperative matrix properties
/// <para>If some types are preferred over other types (e.g. for performance), theyshould appear earlier in the list enumerated byvkGetPhysicalDeviceCooperativeMatrixPropertiesNV.</para>
/// <para>At least one entry in the list must have power of two values for all ofMSize, KSize, and NSize.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV </para>
/// <para>   pNext must be NULL </para>
/// <para>   AType must be a valid VkComponentTypeNV value</para>
/// <para>   BType must be a valid VkComponentTypeNV value</para>
/// <para>   CType must be a valid VkComponentTypeNV value</para>
/// <para>   DType must be a valid VkComponentTypeNV value</para>
/// <para>   scope must be a valid VkScopeNV value</para>
/// </summary>
public unsafe struct VkCooperativeMatrixPropertiesNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                pNext;
    /// <summary> MSize is the number of rows in matrices A, C, and D.</summary>
    public UInt32             MSize;
    /// <summary> NSize is the number of columns in matrices B, C, D.</summary>
    public UInt32             NSize;
    /// <summary> KSize is the number of columns in matrix A and rows in matrix B.</summary>
    public UInt32             KSize;
    /// <summary> AType is the component type of matrix A, of type
    /// VkComponentTypeNV.</summary>
    public VkComponentTypeNV    AType;
    /// <summary> BType is the component type of matrix B, of type
    /// VkComponentTypeNV.</summary>
    public VkComponentTypeNV    BType;
    /// <summary> CType is the component type of matrix C, of type
    /// VkComponentTypeNV.</summary>
    public VkComponentTypeNV    CType;
    /// <summary> DType is the component type of matrix D, of type
    /// VkComponentTypeNV.</summary>
    public VkComponentTypeNV    DType;
    /// <summary> scope is the scope of all the matrix types, of type
    /// VkScopeNV.</summary>
    public VkScopeNV            scope;
}
// Struct: 54
/// <summary>VkCopyDescriptorSet - Structure specifying a copy descriptor set operation
/// <para>   srcBinding must be a valid binding within srcSet </para>
/// <para>  The sum of srcArrayElement and descriptorCount must be lessthan or equal to the number of array elements in the descriptor setbinding specified by srcBinding, and all applicable consecutivebindings, as described by html/vkspec.html#descriptorsets-updates-consecutive </para>
/// <para>   dstBinding must be a valid binding within dstSet </para>
/// <para>  The sum of dstArrayElement and descriptorCount must be lessthan or equal to the number of array elements in the descriptor setbinding specified by dstBinding, and all applicable consecutivebindings, as described by html/vkspec.html#descriptorsets-updates-consecutive </para>
/// <para>  The type of dstBinding within dstSet must be equal to thetype of srcBinding within srcSet </para>
/// <para>  If srcSet is equal to dstSet, then the source anddestination ranges of descriptors must not overlap, where the rangesmay include array elements from consecutive bindings as described byhtml/vkspec.html#descriptorsets-updates-consecutive </para>
/// <para>  If the descriptor type of the descriptor set binding specified bysrcBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT,srcArrayElement must be an integer multiple of 4 </para>
/// <para>  If the descriptor type of the descriptor set binding specified bydstBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT,dstArrayElement must be an integer multiple of 4 </para>
/// <para>  If the descriptor type of the descriptor set binding specified by eithersrcBinding or dstBinding isVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, descriptorCount must be an integer multiple of 4 </para>
/// <para>  If srcSet’s layout was created with theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXTflag set, then dstSet’s layout must also have been created withthe VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXTflag set</para>
/// <para>  If srcSet’s layout was created without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXTflag set, then dstSet’s layout must also have been createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXTflag set</para>
/// <para>  If the descriptor pool from which srcSet was allocated was createdwith the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flagset, then the descriptor pool from which dstSet was allocatedmust also have been created with theVK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set</para>
/// <para>  If the descriptor pool from which srcSet was allocated was createdwithout the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXTflag set, then the descriptor pool from which dstSet was allocatedmust also have been created without theVK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET </para>
/// <para>   pNext must be NULL </para>
/// <para>   srcSet must be a valid VkDescriptorSet handle</para>
/// <para>   dstSet must be a valid VkDescriptorSet handle</para>
/// <para>   Both of dstSet, and srcSet must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkCopyDescriptorSet {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> srcSet, srcBinding, and srcArrayElement are the source
    /// set, binding, and array element, respectively.
    /// If the descriptor binding identified by srcSet and
    /// srcBinding has a descriptor type of
    /// VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then
    /// srcArrayElement specifies the starting byte offset within the
    /// binding to copy from.</summary>
    public VkDescriptorSet    srcSet;
    public UInt32           srcBinding;
    public UInt32           srcArrayElement;
    /// <summary> dstSet, dstBinding, and dstArrayElement are the
    /// destination set, binding, and array element, respectively.
    /// If the descriptor binding identified by dstSet and
    /// dstBinding has a descriptor type of
    /// VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then
    /// dstArrayElement specifies the starting byte offset within the
    /// binding to copy to.</summary>
    public VkDescriptorSet    dstSet;
    public UInt32           dstBinding;
    public UInt32           dstArrayElement;
    /// <summary> descriptorCount is the number of descriptors to copy from the
    /// source to destination.
    /// If descriptorCount is greater than the number of remaining array
    /// elements in the source or destination binding, those affect consecutive
    /// bindings in a manner similar to VkWriteDescriptorSet above.
    /// If the descriptor binding identified by srcSet and
    /// srcBinding has a descriptor type of
    /// VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then
    /// descriptorCount specifies the number of bytes to copy and the
    /// remaining array elements in the source or destination binding refer to
    /// the remaining number of bytes in those.</summary>
    public UInt32           descriptorCount;
}
// Struct: 55
/// <summary>VkD3D12FenceSubmitInfoKHR - Structure specifying values for Direct3D 12 fence-backed semaphores
/// <para>If the semaphore in VkSubmitInfo::pWaitSemaphores orVkSubmitInfo::pSignalSemaphores corresponding to an entry inpWaitSemaphoreValues or pSignalSemaphoreValues respectively doesnot currently have a payloadreferring to a Direct3D 12 fence, the implementation must ignore the valuein the pWaitSemaphoreValues or pSignalSemaphoreValues entry.</para>
/// <para>   waitSemaphoreValuesCount must be the same value asVkSubmitInfo::waitSemaphoreCount, where VkSubmitInfois in the pNext chain of this VkD3D12FenceSubmitInfoKHRstructure.</para>
/// <para>   signalSemaphoreValuesCount must be the same value asVkSubmitInfo::signalSemaphoreCount, where VkSubmitInfois in the pNext chain of this VkD3D12FenceSubmitInfoKHRstructure.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR </para>
/// <para>   If waitSemaphoreValuesCount is not 0, and pWaitSemaphoreValues is not NULL, pWaitSemaphoreValues must be a valid pointer to an array of waitSemaphoreValuesCount uint64_t values</para>
/// <para>   If signalSemaphoreValuesCount is not 0, and pSignalSemaphoreValues is not NULL, pSignalSemaphoreValues must be a valid pointer to an array of signalSemaphoreValuesCount uint64_t values</para>
/// </summary>
public unsafe struct VkD3D12FenceSubmitInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> waitSemaphoreValuesCount is the number of semaphore wait values
    /// specified in pWaitSemaphoreValues.</summary>
    public UInt32           waitSemaphoreValuesCount;
    /// <summary> pWaitSemaphoreValues is an array of length
    /// waitSemaphoreValuesCount containing values for the corresponding
    /// semaphores in VkSubmitInfo::pWaitSemaphores to wait for.</summary>
    public /* const */ UInt64*    pWaitSemaphoreValues;
    /// <summary> signalSemaphoreValuesCount is the number of semaphore signal
    /// values specified in pSignalSemaphoreValues.</summary>
    public UInt32           signalSemaphoreValuesCount;
    /// <summary> pSignalSemaphoreValues is an array of length
    /// signalSemaphoreValuesCount containing values for the corresponding
    /// semaphores in VkSubmitInfo::pSignalSemaphores to set when
    /// signaled.</summary>
    public /* const */ UInt64*    pSignalSemaphoreValues;
}
// Struct: 56
/// <summary>VkDebugMarkerMarkerInfoEXT - Specify parameters of a command buffer marker region
/// <para>   sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   pMarkerName must be a null-terminated UTF-8 string</para>
/// </summary>
public unsafe struct VkDebugMarkerMarkerInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> pMarkerName is a pointer to a null-terminated UTF-8 string that
    /// contains the name of the marker.</summary>
    public IntPtr        pMarkerName;
    public fixed float              color[4];
}
// Struct: 57
/// <summary>VkDebugMarkerObjectNameInfoEXT - Specify parameters of a name to give to an object
/// <para>Applications may change the name associated with an object simply bycalling vkDebugMarkerSetObjectNameEXT again with a new string.To remove a previously set name, pObjectName should be set to anempty string.</para>
/// <para>   objectType must not beVK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT </para>
/// <para>   object must not be VK_NULL_HANDLE </para>
/// <para>   object must be a Vulkan object of the type associated withobjectType as defined in html/vkspec.html#debug-report-object-types.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   objectType must be a valid VkDebugReportObjectTypeEXT value</para>
/// <para>   pObjectName must be a null-terminated UTF-8 string</para>
/// </summary>
public unsafe struct VkDebugMarkerObjectNameInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                   pNext;
    /// <summary> objectType is a VkDebugReportObjectTypeEXT specifying the
    /// type of the object to be named.</summary>
    public VkDebugReportObjectTypeEXT    objectType;
    /// <summary> object is the object to be named.</summary>
    public UInt64                      _object;
    /// <summary> pObjectName is a null-terminated UTF-8 string specifying the name
    /// to apply to object.</summary>
    public IntPtr                   pObjectName;
}
// Struct: 58
/// <summary>VkDebugMarkerObjectTagInfoEXT - Specify parameters of a tag to attach to an object
/// <para>The tagName parameter gives a name or identifier to the type of databeing tagged.This can be used by debugging layers to easily filter for only data that canbe used by that implementation.</para>
/// <para>   objectType must not beVK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT </para>
/// <para>   object must not be VK_NULL_HANDLE </para>
/// <para>   object must be a Vulkan object of the type associated withobjectType as defined in html/vkspec.html#debug-report-object-types.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   objectType must be a valid VkDebugReportObjectTypeEXT value</para>
/// <para>   pTag must be a valid pointer to an array of tagSize bytes</para>
/// <para>   tagSize must be greater than 0 </para>
/// </summary>
public unsafe struct VkDebugMarkerObjectTagInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                   pNext;
    /// <summary> objectType is a VkDebugReportObjectTypeEXT specifying the
    /// type of the object to be named.</summary>
    public VkDebugReportObjectTypeEXT    objectType;
    /// <summary> object is the object to be tagged.</summary>
    public UInt64                      _object;
    /// <summary> tagName is a numerical identifier of the tag.</summary>
    public UInt64                      tagName;
    /// <summary> tagSize is the number of bytes of data to attach to the object.</summary>
    public size_t                        tagSize;
    /// <summary> pTag is an array of tagSize bytes containing the data to be
    /// associated with the object.</summary>
    public /* const */ void*                   pTag;
}
// Struct: 59
/// <summary>VkDebugReportCallbackCreateInfoEXT - Structure specifying parameters of a newly created debug report callback
/// <para>For each VkDebugReportCallbackEXT that is created theVkDebugReportCallbackCreateInfoEXT::flags determine when thatVkDebugReportCallbackCreateInfoEXT::pfnCallback is called.When an event happens, the implementation will do a bitwise AND of theevent’s VkDebugReportFlagBitsEXT flags to eachVkDebugReportCallbackEXT object’s flags.For each non-zero result the corresponding callback will be called.The callback will come directly from the component that detected the event,unless some other layer intercepts the calls for its own purposes (filterthem in a different way, log to a system error log, etc.).</para>
/// <para>An application may receive multiple callbacks if multipleVkDebugReportCallbackEXT objects were created.A callback will always be executed in the same thread as the originatingVulkan call.</para>
/// <para>A callback may be called from multiple threads simultaneously (if theapplication is making Vulkan calls from multiple threads).</para>
/// <para>   pfnCallback must be a valid PFN_vkDebugReportCallbackEXT </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT </para>
/// <para>   flags must be a valid combination of VkDebugReportFlagBitsEXT values</para>
/// </summary>
public unsafe struct VkDebugReportCallbackCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                 sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                     pNext;
    /// <summary> flags is a bitmask of VkDebugReportFlagBitsEXT specifying
    /// which event(s) will cause this callback to be called.</summary>
    public VkDebugReportFlagsEXT           flags;
    /// <summary> pfnCallback is the application callback function to call.</summary>
    public PFN_vkDebugReportCallbackEXT    pfnCallback;
    /// <summary> pUserData is user data to be passed to the callback.</summary>
    public void*                           pUserData;
}
// Struct: 60
/// <summary>VkDebugUtilsLabelEXT - Specify parameters of a label region
/// <para>   sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   pLabelName must be a null-terminated UTF-8 string</para>
/// </summary>
public unsafe struct VkDebugUtilsLabelEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> pLabelName is a pointer to a null-terminated UTF-8 string that
    /// contains the name of the label.</summary>
    public IntPtr        pLabelName;
    public fixed float              color[4];
}
// Struct: 61
/// <summary>VkDebugUtilsMessengerCallbackDataEXT - Structure specifying parameters returned to the callback
/// <para>This structure should only be considered valid during the lifetime of thetriggered callback.</para>
/// <para>Since adding queue and command buffer labels behaves like pushing andpopping onto a stack, the order of both pQueueLabels andpCmdBufLabels is based on the order the labels were defined.The result is that the first label in either pQueueLabels orpCmdBufLabels will be the first defined (and therefore the oldest)while the last label in each list will be the most recent.</para>
/// <para> pQueueLabels will only be non-NULL if one of the objects inpObjects can be related directly to a defined VkQueue which hashad one or more labels associated with it.</para>
/// <para>Likewise, pCmdBufLabels will only be non-NULL if one of the objects inpObjects can be related directly to a defined VkCommandBufferwhich has had one or more labels associated with it.Additionally, while command buffer labels allow for beginning and endingacross different command buffers, the debug messaging framework cannotguarantee that labels in pCmdBufLables will contain those definedoutside of the associated command buffer.This is partially due to the fact that the association of one command bufferwith another may not have been defined at the time the debug message istriggered.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   If pMessageIdName is not NULL, pMessageIdName must be a null-terminated UTF-8 string</para>
/// <para>   pMessage must be a null-terminated UTF-8 string</para>
/// <para>   If queueLabelCount is not 0, pQueueLabels must be a valid pointer to an array of queueLabelCount valid VkDebugUtilsLabelEXT structures</para>
/// <para>   If cmdBufLabelCount is not 0, pCmdBufLabels must be a valid pointer to an array of cmdBufLabelCount valid VkDebugUtilsLabelEXT structures</para>
/// <para>   If objectCount is not 0, pObjects must be a valid pointer to an array of objectCount valid VkDebugUtilsObjectNameInfoEXT structures</para>
/// </summary>
public unsafe struct VkDebugUtilsMessengerCallbackDataEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                              sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                  pNext;
    /// <summary> flags is 0 and reserved for future use.</summary>
    public VkDebugUtilsMessengerCallbackDataFlagsEXT    flags;
    /// <summary> pMessageIdName is a null-terminated string that identifies the
    /// particular message ID that is associated with the provided message.
    /// If the message corresponds to a validation layer message, then this
    /// string may contain the portion of the Vulkan specification that is
    /// believed to have been violated.</summary>
    public IntPtr                                  pMessageIdName;
    /// <summary> messageIdNumber is the ID number of the triggering message.
    /// If the message corresponds to a validation layer message, then this
    /// number is related to the internal number associated with the message
    /// being triggered.</summary>
    public Int32                                      messageIdNumber;
    /// <summary> pMessage is a null-terminated string detailing the trigger
    /// conditions.</summary>
    public IntPtr                                  pMessage;
    /// <summary> queueLabelCount is a count of items contained in the
    /// pQueueLabels array.</summary>
    public UInt32                                     queueLabelCount;
    /// <summary> pQueueLabels is NULL or a pointer to an array of
    /// VkDebugUtilsLabelEXT active in the current VkQueue at the
    /// time the callback was triggered.
    /// Refer to Queue Labels for more information.</summary>
    public /* const */ VkDebugUtilsLabelEXT*                  pQueueLabels;
    /// <summary> cmdBufLabelCount is a count of items contained in the
    /// pCmdBufLabels array.</summary>
    public UInt32                                     cmdBufLabelCount;
    /// <summary> pCmdBufLabels is NULL or a pointer to an array of
    /// VkDebugUtilsLabelEXT active in the current VkCommandBuffer
    /// at the time the callback was triggered.
    /// Refer to Command Buffer Labels for
    /// more information.</summary>
    public /* const */ VkDebugUtilsLabelEXT*                  pCmdBufLabels;
    /// <summary> objectCount is a count of items contained in the pObjects
    /// array.</summary>
    public UInt32                                     objectCount;
    /// <summary> pObjects is a pointer to an array of
    /// VkDebugUtilsObjectNameInfoEXT objects related to the detected
    /// issue.
    /// The array is roughly in order or importance, but the 0th element is
    /// always guaranteed to be the most important object for this message.</summary>
    public /* const */ VkDebugUtilsObjectNameInfoEXT*         pObjects;
}
// Struct: 62
/// <summary>VkDebugUtilsMessengerCreateInfoEXT - Structure specifying parameters of a newly created debug messenger
/// <para>For each VkDebugUtilsMessengerEXT that is created theVkDebugUtilsMessengerCreateInfoEXT::messageSeverity andVkDebugUtilsMessengerCreateInfoEXT::messageType determine whenthat VkDebugUtilsMessengerCreateInfoEXT::pfnUserCallback iscalled.The process to determine if the user’s pfnUserCallback is triggeredwhen an event occurs is as follows:</para>
/// <para>The implementation will perform a bitwise AND of the event’sVkDebugUtilsMessageSeverityFlagBitsEXT with themessageSeverity provided during creation of theVkDebugUtilsMessengerEXT object.</para>
/// <para>If the value is 0, the message is skipped.</para>
/// <para>The implementation will perform bitwise AND of the event’sVkDebugUtilsMessageTypeFlagBitsEXT with the messageTypeprovided during the creation of the VkDebugUtilsMessengerEXTobject.</para>
/// <para>If the value is 0, the message is skipped.</para>
/// <para>The callback will trigger a debug message for the current event</para>
/// <para>The callback will come directly from the component that detected the event,unless some other layer intercepts the calls for its own purposes (filterthem in a different way, log to a system error log, etc.).</para>
/// <para>An application can receive multiple callbacks if multipleVkDebugUtilsMessengerEXT objects are created.A callback will always be executed in the same thread as the originatingVulkan call.</para>
/// <para>A callback can be called from multiple threads simultaneously (if theapplication is making Vulkan calls from multiple threads).</para>
/// <para>   pfnUserCallback must be a validPFN_vkDebugUtilsMessengerCallbackEXT </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT </para>
/// <para>   flags must be 0 </para>
/// <para>   messageSeverity must be a valid combination of VkDebugUtilsMessageSeverityFlagBitsEXT values</para>
/// <para>   messageSeverity must not be 0 </para>
/// <para>   messageType must be a valid combination of VkDebugUtilsMessageTypeFlagBitsEXT values</para>
/// <para>   messageType must not be 0 </para>
/// </summary>
public unsafe struct VkDebugUtilsMessengerCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                         sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                             pNext;
    /// <summary> flags is 0 and reserved for future use.</summary>
    public VkDebugUtilsMessengerCreateFlagsEXT     flags;
    /// <summary> messageSeverity is a bitmask of
    /// VkDebugUtilsMessageSeverityFlagBitsEXT specifying which severity
    /// of event(s) will cause this callback to be called.</summary>
    public VkDebugUtilsMessageSeverityFlagsEXT     messageSeverity;
    /// <summary> messageType is a bitmask of
    /// VkDebugUtilsMessageTypeFlagBitsEXT specifying which type of
    /// event(s) will cause this callback to be called.</summary>
    public VkDebugUtilsMessageTypeFlagsEXT         messageType;
    /// <summary> pfnUserCallback is the application callback function to call.</summary>
    public PFN_vkDebugUtilsMessengerCallbackEXT    pfnUserCallback;
    /// <summary> pUserData is user data to be passed to the callback.</summary>
    public void*                                   pUserData;
}
// Struct: 63
/// <summary>VkDebugUtilsObjectNameInfoEXT - Specify parameters of a name to give to an object
/// <para>Applications may change the name associated with an object simply bycalling vkSetDebugUtilsObjectNameEXT again with a new string.If pObjectName is an empty string, then any previously set name isremoved.</para>
/// <para>  If objectType is VK_OBJECT_TYPE_UNKNOWN, objectHandle must not be VK_NULL_HANDLE </para>
/// <para>  If objectType is not VK_OBJECT_TYPE_UNKNOWN,objectHandle must be VK_NULL_HANDLE or a valid Vulkanhandle of the type associated with objectType as defined in theVkObjectType and Vulkan Handle Relationshiptable</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   objectType must be a valid VkObjectType value</para>
/// <para>   If pObjectName is not NULL, pObjectName must be a null-terminated UTF-8 string</para>
/// </summary>
public unsafe struct VkDebugUtilsObjectNameInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> objectType is a VkObjectType specifying the type of the
    /// object to be named.</summary>
    public VkObjectType       objectType;
    /// <summary> objectHandle is the object to be named.</summary>
    public UInt64           objectHandle;
    /// <summary> pObjectName is a null-terminated UTF-8 string specifying the name
    /// to apply to objectHandle.</summary>
    public IntPtr        pObjectName;
}
// Struct: 64
/// <summary>VkDebugUtilsObjectTagInfoEXT - Specify parameters of a tag to attach to an object
/// <para>The tagName parameter gives a name or identifier to the type of databeing tagged.This can be used by debugging layers to easily filter for only data that canbe used by that implementation.</para>
/// <para>   objectType must not be VK_OBJECT_TYPE_UNKNOWN </para>
/// <para>   objectHandle must be a valid Vulkan handle of the type associatedwith objectType as defined in the VkObjectType and Vulkan Handle Relationship table</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   objectType must be a valid VkObjectType value</para>
/// <para>   pTag must be a valid pointer to an array of tagSize bytes</para>
/// <para>   tagSize must be greater than 0 </para>
/// </summary>
public unsafe struct VkDebugUtilsObjectTagInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> objectType is a VkObjectType specifying the type of the
    /// object to be named.</summary>
    public VkObjectType       objectType;
    /// <summary> objectHandle is the object to be tagged.</summary>
    public UInt64           objectHandle;
    /// <summary> tagName is a numerical identifier of the tag.</summary>
    public UInt64           tagName;
    /// <summary> tagSize is the number of bytes of data to attach to the object.</summary>
    public size_t             tagSize;
    /// <summary> pTag is an array of tagSize bytes containing the data to be
    /// associated with the object.</summary>
    public /* const */ void*        pTag;
}
// Struct: 65
/// <summary>VkDedicatedAllocationBufferCreateInfoNV - Specify that a buffer is bound to a dedicated memory resource
/// <para>   sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV </para>
/// </summary>
public unsafe struct VkDedicatedAllocationBufferCreateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> dedicatedAllocation specifies whether the buffer will have a
    /// dedicated allocation bound to it.</summary>
    public VkBool32           dedicatedAllocation;
}
// Struct: 66
/// <summary>VkDedicatedAllocationImageCreateInfoNV - Specify that an image is bound to a dedicated memory resource
/// <para>Using a dedicated allocation for color and depth/stencil attachments orother large images may improve performance on some devices.</para>
/// <para>  If dedicatedAllocation is VK_TRUE,VkImageCreateInfo::flags must not includeVK_IMAGE_CREATE_SPARSE_BINDING_BIT,VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, orVK_IMAGE_CREATE_SPARSE_ALIASED_BIT </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV </para>
/// </summary>
public unsafe struct VkDedicatedAllocationImageCreateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> dedicatedAllocation specifies whether the image will have a
    /// dedicated allocation bound to it.</summary>
    public VkBool32           dedicatedAllocation;
}
// Struct: 67
/// <summary>VkDedicatedAllocationMemoryAllocateInfoNV - Specify a dedicated memory allocation resource
/// <para>  At least one of image and buffer must beVK_NULL_HANDLE </para>
/// <para>  If image is not VK_NULL_HANDLE, the image must have beencreated withVkDedicatedAllocationImageCreateInfoNV::dedicatedAllocationequal to VK_TRUE </para>
/// <para>  If buffer is not VK_NULL_HANDLE, the buffer must have beencreated withVkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocationequal to VK_TRUE </para>
/// <para>  If image is not VK_NULL_HANDLE,VkMemoryAllocateInfo::allocationSize must equal theVkMemoryRequirements::size of the image</para>
/// <para>  If buffer is not VK_NULL_HANDLE,VkMemoryAllocateInfo::allocationSize must equal theVkMemoryRequirements::size of the buffer</para>
/// <para>  If image is not VK_NULL_HANDLE andVkMemoryAllocateInfo defines a memory import operation, the memorybeing imported must also be a dedicated image allocation andimage must be identical to the image associated with the importedmemory.</para>
/// <para>  If buffer is not VK_NULL_HANDLE andVkMemoryAllocateInfo defines a memory import operation, the memorybeing imported must also be a dedicated buffer allocation andbuffer must be identical to the buffer associated with theimported memory.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV </para>
/// <para>   If image is not VK_NULL_HANDLE, image must be a valid VkImage handle</para>
/// <para>   If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle</para>
/// <para>   Both of buffer, and image that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkDedicatedAllocationMemoryAllocateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> image is VK_NULL_HANDLE or a handle of an image which this
    /// memory will be bound to.</summary>
    public VkImage            image;
    /// <summary> buffer is VK_NULL_HANDLE or a handle of a buffer which this
    /// memory will be bound to.</summary>
    public VkBuffer           buffer;
}
// Struct: 68
/// <summary>VkDescriptorBufferInfo - Structure specifying descriptor buffer info
/// <para>When setting range to VK_WHOLE_SIZE, the effective range mustnot be larger than the maximum range for the descriptor type( maxUniformBufferRange  or maxStorageBufferRange ).This means that VK_WHOLE_SIZE is not typically useful in the commoncase where uniform buffer descriptors are suballocated from a buffer that ismuch larger than maxUniformBufferRange.</para>
/// <para>For VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC andVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC descriptor types,offset is the base offset from which the dynamic offset is applied andrange is the static size used for all dynamic offsets.</para>
/// <para>   offset must be less than the size of buffer </para>
/// <para>  If range is not equal to VK_WHOLE_SIZE, range must begreater than 0 </para>
/// <para>  If range is not equal to VK_WHOLE_SIZE, range must beless than or equal to the size of buffer minus offset </para>
/// <para>   buffer must be a valid VkBuffer handle</para>
/// </summary>
public unsafe struct VkDescriptorBufferInfo {
    /// <summary> buffer is the buffer resource.</summary>
    public VkBuffer        buffer;
    /// <summary> offset is the offset in bytes from the start of buffer.
    /// Access to buffer memory via this descriptor uses addressing that is
    /// relative to this starting offset.</summary>
    public VkDeviceSize    offset;
    /// <summary> range is the size in bytes that is used for this descriptor
    /// update, or VK_WHOLE_SIZE to use the range from offset to the
    /// end of the buffer.</summary>
    public VkDeviceSize    range;
}
// Struct: 69
/// <summary>VkDescriptorImageInfo - Structure specifying descriptor image info
/// <para>Members of VkDescriptorImageInfo that are not used in an update (asdescribed above) are ignored.</para>
/// <para>   imageView must not be 2D or 2D array image view created from a 3Dimage</para>
/// <para>  If imageView is created from a depth/stencil image, theaspectMask used to create the imageView must include eitherVK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT butnot both.</para>
/// <para>   imageLayout must match the actual VkImageLayout of eachsubresource accessible from imageView at the time this descriptoris accessed as defined by the image layout matching rules </para>
/// <para>  If sampler is used and the VkFormat of the image is amulti-planar format, theimage must have been created withVK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, and the aspectMask ofthe imageView must be VK_IMAGE_ASPECT_PLANE_0_BIT,VK_IMAGE_ASPECT_PLANE_1_BIT or (for three-plane formats only)VK_IMAGE_ASPECT_PLANE_2_BIT </para>
/// <para>   Both of imageView, and sampler that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkDescriptorImageInfo {
    /// <summary> sampler is a sampler handle, and is used in descriptor updates for
    /// types VK_DESCRIPTOR_TYPE_SAMPLER and
    /// VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER if the binding being
    /// updated does not use immutable samplers.</summary>
    public VkSampler        sampler;
    /// <summary> imageView is an image view handle, and is used in descriptor
    /// updates for types VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    /// VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    /// VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and
    /// VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.</summary>
    public VkImageView      imageView;
    /// <summary> imageLayout is the layout that the image subresources accessible
    /// from imageView will be in at the time this descriptor is accessed.
    /// imageLayout is used in descriptor updates for types
    /// VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    /// VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    /// VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and
    /// VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.</summary>
    public VkImageLayout    imageLayout;
}
// Struct: 70
/// <summary>VkDescriptorPoolCreateInfo - Structure specifying parameters of a newly created descriptor pool
/// <para>If multiple VkDescriptorPoolSize structures appear in thepPoolSizes array then the pool will be created with enough storage forthe total number of descriptors of each type.</para>
/// <para>Fragmentation of a descriptor pool is possible and may lead to descriptorset allocation failures.A failure due to fragmentation is defined as failing a descriptor setallocation despite the sum of all outstanding descriptor set allocationsfrom the pool plus the requested allocation requiring no more than the totalnumber of descriptors requested at pool creation.Implementations provide certain guarantees of when fragmentation must notcause allocation failure, as described below.</para>
/// <para>If a descriptor pool has not had any descriptor sets freed since it wascreated or most recently reset then fragmentation must not cause anallocation failure (note that this is always the case for a pool createdwithout the VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT bitset).Additionally, if all sets allocated from the pool since it was created ormost recently reset use the same number of descriptors (of each type) andthe requested allocation also uses that same number of descriptors (of eachtype), then fragmentation must not cause an allocation failure.</para>
/// <para>If an allocation failure occurs due to fragmentation, an application cancreate an additional descriptor pool to perform further descriptor setallocations.</para>
/// <para>If flags has theVK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT bit set,descriptor pool creation may fail with the errorVK_ERROR_FRAGMENTATION_EXT if the total number of descriptors acrossall pools (including this one) created with this bit set exceedsmaxUpdateAfterBindDescriptorsInAllPools, or if fragmentation of theunderlying hardware resources occurs.</para>
/// <para>   maxSets must be greater than 0 </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkDescriptorPoolInlineUniformBlockCreateInfoEXT </para>
/// <para>   flags must be a valid combination of VkDescriptorPoolCreateFlagBits values</para>
/// <para>   pPoolSizes must be a valid pointer to an array of poolSizeCount valid VkDescriptorPoolSize structures</para>
/// <para>   poolSizeCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkDescriptorPoolCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                    pNext;
    /// <summary> flags is a bitmask of VkDescriptorPoolCreateFlagBits
    /// specifying certain supported operations on the pool.</summary>
    public VkDescriptorPoolCreateFlags    flags;
    /// <summary> maxSets is the maximum number of descriptor sets that can be
    /// allocated from the pool.</summary>
    public UInt32                       maxSets;
    /// <summary> poolSizeCount is the number of elements in pPoolSizes.</summary>
    public UInt32                       poolSizeCount;
    /// <summary> pPoolSizes is a pointer to an array of VkDescriptorPoolSize
    /// structures, each containing a descriptor type and number of descriptors
    /// of that type to be allocated in the pool.</summary>
    public /* const */ VkDescriptorPoolSize*    pPoolSizes;
}
// Struct: 71
/// <summary>VkDescriptorPoolInlineUniformBlockCreateInfoEXT - Structure specifying the maximum number of inline uniform block bindings of a newly created descriptor pool
/// <para>   sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT </para>
/// </summary>
public unsafe struct VkDescriptorPoolInlineUniformBlockCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> maxInlineUniformBlockBindings is the number of inline uniform
    /// block bindings to allocate.</summary>
    public UInt32           maxInlineUniformBlockBindings;
}
// Struct: 72
/// <summary>VkDescriptorPoolSize - Structure specifying descriptor pool size
/// <para>   descriptorCount must be greater than 0 </para>
/// <para>  If type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT thendescriptorCount must be a multiple of 4 </para>
/// <para>   type must be a valid VkDescriptorType value</para>
/// </summary>
public unsafe struct VkDescriptorPoolSize {
    /// <summary> type is the type of descriptor.</summary>
    public VkDescriptorType    type;
    /// <summary> descriptorCount is the number of descriptors of that type to
    /// allocate.
    /// If type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then
    /// descriptorCount is the number of bytes to allocate for descriptors
    /// of this type.</summary>
    public UInt32            descriptorCount;
}
// Struct: 73
/// <summary>VkDescriptorSetAllocateInfo - Structure specifying the allocation parameters for descriptor sets
/// <para>  Each element of pSetLayouts must not have been created withVK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set</para>
/// <para>  If any element of pSetLayouts was created with theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset, descriptorPool must have been created with theVK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkDescriptorSetVariableDescriptorCountAllocateInfoEXT </para>
/// <para>   descriptorPool must be a valid VkDescriptorPool handle</para>
/// <para>   pSetLayouts must be a valid pointer to an array of descriptorSetCount valid VkDescriptorSetLayout handles</para>
/// <para>   descriptorSetCount must be greater than 0 </para>
/// <para>   Both of descriptorPool, and the elements of pSetLayouts must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkDescriptorSetAllocateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                 sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                     pNext;
    /// <summary> descriptorPool is the pool which the sets will be allocated from.</summary>
    public VkDescriptorPool                descriptorPool;
    /// <summary> descriptorSetCount determines the number of descriptor sets to be
    /// allocated from the pool.</summary>
    public UInt32                        descriptorSetCount;
    /// <summary> pSetLayouts is an array of descriptor set layouts, with each
    /// member specifying how the corresponding descriptor set is allocated.</summary>
    public /* const */ VkDescriptorSetLayout*    pSetLayouts;
}
// Struct: 74
/// <summary>VkDescriptorSetLayoutBinding - Structure specifying a descriptor set layout binding
/// <para> pImmutableSamplers affects initialization of samplers.If descriptorType specifies a VK_DESCRIPTOR_TYPE_SAMPLER orVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER type descriptor, thenpImmutableSamplers can be used to initialize a set of immutablesamplers.Immutable samplers are permanently bound into the set layout; laterbinding a sampler into an immutable sampler slot in a descriptor set isnot allowed.If pImmutableSamplers is not NULL, then it is considered to be apointer to an array of sampler handles that will be consumed by the setlayout and used for the corresponding binding.If pImmutableSamplers is NULL, then the sampler slots aredynamic and sampler handles must be bound into descriptor sets usingthis layout.If descriptorType is not one of these descriptor types, thenpImmutableSamplers is ignored.</para>
/// <para>The above layout definition allows the descriptor bindings to be specifiedsparsely such that not all binding numbers between 0 and the maximum bindingnumber need to be specified in the pBindings array.Bindings that are not specified have a descriptorCount andstageFlags of zero, and the value of descriptorType isundefined.However, all binding numbers between 0 and the maximum binding number in theVkDescriptorSetLayoutCreateInfo::pBindings array may consumememory in the descriptor set layout even if not all descriptor bindings areused, though it should not consume additional memory from the descriptorpool.</para>
/// <para>The maximum binding number specified should be as compact as possible toavoid wasted memory.</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER orVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, anddescriptorCount is not 0 and pImmutableSamplers is notNULL, pImmutableSamplers must be a valid pointer to an array ofdescriptorCount valid VkSampler handles</para>
/// <para>  If descriptorType isVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT thendescriptorCount must be a multiple of 4 </para>
/// <para>  If descriptorType isVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT thendescriptorCount must be less than or equal toVkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxInlineUniformBlockSize </para>
/// <para>  If descriptorCount is not 0, stageFlags must be a validcombination of VkShaderStageFlagBits values</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT anddescriptorCount is not 0, then stageFlags must be 0 orVK_SHADER_STAGE_FRAGMENT_BIT </para>
/// <para>   descriptorType must be a valid VkDescriptorType value</para>
/// </summary>
public unsafe struct VkDescriptorSetLayoutBinding {
    /// <summary> binding is the binding number of this entry and corresponds to a
    /// resource of the same binding number in the shader stages.</summary>
    public UInt32              binding;
    /// <summary> descriptorType is a VkDescriptorType specifying which type
    /// of resource descriptors are used for this binding.</summary>
    public VkDescriptorType      descriptorType;
    /// <summary> descriptorCount is the number of descriptors contained in the
    /// binding, accessed in a shader as an array
    /// , except if descriptorType is
    /// VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT in which case
    /// descriptorCount is the size in bytes of the inline uniform block
    /// .
    /// If descriptorCount is zero this binding entry is reserved and the
    /// resource must not be accessed from any stage via this binding within
    /// any pipeline using the set layout.</summary>
    public UInt32              descriptorCount;
    /// <summary> stageFlags member is a bitmask of VkShaderStageFlagBits
    /// specifying which pipeline shader stages can access a resource for this
    /// binding.
    /// VK_SHADER_STAGE_ALL is a shorthand specifying that all defined
    /// shader stages, including any additional stages defined by extensions,
    /// can access the resource.</summary>
    public VkShaderStageFlags    stageFlags;
    public /* const */ VkSampler*      pImmutableSamplers;
}
// Struct: 75
/// <summary>VkDescriptorSetLayoutBindingFlagsCreateInfoEXT - Structure specifying creation flags for descriptor set layout bindings
/// <para>If bindingCount is zero or if this structure is not in the pNextchain, the VkDescriptorBindingFlagsEXT for each descriptor set layoutbinding is considered to be zero.Otherwise, the descriptor set layout binding atVkDescriptorSetLayoutCreateInfo::pBindings[i] uses the flags inpBindingFlags[i].</para>
/// <para>  If bindingCount is not zero, bindingCount must equalVkDescriptorSetLayoutCreateInfo::bindingCount </para>
/// <para>  If VkDescriptorSetLayoutCreateInfo::flags includesVK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then allelements of pBindingFlags must not includeVK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT,VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT, orVK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT </para>
/// <para>  If an element of pBindingFlags includesVK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT, then allother elements of VkDescriptorSetLayoutCreateInfo::pBindings must have a smaller value of binding </para>
/// <para>  IfVkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingUniformBufferUpdateAfterBindis not enabled, all bindings with descriptor typeVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER must not useVK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT </para>
/// <para>  IfVkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingSampledImageUpdateAfterBindis not enabled, all bindings with descriptor typeVK_DESCRIPTOR_TYPE_SAMPLER,VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, orVK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must not useVK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT </para>
/// <para>  IfVkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingStorageImageUpdateAfterBindis not enabled, all bindings with descriptor typeVK_DESCRIPTOR_TYPE_STORAGE_IMAGE must not useVK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT </para>
/// <para>  IfVkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingStorageBufferUpdateAfterBindis not enabled, all bindings with descriptor typeVK_DESCRIPTOR_TYPE_STORAGE_BUFFER must not useVK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT </para>
/// <para>  IfVkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingUniformTexelBufferUpdateAfterBindis not enabled, all bindings with descriptor typeVK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must not useVK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT </para>
/// <para>  IfVkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingStorageTexelBufferUpdateAfterBindis not enabled, all bindings with descriptor typeVK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must not useVK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT </para>
/// <para>  IfVkPhysicalDeviceInlineUniformBlockFeaturesEXT::descriptorBindingInlineUniformBlockUpdateAfterBindis not enabled, all bindings with descriptor typeVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT must not useVK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT </para>
/// <para>  All bindings with descriptor typeVK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, orVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must not useVK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT </para>
/// <para>  IfVkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingUpdateUnusedWhilePendingis not enabled, all elements of pBindingFlags must not includeVK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT </para>
/// <para>  IfVkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingPartiallyBoundis not enabled, all elements of pBindingFlags must not includeVK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT </para>
/// <para>  IfVkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingVariableDescriptorCountis not enabled, all elements of pBindingFlags must not includeVK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT </para>
/// <para>  If an element of pBindingFlags includesVK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT, thatelement’s descriptorType must not beVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC orVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT </para>
/// <para>   If bindingCount is not 0, and pBindingFlags is not NULL, pBindingFlags must be a valid pointer to an array of bindingCount valid combinations of VkDescriptorBindingFlagBitsEXT values</para>
/// </summary>
public unsafe struct VkDescriptorSetLayoutBindingFlagsCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                           pNext;
    /// <summary> bindingCount is zero or the number of elements in
    /// pBindingFlags.</summary>
    public UInt32                              bindingCount;
    /// <summary> pBindingFlags is a pointer to an array of
    /// VkDescriptorBindingFlagsEXT bitfields, one for each descriptor set
    /// layout binding.</summary>
    public /* const */ VkDescriptorBindingFlagsEXT*    pBindingFlags;
}
// Struct: 76
/// <summary>VkDescriptorSetLayoutCreateInfo - Structure specifying parameters of a newly created descriptor set layout
/// <para>  The VkDescriptorSetLayoutBinding::binding members of theelements of the pBindings array must each have different values.</para>
/// <para>  If flags containsVK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then allelements of pBindings must not have a descriptorType ofVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC orVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC </para>
/// <para>  If flags containsVK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then allelements of pBindings must not have a descriptorType ofVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT </para>
/// <para>  If flags containsVK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then thetotal number of elements of all bindings must be less than or equal toVkPhysicalDevicePushDescriptorPropertiesKHR::maxPushDescriptors </para>
/// <para>  If any binding has theVK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT bit set,flags must includeVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT </para>
/// <para>  If any binding has theVK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT bit set, then allbindings must not have descriptorType ofVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC orVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkDescriptorSetLayoutBindingFlagsCreateInfoEXT </para>
/// <para>   flags must be a valid combination of VkDescriptorSetLayoutCreateFlagBits values</para>
/// <para>   If bindingCount is not 0, pBindings must be a valid pointer to an array of bindingCount valid VkDescriptorSetLayoutBinding structures</para>
/// </summary>
public unsafe struct VkDescriptorSetLayoutCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                        sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                            pNext;
    /// <summary> flags is a bitmask
    /// of VkDescriptorSetLayoutCreateFlagBits
    /// specifying options for descriptor set layout creation.</summary>
    public VkDescriptorSetLayoutCreateFlags       flags;
    /// <summary> bindingCount is the number of elements in pBindings.</summary>
    public UInt32                               bindingCount;
    /// <summary> pBindings is a pointer to an array of
    /// VkDescriptorSetLayoutBinding structures.</summary>
    public /* const */ VkDescriptorSetLayoutBinding*    pBindings;
}
// Struct: 77
/// <summary>VkDescriptorSetLayoutSupport - Structure returning information about whether a descriptor set layout can be supported
/// <para> supported is set to VK_TRUE if the descriptor set can becreated, or else is set to VK_FALSE.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkDescriptorSetVariableDescriptorCountLayoutSupportEXT </para>
/// </summary>
public unsafe struct VkDescriptorSetLayoutSupport {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> supported specifies whether the descriptor set layout can be
    /// created.</summary>
    public VkBool32           supported;
}
// Struct: 78
/// <summary>VkDescriptorSetVariableDescriptorCountAllocateInfoEXT - Structure specifying additional allocation parameters for descriptor sets
/// <para>If descriptorSetCount is zero or this structure is not included in thepNext chain, then the variable lengths are considered to be zero.Otherwise, pDescriptorCounts[i] is the number of descriptors in thevariable count descriptor binding in the corresponding descriptor setlayout.If the variable count descriptor binding in the corresponding descriptor setlayout has a descriptor type ofVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT thenpDescriptorCounts[i] specifies the binding’s capacity in bytes.If VkDescriptorSetAllocateInfo::pSetLayouts[i] does not includea variable count descriptor binding, then pDescriptorCounts[i] isignored.</para>
/// <para>  If descriptorSetCount is not zero, descriptorSetCount mustequal VkDescriptorSetAllocateInfo::descriptorSetCount </para>
/// <para>  If VkDescriptorSetAllocateInfo::pSetLayouts[i] has avariable descriptor count binding, then pDescriptorCounts[i] mustbe less than or equal to the descriptor count specified for that bindingwhen the descriptor set layout was created.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT </para>
/// <para>   If descriptorSetCount is not 0, pDescriptorCounts must be a valid pointer to an array of descriptorSetCount uint32_t values</para>
/// </summary>
public unsafe struct VkDescriptorSetVariableDescriptorCountAllocateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> descriptorSetCount is zero or the number of elements in
    /// pDescriptorCounts.</summary>
    public UInt32           descriptorSetCount;
    /// <summary> pDescriptorCounts is an array of descriptor counts, with each
    /// member specifying the number of descriptors in a variable descriptor
    /// count binding in the corresponding descriptor set being allocated.</summary>
    public /* const */ UInt32*    pDescriptorCounts;
}
// Struct: 79
/// <summary>VkDescriptorSetVariableDescriptorCountLayoutSupportEXT - Structure returning information about whether a descriptor set layout can be supported
/// <para>If the create info includes a variable-sized descriptor, thensupported is determined assuming the requested size of thevariable-sized descriptor, and maxVariableDescriptorCount is set tothe maximum size of that descriptor that can be successfully created (whichis greater than or equal to the requested size passed in).If the create info does not include a variable-sized descriptor or if theVkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingVariableDescriptorCountfeature is not enabled, then maxVariableDescriptorCount is set tozero.For the purposes of this command, a variable-sized descriptor binding with adescriptorCount of zero is treated as if the descriptorCount isone, and thus the binding is not ignored and the maximum descriptor countwill be returned.If the layout is not supported, then the value written tomaxVariableDescriptorCount is undefined.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT </para>
/// </summary>
public unsafe struct VkDescriptorSetVariableDescriptorCountLayoutSupportEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> maxVariableDescriptorCount indicates the maximum number of
    /// descriptors supported in the highest numbered binding of the layout, if
    /// that binding is variable-sized.
    /// If the highest numbered binding of the layout has a descriptor type of
    /// VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then
    /// maxVariableDescriptorCount indicates the maximum byte size
    /// supported for the binding, if that binding is variable-sized.</summary>
    public UInt32           maxVariableDescriptorCount;
}
// Struct: 80
/// <summary>VkDescriptorUpdateTemplateCreateInfo - Structure specifying parameters of a newly created descriptor update template
/// <para>  If templateType isVK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,descriptorSetLayout must be a valid VkDescriptorSetLayouthandle</para>
/// <para>  If templateType isVK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,pipelineBindPoint must be a valid VkPipelineBindPoint value</para>
/// <para>  If templateType isVK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,pipelineLayout must be a valid VkPipelineLayout handle</para>
/// <para>  If templateType isVK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, set must be the unique set number in the pipeline layout that uses adescriptor set layout that was created withVK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   pDescriptorUpdateEntries must be a valid pointer to an array of descriptorUpdateEntryCount valid VkDescriptorUpdateTemplateEntry structures</para>
/// <para>   templateType must be a valid VkDescriptorUpdateTemplateType value</para>
/// <para>   If descriptorSetLayout is not VK_NULL_HANDLE, descriptorSetLayout must be a valid VkDescriptorSetLayout handle</para>
/// <para>   descriptorUpdateEntryCount must be greater than 0 </para>
/// <para>   Both of descriptorSetLayout, and pipelineLayout that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkDescriptorUpdateTemplateCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                           sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                               pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkDescriptorUpdateTemplateCreateFlags     flags;
    /// <summary> descriptorUpdateEntryCount is the number of elements in the
    /// pDescriptorUpdateEntries array.</summary>
    public UInt32                                  descriptorUpdateEntryCount;
    /// <summary> pDescriptorUpdateEntries is a pointer to an array of
    /// VkDescriptorUpdateTemplateEntry structures describing the
    /// descriptors to be updated by the descriptor update template.</summary>
    public /* const */ VkDescriptorUpdateTemplateEntry*    pDescriptorUpdateEntries;
    /// <summary> templateType Specifies the type of the descriptor update template.
    /// If set to VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET it
    /// can only be used to update descriptor sets with a fixed
    /// descriptorSetLayout.
    /// If set to VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
    /// it can only be used to push descriptor sets using the provided
    /// pipelineBindPoint, pipelineLayout, and set number.</summary>
    public VkDescriptorUpdateTemplateType            templateType;
    /// <summary> descriptorSetLayout is the descriptor set layout the parameter
    /// update template will be used with.
    /// All descriptor sets which are going to be updated through the newly
    /// created descriptor update template must be created with this layout.
    /// descriptorSetLayout is the descriptor set layout used to build the
    /// descriptor update template.
    /// All descriptor sets which are going to be updated through the newly
    /// created descriptor update template must be created with a layout that
    /// matches (is the same as, or defined identically to) this layout.
    /// This parameter is ignored if templateType is not
    /// VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET.</summary>
    public VkDescriptorSetLayout                     descriptorSetLayout;
    /// <summary> pipelineBindPoint is a VkPipelineBindPoint indicating
    /// whether the descriptors will be used by graphics pipelines or compute
    /// pipelines.
    /// This parameter is ignored if templateType is not
    /// VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR </summary>
    public VkPipelineBindPoint                       pipelineBindPoint;
    /// <summary> pipelineLayout is a VkPipelineLayout object used to program
    /// the bindings.
    /// This parameter is ignored if templateType is not
    /// VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR </summary>
    public VkPipelineLayout                          pipelineLayout;
    /// <summary> set is the set number of the descriptor set in the pipeline layout
    /// that will be updated.
    /// This parameter is ignored if templateType is not
    /// VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR </summary>
    public UInt32                                  set;
}
// Struct: 81
/// <summary>VkDescriptorUpdateTemplateEntry - Describes a single descriptor update of the descriptor update template
/// <para>   dstBinding must be a valid binding in the descriptor set layoutimplicitly specified when using a descriptor update template to updatedescriptors.</para>
/// <para>   dstArrayElement and descriptorCount must be less than orequal to the number of array elements in the descriptor set bindingimplicitly specified when using a descriptor update template to updatedescriptors, and all applicable consecutive bindings, as described byhtml/vkspec.html#descriptorsets-updates-consecutive </para>
/// <para>  If descriptor type isVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, dstArrayElement must be an integer multiple of 4 </para>
/// <para>  If descriptor type isVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, descriptorCount must be an integer multiple of 4 </para>
/// <para>   descriptorType must be a valid VkDescriptorType value</para>
/// </summary>
public unsafe struct VkDescriptorUpdateTemplateEntry {
    /// <summary> dstBinding is the descriptor binding to update when using this
    /// descriptor update template.</summary>
    public UInt32            dstBinding;
    /// <summary> dstArrayElement is the starting element in the array belonging to
    /// dstBinding.
    /// If the descriptor binding identified by srcBinding has a
    /// descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT
    /// then dstArrayElement specifies the starting byte offset to update.</summary>
    public UInt32            dstArrayElement;
    /// <summary> descriptorCount is the number of descriptors to update.
    /// If descriptorCount is greater than the number of remaining array
    /// elements in the destination binding, those affect consecutive bindings
    /// in a manner similar to VkWriteDescriptorSet above.
    /// If the descriptor binding identified by dstBinding has a
    /// descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT
    /// then descriptorCount specifies the number of bytes to update and
    /// the remaining array elements in the destination binding refer to the
    /// remaining number of bytes in it.</summary>
    public UInt32            descriptorCount;
    /// <summary> descriptorType is a VkDescriptorType specifying the type of
    /// the descriptor.</summary>
    public VkDescriptorType    descriptorType;
    /// <summary> offset is the offset in bytes of the first binding in the raw data
    /// structure.</summary>
    public size_t              offset;
    /// <summary> stride is the stride in bytes between two consecutive array
    /// elements of the descriptor update informations in the raw data
    /// structure.
    /// The actual pointer ptr for each array element j of update entry i is
    /// computed using the following formula:</summary>
    public size_t              stride;
}
// Struct: 82
/// <summary>VkDeviceCreateInfo - Structure specifying parameters of a newly created device
/// <para>  The queueFamilyIndex member of each element ofpQueueCreateInfos must be unique within pQueueCreateInfos,except that two members can share the same queueFamilyIndex if oneis a protected-capable queue and one is not a protected-capable queue.</para>
/// <para>  If the pNext chain includes a VkPhysicalDeviceFeatures2structure, then pEnabledFeatures must be NULL </para>
/// <para>   ppEnabledExtensionNames must not contain html/vkspec.html#VK_AMD_negative_viewport_height  </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupDeviceCreateInfo, VkDeviceMemoryOverallocationCreateInfoAMD, VkPhysicalDevice16BitStorageFeatures, VkPhysicalDevice8BitStorageFeaturesKHR, VkPhysicalDeviceASTCDecodeFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, VkPhysicalDeviceConditionalRenderingFeaturesEXT, VkPhysicalDeviceCooperativeMatrixFeaturesNV, VkPhysicalDeviceCornerSampledImageFeaturesNV, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, VkPhysicalDeviceDepthClipEnableFeaturesEXT, VkPhysicalDeviceDescriptorIndexingFeaturesEXT, VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPhysicalDeviceFeatures2, VkPhysicalDeviceFloat16Int8FeaturesKHR, VkPhysicalDeviceFragmentDensityMapFeaturesEXT, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, VkPhysicalDeviceHostQueryResetFeaturesEXT, VkPhysicalDeviceInlineUniformBlockFeaturesEXT, VkPhysicalDeviceMemoryPriorityFeaturesEXT, VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, VkPhysicalDeviceSamplerYcbcrConversionFeatures, VkPhysicalDeviceScalarBlockLayoutFeaturesEXT, VkPhysicalDeviceShaderAtomicInt64FeaturesKHR, VkPhysicalDeviceShaderDrawParametersFeatures, VkPhysicalDeviceShaderImageFootprintFeaturesNV, VkPhysicalDeviceShadingRateImageFeaturesNV, VkPhysicalDeviceTransformFeedbackFeaturesEXT, VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, or VkPhysicalDeviceYcbcrImageArraysFeaturesEXT </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   flags must be 0 </para>
/// <para>   pQueueCreateInfos must be a valid pointer to an array of queueCreateInfoCount valid VkDeviceQueueCreateInfo structures</para>
/// <para>   If enabledLayerCount is not 0, ppEnabledLayerNames must be a valid pointer to an array of enabledLayerCount null-terminated UTF-8 strings</para>
/// <para>   If enabledExtensionCount is not 0, ppEnabledExtensionNames must be a valid pointer to an array of enabledExtensionCount null-terminated UTF-8 strings</para>
/// <para>   If pEnabledFeatures is not NULL, pEnabledFeatures must be a valid pointer to a valid VkPhysicalDeviceFeatures structure</para>
/// <para>   queueCreateInfoCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkDeviceCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                        pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkDeviceCreateFlags                flags;
    /// <summary> queueCreateInfoCount is the unsigned integer size of the
    /// pQueueCreateInfos array.
    /// Refer to the Queue Creation section
    /// below for further details.</summary>
    public UInt32                           queueCreateInfoCount;
    /// <summary> pQueueCreateInfos is a pointer to an array of
    /// VkDeviceQueueCreateInfo structures describing the queues that are
    /// requested to be created along with the logical device.
    /// Refer to the Queue Creation section
    /// below for further details.</summary>
    public /* const */ VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    /// <summary> enabledLayerCount is deprecated and ignored.</summary>
    public UInt32                           enabledLayerCount;
    /// <summary> ppEnabledLayerNames is deprecated and ignored.
    /// See html/vkspec.html#extendingvulkan-layers-devicelayerdeprecation.</summary>
    public IntPtr const*                 ppEnabledLayerNames;
    /// <summary> enabledExtensionCount is the number of device extensions to
    /// enable.</summary>
    public UInt32                           enabledExtensionCount;
    /// <summary> ppEnabledExtensionNames is a pointer to an array of
    /// enabledExtensionCount null-terminated UTF-8 strings containing the
    /// names of extensions to enable for the created device.
    /// See the html/vkspec.html#extendingvulkan-extensions section for further details.</summary>
    public IntPtr const*                 ppEnabledExtensionNames;
    /// <summary> pEnabledFeatures is NULL or a pointer to a
    /// VkPhysicalDeviceFeatures structure that contains boolean
    /// indicators of all the features to be enabled.
    /// Refer to the Features section for further details.</summary>
    public /* const */ VkPhysicalDeviceFeatures*    pEnabledFeatures;
}
// Struct: 83
/// <summary>VkDeviceEventInfoEXT - Describe a device event to create
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   deviceEvent must be a valid VkDeviceEventTypeEXT value</para>
/// </summary>
public unsafe struct VkDeviceEventInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType         sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*             pNext;
    public VkDeviceEventTypeEXT    deviceEvent;
}
// Struct: 84
/// <summary>VkDeviceGeneratedCommandsFeaturesNVX - Structure specifying physical device support
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkDeviceGeneratedCommandsFeaturesNVX {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> computeBindingPointSupport specifies whether the
    /// VkObjectTableNVX supports entries with
    /// VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX bit set and
    /// VkIndirectCommandsLayoutNVX supports
    /// VK_PIPELINE_BIND_POINT_COMPUTE.</summary>
    public VkBool32           computeBindingPointSupport;
}
// Struct: 85
/// <summary>VkDeviceGeneratedCommandsLimitsNVX - Structure specifying physical device limits
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkDeviceGeneratedCommandsLimitsNVX {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> maxIndirectCommandsLayoutTokenCount the maximum number of tokens
    /// in VkIndirectCommandsLayoutNVX.</summary>
    public UInt32           maxIndirectCommandsLayoutTokenCount;
    /// <summary> maxObjectEntryCounts the maximum number of entries per resource
    /// type in VkObjectTableNVX.</summary>
    public UInt32           maxObjectEntryCounts;
    /// <summary> minSequenceCountBufferOffsetAlignment the minimum alignment for
    /// memory addresses optionally used in vkCmdProcessCommandsNVX.</summary>
    public UInt32           minSequenceCountBufferOffsetAlignment;
    /// <summary> minSequenceIndexBufferOffsetAlignment the minimum alignment for
    /// memory addresses optionally used in vkCmdProcessCommandsNVX.</summary>
    public UInt32           minSequenceIndexBufferOffsetAlignment;
    /// <summary> minCommandsTokenBufferOffsetAlignment the minimum alignment for
    /// memory addresses optionally used in vkCmdProcessCommandsNVX.</summary>
    public UInt32           minCommandsTokenBufferOffsetAlignment;
}
// Struct: 86
/// <summary>VkDeviceGroupBindSparseInfo - Structure indicating which instances are bound
/// <para>These device indices apply to all buffer and image memory binds included inthe batch that points to this structure.The semaphore waits and signals for the batch are executed only by thephysical device specified by the resourceDeviceIndex.</para>
/// <para>If this structure is not present, resourceDeviceIndex andmemoryDeviceIndex are assumed to be zero.</para>
/// <para>   resourceDeviceIndex and memoryDeviceIndex must both bevalid device indices.</para>
/// <para>  Each memory allocation bound in this batch must have allocated aninstance for memoryDeviceIndex.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO </para>
/// </summary>
public unsafe struct VkDeviceGroupBindSparseInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> resourceDeviceIndex is a device index indicating which instance of
    /// the resource is bound.</summary>
    public UInt32           resourceDeviceIndex;
    /// <summary> memoryDeviceIndex is a device index indicating which instance of
    /// the memory the resource instance is bound to.</summary>
    public UInt32           memoryDeviceIndex;
}
// Struct: 87
/// <summary>VkDeviceGroupCommandBufferBeginInfo - Set the initial device mask for a command buffer
/// <para>The initial device mask also acts as an upper bound on the set of devicesthat can ever be in the device mask in the command buffer.</para>
/// <para>If this structure is not present, the initial value of a command buffer’sdevice mask is set to include all physical devices in the logical devicewhen the command buffer begins recording.</para>
/// <para>   deviceMask must be a valid device mask value</para>
/// <para>   deviceMask must not be zero</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO </para>
/// </summary>
public unsafe struct VkDeviceGroupCommandBufferBeginInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> deviceMask is the initial value of the command buffer’s device
    /// mask.</summary>
    public UInt32           deviceMask;
}
// Struct: 88
/// <summary>VkDeviceGroupDeviceCreateInfo - Create a logical device from multiple physical devices
/// <para>The elements of the pPhysicalDevices array are an ordered list of thephysical devices that the logical device represents.These must be a subset of a single device group, and need not be in thesame order as they were enumerated.The order of the physical devices in the pPhysicalDevices arraydetermines the device index of each physical device, with element ibeing assigned a device index of i.Certain commands and structures refer to one or more physical devices byusing device indices or device masks formed using device indices.</para>
/// <para>A logical device created without using VkDeviceGroupDeviceCreateInfo,or with physicalDeviceCount equal to zero, is equivalent to aphysicalDeviceCount of one and pPhysicalDevices pointing to thephysicalDevice parameter to vkCreateDevice.In particular, the device index of that physical device is zero.</para>
/// <para>  Each element of pPhysicalDevices must be unique</para>
/// <para>  All elements of pPhysicalDevices must be in the same device groupas enumerated by vkEnumeratePhysicalDeviceGroups </para>
/// <para>  If physicalDeviceCount is not 0, the physicalDeviceparameter of vkCreateDevice must be an element ofpPhysicalDevices.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO </para>
/// <para>   If physicalDeviceCount is not 0, pPhysicalDevices must be a valid pointer to an array of physicalDeviceCount valid VkPhysicalDevice handles</para>
/// </summary>
public unsafe struct VkDeviceGroupDeviceCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                pNext;
    /// <summary> physicalDeviceCount is the number of elements in the
    /// pPhysicalDevices array.</summary>
    public UInt32                   physicalDeviceCount;
    /// <summary> pPhysicalDevices is an array of physical device handles belonging
    /// to the same device group.</summary>
    public /* const */ VkPhysicalDevice*    pPhysicalDevices;
}
// Struct: 89
/// <summary>VkDeviceGroupPresentCapabilitiesKHR - Present capabilities from other physical devices
/// <para> modes always has VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR set.</para>
/// <para>The present mode flags are also used when presenting an image, inVkDeviceGroupPresentInfoKHR::mode.</para>
/// <para>If a device group only includes a single physical device, then modes must equal VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkDeviceGroupPresentCapabilitiesKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                     sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                         pNext;
    public fixed UInt32                            presentMask[VK_MAX_DEVICE_GROUP_SIZE];
    /// <summary> modes is a bitmask of VkDeviceGroupPresentModeFlagBitsKHR
    /// indicating which device group presentation modes are supported.</summary>
    public VkDeviceGroupPresentModeFlagsKHR    modes;
}
// Struct: 90
/// <summary>VkDeviceGroupPresentInfoKHR - Mode and mask controlling which physical devices' images are presented
/// <para>If mode is VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR, then eachelement of pDeviceMasks selects which instance of the swapchain imageis presented.Each element of pDeviceMasks must have exactly one bit set, and thecorresponding physical device must have a presentation engine as reportedby VkDeviceGroupPresentCapabilitiesKHR.</para>
/// <para>If mode is VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR, theneach element of pDeviceMasks selects which instance of the swapchainimage is presented.Each element of pDeviceMasks must have exactly one bit set, and somephysical device in the logical device must include that bit in itsVkDeviceGroupPresentCapabilitiesKHR::presentMask.</para>
/// <para>If mode is VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR, then eachelement of pDeviceMasks selects which instances of the swapchain imageare component-wise summed and the sum of those images is presented.If the sum in any component is outside the representable range, the value ofthat component is undefined.Each element of pDeviceMasks must have a value for which all set bitsare set in one of the elements ofVkDeviceGroupPresentCapabilitiesKHR::presentMask.</para>
/// <para>If mode isVK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR, then eachelement of pDeviceMasks selects which instance(s) of the swapchainimages are presented.For each bit set in each element of pDeviceMasks, the correspondingphysical device must have a presentation engine as reported byVkDeviceGroupPresentCapabilitiesKHR.</para>
/// <para>If VkDeviceGroupPresentInfoKHR is not provided or swapchainCountis zero then the masks are considered to be 1.If VkDeviceGroupPresentInfoKHR is not provided, mode isconsidered to be VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR.</para>
/// <para>   swapchainCount must equal 0 orVkPresentInfoKHR::swapchainCount </para>
/// <para>  If mode is VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR, theneach element of pDeviceMasks must have exactly one bit set, andthe corresponding element ofVkDeviceGroupPresentCapabilitiesKHR::presentMask must benon-zero</para>
/// <para>  If mode is VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR, theneach element of pDeviceMasks must have exactly one bit set, andsome physical device in the logical device must include that bit in itsVkDeviceGroupPresentCapabilitiesKHR::presentMask.</para>
/// <para>  If mode is VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR, theneach element of pDeviceMasks must have a value for which all setbits are set in one of the elements ofVkDeviceGroupPresentCapabilitiesKHR::presentMask </para>
/// <para>  If mode isVK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR, then foreach bit set in each element of pDeviceMasks, the correspondingelement of VkDeviceGroupPresentCapabilitiesKHR::presentMask must be non-zero</para>
/// <para>  The value of each element of pDeviceMasks must be equal to thedevice mask passed in VkAcquireNextImageInfoKHR::deviceMaskwhen the image index was last acquired</para>
/// <para>   mode must have exactly one bit set, and that bit must have beenincluded in VkDeviceGroupSwapchainCreateInfoKHR::modes </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR </para>
/// <para>   If swapchainCount is not 0, pDeviceMasks must be a valid pointer to an array of swapchainCount uint32_t values</para>
/// <para>   mode must be a valid VkDeviceGroupPresentModeFlagBitsKHR value</para>
/// </summary>
public unsafe struct VkDeviceGroupPresentInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                        sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                            pNext;
    /// <summary> swapchainCount is zero or the number of elements in
    /// pDeviceMasks.</summary>
    public UInt32                               swapchainCount;
    /// <summary> pDeviceMasks is an array of device masks, one for each element of
    /// VkPresentInfoKHR::pSwapchains.</summary>
    public /* const */ UInt32*                        pDeviceMasks;
    /// <summary> mode is the device group present mode that will be used for this
    /// present.</summary>
    public VkDeviceGroupPresentModeFlagBitsKHR    mode;
}
// Struct: 91
/// <summary>VkDeviceGroupRenderPassBeginInfo - Set the initial device mask and render areas for a render pass instance
/// <para>The deviceMask serves several purposes.It is an upper bound on the set of physical devices that can be used duringthe render pass instance, and the initial device mask when the render passinstance begins.In addition, commands transitioning to the next subpass in the render passinstance and commands ending the render pass instance, and, accordinglyrender pass attachment load, store, and resolve operations and subpassdependencies corresponding to the render pass instance, are executed on thephysical devices included in the device mask provided here.</para>
/// <para>If deviceRenderAreaCount is not zero, then the elements ofpDeviceRenderAreas override the value ofVkRenderPassBeginInfo::renderArea, and provide a render areaspecific to each physical device.These render areas serve the same purpose asVkRenderPassBeginInfo::renderArea, including controlling theregion of attachments that are cleared by VK_ATTACHMENT_LOAD_OP_CLEARand that are resolved into resolve attachments.</para>
/// <para>If this structure is not present, the render pass instance’s device mask isthe value of VkDeviceGroupCommandBufferBeginInfo::deviceMask.If this structure is not present or if deviceRenderAreaCount is zero,VkRenderPassBeginInfo::renderArea is used for all physicaldevices.</para>
/// <para>   deviceMask must be a valid device mask value</para>
/// <para>   deviceMask must not be zero</para>
/// <para>   deviceMask must be a subset of the command buffer’s initialdevice mask</para>
/// <para>   deviceRenderAreaCount must either be zero or equal to the numberof physical devices in the logical device.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO </para>
/// <para>   If deviceRenderAreaCount is not 0, pDeviceRenderAreas must be a valid pointer to an array of deviceRenderAreaCount VkRect2D structures</para>
/// </summary>
public unsafe struct VkDeviceGroupRenderPassBeginInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> deviceMask is the device mask for the render pass instance.</summary>
    public UInt32           deviceMask;
    /// <summary> deviceRenderAreaCount is the number of elements in the
    /// pDeviceRenderAreas array.</summary>
    public UInt32           deviceRenderAreaCount;
    /// <summary> pDeviceRenderAreas is an array of structures of type
    /// VkRect2D defining the render area for each physical device.</summary>
    public /* const */ VkRect2D*    pDeviceRenderAreas;
}
// Struct: 92
/// <summary>VkDeviceGroupSubmitInfo - Structure indicating which physical devices execute semaphore operations and command buffers
/// <para>If this structure is not present, semaphore operations and command buffersexecute on device index zero.</para>
/// <para>   waitSemaphoreCount must equalVkSubmitInfo::waitSemaphoreCount </para>
/// <para>   commandBufferCount must equalVkSubmitInfo::commandBufferCount </para>
/// <para>   signalSemaphoreCount must equalVkSubmitInfo::signalSemaphoreCount </para>
/// <para>  All elements of pWaitSemaphoreDeviceIndices andpSignalSemaphoreDeviceIndices must be valid device indices</para>
/// <para>  All elements of pCommandBufferDeviceMasks must be valid devicemasks</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO </para>
/// <para>   If waitSemaphoreCount is not 0, pWaitSemaphoreDeviceIndices must be a valid pointer to an array of waitSemaphoreCount uint32_t values</para>
/// <para>   If commandBufferCount is not 0, pCommandBufferDeviceMasks must be a valid pointer to an array of commandBufferCount uint32_t values</para>
/// <para>   If signalSemaphoreCount is not 0, pSignalSemaphoreDeviceIndices must be a valid pointer to an array of signalSemaphoreCount uint32_t values</para>
/// </summary>
public unsafe struct VkDeviceGroupSubmitInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> waitSemaphoreCount is the number of elements in the
    /// pWaitSemaphoreDeviceIndices array.</summary>
    public UInt32           waitSemaphoreCount;
    /// <summary> pWaitSemaphoreDeviceIndices is an array of device indices
    /// indicating which physical device executes the semaphore wait operation
    /// in the corresponding element of
    /// VkSubmitInfo::pWaitSemaphores.</summary>
    public /* const */ UInt32*    pWaitSemaphoreDeviceIndices;
    /// <summary> commandBufferCount is the number of elements in the
    /// pCommandBufferDeviceMasks array.</summary>
    public UInt32           commandBufferCount;
    /// <summary> pCommandBufferDeviceMasks is an array of device masks indicating
    /// which physical devices execute the command buffer in the corresponding
    /// element of VkSubmitInfo::pCommandBuffers.
    /// A physical device executes the command buffer if the corresponding bit
    /// is set in the mask.</summary>
    public /* const */ UInt32*    pCommandBufferDeviceMasks;
    /// <summary> signalSemaphoreCount is the number of elements in the
    /// pSignalSemaphoreDeviceIndices array.</summary>
    public UInt32           signalSemaphoreCount;
    /// <summary> pSignalSemaphoreDeviceIndices is an array of device indices
    /// indicating which physical device executes the semaphore signal operation
    /// in the corresponding element of
    /// VkSubmitInfo::pSignalSemaphores.</summary>
    public /* const */ UInt32*    pSignalSemaphoreDeviceIndices;
}
// Struct: 93
/// <summary>VkDeviceGroupSwapchainCreateInfoKHR - Structure specifying parameters of a newly created swapchain object
/// <para>If this structure is not present, modes is considered to beVK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR </para>
/// <para>   modes must be a valid combination of VkDeviceGroupPresentModeFlagBitsKHR values</para>
/// <para>   modes must not be 0 </para>
/// </summary>
public unsafe struct VkDeviceGroupSwapchainCreateInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                     sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                         pNext;
    /// <summary> modes is a bitfield of modes that the swapchain can be used with.</summary>
    public VkDeviceGroupPresentModeFlagsKHR    modes;
}
// Struct: 94
/// <summary>VkDeviceMemoryOverallocationCreateInfoAMD - Specify memory overallocation behavior for a Vulkan device
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD </para>
/// <para>   overallocationBehavior must be a valid VkMemoryOverallocationBehaviorAMD value</para>
/// </summary>
public unsafe struct VkDeviceMemoryOverallocationCreateInfoAMD {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                          pNext;
    /// <summary> overallocationBehavior is the desired overallocation behavior.</summary>
    public VkMemoryOverallocationBehaviorAMD    overallocationBehavior;
}
// Struct: 95
/// <summary>VkDeviceQueueCreateInfo - Structure specifying parameters of a newly created device queue
/// <para>   queueFamilyIndex must be less thanpQueueFamilyPropertyCount returned byvkGetPhysicalDeviceQueueFamilyProperties </para>
/// <para>   queueCount must be less than or equal to the queueCountmember of the VkQueueFamilyProperties structure, as returned byvkGetPhysicalDeviceQueueFamilyProperties in thepQueueFamilyProperties[queueFamilyIndex]</para>
/// <para>  Each element of pQueuePriorities must be between 0.0 and 1.0inclusive</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkDeviceQueueGlobalPriorityCreateInfoEXT </para>
/// <para>   flags must be a valid combination of VkDeviceQueueCreateFlagBits values</para>
/// <para>   pQueuePriorities must be a valid pointer to an array of queueCount float values</para>
/// <para>   queueCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkDeviceQueueCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                 pNext;
    /// <summary> flags is a bitmask indicating behavior of the queue.</summary>
    public VkDeviceQueueCreateFlags    flags;
    /// <summary> queueFamilyIndex is an unsigned integer indicating the index of
    /// the queue family to create on this device.
    /// This index corresponds to the index of an element of the
    /// pQueueFamilyProperties array that was returned by
    /// vkGetPhysicalDeviceQueueFamilyProperties.</summary>
    public UInt32                    queueFamilyIndex;
    /// <summary> queueCount is an unsigned integer specifying the number of queues
    /// to create in the queue family indicated by queueFamilyIndex.</summary>
    public UInt32                    queueCount;
    /// <summary> pQueuePriorities is an array of queueCount normalized
    /// floating point values, specifying priorities of work that will be
    /// submitted to each created queue.
    /// See Queue Priority for more information.</summary>
    public /* const */ float*                pQueuePriorities;
}
// Struct: 96
/// <summary>VkDeviceQueueGlobalPriorityCreateInfoEXT - Specify a system wide priority
/// <para>A queue created without specifyingVkDeviceQueueGlobalPriorityCreateInfoEXT will default toVK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT </para>
/// <para>   globalPriority must be a valid VkQueueGlobalPriorityEXT value</para>
/// </summary>
public unsafe struct VkDeviceQueueGlobalPriorityCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                 pNext;
    /// <summary> globalPriority is the system-wide priority associated to this
    /// queue as specified by VkQueueGlobalPriorityEXT </summary>
    public VkQueueGlobalPriorityEXT    globalPriority;
}
// Struct: 97
/// <summary>VkDeviceQueueInfo2 - Structure specifying the parameters used for device queue creation
/// <para>The queue returned by vkGetDeviceQueue2 must have the sameflags value from this structure as that used at device creation timein a VkDeviceQueueCreateInfo instance.If no matching flags were specified at device creation time thenpQueue will return VK_NULL_HANDLE.</para>
/// <para>   queueFamilyIndex must be one of the queue family indicesspecified when device was created, via theVkDeviceQueueCreateInfo structure</para>
/// <para>   queueIndex must be less than the number of queues created for thespecified queue family index and VkDeviceQueueCreateFlags memberflags equal to this flags value when device wascreated, via the queueCount member of theVkDeviceQueueCreateInfo structure</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be a valid combination of VkDeviceQueueCreateFlagBits values</para>
/// <para>   flags must not be 0 </para>
/// </summary>
public unsafe struct VkDeviceQueueInfo2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.
    /// The pNext chain of VkDeviceQueueInfo2 is used to provide
    /// additional image parameters to vkGetDeviceQueue2.</summary>
    public /* const */ void*                 pNext;
    /// <summary> flags is a VkDeviceQueueCreateFlags value indicating the
    /// flags used to create the device queue.</summary>
    public VkDeviceQueueCreateFlags    flags;
    /// <summary> queueFamilyIndex is the index of the queue family to which the
    /// queue belongs.</summary>
    public UInt32                    queueFamilyIndex;
    /// <summary> queueIndex is the index within this queue family of the queue to
    /// retrieve.</summary>
    public UInt32                    queueIndex;
}
// Struct: 98
/// <summary>VkDispatchIndirectCommand - Structure specifying a dispatch indirect command
/// <para>The members of VkDispatchIndirectCommand have the same meaning as thecorresponding parameters of vkCmdDispatch.</para>
/// <para>   x must be less than or equal toVkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]</para>
/// <para>   y must be less than or equal toVkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]</para>
/// <para>   z must be less than or equal toVkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]</para>
/// </summary>
public unsafe struct VkDispatchIndirectCommand {
    /// <summary> x is the number of local workgroups to dispatch in the X
    /// dimension.</summary>
    public UInt32    x;
    /// <summary> y is the number of local workgroups to dispatch in the Y
    /// dimension.</summary>
    public UInt32    y;
    /// <summary> z is the number of local workgroups to dispatch in the Z
    /// dimension.</summary>
    public UInt32    z;
}
// Struct: 99
/// <summary>VkDisplayEventInfoEXT - Describe a display event to create
/// <para>   sType must be VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   displayEvent must be a valid VkDisplayEventTypeEXT value</para>
/// </summary>
public unsafe struct VkDisplayEventInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*              pNext;
    /// <summary> displayEvent is a VkDisplayEventTypeEXT specifying when the
    /// fence will be signaled.</summary>
    public VkDisplayEventTypeEXT    displayEvent;
}
// Struct: 100
/// <summary>VkDisplayModeCreateInfoKHR - Structure specifying parameters of a newly created display mode object
/// <para>   sType must be VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   parameters must be a valid VkDisplayModeParametersKHR structure</para>
/// </summary>
public unsafe struct VkDisplayModeCreateInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                    pNext;
    /// <summary> flags is reserved for future use, and must be zero.</summary>
    public VkDisplayModeCreateFlagsKHR    flags;
    /// <summary> parameters is a VkDisplayModeParametersKHR structure
    /// describing the display parameters to use in creating the new mode.
    /// If the parameters are not compatible with the specified display, the
    /// implementation must return VK_ERROR_INITIALIZATION_FAILED.</summary>
    public VkDisplayModeParametersKHR     parameters;
}
// Struct: 101
/// <summary>VkDisplayModeParametersKHR - Structure describing display parameters associated with a display mode
/// <para>For example, a 60Hz display mode would report a refreshRate of 60,000.</para>
/// <para>  The width member of visibleRegion must be greater than 0 </para>
/// <para>  The height member of visibleRegion must be greater than 0 </para>
/// <para>   refreshRate must be greater than 0 </para>
/// </summary>
public unsafe struct VkDisplayModeParametersKHR {
    /// <summary> visibleRegion is the 2D extents of the visible region.</summary>
    public VkExtent2D    visibleRegion;
    /// <summary> refreshRate is a uint32_t that is the number of times the
    /// display is refreshed each second multiplied by 1000.</summary>
    public UInt32      refreshRate;
}
// Struct: 102
/// <summary>VkDisplayModeProperties2KHR - Structure describing an available display mode
/// <para>   sType must be VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkDisplayModeProperties2KHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                         pNext;
    /// <summary> displayModeProperties is an instance of the
    /// VkDisplayModePropertiesKHR structure.</summary>
    public VkDisplayModePropertiesKHR    displayModeProperties;
}
// Struct: 103
/// <summary>VkDisplayModePropertiesKHR - Structure describing display mode properties
/// </summary>
public unsafe struct VkDisplayModePropertiesKHR {
    /// <summary> displayMode is a handle to the display mode described in this
    /// structure.
    /// This handle will be valid for the lifetime of the Vulkan instance.</summary>
    public VkDisplayModeKHR              displayMode;
    /// <summary> parameters is a VkDisplayModeParametersKHR structure
    /// describing the display parameters associated with displayMode.</summary>
    public VkDisplayModeParametersKHR    parameters;
}
// Struct: 104
/// <summary>VkDisplayNativeHdrSurfaceCapabilitiesAMD - Structure describing display native HDR specific capabilities of a surface
/// <para>   sType must be VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD </para>
/// </summary>
public unsafe struct VkDisplayNativeHdrSurfaceCapabilitiesAMD {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> localDimmingSupport specifies whether the surface supports local
    /// dimming.
    /// If this is VK_TRUE, VkSwapchainDisplayNativeHdrCreateInfoAMD can be used to explicitly enable or disable local dimming for the
    /// surface.
    /// Local dimming may also be overriden by vkSetLocalDimmingAMD during
    /// the lifetime of the swapchain.</summary>
    public VkBool32           localDimmingSupport;
}
// Struct: 105
/// <summary>VkDisplayPlaneCapabilities2KHR - Structure describing the capabilities of a mode and plane combination
/// <para>   sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkDisplayPlaneCapabilities2KHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                  sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                            pNext;
    /// <summary> capabilities is an instance of the
    /// VkDisplayPlaneCapabilitiesKHR structure.</summary>
    public VkDisplayPlaneCapabilitiesKHR    capabilities;
}
// Struct: 106
/// <summary>VkDisplayPlaneCapabilitiesKHR - Structure describing capabilities of a mode and plane combination
/// <para>The minimum and maximum position and extent fields describe theimplementation limits, if any, as they apply to the specified display modeand plane.Vendors may support displaying a subset of a swapchain’s presentable imageson the specified display plane.This is expressed by returning minSrcPosition, maxSrcPosition,minSrcExtent, and maxSrcExtent values that indicate a range ofpossible positions and sizes may be used to specify the region within thepresentable images that source pixels will be read from when creating aswapchain on the specified display mode and plane.</para>
/// <para>Vendors may also support mapping the presentable images’ content to asubset or superset of the visible region in the specified display mode.This is expressed by returning minDstPosition, maxDstPosition,minDstExtent and maxDstExtent values that indicate a range ofpossible positions and sizes may be used to describe the region within thedisplay mode that the source pixels will be mapped to.</para>
/// <para>Other vendors may support only a 1-1 mapping between pixels in thepresentable images and the display mode.This may be indicated by returning (0,0) for minSrcPosition,maxSrcPosition, minDstPosition, and maxDstPosition, and(display mode width, display mode height) for minSrcExtent,maxSrcExtent, minDstExtent, and maxDstExtent.</para>
/// <para>These values indicate the limits of the implementation’s individual fields.Not all combinations of values within the offset and extent ranges returnedin VkDisplayPlaneCapabilitiesKHR are guaranteed to be supported.Vendors may still fail presentation requests that specify unsupportedcombinations.</para>
/// </summary>
public unsafe struct VkDisplayPlaneCapabilitiesKHR {
    /// <summary> supportedAlpha is a bitmask of
    /// VkDisplayPlaneAlphaFlagBitsKHR describing the supported alpha
    /// blending modes.</summary>
    public VkDisplayPlaneAlphaFlagsKHR    supportedAlpha;
    /// <summary> minSrcPosition is the minimum source rectangle offset supported by
    /// this plane using the specified mode.</summary>
    public VkOffset2D                     minSrcPosition;
    /// <summary> maxSrcPosition is the maximum source rectangle offset supported by
    /// this plane using the specified mode.
    /// The x and y components of maxSrcPosition must each be
    /// greater than or equal to the x and y components of
    /// minSrcPosition, respectively.</summary>
    public VkOffset2D                     maxSrcPosition;
    /// <summary> minSrcExtent is the minimum source rectangle size supported by
    /// this plane using the specified mode.</summary>
    public VkExtent2D                     minSrcExtent;
    /// <summary> maxSrcExtent is the maximum source rectangle size supported by
    /// this plane using the specified mode.</summary>
    public VkExtent2D                     maxSrcExtent;
    /// <summary> minDstPosition, maxDstPosition, minDstExtent,
    /// maxDstExtent all have similar semantics to their corresponding
    /// *Src* equivalents, but apply to the output region within the mode
    /// rather than the input region within the source image.
    /// Unlike the *Src* offsets, minDstPosition and
    /// maxDstPosition may contain negative values.</summary>
    public VkOffset2D                     minDstPosition;
    public VkOffset2D                     maxDstPosition;
    public VkExtent2D                     minDstExtent;
    public VkExtent2D                     maxDstExtent;
}
// Struct: 107
/// <summary>VkDisplayPlaneInfo2KHR - Structure defining the intended configuration of a display plane
/// <para>This parameter also implicitly specifies a display.</para>
/// <para> planeIndex is the plane which the application intends to use withthe display.</para>
/// <para>The members of VkDisplayPlaneInfo2KHR correspond to the arguments tovkGetDisplayPlaneCapabilitiesKHR, with sType and pNextadded for extensibility.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   mode must be a valid VkDisplayModeKHR handle</para>
/// <para>Host access to mode must be externally synchronized</para>
/// </summary>
public unsafe struct VkDisplayPlaneInfo2KHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType     sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*         pNext;
    /// <summary> mode is the display mode the application intends to program when
    /// using the specified plane.</summary>
    public VkDisplayModeKHR    mode;
    public UInt32            planeIndex;
}
// Struct: 108
/// <summary>VkDisplayPlaneProperties2KHR - Structure describing an available display plane
/// <para>   sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkDisplayPlaneProperties2KHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                          pNext;
    /// <summary> displayPlaneProperties is an instance of the
    /// VkDisplayPlanePropertiesKHR structure.</summary>
    public VkDisplayPlanePropertiesKHR    displayPlaneProperties;
}
// Struct: 109
/// <summary>VkDisplayPlanePropertiesKHR - Structure describing display plane properties
/// </summary>
public unsafe struct VkDisplayPlanePropertiesKHR {
    /// <summary> currentDisplay is the handle of the display the plane is currently
    /// associated with.
    /// If the plane is not currently attached to any displays, this will be
    /// VK_NULL_HANDLE.</summary>
    public VkDisplayKHR    currentDisplay;
    /// <summary> currentStackIndex is the current z-order of the plane.
    /// This will be between 0 and the value returned by
    /// vkGetPhysicalDeviceDisplayPlanePropertiesKHR in
    /// pPropertyCount.</summary>
    public UInt32        currentStackIndex;
}
// Struct: 110
/// <summary>VkDisplayPowerInfoEXT - Describe the power state of a display
/// <para>   sType must be VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   powerState must be a valid VkDisplayPowerStateEXT value</para>
/// </summary>
public unsafe struct VkDisplayPowerInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType           sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*               pNext;
    /// <summary> powerState is a VkDisplayPowerStateEXT value specifying the
    /// new power state of the display.</summary>
    public VkDisplayPowerStateEXT    powerState;
}
// Struct: 111
/// <summary>VkDisplayPresentInfoKHR - Structure describing parameters of a queue presentation to a swapchain
/// <para>If the extent of the srcRect and dstRect are not equal, thepresented pixels will be scaled accordingly.</para>
/// <para>   srcRect must specify a rectangular region that is a subset of theimage being presented</para>
/// <para>   dstRect must specify a rectangular region that is a subset of thevisibleRegion parameter of the display mode the swapchain beingpresented uses</para>
/// <para>  If the persistentContent member of theVkDisplayPropertiesKHR structure returned byvkGetPhysicalDeviceDisplayPropertiesKHR for the display thepresent operation targets then persistent must be VK_FALSE </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR </para>
/// </summary>
public unsafe struct VkDisplayPresentInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> srcRect is a rectangular region of pixels to present.
    /// It must be a subset of the image being presented.
    /// If VkDisplayPresentInfoKHR is not specified, this region will be
    /// assumed to be the entire presentable image.</summary>
    public VkRect2D           srcRect;
    /// <summary> dstRect is a rectangular region within the visible region of the
    /// swapchain’s display mode.
    /// If VkDisplayPresentInfoKHR is not specified, this region will be
    /// assumed to be the entire visible region of the visible region of the
    /// swapchain’s mode.
    /// If the specified rectangle is a subset of the display mode’s visible
    /// region, content from display planes below the swapchain’s plane will be
    /// visible outside the rectangle.
    /// If there are no planes below the swapchain’s, the area outside the
    /// specified rectangle will be black.
    /// If portions of the specified rectangle are outside of the display’s
    /// visible region, pixels mapping only to those portions of the rectangle
    /// will be discarded.</summary>
    public VkRect2D           dstRect;
    /// <summary> persistent: If this is VK_TRUE, the display engine will
    /// enable buffered mode on displays that support it.
    /// This allows the display engine to stop sending content to the display
    /// until a new image is presented.
    /// The display will instead maintain a copy of the last presented image.
    /// This allows less power to be used, but may increase presentation
    /// latency.
    /// If VkDisplayPresentInfoKHR is not specified, persistent mode will
    /// not be used.</summary>
    public VkBool32           persistent;
}
// Struct: 112
/// <summary>VkDisplayProperties2KHR - Structure describing an available display device
/// <para>   sType must be VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkDisplayProperties2KHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType           sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                     pNext;
    /// <summary> displayProperties is an instance of the
    /// VkDisplayPropertiesKHR structure.</summary>
    public VkDisplayPropertiesKHR    displayProperties;
}
// Struct: 113
/// <summary>VkDisplayPropertiesKHR - Structure describing an available display device
/// <para>For devices which have no natural value to return here, implementationsshould return the maximum resolution supported.</para>
/// <para> supportedTransforms is a bitmask ofVkSurfaceTransformFlagBitsKHR describing which transforms aresupported by this display.</para>
/// <para> planeReorderPossible tells whether the planes on this display canhave their z order changed.If this is VK_TRUE, the application can re-arrange the planes onthis display in any order relative to each other.</para>
/// <para> persistentContent tells whether the display supportsself-refresh/internal buffering.If this is true, the application can submit persistent presentoperations on swapchains created against this display.</para>
/// <para>Persistent presents may have higher latency, and may use less power whenthe screen content is updated infrequently, or when only a portion of thescreen needs to be updated in most frames.</para>
/// </summary>
public unsafe struct VkDisplayPropertiesKHR {
    /// <summary> display is a handle that is used to refer to the display described
    /// here.
    /// This handle will be valid for the lifetime of the Vulkan instance.</summary>
    public VkDisplayKHR                  display;
    /// <summary> displayName is a pointer to a NULL-terminated string containing
    /// the name of the display.
    /// Generally, this will be the name provided by the display’s EDID.
    /// It can be NULL if no suitable name is available.
    /// If not NULL, the memory it points to must remain accessible as long
    /// as display is valid.</summary>
    public IntPtr                   displayName;
    /// <summary> physicalDimensions describes the physical width and height of the
    /// visible portion of the display, in millimeters.</summary>
    public VkExtent2D                    physicalDimensions;
    /// <summary> physicalResolution describes the physical, native, or preferred
    /// resolution of the display.</summary>
    public VkExtent2D                    physicalResolution;
    public VkSurfaceTransformFlagsKHR    supportedTransforms;
    public VkBool32                      planeReorderPossible;
    public VkBool32                      persistentContent;
}
// Struct: 114
/// <summary>VkDisplaySurfaceCreateInfoKHR - Structure specifying parameters of a newly created display plane surface object
/// <para>Creating a display surface must not modify the state of the displays,planes, or other resources it names.For example, it must not apply the specified mode to be set on theassociated display.Application of display configuration occurs as a side effect of presentingto a display surface.</para>
/// <para>   planeIndex must be less than the number of display planessupported by the device as determined by callingvkGetPhysicalDeviceDisplayPlanePropertiesKHR </para>
/// <para>  If the planeReorderPossible member of theVkDisplayPropertiesKHR structure returned byvkGetPhysicalDeviceDisplayPropertiesKHR for the displaycorresponding to displayMode is VK_TRUE thenplaneStackIndex must be less than the number of display planessupported by the device as determined by callingvkGetPhysicalDeviceDisplayPlanePropertiesKHR; otherwiseplaneStackIndex must equal the currentStackIndex member ofVkDisplayPlanePropertiesKHR returned byvkGetPhysicalDeviceDisplayPlanePropertiesKHR for the display planecorresponding to displayMode </para>
/// <para>  If alphaMode is VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR thenglobalAlpha must be between 0 and 1, inclusive</para>
/// <para>   alphaMode must be 0 or one of the bits present in thesupportedAlpha member of VkDisplayPlaneCapabilitiesKHRreturned by vkGetDisplayPlaneCapabilitiesKHR for the display planecorresponding to displayMode </para>
/// <para>  The width and height members of imageExtent must beless than the maxImageDimensions2D member ofVkPhysicalDeviceLimits </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   displayMode must be a valid VkDisplayModeKHR handle</para>
/// <para>   transform must be a valid VkSurfaceTransformFlagBitsKHR value</para>
/// <para>   alphaMode must be a valid VkDisplayPlaneAlphaFlagBitsKHR value</para>
/// </summary>
public unsafe struct VkDisplaySurfaceCreateInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                   sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                       pNext;
    /// <summary> flags is reserved for future use, and must be zero.</summary>
    public VkDisplaySurfaceCreateFlagsKHR    flags;
    /// <summary> displayMode is a VkDisplayModeKHR handle specifying the mode
    /// to use when displaying this surface.</summary>
    public VkDisplayModeKHR                  displayMode;
    /// <summary> planeIndex is the plane on which this surface appears.</summary>
    public UInt32                          planeIndex;
    /// <summary> planeStackIndex is the z-order of the plane.</summary>
    public UInt32                          planeStackIndex;
    /// <summary> transform is a VkSurfaceTransformFlagBitsKHR value
    /// specifying the transformation to apply to images as part of the scanout
    /// operation.</summary>
    public VkSurfaceTransformFlagBitsKHR     transform;
    /// <summary> globalAlpha is the global alpha value.
    /// This value is ignored if alphaMode is not
    /// VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR.</summary>
    public float                             globalAlpha;
    /// <summary> alphaMode is a VkDisplayPlaneAlphaFlagBitsKHR value
    /// specifying the type of alpha blending to use.</summary>
    public VkDisplayPlaneAlphaFlagBitsKHR    alphaMode;
    /// <summary> imageExtent The size of the presentable images to use with the
    /// surface.</summary>
    public VkExtent2D                        imageExtent;
}
// Struct: 115
/// <summary>VkDrawIndexedIndirectCommand - Structure specifying a draw indexed indirect command
/// <para>The members of VkDrawIndexedIndirectCommand have the same meaning asthe similarly named parameters of vkCmdDrawIndexed.</para>
/// <para>  For a given vertex buffer binding, any attribute data fetched must beentirely contained within the corresponding vertex buffer binding, asdescribed in html/vkspec.html#fxvertex-input </para>
/// <para>   (indexSize * (firstIndex +  indexCount) + offset) must be less than or equal to the size of the boundindex buffer, with indexSize being based on the type specified byindexType, where the index buffer, indexType, andoffset are specified via vkCmdBindIndexBuffer </para>
/// <para>  If the drawIndirectFirstInstancefeature is not enabled, firstInstance must be 0 </para>
/// </summary>
public unsafe struct VkDrawIndexedIndirectCommand {
    /// <summary> indexCount is the number of vertices to draw.</summary>
    public UInt32    indexCount;
    /// <summary> instanceCount is the number of instances to draw.</summary>
    public UInt32    instanceCount;
    /// <summary> firstIndex is the base index within the index buffer.</summary>
    public UInt32    firstIndex;
    /// <summary> vertexOffset is the value added to the vertex index before
    /// indexing into the vertex buffer.</summary>
    public Int32     vertexOffset;
    /// <summary> firstInstance is the instance ID of the first instance to draw.</summary>
    public UInt32    firstInstance;
}
// Struct: 116
/// <summary>VkDrawIndirectCommand - Structure specifying a draw indirect command
/// <para>The members of VkDrawIndirectCommand have the same meaning as thesimilarly named parameters of vkCmdDraw.</para>
/// <para>  For a given vertex buffer binding, any attribute data fetched must beentirely contained within the corresponding vertex buffer binding, asdescribed in html/vkspec.html#fxvertex-input </para>
/// <para>  If the drawIndirectFirstInstancefeature is not enabled, firstInstance must be 0 </para>
/// </summary>
public unsafe struct VkDrawIndirectCommand {
    /// <summary> vertexCount is the number of vertices to draw.</summary>
    public UInt32    vertexCount;
    /// <summary> instanceCount is the number of instances to draw.</summary>
    public UInt32    instanceCount;
    /// <summary> firstVertex is the index of the first vertex to draw.</summary>
    public UInt32    firstVertex;
    /// <summary> firstInstance is the instance ID of the first instance to draw.</summary>
    public UInt32    firstInstance;
}
// Struct: 117
/// <summary>VkDrawMeshTasksIndirectCommandNV - Structure specifying a mesh tasks draw indirect command
/// <para>The members of VkDrawMeshTasksIndirectCommandNV have the same meaningas the similarly named parameters of vkCmdDrawMeshTasksNV.</para>
/// <para>   taskCount must be less than or equal toVkPhysicalDeviceMeshShaderPropertiesNV::maxDrawMeshTasksCount </para>
/// </summary>
public unsafe struct VkDrawMeshTasksIndirectCommandNV {
    /// <summary> taskCount is the number of local workgroups to dispatch in the X
    /// dimension.
    /// Y and Z dimension are implicitly set to one.</summary>
    public UInt32    taskCount;
    /// <summary> firstTask is the X component of the first workgroup ID.</summary>
    public UInt32    firstTask;
}
// Struct: 118
/// <summary>VkDrmFormatModifierPropertiesEXT - Structure specifying properties of a format when combined with a DRM format modifier
/// <para>The returned drmFormatModifierTilingFeatures must contain at leastone bit.</para>
/// <para>The implementation must not return DRM_FORMAT_MOD_INVALID indrmFormatModifier.</para>
/// <para>An image’s memory planecount (as returned bydrmFormatModifierPlaneCount) is distinct from its format planecount(in the sense of multi-planarY’CBCR formats).In VkImageAspectFlags, eachVK_IMAGE_ASPECT_MEMORY_PLANE  i_BIT_EXT represents a _memory planeand each VK_IMAGE_ASPECT_PLANE  i_BIT a _format plane.</para>
/// <para>An image’s set of format planes is an ordered partition of the image’scontent into separable groups of format channels.The ordered partition is encoded in the name of each VkFormat.For example, VK_FORMAT_G8_B8R8_2PLANE_420_UNORM contains two formatplanes; the first plane contains the green channel and the second planecontains the blue channel and red channel.If the format name does not contain PLANE, then the format contains asingle plane; for example, VK_FORMAT_R8G8B8A8_UNORM.Some commands, such as vkCmdCopyBufferToImage, do not operate on allformat channels in the image, but instead operate only on the formatplanes explicitly chosen by the application and operate on each formatplane independently.</para>
/// <para>An image’s set of memory planes is an ordered partition of the image’smemory rather than the image’s content.Each memory plane is a contiguous range of memory.The union of an image’s memory planes is not necessarily contiguous.</para>
/// <para>If an image is linear, then the partition isthe same for memory planes and for format planes.Therefore, if the returned drmFormatModifier isDRM_FORMAT_MOD_LINEAR, then drmFormatModifierPlaneCount mustequal the format planecount, and drmFormatModifierTilingFeatures must be identical to theVkFormatProperties2::linearTilingFeatures returned in the samepNext chain.</para>
/// <para>If an image is non-linear, then the partitionof the image’s memory into memory planes is implementation-specific andmay be unrelated to the partition of the image’s content into formatplanes.For example, consider an image whose format isVK_FORMAT_G8_B8_R8_3PLANE_420_UNORM, tiling isVK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, whose drmFormatModifieris not DRM_FORMAT_MOD_LINEAR, and flags lacksVK_IMAGE_CREATE_DISJOINT_BIT.The image has 3 format planes, and commands suchvkCmdCopyBufferToImage act on each format plane independently as ifthe data of each format plane were separable from the data of the otherplanes.In a straightforward implementation, the implementation may store theimage’s content in 3 adjacent memory planes where each memory planecorresponds exactly to a format plane.However, the implementation may also store the image’s content in a singlememory plane where all format channels are combined using animplementation-private block-compressed format; or the implementation maystore the image’s content in a collection of 7 adjacent memory planesusing an implementation-private sharding technique.Because the image is non-linear and non-disjoint, the implementation hasmuch freedom when choosing the image’s placement in memory.</para>
/// <para>The memory planecount applies to function parameters and structures onlywhen the API specifies an explicit requirement ondrmFormatModifierPlaneCount.In all other cases, the memory planecount is ignored.</para>
/// </summary>
public unsafe struct VkDrmFormatModifierPropertiesEXT {
    /// <summary> drmFormatModifier is a Linux DRM format modifier.</summary>
    public UInt64                drmFormatModifier;
    /// <summary> drmFormatModifierPlaneCount is the number of memory planes in
    /// any image created with format and drmFormatModifier.
    /// An image’s memory planecount is distinct from its format planecount,
    /// as explained below.</summary>
    public UInt32                drmFormatModifierPlaneCount;
    /// <summary> drmFormatModifierTilingFeatures is a bitmask of
    /// VkFormatFeatureFlagBits that are supported by any image created
    /// with format and drmFormatModifier.</summary>
    public VkFormatFeatureFlags    drmFormatModifierTilingFeatures;
}
// Struct: 119
/// <summary>VkDrmFormatModifierPropertiesListEXT - Structure specifying the list of DRM format modifiers supported for a format
/// <para>If pDrmFormatModifierProperties is NULL, then the function returnsin drmFormatModifierCount the number of modifiers compatible with thequeried format.Otherwise, the application must set drmFormatModifierCount to thelength of the array pDrmFormatModifierProperties; the function willwrite at most drmFormatModifierCount elements to the array, and willreturn in drmFormatModifierCount the number of elements written.</para>
/// <para>Among the elements in array pDrmFormatModifierProperties, eachreturned drmFormatModifier must be unique.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT </para>
/// </summary>
public unsafe struct VkDrmFormatModifierPropertiesListEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                                pNext;
    /// <summary> drmFormatModifierCount is an inout parameter related to the number
    /// of modifiers compatible with the format, as described below.</summary>
    public UInt32                             drmFormatModifierCount;
    /// <summary> pDrmFormatModifierProperties is either NULL or an array of
    /// VkDrmFormatModifierPropertiesEXT structures.</summary>
    public VkDrmFormatModifierPropertiesEXT*    pDrmFormatModifierProperties;
}
// Struct: 120
/// <summary>VkEventCreateInfo - Structure specifying parameters of a newly created event
/// <para>   sType must be VK_STRUCTURE_TYPE_EVENT_CREATE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkEventCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*           pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkEventCreateFlags    flags;
}
// Struct: 121
/// <summary>VkExportFenceCreateInfo - Structure specifying handle types that can be exported from a fence
/// <para>  The bits in handleTypes must be supported and compatible, asreported by VkExternalFenceProperties.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO </para>
/// <para>   handleTypes must be a valid combination of VkExternalFenceHandleTypeFlagBits values</para>
/// </summary>
public unsafe struct VkExportFenceCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                   sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                       pNext;
    /// <summary> handleTypes is a bitmask of
    /// VkExternalFenceHandleTypeFlagBits specifying one or more fence
    /// handle types the application can export from the resulting fence.
    /// The application can request multiple handle types for the same fence.</summary>
    public VkExternalFenceHandleTypeFlags    handleTypes;
}
// Struct: 122
/// <summary>VkExportFenceWin32HandleInfoKHR - Structure specifying additional attributes of Windows handles exported from a fence
/// <para>If this structure is not present, or if pAttributes is set to NULL,default security descriptor values will be used, and child processes createdby the application will not inherit the handle, as described in the MSDNdocumentation for “Synchronization Object Security and Access Rights”1.Further, if the structure is not present, the access rights will be</para>
/// <para> DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE </para>
/// <para>for handles of the following types:</para>
/// <para> VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT </para>
/// <para> https://msdn.microsoft.com/en-us/library/windows/desktop/ms686670.aspx </para>
/// <para>  If VkExportFenceCreateInfo::handleTypes does not includeVK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,VkExportFenceWin32HandleInfoKHR must not be in the pNextchain of VkFenceCreateInfo.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR </para>
/// <para>   If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value</para>
/// </summary>
public unsafe struct VkExportFenceWin32HandleInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                   pNext;
    /// <summary> pAttributes is a pointer to a Windows SECURITY_ATTRIBUTES
    /// structure specifying security attributes of the handle.</summary>
    public /* const */ SECURITY_ATTRIBUTES*    pAttributes;
    /// <summary> dwAccess is a DWORD specifying access rights of the handle.</summary>
    public DWORD                         dwAccess;
    /// <summary> name is a NULL-terminated UTF-16 string to associate with the
    /// underlying synchronization primitive referenced by NT handles exported
    /// from the created fence.</summary>
    public LPCWSTR                       name;
}
// Struct: 123
/// <summary>VkExportMemoryAllocateInfo - Specify exportable handle types for a device memory object
/// <para>  The bits in handleTypes must be supported and compatible, asreported by VkExternalImageFormatProperties orVkExternalBufferProperties.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO </para>
/// <para>   handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values</para>
/// </summary>
public unsafe struct VkExportMemoryAllocateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                        pNext;
    /// <summary> handleTypes is a bitmask of
    /// VkExternalMemoryHandleTypeFlagBits specifying one or more memory
    /// handle types the application can export from the resulting allocation.
    /// The application can request multiple handle types for the same
    /// allocation.</summary>
    public VkExternalMemoryHandleTypeFlags    handleTypes;
}
// Struct: 124
/// <summary>VkExportMemoryAllocateInfoNV - Specify memory handle types that may be exported
/// <para>   sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV </para>
/// <para>   handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values</para>
/// </summary>
public unsafe struct VkExportMemoryAllocateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                          pNext;
    /// <summary> handleTypes is a bitmask of
    /// VkExternalMemoryHandleTypeFlagBitsNV specifying one or more memory
    /// handle types that may be exported.
    /// Multiple handle types may be requested for the same allocation as long
    /// as they are compatible, as reported by
    /// vkGetPhysicalDeviceExternalImageFormatPropertiesNV.</summary>
    public VkExternalMemoryHandleTypeFlagsNV    handleTypes;
}
// Struct: 125
/// <summary>VkExportMemoryWin32HandleInfoKHR - Structure specifying additional attributes of Windows handles exported from a memory
/// <para>If this structure is not present, or if pAttributes is set to NULL,default security descriptor values will be used, and child processes createdby the application will not inherit the handle, as described in the MSDNdocumentation for “Synchronization Object Security and Access Rights”1.Further, if the structure is not present, the access rights will be</para>
/// <para> DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE </para>
/// <para>for handles of the following types:</para>
/// <para> VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT </para>
/// <para>And</para>
/// <para> GENERIC_ALL </para>
/// <para>for handles of the following types:</para>
/// <para> VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT </para>
/// <para> https://msdn.microsoft.com/en-us/library/windows/desktop/ms686670.aspx </para>
/// <para>  If VkExportMemoryAllocateInfo::handleTypes does not includeVK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, orVK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,VkExportMemoryWin32HandleInfoKHR must not be in the pNextchain of VkMemoryAllocateInfo.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR </para>
/// <para>   If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value</para>
/// </summary>
public unsafe struct VkExportMemoryWin32HandleInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                   pNext;
    /// <summary> pAttributes is a pointer to a Windows SECURITY_ATTRIBUTES
    /// structure specifying security attributes of the handle.</summary>
    public /* const */ SECURITY_ATTRIBUTES*    pAttributes;
    /// <summary> dwAccess is a DWORD specifying access rights of the handle.</summary>
    public DWORD                         dwAccess;
    /// <summary> name is a NULL-terminated UTF-16 string to associate with the
    /// underlying resource referenced by NT handles exported from the created
    /// memory.</summary>
    public LPCWSTR                       name;
}
// Struct: 126
/// <summary>VkExportMemoryWin32HandleInfoNV - specify security attributes and access rights for Win32 memory handles
/// <para>If this structure is not present, or if pAttributes is set to NULL,default security descriptor values will be used, and child processes createdby the application will not inherit the handle, as described in the MSDNdocumentation for “Synchronization Object Security and Access Rights”[1].Further, if the structure is not present, the access rights will be</para>
/// <para>[1] https://msdn.microsoft.com/en-us/library/windows/desktop/ms686670.aspx </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV </para>
/// <para>   If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value</para>
/// </summary>
public unsafe struct VkExportMemoryWin32HandleInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                   pNext;
    /// <summary> pAttributes is a pointer to a Windows SECURITY_ATTRIBUTES
    /// structure specifying security attributes of the handle.</summary>
    public /* const */ SECURITY_ATTRIBUTES*    pAttributes;
    /// <summary> dwAccess is a DWORD specifying access rights of the handle.</summary>
    public DWORD                         dwAccess;
}
// Struct: 127
/// <summary>VkExportSemaphoreCreateInfo - Structure specifying handle types that can be exported from a semaphore
/// <para>  The bits in handleTypes must be supported and compatible, asreported by VkExternalSemaphoreProperties.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO </para>
/// <para>   handleTypes must be a valid combination of VkExternalSemaphoreHandleTypeFlagBits values</para>
/// </summary>
public unsafe struct VkExportSemaphoreCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                           pNext;
    /// <summary> handleTypes is a bitmask of
    /// VkExternalSemaphoreHandleTypeFlagBits specifying one or more
    /// semaphore handle types the application can export from the resulting
    /// semaphore.
    /// The application can request multiple handle types for the same
    /// semaphore.</summary>
    public VkExternalSemaphoreHandleTypeFlags    handleTypes;
}
// Struct: 128
/// <summary>VkExportSemaphoreWin32HandleInfoKHR - Structure specifying additional attributes of Windows handles exported from a semaphore
/// <para>If this structure is not present, or if pAttributes is set to NULL,default security descriptor values will be used, and child processes createdby the application will not inherit the handle, as described in the MSDNdocumentation for “Synchronization Object Security and Access Rights”1.Further, if the structure is not present, the access rights will be</para>
/// <para> DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE </para>
/// <para>for handles of the following types:</para>
/// <para> VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT </para>
/// <para>And</para>
/// <para> GENERIC_ALL </para>
/// <para>for handles of the following types:</para>
/// <para> VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT </para>
/// <para> https://msdn.microsoft.com/en-us/library/windows/desktop/ms686670.aspx </para>
/// <para>  If VkExportSemaphoreCreateInfo::handleTypes does not includeVK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT orVK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,VkExportSemaphoreWin32HandleInfoKHR must not be in thepNext chain of VkSemaphoreCreateInfo.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR </para>
/// <para>   If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value</para>
/// </summary>
public unsafe struct VkExportSemaphoreWin32HandleInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                   pNext;
    /// <summary> pAttributes is a pointer to a Windows SECURITY_ATTRIBUTES
    /// structure specifying security attributes of the handle.</summary>
    public /* const */ SECURITY_ATTRIBUTES*    pAttributes;
    /// <summary> dwAccess is a DWORD specifying access rights of the handle.</summary>
    public DWORD                         dwAccess;
    /// <summary> name is a NULL-terminated UTF-16 string to associate with the
    /// underlying synchronization primitive referenced by NT handles exported
    /// from the created semaphore.</summary>
    public LPCWSTR                       name;
}
// Struct: 129
/// <summary>VkExtensionProperties - Structure specifying an extension properties
/// </summary>
public unsafe struct VkExtensionProperties {
    public fixed char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
    /// <summary> specVersion is the version of this extension.
    /// It is an integer, incremented with backward compatible changes.</summary>
    public UInt32    specVersion;
}
// Struct: 130
/// <summary>VkExtent2D - Structure specifying a two-dimensional extent
/// </summary>
public unsafe struct VkExtent2D {
    /// <summary> width is the width of the extent.</summary>
    public UInt32    width;
    /// <summary> height is the height of the extent.</summary>
    public UInt32    height;
}
// Struct: 131
/// <summary>VkExtent3D - Structure specifying a three-dimensional extent
/// </summary>
public unsafe struct VkExtent3D {
    /// <summary> width is the width of the extent.</summary>
    public UInt32    width;
    /// <summary> height is the height of the extent.</summary>
    public UInt32    height;
    /// <summary> depth is the depth of the extent.</summary>
    public UInt32    depth;
}
// Struct: 132
/// <summary>VkExternalBufferProperties - Structure specifying supported external handle capabilities
/// <para>   sType must be VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkExternalBufferProperties {
    /// <summary> sType is the type of this structure</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                         pNext;
    /// <summary> externalMemoryProperties is an instance of the
    /// VkExternalMemoryProperties structure specifying various
    /// capabilities of the external handle type when used with the specified
    /// buffer creation parameters.</summary>
    public VkExternalMemoryProperties    externalMemoryProperties;
}
// Struct: 133
/// <summary>VkExternalFenceProperties - Structure describing supported external fence handle features
/// <para>If handleType is not supported by the implementation, thenVkExternalFenceProperties::externalFenceFeatures will be set tozero.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkExternalFenceProperties {
    public VkStructureType                   sType;
    public void*                             pNext;
    /// <summary> exportFromImportedHandleTypes is a bitmask of
    /// VkExternalFenceHandleTypeFlagBits indicating which types of
    /// imported handle handleType can be exported from.</summary>
    public VkExternalFenceHandleTypeFlags    exportFromImportedHandleTypes;
    /// <summary> compatibleHandleTypes is a bitmask of
    /// VkExternalFenceHandleTypeFlagBits specifying handle types which
    /// can be specified at the same time as handleType when creating a
    /// fence.</summary>
    public VkExternalFenceHandleTypeFlags    compatibleHandleTypes;
    /// <summary> externalFenceFeatures is a bitmask of
    /// VkExternalFenceFeatureFlagBits indicating the features of
    /// handleType.</summary>
    public VkExternalFenceFeatureFlags       externalFenceFeatures;
}
// Struct: 134
/// <summary>VkExternalFormatANDROID - Structure containing an Android hardware buffer external format
/// <para>If externalFormat is zero, the effect is as if theVkExternalFormatANDROID structure was not present.Otherwise, the image will have the specified external format.</para>
/// <para>   externalFormat must be 0 or a value returned in theexternalFormat member ofVkAndroidHardwareBufferFormatPropertiesANDROID by an earlier callto vkGetAndroidHardwareBufferPropertiesANDROID </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID </para>
/// </summary>
public unsafe struct VkExternalFormatANDROID {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> externalFormat is an implementation-defined identifier for the
    /// external format</summary>
    public UInt64           externalFormat;
}
// Struct: 135
/// <summary>VkExternalImageFormatProperties - Structure specifying supported external handle properties
/// <para>   sType must be VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES </para>
/// </summary>
public unsafe struct VkExternalImageFormatProperties {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                         pNext;
    /// <summary> externalMemoryProperties is an instance of the
    /// VkExternalMemoryProperties structure specifying various
    /// capabilities of the external handle type when used with the specified
    /// image creation parameters.</summary>
    public VkExternalMemoryProperties    externalMemoryProperties;
}
// Struct: 136
/// <summary>VkExternalImageFormatPropertiesNV - Structure specifying external image format properties
/// </summary>
public unsafe struct VkExternalImageFormatPropertiesNV {
    /// <summary> imageFormatProperties will be filled in as when calling
    /// vkGetPhysicalDeviceImageFormatProperties, but the values returned
    /// may vary depending on the external handle type requested.</summary>
    public VkImageFormatProperties              imageFormatProperties;
    /// <summary> externalMemoryFeatures is a bitmask of
    /// VkExternalMemoryFeatureFlagBitsNV, indicating properties of the
    /// external memory handle type
    /// (vkGetPhysicalDeviceExternalImageFormatPropertiesNV::externalHandleType)
    /// being queried, or 0 if the external memory handle type is 0.</summary>
    public VkExternalMemoryFeatureFlagsNV       externalMemoryFeatures;
    /// <summary> exportFromImportedHandleTypes is a bitmask of
    /// VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for
    /// every external handle type that may be used to create memory from which
    /// the handles of the type specified in
    /// vkGetPhysicalDeviceExternalImageFormatPropertiesNV::externalHandleType can be exported, or 0 if the external memory handle type is 0.</summary>
    public VkExternalMemoryHandleTypeFlagsNV    exportFromImportedHandleTypes;
    /// <summary> compatibleHandleTypes is a bitmask of
    /// VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for
    /// every external handle type that may be specified simultaneously with
    /// the handle type specified by
    /// vkGetPhysicalDeviceExternalImageFormatPropertiesNV::externalHandleType
    /// when calling vkAllocateMemory, or 0 if the external memory handle
    /// type is 0.
    /// compatibleHandleTypes will always contain
    /// vkGetPhysicalDeviceExternalImageFormatPropertiesNV::externalHandleType </summary>
    public VkExternalMemoryHandleTypeFlagsNV    compatibleHandleTypes;
}
// Struct: 137
/// <summary>VkExternalMemoryBufferCreateInfo - Specify that a buffer may be backed by external memory
/// <para>   sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO </para>
/// <para>   handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values</para>
/// </summary>
public unsafe struct VkExternalMemoryBufferCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                        pNext;
    /// <summary> handleTypes is a bitmask of
    /// VkExternalMemoryHandleTypeFlagBits specifying one or more external
    /// memory handle types.</summary>
    public VkExternalMemoryHandleTypeFlags    handleTypes;
}
// Struct: 138
/// <summary>VkExternalMemoryImageCreateInfo - Specify that an image may be backed by external memory
/// <para>   sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO </para>
/// <para>   handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values</para>
/// <para>   handleTypes must not be 0 </para>
/// </summary>
public unsafe struct VkExternalMemoryImageCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                        pNext;
    /// <summary> handleTypes is a bitmask of
    /// VkExternalMemoryHandleTypeFlagBits specifying one or more external
    /// memory handle types.</summary>
    public VkExternalMemoryHandleTypeFlags    handleTypes;
}
// Struct: 139
/// <summary>VkExternalMemoryImageCreateInfoNV - Specify that an image may be backed by external memory
/// <para>   sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV </para>
/// <para>   handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values</para>
/// </summary>
public unsafe struct VkExternalMemoryImageCreateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                          pNext;
    /// <summary> handleTypes is a bitmask of
    /// VkExternalMemoryHandleTypeFlagBitsNV specifying one or more
    /// external memory handle types.</summary>
    public VkExternalMemoryHandleTypeFlagsNV    handleTypes;
}
// Struct: 140
/// <summary>VkExternalMemoryProperties - Structure specifying external memory handle type capabilities
/// <para> compatibleHandleTypes must include at least handleType.Inclusion of a handle type in compatibleHandleTypes does not imply thevalues returned in VkImageFormatProperties2 will be the same whenVkPhysicalDeviceExternalImageFormatInfo::handleType is set tothat type.The application is responsible for querying the capabilities of all handletypes intended for concurrent use in a single image and intersecting them toobtain the compatible set of capabilities.</para>
/// </summary>
public unsafe struct VkExternalMemoryProperties {
    /// <summary> externalMemoryFeatures is a bitmask of
    /// VkExternalMemoryFeatureFlagBits specifying the features of
    /// handleType.</summary>
    public VkExternalMemoryFeatureFlags       externalMemoryFeatures;
    /// <summary> exportFromImportedHandleTypes is a bitmask of
    /// VkExternalMemoryHandleTypeFlagBits specifying which types of
    /// imported handle handleType can be exported from.</summary>
    public VkExternalMemoryHandleTypeFlags    exportFromImportedHandleTypes;
    /// <summary> compatibleHandleTypes is a bitmask of
    /// VkExternalMemoryHandleTypeFlagBits specifying handle types which
    /// can be specified at the same time as handleType when creating an
    /// image compatible with external memory.</summary>
    public VkExternalMemoryHandleTypeFlags    compatibleHandleTypes;
}
// Struct: 141
/// <summary>VkExternalSemaphoreProperties - Structure describing supported external semaphore handle features
/// <para>If handleType is not supported by the implementation, thenVkExternalSemaphoreProperties::externalSemaphoreFeatures will beset to zero.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkExternalSemaphoreProperties {
    public VkStructureType                       sType;
    public void*                                 pNext;
    /// <summary> exportFromImportedHandleTypes is a bitmask of
    /// VkExternalSemaphoreHandleTypeFlagBits specifying which types of
    /// imported handle handleType can be exported from.</summary>
    public VkExternalSemaphoreHandleTypeFlags    exportFromImportedHandleTypes;
    /// <summary> compatibleHandleTypes is a bitmask of
    /// VkExternalSemaphoreHandleTypeFlagBits specifying handle types
    /// which can be specified at the same time as handleType when
    /// creating a semaphore.</summary>
    public VkExternalSemaphoreHandleTypeFlags    compatibleHandleTypes;
    /// <summary> externalSemaphoreFeatures is a bitmask of
    /// VkExternalSemaphoreFeatureFlagBits describing the features of
    /// handleType.</summary>
    public VkExternalSemaphoreFeatureFlags       externalSemaphoreFeatures;
}
// Struct: 142
/// <summary>VkFenceCreateInfo - Structure specifying parameters of a newly created fence
/// <para>   sType must be VK_STRUCTURE_TYPE_FENCE_CREATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkExportFenceCreateInfo or VkExportFenceWin32HandleInfoKHR </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   flags must be a valid combination of VkFenceCreateFlagBits values</para>
/// </summary>
public unsafe struct VkFenceCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*           pNext;
    /// <summary> flags is a bitmask of VkFenceCreateFlagBits specifying the
    /// initial state and behavior of the fence.</summary>
    public VkFenceCreateFlags    flags;
}
// Struct: 143
/// <summary>VkFenceGetFdInfoKHR - Structure describing a POSIX FD fence export operation
/// <para>The properties of the file descriptor returned depend on the value ofhandleType.See VkExternalFenceHandleTypeFlagBits for a description of theproperties of the defined external fence handle types.</para>
/// <para>   handleType must have been included inVkExportFenceCreateInfo::handleTypes when fence’scurrent payload was created.</para>
/// <para>  If handleType refers to a handle type with copy payloadtransference semantics, fence must be signaled, or have anassociated fence signal operationpending execution.</para>
/// <para>   fence must not currently have its payload replaced by an importedpayload as described below inImporting Fence Payloads unlessthat imported payload’s handle type was included inVkExternalFenceProperties::exportFromImportedHandleTypes forhandleType.</para>
/// <para>   handleType must be defined as a POSIX file descriptor handle.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   fence must be a valid VkFence handle</para>
/// <para>   handleType must be a valid VkExternalFenceHandleTypeFlagBits value</para>
/// </summary>
public unsafe struct VkFenceGetFdInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                          pNext;
    /// <summary> fence is the fence from which state will be exported.</summary>
    public VkFence                              fence;
    /// <summary> handleType is the type of handle requested.</summary>
    public VkExternalFenceHandleTypeFlagBits    handleType;
}
// Struct: 144
/// <summary>VkFenceGetWin32HandleInfoKHR - Structure describing a Win32 handle fence export operation
/// <para>The properties of the handle returned depend on the value ofhandleType.See VkExternalFenceHandleTypeFlagBits for a description of theproperties of the defined external fence handle types.</para>
/// <para>   handleType must have been included inVkExportFenceCreateInfo::handleTypes when the fence’scurrent payload was created.</para>
/// <para>  If handleType is defined as an NT handle,vkGetFenceWin32HandleKHR must be called no more than once foreach valid unique combination of fence and handleType.</para>
/// <para>   fence must not currently have its payload replaced by an importedpayload as described below inImporting Fence Payloads unlessthat imported payload’s handle type was included inVkExternalFenceProperties::exportFromImportedHandleTypes forhandleType.</para>
/// <para>  If handleType refers to a handle type with copy payloadtransference semantics, fence must be signaled, or have anassociated fence signal operationpending execution.</para>
/// <para>   handleType must be defined as an NT handle or a global sharehandle.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   fence must be a valid VkFence handle</para>
/// <para>   handleType must be a valid VkExternalFenceHandleTypeFlagBits value</para>
/// </summary>
public unsafe struct VkFenceGetWin32HandleInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                          pNext;
    /// <summary> fence is the fence from which state will be exported.</summary>
    public VkFence                              fence;
    /// <summary> handleType is the type of handle requested.</summary>
    public VkExternalFenceHandleTypeFlagBits    handleType;
}
// Struct: 145
/// <summary>VkFilterCubicImageViewImageFormatPropertiesEXT - Structure for querying cubic filtering capabilities of an image view type
/// <para>   sType must be VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT </para>
/// <para>  If the pNext chain of the VkImageFormatProperties2 structurecontains an instance ofVkFilterCubicImageViewImageFormatPropertiesEXT, the pNextchain of the VkPhysicalDeviceImageFormatInfo2 structure mustcontain an instance of VkPhysicalDeviceImageViewImageFormatInfoEXTwith an imageViewType that is compatible with imageType.</para>
/// </summary>
public unsafe struct VkFilterCubicImageViewImageFormatPropertiesEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> filterCubic tells if image format, image type and image view type
    /// can be used with cubic filtering.
    /// This field is set by the implementation.
    /// User-specified value is ignored.</summary>
    public VkBool32           filterCubic;
    /// <summary> filterCubicMinmax tells if image format, image type and image view
    /// type can be used with cubic filtering and minmax filtering.
    /// This field is set by the implementation.
    /// User-specified value is ignored.</summary>
    public VkBool32           filterCubicMinmax ;
}
// Struct: 146
/// <summary>VkFormatProperties - Structure specifying image format properties
/// <para>If no format feature flags are supported, the format itself is notsupported, and images of that format cannot be created.</para>
/// <para>If format is a block-compressed format, then bufferFeatures must not support any features for the format.</para>
/// <para>If format is not a multi-plane format then linearTilingFeaturesand optimalTilingFeatures must not containVK_FORMAT_FEATURE_DISJOINT_BIT.</para>
/// </summary>
public unsafe struct VkFormatProperties {
    /// <summary> linearTilingFeatures is a bitmask of VkFormatFeatureFlagBits
    /// specifying features supported by images created with a tiling
    /// parameter of VK_IMAGE_TILING_LINEAR.</summary>
    public VkFormatFeatureFlags    linearTilingFeatures;
    /// <summary> optimalTilingFeatures is a bitmask of
    /// VkFormatFeatureFlagBits specifying features supported by images
    /// created with a tiling parameter of VK_IMAGE_TILING_OPTIMAL.</summary>
    public VkFormatFeatureFlags    optimalTilingFeatures;
    /// <summary> bufferFeatures is a bitmask of VkFormatFeatureFlagBits
    /// specifying features supported by buffers.</summary>
    public VkFormatFeatureFlags    bufferFeatures;
}
// Struct: 147
/// <summary>VkFormatProperties2 - Structure specifying image format properties
/// <para>   sType must be VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkDrmFormatModifierPropertiesListEXT </para>
/// </summary>
public unsafe struct VkFormatProperties2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                 pNext;
    /// <summary> formatProperties is a structure of type VkFormatProperties
    /// describing features supported by the requested format.</summary>
    public VkFormatProperties    formatProperties;
}
// Struct: 148
/// <summary>VkFramebufferCreateInfo - Structure specifying parameters of a newly created framebuffer
/// <para>Applications must ensure that all accesses to memory that backs imagesubresources used as attachments in a given renderpass instance eitherhappen-before the load operations for thoseattachments, or happen-after the storeoperations for those attachments.</para>
/// <para>For depth/stencil attachments, each aspect can be used separately asattachments and non-attachments as long as the non-attachment accesses arealso via an image subresource in either theVK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL layout orthe VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL layout,and the attachment resource uses whichever of those two layouts the imageaccesses do not.Use of non-attachment aspects in this case is only well defined if theattachment is used in the subpass where the non-attachment access is beingmade, or the layout of the image subresource is constant throughout theentire render pass instance, including the initialLayout andfinalLayout.</para>
/// <para>These restrictions meanthat the render pass has full knowledge of all uses of all of theattachments, so that the implementation is able to make correct decisionsabout when and how to perform layout transitions, when to overlap executionof subpasses, etc.</para>
/// <para>It is legal for a subpass to use no color or depth/stencil attachments, andrather use shader side effects such as image stores and atomics to producean output.In this case, the subpass continues to use the width, height,and layers of the framebuffer to define the dimensions of therendering area, and the rasterizationSamples from each pipeline’sVkPipelineMultisampleStateCreateInfo to define the number of samplesused in rasterization; however, ifVkPhysicalDeviceFeatures::variableMultisampleRate isVK_FALSE, then all pipelines to be bound with a given zero-attachmentsubpass must have the same value forVkPipelineMultisampleStateCreateInfo::rasterizationSamples.</para>
/// <para>   attachmentCount must be equal to the attachment count specifiedin renderPass </para>
/// <para>  Each element of pAttachments that is used as a color attachment orresolve attachment by renderPass must have been created with ausage value including VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT </para>
/// <para>  Each element of pAttachments that is used as a depth/stencilattachment by renderPass must have been created with ausage value includingVK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT </para>
/// <para>  Each element of pAttachments that is used as a depth/stencilresolve attachment by renderPass must have been created with ausage value includingVK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT </para>
/// <para>  Each element of pAttachments that is used as an input attachmentby renderPass must have been created with a usage valueincluding VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT </para>
/// <para>  Each element of pAttachments that is used as a fragment densitymap attachment by renderPass must not have been created with aflags value including VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT.</para>
/// <para>  If renderPass has a fragment density map attachment andnon-subsample image feature is notenabled, each element of pAttachments must have been created witha flags value including VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXTunless that element is the fragment density map attachment.</para>
/// <para>  Each element of pAttachments must have been created with anVkFormat value that matches the VkFormat specified by thecorresponding VkAttachmentDescription in renderPass </para>
/// <para>  Each element of pAttachments must have been created with asamples value that matches the samples value specified bythe corresponding VkAttachmentDescription in renderPass </para>
/// <para>  Each element of pAttachments must have dimensions at least aslarge as the corresponding framebuffer dimension except for any elementthat is referenced by fragmentDensityMapAttachment </para>
/// <para>  An element of pAttachments that is referenced byfragmentDensityMapAttachment must have a width at least as largeas\(\lceil{\frac{width}{maxFragmentDensityTexelSize_{width}}}\rceil\)</para>
/// <para>  An element of pAttachments that is referenced byfragmentDensityMapAttachment must have a height at least as largeas\(\lceil{\frac{height}{maxFragmentDensityTexelSize_{height}}}\rceil\)</para>
/// <para>  Each element of pAttachments must only specify a single mip level</para>
/// <para>  Each element of pAttachments must have been created with theidentity swizzle</para>
/// <para>   width must be greater than 0.</para>
/// <para>   width must be less than or equal toVkPhysicalDeviceLimits::maxFramebufferWidth </para>
/// <para>   height must be greater than 0.</para>
/// <para>   height must be less than or equal toVkPhysicalDeviceLimits::maxFramebufferHeight </para>
/// <para>   layers must be greater than 0.</para>
/// <para>   layers must be less than or equal toVkPhysicalDeviceLimits::maxFramebufferLayers </para>
/// <para>  Each element of pAttachments that is a 2D or 2D array image viewtaken from a 3D image must not be a depth/stencil format</para>
/// <para>  If renderPass was specified with non-zero view masks, layers must be greater than or equal to the greatest position of any bitincluded in any of those view masks</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   renderPass must be a valid VkRenderPass handle</para>
/// <para>   If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkImageView handles</para>
/// <para>   Both of renderPass, and the elements of pAttachments that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkFramebufferCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                 pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkFramebufferCreateFlags    flags;
    /// <summary> renderPass is a render pass that defines what render passes the
    /// framebuffer will be compatible with.
    /// See Render Pass Compatibility for details.</summary>
    public VkRenderPass                renderPass;
    /// <summary> attachmentCount is the number of attachments.</summary>
    public UInt32                    attachmentCount;
    /// <summary> pAttachments is an array of VkImageView handles, each of
    /// which will be used as the corresponding attachment in a render pass
    /// instance.</summary>
    public /* const */ VkImageView*          pAttachments;
    /// <summary> width, height and layers define the dimensions of the
    /// framebuffer.
    /// If the render pass uses multiview, then layers must be one and
    /// each attachment requires a number of layers that is greater than the
    /// maximum bit index set in the view mask in the subpasses in which it is
    /// used.</summary>
    public UInt32                    width;
    public UInt32                    height;
    public UInt32                    layers;
}
// Struct: 149
/// <summary>VkGeometryAABBNV - Structure specifying axis-aligned bounding box geometry in a bottom-level acceleration structure
/// <para>The AABB data in memory is six 32-bit floats consisting of the minimum x, y,and z values followed by the maximum x, y, and z values.</para>
/// <para>   offset must be less than the size of aabbData </para>
/// <para>   offset must be a multiple of 8 </para>
/// <para>   stride must be a multiple of 8 </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV </para>
/// <para>   pNext must be NULL </para>
/// <para>   If aabbData is not VK_NULL_HANDLE, aabbData must be a valid VkBuffer handle</para>
/// </summary>
public unsafe struct VkGeometryAABBNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> aabbData is the buffer containing axis-aligned bounding box data.</summary>
    public VkBuffer           aabbData;
    /// <summary> numAABBs is the number of AABBs in this geometry.</summary>
    public UInt32           numAABBs;
    /// <summary> stride is the stride in bytes between AABBs in aabbData.</summary>
    public UInt32           stride;
    /// <summary> offset is the offset in bytes of the first AABB in aabbData.</summary>
    public VkDeviceSize       offset;
}
// Struct: 150
/// <summary>VkGeometryDataNV - Structure specifying geometry in a bottom-level acceleration structure
/// <para>   triangles must be a valid VkGeometryTrianglesNV structure</para>
/// <para>   aabbs must be a valid VkGeometryAABBNV structure</para>
/// </summary>
public unsafe struct VkGeometryDataNV {
    /// <summary> triangles contains triangle data if
    /// VkGeometryNV::geometryType is
    /// VK_GEOMETRY_TYPE_TRIANGLES_NV.</summary>
    public VkGeometryTrianglesNV    triangles;
    /// <summary> aabbs contains axis-aligned bounding box data if
    /// VkGeometryNV::geometryType is
    /// VK_GEOMETRY_TYPE_AABBS_NV.</summary>
    public VkGeometryAABBNV         aabbs;
}
// Struct: 151
/// <summary>VkGeometryNV - Structure specifying a geometry in a bottom-level acceleration structure
/// <para>   sType must be VK_STRUCTURE_TYPE_GEOMETRY_NV </para>
/// <para>   pNext must be NULL </para>
/// <para>   geometryType must be a valid VkGeometryTypeNV value</para>
/// <para>   geometry must be a valid VkGeometryDataNV structure</para>
/// <para>   flags must be a valid combination of VkGeometryFlagBitsNV values</para>
/// </summary>
public unsafe struct VkGeometryNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*          pNext;
    /// <summary> geometryType describes which type of geometry this
    /// VkGeometryNV refers to.</summary>
    public VkGeometryTypeNV     geometryType;
    /// <summary> geometry contains the geometry data as described in
    /// VkGeometryDataNV.</summary>
    public VkGeometryDataNV     geometry;
    /// <summary> flags has flags describing options for this geometry.</summary>
    public VkGeometryFlagsNV    flags;
}
// Struct: 152
/// <summary>VkGeometryTrianglesNV - Structure specifying a triangle geometry in a bottom-level acceleration structure
/// <para>If indexType is VK_INDEX_TYPE_NONE_NV, then this structuredescribes a set of triangles determined by vertexCount.Otherwise, this structure describes a set of indexed triangles determined byindexCount.</para>
/// <para>   vertexOffset must be less than the size of vertexData </para>
/// <para>   vertexOffset must be a multiple of the component size ofvertexFormat </para>
/// <para>   vertexFormat must be one of VK_FORMAT_R32G32B32_SFLOAT,VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R16G16B16_SFLOAT,VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R16G16_SNORM, orVK_FORMAT_R16G16B16_SNORM </para>
/// <para>   indexOffset must be less than the size of indexData </para>
/// <para>   indexOffset must be a multiple of the element size ofindexType </para>
/// <para>   indexType must be VK_INDEX_TYPE_UINT16,VK_INDEX_TYPE_UINT32, or VK_INDEX_TYPE_NONE_NV </para>
/// <para>   indexData must be VK_NULL_HANDLE if indexType isVK_INDEX_TYPE_NONE_NV </para>
/// <para>   indexData must be a valid VkBuffer handle ifindexType is not VK_INDEX_TYPE_NONE_NV </para>
/// <para>   indexCount must be 0 if indexType isVK_INDEX_TYPE_NONE_NV </para>
/// <para>   transformOffset must be less than the size of transformData </para>
/// <para>   transformOffset must be a multiple of 16 </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV </para>
/// <para>   pNext must be NULL </para>
/// <para>   If vertexData is not VK_NULL_HANDLE, vertexData must be a valid VkBuffer handle</para>
/// <para>   vertexFormat must be a valid VkFormat value</para>
/// <para>   If indexData is not VK_NULL_HANDLE, indexData must be a valid VkBuffer handle</para>
/// <para>   indexType must be a valid VkIndexType value</para>
/// <para>   If transformData is not VK_NULL_HANDLE, transformData must be a valid VkBuffer handle</para>
/// <para>   Each of indexData, transformData, and vertexData that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkGeometryTrianglesNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> vertexData is the buffer containing vertex data for this geometry.</summary>
    public VkBuffer           vertexData;
    /// <summary> vertexOffset is the offset in bytes within vertexData
    /// containing vertex data for this geometry.</summary>
    public VkDeviceSize       vertexOffset;
    /// <summary> vertexCount is the number of valid vertices.</summary>
    public UInt32           vertexCount;
    /// <summary> vertexStride is the stride in bytes between each vertex.</summary>
    public VkDeviceSize       vertexStride;
    /// <summary> vertexFormat is the format of each vertex element.</summary>
    public VkFormat           vertexFormat;
    /// <summary> indexData is the buffer containing index data for this geometry.</summary>
    public VkBuffer           indexData;
    /// <summary> indexOffset is the offset in bytes within indexData
    /// containing index data for this geometry.</summary>
    public VkDeviceSize       indexOffset;
    /// <summary> indexCount is the number of indices to include in this geometry.</summary>
    public UInt32           indexCount;
    /// <summary> indexType is the format of each index.</summary>
    public VkIndexType        indexType;
    /// <summary> transformData is a buffer containing optional reference to an
    /// array of 32-bit floats representing a 3x4 row major affine
    /// transformation matrix for this geometry.</summary>
    public VkBuffer           transformData;
    /// <summary> transformOffset is the offset in bytes in transformData of
    /// the transform information described above.</summary>
    public VkDeviceSize       transformOffset;
}
// Struct: 153
/// <summary>VkGraphicsPipelineCreateInfo - Structure specifying parameters of a newly created graphics pipeline
/// <para>The parameters basePipelineHandle and basePipelineIndex aredescribed in more detail in PipelineDerivatives.</para>
/// <para> pStages points to an array of VkPipelineShaderStageCreateInfostructures, which were previously described in ComputePipelines.</para>
/// <para> pDynamicState points to a structure of typeVkPipelineDynamicStateCreateInfo.</para>
/// <para>If any shader stage fails to compile,the compile log will be reported back to the application, andVK_ERROR_INVALID_SHADER_NV will be generated.</para>
/// <para>  If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BITflag, and basePipelineIndex is -1, basePipelineHandle mustbe a valid handle to a graphics VkPipeline </para>
/// <para>  If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BITflag, and basePipelineHandle is VK_NULL_HANDLE,basePipelineIndex must be a valid index into the callingcommand’s pCreateInfos parameter</para>
/// <para>  If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BITflag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE </para>
/// <para>  If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BITflag, and basePipelineHandle is not VK_NULL_HANDLE,basePipelineIndex must be -1</para>
/// <para>  The stage member of each element of pStages must be unique</para>
/// <para>  The geometric shader stages provided in pStages must be eitherfrom the mesh shading pipeline (stage isVK_SHADER_STAGE_TASK_BIT_NV or VK_SHADER_STAGE_MESH_BIT_NV)or from the primitive shading pipeline (stage isVK_SHADER_STAGE_VERTEX_BIT,VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, orVK_SHADER_STAGE_GEOMETRY_BIT).</para>
/// <para>  The stage member of one element of pStages must be eitherVK_SHADER_STAGE_VERTEX_BIT or VK_SHADER_STAGE_MESH_BIT_NV.</para>
/// <para>  The stage member of each element of pStages must not beVK_SHADER_STAGE_COMPUTE_BIT </para>
/// <para>  If pStages includes a tessellation control shader stage, it mustinclude a tessellation evaluation shader stage</para>
/// <para>  If pStages includes a tessellation evaluation shader stage, itmust include a tessellation control shader stage</para>
/// <para>  If pStages includes a tessellation control shader stage and atessellation evaluation shader stage, pTessellationState must bea valid pointer to a valid VkPipelineTessellationStateCreateInfostructure</para>
/// <para>  If pStages includes tessellation shader stages, the shader code ofat least one stage must contain an OpExecutionMode instructionthat specifies the type of subdivision in the pipeline</para>
/// <para>  If pStages includes tessellation shader stages, and the shadercode of both stages contain an OpExecutionMode instruction thatspecifies the type of subdivision in the pipeline, they must bothspecify the same subdivision mode</para>
/// <para>  If pStages includes tessellation shader stages, the shader code ofat least one stage must contain an OpExecutionMode instructionthat specifies the output patch size in the pipeline</para>
/// <para>  If pStages includes tessellation shader stages, and the shadercode of both contain an OpExecutionMode instruction that specifiesthe out patch size in the pipeline, they must both specify the samepatch size</para>
/// <para>  If pStages includes tessellation shader stages, the topologymember of pInputAssembly must beVK_PRIMITIVE_TOPOLOGY_PATCH_LIST </para>
/// <para>  If the topology member of pInputAssembly isVK_PRIMITIVE_TOPOLOGY_PATCH_LIST, pStages must includetessellation shader stages</para>
/// <para>  If pStages includes a geometry shader stage, and does not includeany tessellation shader stages, its shader code must contain anOpExecutionMode instruction that specifies an input primitive typethat is compatible with the primitivetopology specified in pInputAssembly </para>
/// <para>  If pStages includes a geometry shader stage, and also includestessellation shader stages, its shader code must contain anOpExecutionMode instruction that specifies an input primitive typethat is compatible with the primitivetopology that is output by the tessellation stages</para>
/// <para>  If pStages includes a fragment shader stage and a geometry shaderstage, and the fragment shader code reads from an input variable that isdecorated with PrimitiveID, then the geometry shader code mustwrite to a matching output variable, decorated with PrimitiveID, inall execution paths</para>
/// <para>  If pStages includes a fragment shader stage, its shader code mustnot read from any input attachment that is defined asVK_ATTACHMENT_UNUSED in subpass </para>
/// <para>  The shader code for the entry points identified by pStages, andthe rest of the state identified by this structure must adhere to thepipeline linking rules described in the Shader Interfaceschapter</para>
/// <para>  If rasterization is not disabled and subpass uses a depth/stencilattachment in renderPass that has a layout ofVK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMALor VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMALin the VkAttachmentReference defined by subpass, thedepthWriteEnable member of pDepthStencilState must beVK_FALSE </para>
/// <para>  If rasterization is not disabled and subpass uses a depth/stencilattachment in renderPass that has a layout ofVK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMALor VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMALin the VkAttachmentReference defined by subpass, thefailOp, passOp and depthFailOp members of each of thefront and back members of pDepthStencilState must beVK_STENCIL_OP_KEEP </para>
/// <para>  If rasterization is not disabled and the subpass uses color attachments,then for each color attachment in the subpass the blendEnablemember of the corresponding element of the pAttachment member ofpColorBlendState must be VK_FALSE if the attached image’sformat features does not containVK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT.</para>
/// <para>  If rasterization is not disabled and the subpass uses color attachments,the attachmentCount member of pColorBlendState must beequal to the colorAttachmentCount used to create subpass </para>
/// <para>  If no element of the pDynamicStates member of pDynamicStateis VK_DYNAMIC_STATE_VIEWPORT, the pViewports member ofpViewportState must be a valid pointer to an array ofpViewportState::viewportCount valid VkViewportstructures</para>
/// <para>  If no element of the pDynamicStates member of pDynamicStateis VK_DYNAMIC_STATE_SCISSOR, the pScissors member ofpViewportState must be a valid pointer to an array ofpViewportState::scissorCount VkRect2D structures</para>
/// <para>  If the wide lines feature is not enabled, and no element of thepDynamicStates member of pDynamicState isVK_DYNAMIC_STATE_LINE_WIDTH, the lineWidth member ofpRasterizationState must be 1.0 </para>
/// <para>  If the rasterizerDiscardEnable member of pRasterizationStateis VK_FALSE, pViewportState must be a valid pointer to avalid VkPipelineViewportStateCreateInfo structure</para>
/// <para>  If the rasterizerDiscardEnable member of pRasterizationStateis VK_FALSE, pMultisampleState must be a valid pointer to avalid VkPipelineMultisampleStateCreateInfo structure</para>
/// <para>  If the rasterizerDiscardEnable member of pRasterizationStateis VK_FALSE, and subpass uses a depth/stencil attachment,pDepthStencilState must be a valid pointer to a validVkPipelineDepthStencilStateCreateInfo structure</para>
/// <para>  If the rasterizerDiscardEnable member of pRasterizationStateis VK_FALSE, and subpass uses color attachments,pColorBlendState must be a valid pointer to a validVkPipelineColorBlendStateCreateInfo structure</para>
/// <para>  If the depth bias clamping feature is not enabled, no element of thepDynamicStates member of pDynamicState isVK_DYNAMIC_STATE_DEPTH_BIAS, and the depthBiasEnable memberof pRasterizationState is VK_TRUE, the depthBiasClampmember of pRasterizationState must be 0.0 </para>
/// <para>  If the  html/vkspec.html#VK_EXT_depth_range_unrestricted  extension is not enabledand no element of the pDynamicStates member of pDynamicStateis VK_DYNAMIC_STATE_DEPTH_BOUNDS, and thedepthBoundsTestEnable member of pDepthStencilState isVK_TRUE, the minDepthBounds and maxDepthBounds membersof pDepthStencilState must be between 0.0 and 1.0, inclusive</para>
/// <para>  If no element of the pDynamicStates member of pDynamicStateis VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and thesampleLocationsEnable member of aVkPipelineSampleLocationsStateCreateInfoEXT structure chained tothe pNext chain of pMultisampleState is VK_TRUE,sampleLocationsInfo.sampleLocationGridSize.width must evenlydivideVkMultisamplePropertiesEXT::sampleLocationGridSize.width asreturned by vkGetPhysicalDeviceMultisamplePropertiesEXT with asamples parameter equaling rasterizationSamples </para>
/// <para>  If no element of the pDynamicStates member of pDynamicStateis VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and thesampleLocationsEnable member of aVkPipelineSampleLocationsStateCreateInfoEXT structure chained tothe pNext chain of pMultisampleState is VK_TRUE,sampleLocationsInfo.sampleLocationGridSize.height must evenlydivideVkMultisamplePropertiesEXT::sampleLocationGridSize.height asreturned by vkGetPhysicalDeviceMultisamplePropertiesEXT with asamples parameter equaling rasterizationSamples </para>
/// <para>  If no element of the pDynamicStates member of pDynamicStateis VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and thesampleLocationsEnable member of aVkPipelineSampleLocationsStateCreateInfoEXT structure chained tothe pNext chain of pMultisampleState is VK_TRUE,sampleLocationsInfo.sampleLocationsPerPixel must equalrasterizationSamples </para>
/// <para>  If the sampleLocationsEnable member of aVkPipelineSampleLocationsStateCreateInfoEXT structure chained tothe pNext chain of pMultisampleState is VK_TRUE, thefragment shader code must not statically use the extended instructionInterpolateAtSample </para>
/// <para>   layout must beconsistent with allshaders specified in pStages </para>
/// <para>  If neither the VK_AMD_mixed_attachment_samples nor theVK_NV_framebuffer_mixed_samples extensions are enabled, and ifsubpass uses color and/or depth/stencil attachments, then therasterizationSamples member of pMultisampleState must bethe same as the sample count for those subpass attachments</para>
/// <para>  If the VK_AMD_mixed_attachment_samples extension is enabled, and ifsubpass uses color and/or depth/stencil attachments, then therasterizationSamples member of pMultisampleState must equalthe maximum of the sample counts of those subpass attachments</para>
/// <para>  If the VK_NV_framebuffer_mixed_samples extension is enabled, and ifsubpass has a depth/stencil attachment and depth test, stenciltest, or depth bounds test are enabled, then therasterizationSamples member of pMultisampleState must bethe same as the sample count of the depth/stencil attachment</para>
/// <para>  If the VK_NV_framebuffer_mixed_samples extension is enabled, and ifsubpass has any color attachments, then therasterizationSamples member of pMultisampleState must begreater than or equal to the sample count for those subpass attachments</para>
/// <para>  If subpass does not use any color and/or depth/stencilattachments, then the rasterizationSamples member ofpMultisampleState must follow the rules for azero-attachment subpass </para>
/// <para>   subpass must be a valid subpass within renderPass </para>
/// <para>  If the renderPass has multiview enabled and subpass has morethan one bit set in the view mask and multiviewTessellationShaderis not enabled, then pStages must not include tessellationshaders.</para>
/// <para>  If the renderPass has multiview enabled and subpass has morethan one bit set in the view mask and multiviewGeometryShader isnot enabled, then pStages must not include a geometry shader.</para>
/// <para>  If the renderPass has multiview enabled and subpass has morethan one bit set in the view mask, shaders in the pipeline must notwrite to the Layer built-in output</para>
/// <para>  If the renderPass has multiview enabled, then all shaders mustnot include variables decorated with the Layer built-in decorationin their interfaces.</para>
/// <para>   flags must not contain the VK_PIPELINE_CREATE_DISPATCH_BASEflag.</para>
/// <para>  If pStages includes a fragment shader stage and an inputattachment was referenced by theVkRenderPassInputAttachmentAspectCreateInfo at renderPasscreate time, its shader code must not read from any aspect that was notspecified in the aspectMask of the correspondingVkInputAttachmentAspectReference structure.</para>
/// <para>  The number of resources in layout accessible to each shader stagethat is used by the pipeline must be less than or equal toVkPhysicalDeviceLimits::maxPerStageResources </para>
/// <para>  If no element of the pDynamicStates member of pDynamicStateis VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV, and theviewportWScalingEnable member of aVkPipelineViewportWScalingStateCreateInfoNV structure, chained tothe pNext chain of pViewportState, is VK_TRUE, thepViewportWScalings member of theVkPipelineViewportWScalingStateCreateInfoNV must be a pointer toan array ofVkPipelineViewportWScalingStateCreateInfoNV::viewportCountvalid VkViewportWScalingNV structures</para>
/// <para>  If pStages includes a vertex shader stage, pVertexInputState must be a valid pointer to a validVkPipelineVertexInputStateCreateInfo structure</para>
/// <para>  If pStages includes a vertex shader stage,pInputAssemblyState must be a valid pointer to a validVkPipelineInputAssemblyStateCreateInfo structure</para>
/// <para>  The Xfb execution mode can be specified by only one shader stagein pStages </para>
/// <para>  If any shader stage in pStages specifies Xfb execution modeit must be the last vertex processing stage</para>
/// <para>  If aVkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStreamvalue other than zero is specified, all variables in the outputinterface of the entry point being compiled decorated withPosition, PointSize, ClipDistance, or CullDistance must all be decorated with identical Stream values that match therasterizationStream </para>
/// <para>  IfVkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStreamis zero, or not specified, all variables in the output interface of theentry point being compiled decorated with Position, PointSize,ClipDistance, or CullDistance must all be decorated with aStream value of zero, or must not specify the Streamdecoration</para>
/// <para>  If the last vertex processing stage is a geometry shader, and thatgeometry shader uses the GeometryStreams capability, thenVkPhysicalDeviceTransformFeedbackFeaturesEXT::geometryStreamsfeature must be enabled</para>
/// <para>  If there are any mesh shader stages in the pipeline there must not beany shader stage in the pipeline with a Xfb execution mode.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineCreationFeedbackCreateInfoEXT, VkPipelineDiscardRectangleStateCreateInfoEXT, or VkPipelineRepresentativeFragmentTestStateCreateInfoNV </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   flags must be a valid combination of VkPipelineCreateFlagBits values</para>
/// <para>   pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures</para>
/// <para>   pRasterizationState must be a valid pointer to a valid VkPipelineRasterizationStateCreateInfo structure</para>
/// <para>   If pDynamicState is not NULL, pDynamicState must be a valid pointer to a valid VkPipelineDynamicStateCreateInfo structure</para>
/// <para>   layout must be a valid VkPipelineLayout handle</para>
/// <para>   renderPass must be a valid VkRenderPass handle</para>
/// <para>   stageCount must be greater than 0 </para>
/// <para>   Each of basePipelineHandle, layout, and renderPass that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkGraphicsPipelineCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                                  sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                      pNext;
    /// <summary> flags is a bitmask of VkPipelineCreateFlagBits specifying
    /// how the pipeline will be generated.</summary>
    public VkPipelineCreateFlags                            flags;
    /// <summary> stageCount is the number of entries in the pStages array.</summary>
    public UInt32                                         stageCount;
    /// <summary> pStages is an array of size stageCount structures of type
    /// VkPipelineShaderStageCreateInfo describing the set of the shader
    /// stages to be included in the graphics pipeline.</summary>
    public /* const */ VkPipelineShaderStageCreateInfo*           pStages;
    /// <summary> pVertexInputState is a pointer to an instance of the
    /// VkPipelineVertexInputStateCreateInfo structure.
    /// It is ignored if the pipeline includes a mesh shader stage.</summary>
    public /* const */ VkPipelineVertexInputStateCreateInfo*      pVertexInputState;
    /// <summary> pInputAssemblyState is a pointer to an instance of the
    /// VkPipelineInputAssemblyStateCreateInfo structure which determines
    /// input assembly behavior, as described in Drawing Commands.
    /// It is ignored if the pipeline includes a mesh shader stage.</summary>
    public /* const */ VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;
    /// <summary> pTessellationState is a pointer to an instance of the
    /// VkPipelineTessellationStateCreateInfo structure, and is ignored if
    /// the pipeline does not include a tessellation control shader stage and
    /// tessellation evaluation shader stage.</summary>
    public /* const */ VkPipelineTessellationStateCreateInfo*     pTessellationState;
    /// <summary> pViewportState is a pointer to an instance of the
    /// VkPipelineViewportStateCreateInfo structure, and is ignored if the
    /// pipeline has rasterization disabled.</summary>
    public /* const */ VkPipelineViewportStateCreateInfo*         pViewportState;
    /// <summary> pRasterizationState is a pointer to an instance of the
    /// VkPipelineRasterizationStateCreateInfo structure.</summary>
    public /* const */ VkPipelineRasterizationStateCreateInfo*    pRasterizationState;
    /// <summary> pMultisampleState is a pointer to an instance of the
    /// VkPipelineMultisampleStateCreateInfo, and is ignored if the
    /// pipeline has rasterization disabled.</summary>
    public /* const */ VkPipelineMultisampleStateCreateInfo*      pMultisampleState;
    /// <summary> pDepthStencilState is a pointer to an instance of the
    /// VkPipelineDepthStencilStateCreateInfo structure, and is ignored if
    /// the pipeline has rasterization disabled or if the subpass of the render
    /// pass the pipeline is created against does not use a depth/stencil
    /// attachment.</summary>
    public /* const */ VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;
    /// <summary> pColorBlendState is a pointer to an instance of the
    /// VkPipelineColorBlendStateCreateInfo structure, and is ignored if
    /// the pipeline has rasterization disabled or if the subpass of the render
    /// pass the pipeline is created against does not use any color attachments.</summary>
    public /* const */ VkPipelineColorBlendStateCreateInfo*       pColorBlendState;
    /// <summary> pDynamicState is a pointer to
    /// VkPipelineDynamicStateCreateInfo and is used to indicate which
    /// properties of the pipeline state object are dynamic and can be changed
    /// independently of the pipeline state.
    /// This can be NULL, which means no state in the pipeline is considered
    /// dynamic.</summary>
    public /* const */ VkPipelineDynamicStateCreateInfo*          pDynamicState;
    /// <summary> layout is the description of binding locations used by both the
    /// pipeline and descriptor sets used with the pipeline.</summary>
    public VkPipelineLayout                                 layout;
    /// <summary> renderPass is a handle to a render pass object describing the
    /// environment in which the pipeline will be used; the pipeline must only
    /// be used with an instance of any render pass compatible with the one
    /// provided.
    /// See Render Pass Compatibility for more
    /// information.</summary>
    public VkRenderPass                                     renderPass;
    /// <summary> subpass is the index of the subpass in the render pass where this
    /// pipeline will be used.</summary>
    public UInt32                                         subpass;
    /// <summary> basePipelineHandle is a pipeline to derive from.</summary>
    public VkPipeline                                       basePipelineHandle;
    /// <summary> basePipelineIndex is an index into the pCreateInfos
    /// parameter to use as a pipeline to derive from.</summary>
    public Int32                                          basePipelineIndex;
}
// Struct: 154
/// <summary>VkHdrMetadataEXT - structure to specify Hdr metadata
/// <para>   sType must be VK_STRUCTURE_TYPE_HDR_METADATA_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>The validity and use of this data is outside the scope of Vulkan.</para>
/// </summary>
public unsafe struct VkHdrMetadataEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> displayPrimaryRed is the mastering display’s red primary in
    /// chromaticity coordinates</summary>
    public VkXYColorEXT       displayPrimaryRed;
    /// <summary> displayPrimaryGreen is the mastering display’s green primary in
    /// chromaticity coordinates</summary>
    public VkXYColorEXT       displayPrimaryGreen;
    /// <summary> displayPrimaryBlue is the mastering display’s blue primary in
    /// chromaticity coordinates</summary>
    public VkXYColorEXT       displayPrimaryBlue;
    /// <summary> whitePoint is the mastering display’s white-point in chromaticity
    /// coordinates</summary>
    public VkXYColorEXT       whitePoint;
    /// <summary> maxLuminance is the maximum luminance of the mastering display in
    /// nits</summary>
    public float              maxLuminance;
    /// <summary> minLuminance is the minimum luminance of the mastering display in
    /// nits</summary>
    public float              minLuminance;
    /// <summary> maxContentLightLevel is content’s maximum luminance in nits</summary>
    public float              maxContentLightLevel;
    /// <summary> maxFrameAverageLightLevel is the maximum frame average light level
    /// in nits</summary>
    public float              maxFrameAverageLightLevel;
}
// Struct: 155
/// <summary>VkIOSSurfaceCreateInfoMVK - Structure specifying parameters of a newly created iOS surface object
/// <para>   pView must be a valid UIView and must be backed by aCALayer instance of type CAMetalLayer.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkIOSSurfaceCreateInfoMVK {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                   pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkIOSSurfaceCreateFlagsMVK    flags;
    /// <summary> pView is a reference to a UIView object which will display
    /// this surface.
    /// This UIView must be backed by a CALayer instance of type
    /// CAMetalLayer.</summary>
    public /* const */ void*                   pView;
}
// Struct: 156
/// <summary>VkImageBlit - Structure specifying an image blit operation
/// <para>For each element of the pRegions array, a blit operation is performedthe specified source and destination regions.</para>
/// <para>  The aspectMask member of srcSubresource anddstSubresource must match</para>
/// <para>  The layerCount member of srcSubresource anddstSubresource must match</para>
/// <para>  If either of the calling command’s srcImage or dstImageparameters are of VkImageType VK_IMAGE_TYPE_3D, thebaseArrayLayer and layerCount members of bothsrcSubresource and dstSubresource must be 0 and 1,respectively</para>
/// <para>  The aspectMask member of srcSubresource must specifyaspects present in the calling command’s srcImage </para>
/// <para>  The aspectMask member of dstSubresource must specifyaspects present in the calling command’s dstImage </para>
/// <para>   srcOffset[0].x and srcOffset[1].x must both begreater than or equal to 0 and less than or equal to the source imagesubresource width</para>
/// <para>   srcOffset[0].y and srcOffset[1].y must both begreater than or equal to 0 and less than or equal to the source imagesubresource height</para>
/// <para>  If the calling command’s srcImage is of typeVK_IMAGE_TYPE_1D, then srcOffset[0].y must be 0 andsrcOffset[1].y must be 1.</para>
/// <para>   srcOffset[0].z and srcOffset[1].z must both begreater than or equal to 0 and less than or equal to the source imagesubresource depth</para>
/// <para>  If the calling command’s srcImage is of typeVK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, thensrcOffset[0].z must be 0 and srcOffset[1].z must be 1.</para>
/// <para>   dstOffset[0].x and dstOffset[1].x must both begreater than or equal to 0 and less than or equal to the destinationimage subresource width</para>
/// <para>   dstOffset[0].y and dstOffset[1].y must both begreater than or equal to 0 and less than or equal to the destinationimage subresource height</para>
/// <para>  If the calling command’s dstImage is of typeVK_IMAGE_TYPE_1D, then dstOffset[0].y must be 0 anddstOffset[1].y must be 1.</para>
/// <para>   dstOffset[0].z and dstOffset[1].z must both begreater than or equal to 0 and less than or equal to the destinationimage subresource depth</para>
/// <para>  If the calling command’s dstImage is of typeVK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, thendstOffset[0].z must be 0 and dstOffset[1].z must be 1.</para>
/// <para>   srcSubresource must be a valid VkImageSubresourceLayers structure</para>
/// <para>   dstSubresource must be a valid VkImageSubresourceLayers structure</para>
/// </summary>
public unsafe struct VkImageBlit {
    /// <summary> srcSubresource is the subresource to blit from.</summary>
    public VkImageSubresourceLayers    srcSubresource;
    public fixed VkOffset3D                  srcOffsets[2];
    /// <summary> dstSubresource is the subresource to blit into.</summary>
    public VkImageSubresourceLayers    dstSubresource;
    public fixed VkOffset3D                  dstOffsets[2];
}
// Struct: 157
/// <summary>VkImageCopy - Structure specifying an image copy operation
/// <para>For VK_IMAGE_TYPE_3D images, copies are performed slice by slicestarting with the z member of the srcOffset or dstOffset,and copying depth slices.For images with multiple layers, copies are performed layer by layerstarting with the baseArrayLayer member of the srcSubresource ordstSubresource and copying layerCount layers.Image data can be copied between images with different image types.If one image is VK_IMAGE_TYPE_3D and the other image isVK_IMAGE_TYPE_2D with multiple layers, then each slice is copied to orfrom a different layer.</para>
/// <para>Copies involving a multi-planar image format specify the region to be copied in terms of theplane to be copied, not the coordinates of the multi-planar image.This means that copies accessing the R/B planes of “_422” formatimages must fit the copied region within half the width of the parentimage, and that copies accessing the R/B planes of “_420” formatimages must fit the copied region within half the width andheight of the parent image.</para>
/// <para>  If neither the calling command’s srcImage nor the callingcommand’s dstImage has amulti-planar imageformat then the aspectMask member of srcSubresource anddstSubresource must match</para>
/// <para>  If the calling command’s srcImage has a VkFormat withtwo planes then thesrcSubresource aspectMask must beVK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT </para>
/// <para>  If the calling command’s srcImage has a VkFormat withthree planes then thesrcSubresource aspectMask must beVK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, orVK_IMAGE_ASPECT_PLANE_2_BIT </para>
/// <para>  If the calling command’s dstImage has a VkFormat withtwo planes then thedstSubresource aspectMask must beVK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT </para>
/// <para>  If the calling command’s dstImage has a VkFormat withthree planes then thedstSubresource aspectMask must beVK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, orVK_IMAGE_ASPECT_PLANE_2_BIT </para>
/// <para>  If the calling command’s srcImage has amulti-planar image formatand the dstImage does not have a multi-planar image format, thedstSubresource aspectMask must beVK_IMAGE_ASPECT_COLOR_BIT </para>
/// <para>  If the calling command’s dstImage has amulti-planar image formatand the srcImage does not have a multi-planar image format, thesrcSubresource aspectMask must beVK_IMAGE_ASPECT_COLOR_BIT </para>
/// <para>  The number of slices of the extent (for 3D) or layers of thesrcSubresource (for non-3D) must match the number of slices ofthe extent (for 3D) or layers of the dstSubresource (fornon-3D)</para>
/// <para>  If either of the calling command’s srcImage or dstImageparameters are of VkImageType VK_IMAGE_TYPE_3D, thebaseArrayLayer and layerCount members of the correspondingsubresource must be 0 and 1, respectively</para>
/// <para>  The aspectMask member of srcSubresource must specifyaspects present in the calling command’s srcImage </para>
/// <para>  The aspectMask member of dstSubresource must specifyaspects present in the calling command’s dstImage </para>
/// <para>   srcOffset.x and (extent.width + srcOffset.x) must both be greater than or equal to 0 and lessthan or equal to the source image subresource width</para>
/// <para>   srcOffset.y and (extent.height + srcOffset.y) must both be greater than or equal to 0 and lessthan or equal to the source image subresource height</para>
/// <para>  If the calling command’s srcImage is of typeVK_IMAGE_TYPE_1D, then srcOffset.y must be 0 andextent.height must be 1.</para>
/// <para>   srcOffset.z and (extent.depth + srcOffset.z) must both be greater than or equal to 0 and lessthan or equal to the source image subresource depth</para>
/// <para>  If the calling command’s srcImage is of typeVK_IMAGE_TYPE_1D, then srcOffset.z must be 0 andextent.depth must be 1.</para>
/// <para>  If the calling command’s dstImage is of typeVK_IMAGE_TYPE_1D, then dstOffset.z must be 0 andextent.depth must be 1.</para>
/// <para>  If the calling command’s srcImage is of typeVK_IMAGE_TYPE_2D, then srcOffset.z must be 0.</para>
/// <para>  If the calling command’s dstImage is of typeVK_IMAGE_TYPE_2D, then dstOffset.z must be 0.</para>
/// <para>  If both srcImage and dstImage are of typeVK_IMAGE_TYPE_2D then extent.depth must be 1.</para>
/// <para>  If the calling command’s srcImage is of typeVK_IMAGE_TYPE_2D, and the dstImage is of typeVK_IMAGE_TYPE_3D, then extent.depth must equal to thelayerCount member of srcSubresource.</para>
/// <para>  If the calling command’s dstImage is of typeVK_IMAGE_TYPE_2D, and the srcImage is of typeVK_IMAGE_TYPE_3D, then extent.depth must equal to thelayerCount member of dstSubresource.</para>
/// <para>   dstOffset.x and (extent.width + dstOffset.x) must both be greater than or equal to 0 and lessthan or equal to the destination image subresource width</para>
/// <para>   dstOffset.y and (extent.height + dstOffset.y) must both be greater than or equal to 0 and lessthan or equal to the destination image subresource height</para>
/// <para>  If the calling command’s dstImage is of typeVK_IMAGE_TYPE_1D, then dstOffset.y must be 0 andextent.height must be 1.</para>
/// <para>   dstOffset.z and (extent.depth + dstOffset.z) must both be greater than or equal to 0 and lessthan or equal to the destination image subresource depth</para>
/// <para>  If the calling command’s srcImage is a compressed image,or a single-plane, “_422” image format,all members of srcOffset must be a multiple of the correspondingdimensions of the compressed texel block</para>
/// <para>  If the calling command’s srcImage is a compressed image,or a single-plane, “_422” image format,extent.width must be a multiple of the compressed texel blockwidth or (extent.width +  srcOffset.x) must equalthe source image subresource width</para>
/// <para>  If the calling command’s srcImage is a compressed image,or a single-plane, “_422” image format,extent.height must be a multiple of the compressed texel blockheight or (extent.height +  srcOffset.y) mustequal the source image subresource height</para>
/// <para>  If the calling command’s srcImage is a compressed image,or a single-plane, “_422” image format,extent.depth must be a multiple of the compressed texel blockdepth or (extent.depth +  srcOffset.z) must equalthe source image subresource depth</para>
/// <para>  If the calling command’s dstImage is a compressed format image,or a single-plane, “_422” image format,all members of dstOffset must be a multiple of the correspondingdimensions of the compressed texel block</para>
/// <para>  If the calling command’s dstImage is a compressed format image,or a single-plane, “_422” image format,extent.width must be a multiple of the compressed texel blockwidth or (extent.width +  dstOffset.x) must equalthe destination image subresource width</para>
/// <para>  If the calling command’s dstImage is a compressed format image,or a single-plane, “_422” image format,extent.height must be a multiple of the compressed texel blockheight or (extent.height +  dstOffset.y) mustequal the destination image subresource height</para>
/// <para>  If the calling command’s dstImage is a compressed format image,or a single-plane, “_422” image format,extent.depth must be a multiple of the compressed texel blockdepth or (extent.depth +  dstOffset.z) must equalthe destination image subresource depth</para>
/// <para>   srcSubresource must be a valid VkImageSubresourceLayers structure</para>
/// <para>   dstSubresource must be a valid VkImageSubresourceLayers structure</para>
/// </summary>
public unsafe struct VkImageCopy {
    /// <summary> srcSubresource and dstSubresource are
    /// VkImageSubresourceLayers structures specifying the image
    /// subresources of the images used for the source and destination image
    /// data, respectively.</summary>
    public VkImageSubresourceLayers    srcSubresource;
    /// <summary> srcOffset and dstOffset select the initial x, y,
    /// and z offsets in texels of the sub-regions of the source and
    /// destination image data.</summary>
    public VkOffset3D                  srcOffset;
    public VkImageSubresourceLayers    dstSubresource;
    public VkOffset3D                  dstOffset;
    /// <summary> extent is the size in texels of the image to copy in width,
    /// height and depth.</summary>
    public VkExtent3D                  extent;
}
// Struct: 158
/// <summary>VkImageCreateInfo - Structure specifying the parameters of a newly created image object
/// <para>Images created with tiling equal to VK_IMAGE_TILING_LINEAR havefurther restrictions on their limits and capabilities compared to imagescreated with tiling equal to VK_IMAGE_TILING_OPTIMAL.Creation of images with tiling VK_IMAGE_TILING_LINEAR may not besupported unless other parameters meet all of the constraints:</para>
/// <para> imageType is VK_IMAGE_TYPE_2D </para>
/// <para> format is not a depth/stencil format</para>
/// <para> mipLevels is 1</para>
/// <para> arrayLayers is 1</para>
/// <para> samples is VK_SAMPLE_COUNT_1_BIT </para>
/// <para> usage only includes VK_IMAGE_USAGE_TRANSFER_SRC_BIT and/orVK_IMAGE_USAGE_TRANSFER_DST_BIT </para>
/// <para>Images created with a format from one of those listed inhtml/vkspec.html#formats-requiring-sampler-ycbcr-conversion have further restrictions ontheir limits and capabilities compared to images created with other formats.Creation of images with a format requiringY’CBCR conversion maynot be supported unless other parameters meet all of the constraints:</para>
/// <para> imageType is VK_IMAGE_TYPE_2D </para>
/// <para> mipLevels is 1</para>
/// <para> arrayLayers is 1</para>
/// <para> samples is VK_SAMPLE_COUNT_1_BIT </para>
/// <para>Implementations may support additional limits and capabilities beyond thoselisted above.</para>
/// <para>To determine the set of valid usage bits for a given format, callvkGetPhysicalDeviceFormatProperties.</para>
/// <para>If the size of the resultant image would exceed maxResourceSize, thenvkCreateImage must fail and returnVK_ERROR_OUT_OF_DEVICE_MEMORY.This failure may occur even when all image creation parameters satisfytheir valid usage requirements.</para>
/// <para>For images created without VK_IMAGE_CREATE_EXTENDED_USAGE_BIT ausage bit is valid if it is supported for the format the image iscreated with.</para>
/// <para>For images created with VK_IMAGE_CREATE_EXTENDED_USAGE_BIT ausage bit is valid if it is supported for at least one of the formatsa VkImageView created from the image can have (seeImage Views for more detail).</para>
/// <para>Valid values for some image creation parameters are limited by a numericalupper bound or by inclusion in a bitset.For example, VkImageCreateInfo::arrayLayers is limited byimageCreateMaxArrayLayers, defined below; andVkImageCreateInfo::samples is limited byimageCreateSampleCounts, also defined below.</para>
/// <para>Several limiting values are defined below, as well as assisting values fromwhich the limiting values are derived.The limiting values are referenced by the relevant valid usage statements ofVkImageCreateInfo.</para>
/// <para>Let uint64_t imageCreateDrmFormatModifiers[] be the set ofLinux DRM format modifiers that theresultant image may have.</para>
/// <para>If tiling is not VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,then imageCreateDrmFormatModifiers is empty.</para>
/// <para>If VkImageCreateInfo::pNext containsVkImageDrmFormatModifierExplicitCreateInfoEXT, thenimageCreateDrmFormatModifiers contains exactly one modifier,VkImageDrmFormatModifierExplicitCreateInfoEXT::drmFormatModifier.</para>
/// <para>If VkImageCreateInfo::pNext containsVkImageDrmFormatModifierListCreateInfoEXT, thenimageCreateDrmFormatModifiers contains the exactly the modifiersinVkImageDrmFormatModifierListCreateInfoEXT::pDrmFormatModifiers.</para>
/// <para>Let VkBool32 imageCreateMaybeLinear indicate if the resultant imagemay be linear.</para>
/// <para>If tiling is VK_IMAGE_TILING_LINEAR, thenimageCreateMaybeLinear is true.</para>
/// <para>If tiling is VK_IMAGE_TILING_OPTIMAL, thenimageCreateMaybeLinear is false.</para>
/// <para>If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, thenimageCreateMaybeLinear_ is true if and only ifimageCreateDrmFormatModifiers containsDRM_FORMAT_MOD_LINEAR.</para>
/// <para>Let VkFormatFeatureFlags imageCreateFormatFeatures be the set offormat features available during image creation.</para>
/// <para>If tiling is VK_IMAGE_TILING_LINEAR, thenimageCreateFormatFeatures is the value ofVkImageFormatProperties::linearTilingFeatures found bycalling vkGetPhysicalDeviceFormatProperties with parameterformat equal to VkImageCreateInfo::format.</para>
/// <para>If tiling is VK_IMAGE_TILING_OPTIMAL,and if the pNext chain contains no instance ofVkExternalFormatANDROID with non-zero externalFormat,then imageCreateFormatFeatures is value ofVkImageFormatProperties::optimalTilingFeatures found bycalling vkGetPhysicalDeviceFormatProperties with parameterformat equal to VkImageCreateInfo::format.</para>
/// <para>If tiling is VK_IMAGE_TILING_OPTIMAL, and if thepNext chain contains an instance of VkExternalFormatANDROIDwith non-zero externalFormat, thenimageCreateFormatFeatures is the value ofVkAndroidHardwareBufferFormatPropertiesANDROID::formatFeaturesobtained by vkGetAndroidHardwareBufferPropertiesANDROID with amatching externalFormat value.</para>
/// <para>If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, thenthe value of imageCreateFormatFeatures is found by callingvkGetPhysicalDeviceFormatProperties2 withVkImageFormatProperties::format equal toVkImageCreateInfo::format and withVkDrmFormatModifierPropertiesListEXT chained intoVkImageFormatProperties2; by collecting all members of thereturned arrayVkDrmFormatModifierPropertiesListEXT::pDrmFormatModifierPropertieswhose drmFormatModifier belongs toimageCreateDrmFormatModifiers; and by taking the bitwiseintersection, over the collected array members, ofdrmFormatModifierTilingFeatures.(The resultant imageCreateFormatFeatures may be empty).</para>
/// <para>Let VkImageFormatProperties2 imageCreateImageFormatPropertiesList[] bedefined as follows.</para>
/// <para>If VkImageCreateInfo::pNext contains no instance ofVkExternalFormatANDROID with non-zero externalFormat, thenimageCreateImageFormatPropertiesList isthe list of structures obtained by callingvkGetPhysicalDeviceImageFormatProperties2, possibly multipletimes, as follows:</para>
/// <para>The parameters VkPhysicalDeviceImageFormatInfo2::format,imageType, tiling, usage, and flags must beequal to those in VkImageCreateInfo.</para>
/// <para>If VkImageCreateInfo::pNext contains an instance ofVkExternalMemoryImageCreateInfo where handleTypes is not0, then VkPhysicalDeviceImageFormatInfo2::pNext mustcontain an instance of VkPhysicalDeviceExternalImageFormatInfowhere handleType is not 0; andvkGetPhysicalDeviceImageFormatProperties2 must be called foreach handle type inVkExternalMemoryImageCreateInfo::handleTypes, successivelysettingVkPhysicalDeviceExternalImageFormatInfo::handleType oneach call.</para>
/// <para>If VkImageCreateInfo::pNext contains no instance ofVkExternalMemoryImageCreateInfo or contains an instance wherehandleTypes is 0, thenVkPhysicalDeviceImageFormatInfo2::pNext must eithercontain no instance of VkPhysicalDeviceExternalImageFormatInfoor contain an instance where handleType is 0.</para>
/// <para>If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, thenVkPhysicalDeviceImageFormatInfo2::pNext must contain aninstance of VkPhysicalDeviceImageDrmFormatModifierInfoEXT wheresharingMode is equal toVkImageCreateInfo::sharingMode; and, if sharingModeis VK_SHARING_MODE_CONCURRENT, then queueFamilyIndexCountand pQueueFamilyIndices must be equal to those inVkImageCreateInfo; and, if flags containsVK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, then the instance ofVkImageFormatListCreateInfoKHR in the pNext chain ofVkPhysicalDeviceImageFormatInfo2 must be equivalent to the onein the pNext chain of VkImageCreateInfo; andvkGetPhysicalDeviceImageFormatProperties2 must be called foreach modifier in imageCreateDrmFormatModifiers, successivelysettingVkPhysicalDeviceImageDrmFormatModifierInfoEXT::drmFormatModifieron each call.</para>
/// <para>If tiling is not VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,then VkPhysicalDeviceImageFormatInfo2::pNext must containno instance of VkPhysicalDeviceImageDrmFormatModifierInfoEXT.</para>
/// <para>If any call to vkGetPhysicalDeviceImageFormatProperties2 returnsan error, then imageCreateImageFormatPropertiesList is definedto be the empty list.</para>
/// <para>If VkImageCreateInfo::pNext contains an instance ofVkExternalFormatANDROID with non-zero externalFormat, thenimageCreateImageFormatPropertiesList contains a single elementwhere:</para>
/// <para> VkImageFormatProperties::maxMipLevels is⌊log2(max(extent.width, extent.height,extent.depth))⌋ +  1.</para>
/// <para> VkImageFormatProperties::maxArrayLayers isVkPhysicalDeviceLimits::maxImageArrayLayers.</para>
/// <para>Each component of VkImageFormatProperties::maxExtent isVkPhysicalDeviceLimits::maxImageDimension2D.</para>
/// <para> VkImageFormatProperties::sampleCounts contains exactlyVK_SAMPLE_COUNT_1_BIT.</para>
/// <para>Let uint32_t imageCreateMaxMipLevels bethe minimum value of VkImageFormatProperties::maxMipLevelsin imageCreateImageFormatPropertiesList.The value is undefined if imageCreateImageFormatPropertiesList isempty.</para>
/// <para>Let uint32_t imageCreateMaxArrayLayers bethe minimum value of VkImageFormatProperties::maxArrayLayersin imageCreateImageFormatPropertiesList.The value is undefined if imageCreateImageFormatPropertiesList isempty.</para>
/// <para>Let VkExtent3D imageCreateMaxExtent bethe component-wise minimum over allVkImageFormatProperties::maxExtent values inimageCreateImageFormatPropertiesList.The value is undefined if imageCreateImageFormatPropertiesList isempty.</para>
/// <para>Let VkSampleCountFlags imageCreateSampleCounts bethe intersection of eachVkImageFormatProperties::sampleCounts inimageCreateImageFormatPropertiesList.The value is undefined if imageCreateImageFormatPropertiesList isempty.</para>
/// <para>  Each of the following values (as described inImage Creation Limits) must not beundefined imageCreateMaxMipLevels,imageCreateMaxArrayLayers, imageCreateMaxExtent, andimageCreateSampleCounts.</para>
/// <para>  If sharingMode is VK_SHARING_MODE_CONCURRENT,pQueueFamilyIndices must be a valid pointer to an array ofqueueFamilyIndexCount uint32_t values</para>
/// <para>  If sharingMode is VK_SHARING_MODE_CONCURRENT,queueFamilyIndexCount must be greater than 1 </para>
/// <para>  If sharingMode is VK_SHARING_MODE_CONCURRENT, each elementof pQueueFamilyIndices must be unique and must be less thanpQueueFamilyPropertyCount returned by eithervkGetPhysicalDeviceQueueFamilyProperties orvkGetPhysicalDeviceQueueFamilyProperties2 for thephysicalDevice that was used to create device </para>
/// <para>  If the pNext chain contains an instance ofVkExternalFormatANDROID, and its member externalFormat isnon-zero the format must be VK_FORMAT_UNDEFINED.</para>
/// <para>  If the pNext chain does not contain an instance ofVkExternalFormatANDROID, or does and its memberexternalFormat is 0 the format must not beVK_FORMAT_UNDEFINED.</para>
/// <para>   extent::width must be greater than 0.</para>
/// <para>   extent::height must be greater than 0.</para>
/// <para>   extent::depth must be greater than 0.</para>
/// <para>   mipLevels must be greater than 0 </para>
/// <para>   arrayLayers must be greater than 0 </para>
/// <para>  If flags contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,imageType must be VK_IMAGE_TYPE_2D </para>
/// <para>  If flags containsVK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, imageType mustbe VK_IMAGE_TYPE_2D </para>
/// <para>  If flags contains VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,imageType must be VK_IMAGE_TYPE_3D </para>
/// <para>   extent.width must be less than or equal toimageCreateMaxExtent.width (as defined inImage Creation Limits).</para>
/// <para>   extent.height must be less than or equal toimageCreateMaxExtent.height (as defined inImage Creation Limits).</para>
/// <para>   extent.depth must be less than or equal toimageCreateMaxExtent.depth (as defined inImage Creation Limits).</para>
/// <para>  If imageType is VK_IMAGE_TYPE_2D and flags containsVK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, extent.width andextent.height must be equal and arrayLayers must begreater than or equal to 6</para>
/// <para>  If imageType is VK_IMAGE_TYPE_1D, both extent.heightand extent.depth must be 1 </para>
/// <para>  If imageType is VK_IMAGE_TYPE_2D, extent.depth mustbe 1 </para>
/// <para>   mipLevels must be less than or equal to the number of levels inthe complete mipmap chain based on  extent.width , extent.height , and  extent.depth .</para>
/// <para>   mipLevels must be less than or equal toimageCreateMaxMipLevels (as defined inImage Creation Limits).</para>
/// <para>   arrayLayers must be less than or equal toimageCreateMaxArrayLayers (as defined inImage Creation Limits).</para>
/// <para>  If imageType is VK_IMAGE_TYPE_3D, arrayLayers must be1.</para>
/// <para>  If samples is not VK_SAMPLE_COUNT_1_BIT, thenimageType must be VK_IMAGE_TYPE_2D, flags must notcontain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, mipLevels mustbe equal to 1, and imageCreateMaybeLinear (as defined inImage Creation Limits) must befalse,</para>
/// <para>  If samples is not VK_SAMPLE_COUNT_1_BIT, usage mustnot contain VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT </para>
/// <para>  If usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,then bits other than VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, andVK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT must not be set</para>
/// <para>  If usage includes VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, orVK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.width must beless than or equal toVkPhysicalDeviceLimits::maxFramebufferWidth </para>
/// <para>  If usage includes VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, orVK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.height must beless than or equal toVkPhysicalDeviceLimits::maxFramebufferHeight </para>
/// <para>  If usage includesVK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, extent.width must be less than or equal to\(\lceil{\frac{maxFramebufferWidth}{minFragmentDensityTexelSize_{width}}}\rceil\)</para>
/// <para>  If usage includesVK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, extent.height must be less than or equal to\(\lceil{\frac{maxFramebufferHeight}{minFragmentDensityTexelSize_{height}}}\rceil\)</para>
/// <para>  If usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,usage must also contain at least one ofVK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, orVK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT.</para>
/// <para>   samples must be a bit value that is set inimageCreateSampleCounts (as defined inImage Creation Limits).</para>
/// <para>  If the multisampled storageimages feature is not enabled, and usage containsVK_IMAGE_USAGE_STORAGE_BIT, samples must beVK_SAMPLE_COUNT_1_BIT </para>
/// <para>  If the sparse bindings feature is notenabled, flags must not containVK_IMAGE_CREATE_SPARSE_BINDING_BIT </para>
/// <para>  If the sparse aliased residencyfeature is not enabled, flags must not containVK_IMAGE_CREATE_SPARSE_ALIASED_BIT </para>
/// <para>  If imageType is VK_IMAGE_TYPE_1D, flags must notcontain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT </para>
/// <para>  If the sparse residency for 2Dimages feature is not enabled, and imageType isVK_IMAGE_TYPE_2D, flags must not containVK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT </para>
/// <para>  If the sparse residency for 3Dimages feature is not enabled, and imageType isVK_IMAGE_TYPE_3D, flags must not containVK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT </para>
/// <para>  If the sparse residency for imageswith 2 samples feature is not enabled, imageType isVK_IMAGE_TYPE_2D, and samples isVK_SAMPLE_COUNT_2_BIT, flags must not containVK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT </para>
/// <para>  If the sparse residency for imageswith 4 samples feature is not enabled, imageType isVK_IMAGE_TYPE_2D, and samples isVK_SAMPLE_COUNT_4_BIT, flags must not containVK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT </para>
/// <para>  If the sparse residency for imageswith 8 samples feature is not enabled, imageType isVK_IMAGE_TYPE_2D, and samples isVK_SAMPLE_COUNT_8_BIT, flags must not containVK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT </para>
/// <para>  If the sparse residency for imageswith 16 samples feature is not enabled, imageType isVK_IMAGE_TYPE_2D, and samples isVK_SAMPLE_COUNT_16_BIT, flags must not containVK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT </para>
/// <para>  If flags contains VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT orVK_IMAGE_CREATE_SPARSE_ALIASED_BIT, it must also containVK_IMAGE_CREATE_SPARSE_BINDING_BIT </para>
/// <para>  If any of the bits VK_IMAGE_CREATE_SPARSE_BINDING_BIT,VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, orVK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set,VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT must not also be set</para>
/// <para>  If the protected memory feature is not enabled, flags must notcontain VK_IMAGE_CREATE_PROTECTED_BIT.</para>
/// <para>  If any of the bits VK_IMAGE_CREATE_SPARSE_BINDING_BIT,VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, orVK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set,VK_IMAGE_CREATE_PROTECTED_BIT must not also be set.</para>
/// <para>  If the pNext chain contains an instance ofVkExternalMemoryImageCreateInfoNV, it must not contain aninstance of VkExternalMemoryImageCreateInfo.</para>
/// <para>  If the pNext chain contains an instance ofVkExternalMemoryImageCreateInfo, its handleTypes membermust only contain bits that are also inVkExternalImageFormatProperties::externalMemoryProperties.compatibleHandleTypes,as returned by vkGetPhysicalDeviceImageFormatProperties2 withformat, imageType, tiling, usage, andflags equal to those in this structure, and with an instance ofVkPhysicalDeviceExternalImageFormatInfo in the pNext chain,with a handleType equal to any one of the handle types specifiedin VkExternalMemoryImageCreateInfo::handleTypes </para>
/// <para>  If the pNext chain contains an instance ofVkExternalMemoryImageCreateInfoNV, its handleTypes membermust only contain bits that are also inVkExternalImageFormatPropertiesNV::externalMemoryProperties.compatibleHandleTypes,as returned by vkGetPhysicalDeviceExternalImageFormatPropertiesNVwith format, imageType, tiling, usage, andflags equal to those in this structure, and withexternalHandleType equal to any one of the handle types specifiedin VkExternalMemoryImageCreateInfoNV::handleTypes </para>
/// <para>  If the logical device was created withVkDeviceGroupDeviceCreateInfo::physicalDeviceCount equal to1, flags must not containVK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT </para>
/// <para>  If flags containsVK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT, thenmipLevels must be one, arrayLayers must be one,imageType must be VK_IMAGE_TYPE_2D.and imageCreateMaybeLinear (as defined inImage Creation Limits) must befalse.</para>
/// <para>  If flags containsVK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, then format must be a block-compressed image format,an ETC compressed image format, or anASTC compressed image format.</para>
/// <para>  If flags containsVK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, then flags must also contain VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT.</para>
/// <para>   initialLayout must be VK_IMAGE_LAYOUT_UNDEFINED orVK_IMAGE_LAYOUT_PREINITIALIZED.</para>
/// <para>      If the pNext chain includes aVkExternalMemoryImageCreateInfoorVkExternalMemoryImageCreateInfoNV    structure whose handleTypes member is not 0, initialLayout must be VK_IMAGE_LAYOUT_UNDEFINED </para>
/// <para>  If the image format is one of those listed inhtml/vkspec.html#formats-requiring-sampler-ycbcr-conversion, then mipLevels must be 1</para>
/// <para>  If the image format is one of those listed inhtml/vkspec.html#formats-requiring-sampler-ycbcr-conversion, samples must beVK_SAMPLE_COUNT_1_BIT </para>
/// <para>  If the image format is one of those listed inhtml/vkspec.html#formats-requiring-sampler-ycbcr-conversion, imageType must beVK_IMAGE_TYPE_2D </para>
/// <para>  If the image format is one of those listed inhtml/vkspec.html#formats-requiring-sampler-ycbcr-conversion, and theycbcrImageArrays feature is not enabled, arrayLayers mustbe 1</para>
/// <para>  If format is a multi-planar format, and ifimageCreateFormatFeatures (as defined inImage Creation Limits) does notcontain VK_FORMAT_FEATURE_DISJOINT_BIT, then flags must notcontain VK_IMAGE_CREATE_DISJOINT_BIT.</para>
/// <para>  If format is not a multi-planar format, and flags does notinclude VK_IMAGE_CREATE_ALIAS_BIT, flags must not containVK_IMAGE_CREATE_DISJOINT_BIT </para>
/// <para>  If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, thenthe pNext chain must contain exactly one ofVkImageDrmFormatModifierListCreateInfoEXT orVkImageDrmFormatModifierExplicitCreateInfoEXT.</para>
/// <para>  If the pNext chain containsVkImageDrmFormatModifierListCreateInfoEXT orVkImageDrmFormatModifierExplicitCreateInfoEXT, then tiling must be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT.</para>
/// <para>  If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT andflags contains VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, then thepNext chain must contain VkImageFormatListCreateInfoKHRwith non-zero viewFormatCount.</para>
/// <para>  If flags containsVK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT format must be a depth or depth/stencil format</para>
/// <para>  If the pNext chain includes aVkExternalMemoryImageCreateInfo structure whose handleTypesmember includesVK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,imageType must be VK_IMAGE_TYPE_2D.</para>
/// <para>  If the pNext chain includes aVkExternalMemoryImageCreateInfo structure whose handleTypesmember includesVK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,mipLevels must either be 1 or equal to the number of levels inthe complete mipmap chain based on  extent.width , extent.height , and  extent.depth .</para>
/// <para>  If the pNext chain includes a VkExternalFormatANDROIDstructure whose externalFormat member is not 0, flags must not include VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT.</para>
/// <para>  If the pNext chain includes a VkExternalFormatANDROIDstructure whose externalFormat member is not 0, usage must not include any usages except VK_IMAGE_USAGE_SAMPLED_BIT.</para>
/// <para>  If the pNext chain includes a VkExternalFormatANDROIDstructure whose externalFormat member is not 0, tiling must be VK_IMAGE_TILING_OPTIMAL.</para>
/// <para>  If format is a depth-stencil format and the pNext chaincontains an instance of VkImageStencilUsageCreateInfoEXT, then itsstencilUsage member must only includeVK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT if usage alsoincludes it</para>
/// <para>  If format is a depth-stencil format and the pNext chaincontains an instance of VkImageStencilUsageCreateInfoEXT, then itsstencilUsage member must only includeVK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT if usage alsoincludes it</para>
/// <para>  If Format is a depth-stencil format and the pNext chaincontains an instance of VkImageStencilUsageCreateInfoEXT with itsstencilUsage member includingVK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.width must beless than or equal toVkPhysicalDeviceLimits::maxFramebufferWidth </para>
/// <para>  If format is a depth-stencil format and the pNext chaincontains an instance of VkImageStencilUsageCreateInfoEXT with itsstencilUsage member includingVK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.height must beless than or equal toVkPhysicalDeviceLimits::maxFramebufferHeight </para>
/// <para>  If the multisampled storageimages feature is not enabled, format is a depth-stencil formatand the pNext chain contains an instance ofVkImageStencilUsageCreateInfoEXT with its stencilUsageincluding VK_IMAGE_USAGE_STORAGE_BIT, samples must beVK_SAMPLE_COUNT_1_BIT </para>
/// <para>  If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV,imageType must be VK_IMAGE_TYPE_2D orVK_IMAGE_TYPE_3D </para>
/// <para>  If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, itmust not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT and theformat must not be a depth/stencil format</para>
/// <para>  If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV andimageType is VK_IMAGE_TYPE_2D, extent::width andextent::height must be greater than 1 </para>
/// <para>  If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV andimageType is VK_IMAGE_TYPE_3D, extent::width,extent::height, and extent::depth must begreater than 1 </para>
/// <para>  If usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV,imageType must be VK_IMAGE_TYPE_2D.</para>
/// <para>  If usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV,samples must be VK_SAMPLE_COUNT_1_BIT.</para>
/// <para>  If usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV,tiling must be VK_IMAGE_TILING_OPTIMAL.</para>
/// <para>  If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT,tiling must be VK_IMAGE_TILING_OPTIMAL </para>
/// <para>  If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT,imageType must be VK_IMAGE_TYPE_2D </para>
/// <para>  If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT,flags must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT </para>
/// <para>  If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT,mipLevels must be 1 </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDedicatedAllocationImageCreateInfoNV, VkExternalFormatANDROID, VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfoNV, VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT, VkImageFormatListCreateInfoKHR, VkImageStencilUsageCreateInfoEXT, or VkImageSwapchainCreateInfoKHR </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   flags must be a valid combination of VkImageCreateFlagBits values</para>
/// <para>   imageType must be a valid VkImageType value</para>
/// <para>   format must be a valid VkFormat value</para>
/// <para>   samples must be a valid VkSampleCountFlagBits value</para>
/// <para>   tiling must be a valid VkImageTiling value</para>
/// <para>   usage must be a valid combination of VkImageUsageFlagBits values</para>
/// <para>   usage must not be 0 </para>
/// <para>   sharingMode must be a valid VkSharingMode value</para>
/// <para>   initialLayout must be a valid VkImageLayout value</para>
/// </summary>
public unsafe struct VkImageCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*              pNext;
    /// <summary> flags is a bitmask of VkImageCreateFlagBits describing
    /// additional parameters of the image.</summary>
    public VkImageCreateFlags       flags;
    /// <summary> imageType is a VkImageType value specifying the basic
    /// dimensionality of the image.
    /// Layers in array textures do not count as a dimension for the purposes of
    /// the image type.</summary>
    public VkImageType              imageType;
    /// <summary> format is a VkFormat describing the format and type of the
    /// texel blocks that will be contained in the image.</summary>
    public VkFormat                 format;
    /// <summary> extent is a VkExtent3D describing the number of data
    /// elements in each dimension of the base level.</summary>
    public VkExtent3D               extent;
    /// <summary> mipLevels describes the number of levels of detail available for
    /// minified sampling of the image.</summary>
    public UInt32                 mipLevels;
    /// <summary> arrayLayers is the number of layers in the image.</summary>
    public UInt32                 arrayLayers;
    /// <summary> samples is a VkSampleCountFlagBits specifying the number of
    /// samples per texel.</summary>
    public VkSampleCountFlagBits    samples;
    /// <summary> tiling is a VkImageTiling value specifying the tiling
    /// arrangement of the texel blocks in memory.</summary>
    public VkImageTiling            tiling;
    /// <summary> usage is a bitmask of VkImageUsageFlagBits describing the
    /// intended usage of the image.</summary>
    public VkImageUsageFlags        usage;
    /// <summary> sharingMode is a VkSharingMode value specifying the sharing
    /// mode of the image when it will be accessed by multiple queue families.</summary>
    public VkSharingMode            sharingMode;
    /// <summary> queueFamilyIndexCount is the number of entries in the
    /// pQueueFamilyIndices array.</summary>
    public UInt32                 queueFamilyIndexCount;
    /// <summary> pQueueFamilyIndices is a list of queue families that will access
    /// this image (ignored if sharingMode is not
    /// VK_SHARING_MODE_CONCURRENT).</summary>
    public /* const */ UInt32*          pQueueFamilyIndices;
    /// <summary> initialLayout is a VkImageLayout value specifying the
    /// initial VkImageLayout of all image subresources of the image.
    /// See Image Layouts.</summary>
    public VkImageLayout            initialLayout;
}
// Struct: 159
/// <summary>VkImageDrmFormatModifierExplicitCreateInfoEXT - Specify that an image be created with the provided DRM format modifier and explicit memory layout
/// <para>The i th member of pPlaneLayouts describes the layout of theimage’s i th memory plane (that is,VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT).In each element of pPlaneLayouts, the implementation must ignoresize.The implementation calculates the size of each plane, which the applicationcan query with vkGetImageSubresourceLayout.</para>
/// <para>When creating an image withVkImageDrmFormatModifierExplicitCreateInfoEXT, it is the application’sresponsibility to satisfy all Valid Usage requirements.However, the implementation must validate that the providedpPlaneLayouts, when combined with the provided drmFormatModifierand other creation parameters in VkImageCreateInfo and its pNextchain, produce a valid image.(This validation is necessarily implementation-dependent and outside thescope of Vulkan, and therefore not described by Valid Usage requirements).If this validation fails, then vkCreateImage returnsVK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT.</para>
/// <para>   drmFormatModifier must be compatible with the parameters inVkImageCreateInfo and its pNext chain, as determined byquerying VkPhysicalDeviceImageFormatInfo2KHR extended withVkPhysicalDeviceImageDrmFormatModifierInfoEXT.</para>
/// <para>   drmFormatModifierPlaneCount must be equal to theVkDrmFormatModifierPropertiesEXT::drmFormatModifierPlaneCountassociated with VkImageCreateInfo::format anddrmFormatModifier, as found by queryingVkDrmFormatModifierPropertiesListEXT.</para>
/// <para>  For each element of pPlaneLayouts, size must be 0</para>
/// <para>  For each element of pPlaneLayouts, arrayPitch must be 0 ifVkImageCreateInfo::arrayLayers is 1.</para>
/// <para>  For each element of pPlaneLayouts, depthPitch must be 0 ifVkImageCreateInfo::extent::depth is 1.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT </para>
/// <para>   If drmFormatModifierPlaneCount is not 0, pPlaneLayouts must be a valid pointer to an array of drmFormatModifierPlaneCount VkSubresourceLayout structures</para>
/// </summary>
public unsafe struct VkImageDrmFormatModifierExplicitCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                   pNext;
    /// <summary> drmFormatModifier is the Linux DRM format modifier with which
    /// the image will be created.</summary>
    public UInt64                      drmFormatModifier;
    /// <summary> drmFormatModifierPlaneCount is the number of memory planes in
    /// the image (as reported by VkDrmFormatModifierPropertiesEXT) as
    /// well as the length of the pPlaneLayouts array.</summary>
    public UInt32                      drmFormatModifierPlaneCount;
    /// <summary> pPlaneLayouts is an array of VkSubresourceLayout structures
    /// that describe the image’s memory planes.</summary>
    public /* const */ VkSubresourceLayout*    pPlaneLayouts;
}
// Struct: 160
/// <summary>VkImageDrmFormatModifierListCreateInfoEXT - Specify that an image must be created with a DRM format modifier from the provided list
/// <para>  Each modifier in pDrmFormatModifiers must be compatible with theparameters in VkImageCreateInfo and its pNext chain, asdetermined by querying VkPhysicalDeviceImageFormatInfo2 extendedwith VkPhysicalDeviceImageDrmFormatModifierInfoEXT.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT </para>
/// <para>   pDrmFormatModifiers must be a valid pointer to an array of drmFormatModifierCount uint64_t values</para>
/// <para>   drmFormatModifierCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkImageDrmFormatModifierListCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> drmFormatModifierCount is the length of the
    /// pDrmFormatModifiers array.</summary>
    public UInt32           drmFormatModifierCount;
    /// <summary> pDrmFormatModifiers is an array of Linux DRM format modifiers.</summary>
    public /* const */ UInt64*    pDrmFormatModifiers;
}
// Struct: 161
/// <summary>VkImageDrmFormatModifierPropertiesEXT - Properties of an image’s Linux DRM format modifier
/// <para>If the image was created withVkImageDrmFormatModifierListCreateInfoEXT, then the returneddrmFormatModifier must belong to the list of modifiers provided attime of image creation inVkImageDrmFormatModifierListCreateInfoEXT::pDrmFormatModifiers.If the image was created withVkImageDrmFormatModifierExplicitCreateInfoEXT, then the returneddrmFormatModifier must be the modifier provided at time of imagecreation inVkImageDrmFormatModifierExplicitCreateInfoEXT::drmFormatModifier.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkImageDrmFormatModifierPropertiesEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> drmFormatModifier returns the image’s
    /// Linux DRM format modifier.</summary>
    public UInt64           drmFormatModifier;
}
// Struct: 162
/// <summary>VkImageFormatListCreateInfoKHR - Specify that an image <strong class="purple">can</strong> be used with a particular set of formats
/// <para>If viewFormatCount is zero, pViewFormats is ignored and theimage is created as if the VkImageFormatListCreateInfoKHR structurewere not included in the pNext list of VkImageCreateInfo.</para>
/// <para>  If viewFormatCount is not 0, all of the formats in thepViewFormats array must be compatible with the format specifiedin the format field of VkImageCreateInfo, as described inthe compatibility table.</para>
/// <para>  If VkImageCreateInfo::flags does not containVK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, viewFormatCount must be0 or 1.</para>
/// <para>  If viewFormatCount is not 0,VkImageCreateInfo::format must be in pViewFormats.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR </para>
/// <para>   If viewFormatCount is not 0, pViewFormats must be a valid pointer to an array of viewFormatCount valid VkFormat values</para>
/// </summary>
public unsafe struct VkImageFormatListCreateInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> viewFormatCount is the number of entries in the pViewFormats
    /// array.</summary>
    public UInt32           viewFormatCount;
    /// <summary> pViewFormats is an array which lists of all formats which can be
    /// used when creating views of this image.</summary>
    public /* const */ VkFormat*    pViewFormats;
}
// Struct: 163
/// <summary>VkImageFormatProperties - Structure specifying an image format properties
/// <para>There is no mechanism to query the size of an image before creating it, tocompare that size against maxResourceSize.If an application attempts to create an image that exceeds this limit, thecreation will fail and vkCreateImage will returnVK_ERROR_OUT_OF_DEVICE_MEMORY.While the advertised limit must be at least 231, it may not be possibleto create an image that approaches that size, particularly forVK_IMAGE_TYPE_1D.</para>
/// <para>If the combination of parameters tovkGetPhysicalDeviceImageFormatProperties is not supported by theimplementation for use in vkCreateImage, then all members ofVkImageFormatProperties will be filled with zero.</para>
/// <para>Filling VkImageFormatProperties with zero for unsupported formats isan exception to the usual rule that output structures have undefinedcontents on error.This exception was unintentional, but is preserved for backwardscompatibility.</para>
/// </summary>
public unsafe struct VkImageFormatProperties {
    /// <summary> maxExtent are the maximum image dimensions.
    /// See the Allowed Extent Values section
    /// below for how these values are constrained by type.</summary>
    public VkExtent3D            maxExtent;
    /// <summary> maxMipLevels is the maximum number of mipmap levels.
    /// maxMipLevels must be equal to the number of levels in the
    /// complete mipmap chain based on the  maxExtent.width ,
    ///  maxExtent.height , and  maxExtent.depth , except
    /// when one of the following conditions is true, in which case it may
    /// instead be 1:</summary>
    public UInt32              maxMipLevels;
    /// <summary> maxArrayLayers is the maximum number of array layers.
    /// maxArrayLayers must be no less than
    /// VkPhysicalDeviceLimits::maxImageArrayLayers, except when one
    /// of the following conditions is true, in which case it may instead be
    /// 1:</summary>
    public UInt32              maxArrayLayers;
    /// <summary> sampleCounts is a bitmask of VkSampleCountFlagBits
    /// specifying all the supported sample counts for this image as described
    /// below.</summary>
    public VkSampleCountFlags    sampleCounts;
    /// <summary> maxResourceSize is an upper bound on the total image size in
    /// bytes, inclusive of all image subresources.
    /// Implementations may have an address space limit on total size of a
    /// resource, which is advertised by this property.
    /// maxResourceSize must be at least 231.</summary>
    public VkDeviceSize          maxResourceSize;
}
// Struct: 164
/// <summary>VkImageFormatProperties2 - Structure specifying an image format properties
/// <para>If the combination of parameters tovkGetPhysicalDeviceImageFormatProperties2 is not supported by theimplementation for use in vkCreateImage, then all members ofimageFormatProperties will be filled with zero.</para>
/// <para>Filling imageFormatProperties with zero for unsupported formats is anexception to the usual rule that output structures have undefined contentson error.This exception was unintentional, but is preserved for backwardscompatibility.This exeption only applies to imageFormatProperties, not sType,pNext, or any structures chained from pNext.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkAndroidHardwareBufferUsageANDROID, VkExternalImageFormatProperties, VkFilterCubicImageViewImageFormatPropertiesEXT, VkSamplerYcbcrConversionImageFormatProperties, or VkTextureLODGatherFormatPropertiesAMD </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// </summary>
public unsafe struct VkImageFormatProperties2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.
    /// The pNext chain of VkImageFormatProperties2 is used to allow
    /// the specification of additional capabilities to be returned from
    /// vkGetPhysicalDeviceImageFormatProperties2.</summary>
    public void*                      pNext;
    /// <summary> imageFormatProperties is an instance of a
    /// VkImageFormatProperties structure in which capabilities are
    /// returned.</summary>
    public VkImageFormatProperties    imageFormatProperties;
}
// Struct: 165
/// <summary>VkImageMemoryBarrier - Structure specifying the parameters of an image memory barrier
/// <para>The first access scope islimited to access to memory through the specified image subresource range,via access types in the source access maskspecified by srcAccessMask.If srcAccessMask includes VK_ACCESS_HOST_WRITE_BIT, memorywrites performed by that access type are also made visible, as that accesstype is not performed through a resource.</para>
/// <para>The second access scope islimited to access to memory through the specified image subresource range,via access types in the destination accessmask specified by dstAccessMask.If dstAccessMask includes VK_ACCESS_HOST_WRITE_BIT orVK_ACCESS_HOST_READ_BIT, available memory writes are also made visibleto accesses of those types, as those access types are not performed througha resource.</para>
/// <para>If srcQueueFamilyIndex is not equal to dstQueueFamilyIndex, andsrcQueueFamilyIndex is equal to the current queue family, then thememory barrier defines a queuefamily release operation for the specified image subresource range, andthe second access scope includes no access, as if dstAccessMask was0.</para>
/// <para>If dstQueueFamilyIndex is not equal to srcQueueFamilyIndex, anddstQueueFamilyIndex is equal to the current queue family, then thememory barrier defines a queuefamily acquire operation for the specified image subresource range, andthe first access scope includes no access, as if srcAccessMask was0.</para>
/// <para>If oldLayout is not equal to newLayout, then the memory barrierdefines an image layouttransition for the specified image subresource range.</para>
/// <para>Layout transitions that are performed via image memory barriers execute intheir entirety in submission order,relative to other image layout transitions submitted to the same queue,including those performed by render passes.In effect there is an implicit execution dependency from each such layouttransition to all layout transitions previously submitted to the same queue.</para>
/// <para>The image layout of each image subresource of a depth/stencil image createdwith VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT isdependent on the last sample locations used to render to the imagesubresource as a depth/stencil attachment, thus when the image memberof an VkImageMemoryBarrier is an image created with this flag theapplication can chain a VkSampleLocationsInfoEXT structure to thepNext chain of VkImageMemoryBarrier to specify the samplelocations to use during the image layout transition.</para>
/// <para>If the VkSampleLocationsInfoEXT structure in the pNext chain ofVkImageMemoryBarrier does not match the sample location state lastused to render to the image subresource range specified bysubresourceRange or if no VkSampleLocationsInfoEXT structure isin the pNext chain of VkImageMemoryBarrier then the contents ofthe given image subresource range becomes undefined as if oldLayoutwould equal VK_IMAGE_LAYOUT_UNDEFINED.</para>
/// <para>If image has a multi-planar format and the image is disjoint, thenincluding VK_IMAGE_ASPECT_COLOR_BIT in the aspectMask member ofsubresourceRange is equivalent to includingVK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, and(for three-plane formats only) VK_IMAGE_ASPECT_PLANE_2_BIT.</para>
/// <para>   oldLayout must be VK_IMAGE_LAYOUT_UNDEFINED or the currentlayout of the image subresources affected by the barrier</para>
/// <para>   newLayout must not be VK_IMAGE_LAYOUT_UNDEFINED orVK_IMAGE_LAYOUT_PREINITIALIZED </para>
/// <para>  If image was created with a sharing mode ofVK_SHARING_MODE_CONCURRENT, at least one ofsrcQueueFamilyIndex and dstQueueFamilyIndex must beVK_QUEUE_FAMILY_IGNORED </para>
/// <para>  If image was created with a sharing mode ofVK_SHARING_MODE_CONCURRENT, and one of srcQueueFamilyIndexand dstQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, theother must be VK_QUEUE_FAMILY_IGNORED or a special queue familyreserved for external memory transfers, as described inhtml/vkspec.html#synchronization-queue-transfers.</para>
/// <para>  If image was created with a sharing mode ofVK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex isVK_QUEUE_FAMILY_IGNORED, dstQueueFamilyIndex must also beVK_QUEUE_FAMILY_IGNORED.</para>
/// <para>  If image was created with a sharing mode ofVK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is notVK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or aspecial queue family reserved for external memory transfers, asdescribed in html/vkspec.html#synchronization-queue-transfers.</para>
/// <para>  If image was created with a sharing mode ofVK_SHARING_MODE_EXCLUSIVE and dstQueueFamilyIndex is notVK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or aspecial queue family reserved for external memory transfers, asdescribed in html/vkspec.html#synchronization-queue-transfers.</para>
/// <para>  If image was created with a sharing mode ofVK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex anddstQueueFamilyIndex are not VK_QUEUE_FAMILY_IGNORED, atleast one of them must be the same as the family of the queue that willexecute this barrier</para>
/// <para>   subresourceRange.baseMipLevel must be less than themipLevels specified in VkImageCreateInfo when imagewas created</para>
/// <para>  If subresourceRange.levelCount is notVK_REMAINING_MIP_LEVELS,  subresourceRange.baseMipLevel+  subresourceRange.levelCount  must be less than or equal tothe mipLevels specified in VkImageCreateInfo whenimage was created</para>
/// <para>   subresourceRange.baseArrayLayer must be less than thearrayLayers specified in VkImageCreateInfo when imagewas created</para>
/// <para>  If subresourceRange.layerCount is notVK_REMAINING_ARRAY_LAYERS, subresourceRange.baseArrayLayer + subresourceRange.layerCount  must be less than or equal to thearrayLayers specified in VkImageCreateInfo when imagewas created</para>
/// <para>  If image has a depth/stencil format with both depth and stencilcomponents, then the aspectMask member of subresourceRange must include both VK_IMAGE_ASPECT_DEPTH_BIT andVK_IMAGE_ASPECT_STENCIL_BIT </para>
/// <para>  If image has a single-plane color format or is not disjoint,then the aspectMask member of subresourceRange must beVK_IMAGE_ASPECT_COLOR_BIT </para>
/// <para>  If image has a multi-planar format and the image is disjoint,then the aspectMask member of subresourceRange must includeeither at least one of VK_IMAGE_ASPECT_PLANE_0_BIT,VK_IMAGE_ASPECT_PLANE_1_BIT, andVK_IMAGE_ASPECT_PLANE_2_BIT; or must includeVK_IMAGE_ASPECT_COLOR_BIT </para>
/// <para>  If image has a multi-planar format with only two planes, then theaspectMask member of subresourceRange must not includeVK_IMAGE_ASPECT_PLANE_2_BIT </para>
/// <para>  If either oldLayout or newLayout isVK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then image musthave been created with VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT set</para>
/// <para>  If either oldLayout or newLayout isVK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL then image must have been created withVK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set</para>
/// <para>  If either oldLayout or newLayout isVK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then image must have been created withVK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set</para>
/// <para>  If either oldLayout or newLayout isVK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL thenimage must have been created withVK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set</para>
/// <para>  If either oldLayout or newLayout isVK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL thenimage must have been created withVK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set</para>
/// <para>  If either oldLayout or newLayout isVK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then image musthave been created with VK_IMAGE_USAGE_SAMPLED_BIT orVK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set</para>
/// <para>  If either oldLayout or newLayout isVK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then image must havebeen created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT set</para>
/// <para>  If either oldLayout or newLayout isVK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then image must havebeen created with VK_IMAGE_USAGE_TRANSFER_DST_BIT set</para>
/// <para>  If image is non-sparse then it must be bound completely andcontiguously to a single VkDeviceMemory object</para>
/// <para>  If either oldLayout or newLayout isVK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV then image musthave been created with VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NVset</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkSampleLocationsInfoEXT </para>
/// <para>   srcAccessMask must be a valid combination of VkAccessFlagBits values</para>
/// <para>   dstAccessMask must be a valid combination of VkAccessFlagBits values</para>
/// <para>   oldLayout must be a valid VkImageLayout value</para>
/// <para>   newLayout must be a valid VkImageLayout value</para>
/// <para>   image must be a valid VkImage handle</para>
/// <para>   subresourceRange must be a valid VkImageSubresourceRange structure</para>
/// </summary>
public unsafe struct VkImageMemoryBarrier {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                pNext;
    /// <summary> srcAccessMask is a bitmask of VkAccessFlagBits specifying a
    /// source access mask.</summary>
    public VkAccessFlags              srcAccessMask;
    /// <summary> dstAccessMask is a bitmask of VkAccessFlagBits specifying a
    /// destination access mask.</summary>
    public VkAccessFlags              dstAccessMask;
    /// <summary> oldLayout is the old layout in an
    /// image layout transition.</summary>
    public VkImageLayout              oldLayout;
    /// <summary> newLayout is the new layout in an
    /// image layout transition.</summary>
    public VkImageLayout              newLayout;
    /// <summary> srcQueueFamilyIndex is the source queue family for a
    /// queue family ownership transfer.</summary>
    public UInt32                   srcQueueFamilyIndex;
    /// <summary> dstQueueFamilyIndex is the destination queue family for a
    /// queue family ownership transfer.</summary>
    public UInt32                   dstQueueFamilyIndex;
    /// <summary> image is a handle to the image affected by this barrier.</summary>
    public VkImage                    image;
    /// <summary> subresourceRange describes the image
    /// subresource range within image that is affected by this barrier.</summary>
    public VkImageSubresourceRange    subresourceRange;
}
// Struct: 166
/// <summary>VkImageMemoryRequirementsInfo2 - (None)
/// <para>  If image was created with a multi-planar format and theVK_IMAGE_CREATE_DISJOINT_BIT flag, there must be aVkImagePlaneMemoryRequirementsInfo in the pNext chain of theVkImageMemoryRequirementsInfo2 structure</para>
/// <para>  If image was created with VK_IMAGE_CREATE_DISJOINT_BIT andwith VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then there must bea VkImagePlaneMemoryRequirementsInfo in the pNext chain ofthe VkImageMemoryRequirementsInfo2 structure</para>
/// <para>  If image was not created with theVK_IMAGE_CREATE_DISJOINT_BIT flag, there must not be aVkImagePlaneMemoryRequirementsInfo in the pNext chain of theVkImageMemoryRequirementsInfo2 structure</para>
/// <para>  If image was created with a single-plane format and with anytiling other than VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,then there must not be a VkImagePlaneMemoryRequirementsInfo inthe pNext chain of the VkImageMemoryRequirementsInfo2structure</para>
/// <para>  If image was created with theVK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROIDexternal memory handle type, then image must be bound to memory.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkImagePlaneMemoryRequirementsInfo </para>
/// <para>   image must be a valid VkImage handle</para>
/// </summary>
public unsafe struct VkImageMemoryRequirementsInfo2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> image is the image to query.</summary>
    public VkImage            image;
}
// Struct: 167
/// <summary>VkImagePipeSurfaceCreateInfoFUCHSIA - Structure specifying parameters of a newly created ImagePipe surface object
/// <para>   imagePipeHandle must be a valid zx_handle_t </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkImagePipeSurfaceCreateInfoFUCHSIA {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                         sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                             pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkImagePipeSurfaceCreateFlagsFUCHSIA    flags;
    /// <summary> imagePipeHandle is a zx_handle_t referring to the ImagePipe
    /// to associate with the surface.</summary>
    public zx_handle_t                             imagePipeHandle;
}
// Struct: 168
/// <summary>VkImagePlaneMemoryRequirementsInfo - Structure specifying image plane for memory requirements
/// <para>  If the image’s tiling is VK_IMAGE_TILING_LINEAR orVK_IMAGE_TILING_OPTIMAL, then planeAspect must be a singlevalid format plane for the image.(That is, for a two-plane image planeAspect must beVK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT,and for a three-plane image planeAspect must beVK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT orVK_IMAGE_ASPECT_PLANE_2_BIT).</para>
/// <para>   If the image’s tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then planeAspect must be a single valid memory plane for the image. (That is, aspectMask must specify a plane index that is less than the  drmFormatModifierPlaneCount  associated with the image’s format  and drmFormatModifier .)</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO </para>
/// <para>   planeAspect must be a valid VkImageAspectFlagBits value</para>
/// </summary>
public unsafe struct VkImagePlaneMemoryRequirementsInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*              pNext;
    /// <summary> planeAspect is the aspect corresponding to the image plane to
    /// query.</summary>
    public VkImageAspectFlagBits    planeAspect;
}
// Struct: 169
/// <summary>VkImageResolve - Structure specifying an image resolve operation
/// <para>  The aspectMask member of srcSubresource anddstSubresource must only contain VK_IMAGE_ASPECT_COLOR_BIT </para>
/// <para>  The layerCount member of srcSubresource anddstSubresource must match</para>
/// <para>  If either of the calling command’s srcImage or dstImageparameters are of VkImageType VK_IMAGE_TYPE_3D, thebaseArrayLayer and layerCount members of bothsrcSubresource and dstSubresource must be 0 and 1,respectively</para>
/// <para>   srcOffset.x and (extent.width + srcOffset.x) must both be greater than or equal to 0 and lessthan or equal to the source image subresource width</para>
/// <para>   srcOffset.y and (extent.height + srcOffset.y) must both be greater than or equal to 0 and lessthan or equal to the source image subresource height</para>
/// <para>  If the calling command’s srcImage is of typeVK_IMAGE_TYPE_1D, then srcOffset.y must be 0 andextent.height must be 1.</para>
/// <para>   srcOffset.z and (extent.depth + srcOffset.z) must both be greater than or equal to 0 and lessthan or equal to the source image subresource depth</para>
/// <para>  If the calling command’s srcImage is of typeVK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then srcOffset.z must be 0 and extent.depth must be 1.</para>
/// <para>   dstOffset.x and (extent.width + dstOffset.x) must both be greater than or equal to 0 and lessthan or equal to the destination image subresource width</para>
/// <para>   dstOffset.y and (extent.height + dstOffset.y) must both be greater than or equal to 0 and lessthan or equal to the destination image subresource height</para>
/// <para>  If the calling command’s dstImage is of typeVK_IMAGE_TYPE_1D, then dstOffset.y must be 0 andextent.height must be 1.</para>
/// <para>   dstOffset.z and (extent.depth + dstOffset.z) must both be greater than or equal to 0 and lessthan or equal to the destination image subresource depth</para>
/// <para>  If the calling command’s dstImage is of typeVK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then dstOffset.z must be 0 and extent.depth must be 1.</para>
/// <para>   srcSubresource must be a valid VkImageSubresourceLayers structure</para>
/// <para>   dstSubresource must be a valid VkImageSubresourceLayers structure</para>
/// </summary>
public unsafe struct VkImageResolve {
    /// <summary> srcSubresource and dstSubresource are
    /// VkImageSubresourceLayers structures specifying the image
    /// subresources of the images used for the source and destination image
    /// data, respectively.
    /// Resolve of depth/stencil images is not supported.</summary>
    public VkImageSubresourceLayers    srcSubresource;
    /// <summary> srcOffset and dstOffset select the initial x, y,
    /// and z offsets in texels of the sub-regions of the source and
    /// destination image data.</summary>
    public VkOffset3D                  srcOffset;
    public VkImageSubresourceLayers    dstSubresource;
    public VkOffset3D                  dstOffset;
    /// <summary> extent is the size in texels of the source image to resolve in
    /// width, height and depth.</summary>
    public VkExtent3D                  extent;
}
// Struct: 170
/// <summary>VkImageSparseMemoryRequirementsInfo2 - (None)
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 </para>
/// <para>   pNext must be NULL </para>
/// <para>   image must be a valid VkImage handle</para>
/// </summary>
public unsafe struct VkImageSparseMemoryRequirementsInfo2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> image is the image to query.</summary>
    public VkImage            image;
}
// Struct: 171
/// <summary>VkImageStencilUsageCreateInfoEXT - Specify separate usage flags for the stencil aspect of a depth-stencil image
/// <para>This structure specifies image usages which only apply to the stencil aspectof a depth/stencil format image.When this structure is included in the pNext chain ofVkImageCreateInfo, the stencil aspect of the image must only be usedas specified by stencilUsage.When this structure is not included in the pNext chain ofVkImageCreateInfo, the stencil aspect of an image must only be usedas specified VkImageCreateInfo::usage.Use of other aspects of an image are unaffected by this structure.</para>
/// <para>This structure can also be included in the pNext chain ofVkPhysicalDeviceImageFormatInfo2 to query additional capabilitiesspecific to image creation parameter combinations including a separate setof usage flags for the stencil aspect of the image usingvkGetPhysicalDeviceImageFormatProperties2.When this structure is not present in the pNext chain ofVkPhysicalDeviceImageFormatInfo2 then the implicit value ofstencilUsage matches that ofVkPhysicalDeviceImageFormatInfo2::usage.</para>
/// <para>  If stencilUsage includesVK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, then bits other thanVK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, andVK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT must not be set</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT </para>
/// <para>   stencilUsage must be a valid combination of VkImageUsageFlagBits values</para>
/// <para>   stencilUsage must not be 0 </para>
/// </summary>
public unsafe struct VkImageStencilUsageCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*          pNext;
    /// <summary> stencilUsage is a bitmask of VkImageUsageFlagBits describing
    /// the intended usage of the stencil aspect of the image.</summary>
    public VkImageUsageFlags    stencilUsage;
}
// Struct: 172
/// <summary>VkImageSubresource - Structure specifying an image subresource
/// <para>   aspectMask must be a valid combination of VkImageAspectFlagBits values</para>
/// <para>   aspectMask must not be 0 </para>
/// </summary>
public unsafe struct VkImageSubresource {
    /// <summary> aspectMask is a VkImageAspectFlags selecting the image
    /// aspect.</summary>
    public VkImageAspectFlags    aspectMask;
    /// <summary> mipLevel selects the mipmap level.</summary>
    public UInt32              mipLevel;
    /// <summary> arrayLayer selects the array layer.</summary>
    public UInt32              arrayLayer;
}
// Struct: 173
/// <summary>VkImageSubresourceLayers - Structure specifying an image subresource layers
/// <para>  If aspectMask contains VK_IMAGE_ASPECT_COLOR_BIT, it mustnot contain either of VK_IMAGE_ASPECT_DEPTH_BIT orVK_IMAGE_ASPECT_STENCIL_BIT </para>
/// <para>   aspectMask must not contain VK_IMAGE_ASPECT_METADATA_BIT </para>
/// <para>   aspectMask must not includeVK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i.</para>
/// <para>   layerCount must be greater than 0</para>
/// <para>   aspectMask must be a valid combination of VkImageAspectFlagBits values</para>
/// <para>   aspectMask must not be 0 </para>
/// </summary>
public unsafe struct VkImageSubresourceLayers {
    /// <summary> aspectMask is a combination of VkImageAspectFlagBits,
    /// selecting the color, depth and/or stencil aspects to be copied.</summary>
    public VkImageAspectFlags    aspectMask;
    /// <summary> mipLevel is the mipmap level to copy from.</summary>
    public UInt32              mipLevel;
    /// <summary> baseArrayLayer and layerCount are the starting layer and
    /// number of layers to copy.</summary>
    public UInt32              baseArrayLayer;
    public UInt32              layerCount;
}
// Struct: 174
/// <summary>VkImageSubresourceRange - Structure specifying an image subresource range
/// <para>The number of mipmap levels and array layers must be a subset of the imagesubresources in the image.If an application wants to use all mip levels or layers in an image afterthe baseMipLevel or baseArrayLayer, it can set levelCountand layerCount to the special values VK_REMAINING_MIP_LEVELS andVK_REMAINING_ARRAY_LAYERS without knowing the exact number of miplevels or layers.</para>
/// <para>For cube and cube array image views, the layers of the image view startingat baseArrayLayer correspond to faces in the order +X, -X, +Y, -Y, +Z,-Z.For cube arrays, each set of six sequential layers is a single cube, so thenumber of cube maps in a cube map array view is  layerCount / 6, andimage array layer (baseArrayLayer +  i) is face index(i mod 6) of cube i / 6.If the number of layers in the view, whether set explicitly inlayerCount or implied by VK_REMAINING_ARRAY_LAYERS, is not amultiple of 6, the last cube map in the array must not be accessed.</para>
/// <para> aspectMask must be only VK_IMAGE_ASPECT_COLOR_BIT,VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT ifformat is a color, depth-only or stencil-only format,respectively, except if format is amulti-planar format.If using a depth/stencil format with both depth and stencil components,aspectMask must include at least one ofVK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT, andcan include both.</para>
/// <para>When the VkImageSubresourceRange structure is used to select a subsetof the slices of a 3D image’s mip level in order to create a 2D or 2D arrayimage view of a 3D image created withVK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT, baseArrayLayer andlayerCount specify the first slice index and the number of slices toinclude in the created image view.Such an image view can be used as a framebuffer attachment that refers onlyto the specified range of slices of the selected mip level.However, any layout transitions performed on such an attachment view duringa render pass instance still apply to the entire subresource referencedwhich includes all the slices of the selected mip level.</para>
/// <para>When using an image view of a depth/stencil image to populate a descriptorset (e.g. for sampling in the shader, or for use as an input attachment),the aspectMask must only include one bit and selects whether theimage view is used for depth reads (i.e. using a floating-point sampler orinput attachment in the shader) or stencil reads (i.e. using an unsignedinteger sampler or input attachment in the shader).When an image view of a depth/stencil image is used as a depth/stencilframebuffer attachment, the aspectMask is ignored and both depth andstencil image subresources are used.</para>
/// <para>The components member is of type VkComponentMapping, anddescribes a remapping from components of the image to components of thevector returned by shader image instructions.This remapping must be identity for storage image descriptors, inputattachment descriptors,framebuffer attachments, and any VkImageView used with a combinedimage sampler that enables sampler Y’CBCRconversion.</para>
/// <para>When creating a VkImageView, if samplerY’CBCR conversion is enabled in the sampler, the aspectMask of asubresourceRange used by the VkImageView must beVK_IMAGE_ASPECT_COLOR_BIT.</para>
/// <para>When creating a VkImageView, if sampler Y’CBCR conversion is notenabled in the sampler and the image format ismulti-planar, the image musthave been created with VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, and theaspectMask of the VkImageView’s subresourceRange must beVK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT orVK_IMAGE_ASPECT_PLANE_2_BIT.</para>
/// <para>  If levelCount is not VK_REMAINING_MIP_LEVELS, it must begreater than 0 </para>
/// <para>  If layerCount is not VK_REMAINING_ARRAY_LAYERS, it must begreater than 0 </para>
/// <para>  If aspectMask includes VK_IMAGE_ASPECT_COLOR_BIT, then itmust not include any of VK_IMAGE_ASPECT_PLANE_0_BIT,VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT </para>
/// <para>   aspectMask must not includeVK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i.</para>
/// <para>   aspectMask must be a valid combination of VkImageAspectFlagBits values</para>
/// <para>   aspectMask must not be 0 </para>
/// </summary>
public unsafe struct VkImageSubresourceRange {
    /// <summary> aspectMask is a bitmask of VkImageAspectFlagBits specifying
    /// which aspect(s) of the image are included in the view.</summary>
    public VkImageAspectFlags    aspectMask;
    /// <summary> baseMipLevel is the first mipmap level accessible to the view.</summary>
    public UInt32              baseMipLevel;
    /// <summary> levelCount is the number of mipmap levels (starting from
    /// baseMipLevel) accessible to the view.</summary>
    public UInt32              levelCount;
    /// <summary> baseArrayLayer is the first array layer accessible to the view.</summary>
    public UInt32              baseArrayLayer;
    /// <summary> layerCount is the number of array layers (starting from
    /// baseArrayLayer) accessible to the view.</summary>
    public UInt32              layerCount;
}
// Struct: 175
/// <summary>VkImageSwapchainCreateInfoKHR - Specify that an image will be bound to swapchain memory
/// <para>  If swapchain is not VK_NULL_HANDLE, the fields ofVkImageCreateInfo must match theimplied image creation parametersof the swapchain</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR </para>
/// <para>   If swapchain is not VK_NULL_HANDLE, swapchain must be a valid VkSwapchainKHR handle</para>
/// </summary>
public unsafe struct VkImageSwapchainCreateInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> swapchain is VK_NULL_HANDLE or a handle of a swapchain that
    /// the image will be bound to.</summary>
    public VkSwapchainKHR     swapchain;
}
// Struct: 176
/// <summary>VkImageViewASTCDecodeModeEXT - Structure describing the ASTC decode mode for an image view
/// <para>   decodeMode must be one of VK_FORMAT_R16G16B16A16_SFLOAT,VK_FORMAT_R8G8B8A8_UNORM, orVK_FORMAT_E5B9G9R9_UFLOAT_PACK32 </para>
/// <para>  If the  decodeModeSharedExponent  feature is not enabled,decodeMode must not be VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 </para>
/// <para>  If decodeMode is VK_FORMAT_R8G8B8A8_UNORM the image viewmust not include blocks using any of the ASTC HDR modes</para>
/// <para>   format of the image view must be one ofVK_FORMAT_ASTC_4x4_UNORM_BLOCK,VK_FORMAT_ASTC_4x4_SRGB_BLOCK,VK_FORMAT_ASTC_5x4_UNORM_BLOCK,VK_FORMAT_ASTC_5x4_SRGB_BLOCK,VK_FORMAT_ASTC_5x5_UNORM_BLOCK,VK_FORMAT_ASTC_5x5_SRGB_BLOCK,VK_FORMAT_ASTC_6x5_UNORM_BLOCK,VK_FORMAT_ASTC_6x5_SRGB_BLOCK,VK_FORMAT_ASTC_6x6_UNORM_BLOCK,VK_FORMAT_ASTC_6x6_SRGB_BLOCK,VK_FORMAT_ASTC_8x5_UNORM_BLOCK,VK_FORMAT_ASTC_8x5_SRGB_BLOCK,VK_FORMAT_ASTC_8x6_UNORM_BLOCK,VK_FORMAT_ASTC_8x6_SRGB_BLOCK,VK_FORMAT_ASTC_8x8_UNORM_BLOCK,VK_FORMAT_ASTC_8x8_SRGB_BLOCK,VK_FORMAT_ASTC_10x5_UNORM_BLOCK,VK_FORMAT_ASTC_10x5_SRGB_BLOCK,VK_FORMAT_ASTC_10x6_UNORM_BLOCK,VK_FORMAT_ASTC_10x6_SRGB_BLOCK,VK_FORMAT_ASTC_10x8_UNORM_BLOCK,VK_FORMAT_ASTC_10x8_SRGB_BLOCK,VK_FORMAT_ASTC_10x10_UNORM_BLOCK,VK_FORMAT_ASTC_10x10_SRGB_BLOCK,VK_FORMAT_ASTC_12x10_UNORM_BLOCK,VK_FORMAT_ASTC_12x10_SRGB_BLOCK,VK_FORMAT_ASTC_12x12_UNORM_BLOCK, orVK_FORMAT_ASTC_12x12_SRGB_BLOCK </para>
/// <para>If format uses sRGB encoding then the decodeMode has no effect.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT </para>
/// <para>   decodeMode must be a valid VkFormat value</para>
/// </summary>
public unsafe struct VkImageViewASTCDecodeModeEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> decodeMode is the intermediate format used to decode ASTC
    /// compressed formats.</summary>
    public VkFormat           decodeMode;
}
// Struct: 177
/// <summary>VkImageViewCreateInfo - Structure specifying parameters of a newly created image view
/// <para>Some of the image creation parameters are inherited by the view.In particular, image view creation inherits the implicit parameterusage specifying the allowed usages of the image view that, bydefault, takes the value of the corresponding usage parameterspecified in VkImageCreateInfo at image creation time.If the image was has a depth-stencil format and was created with an instanceof VkImageStencilUsageCreateInfoEXT in the pNext chain ofVkImageCreateInfo, the usage is calculated based on thesubresource.aspectMask provided:  * If aspectMask includes only VK_IMAGE_ASPECT_STENCIL_BIT, the    implicit usage is equal to    VkImageStencilUsageCreateInfoEXT::stencilUsage.  * If aspectMask includes only VK_IMAGE_ASPECT_DEPTH_BIT, the    implicit usage is equal to    VkImageCreateInfo::stencilUsage.  * If both aspects are included in aspectMask, the implicit    usage is equal to the intersection of    slinkVkImageCreateInfo::usage and    VkImageStencilUsageCreateInfoEXT::stencilUsage.The implicit usage can be overriden by including an instance ofVkImageViewUsageCreateInfo structure in the pNext chain.</para>
/// <para>If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BITflag,and if the format of the image is notmulti-planar,format can be different from the image’s format, but ifimage was created without theVK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag andthey are not equal they must be compatible.Image format compatibility is defined in theFormat Compatibility Classes section.Views of compatible formats will have the same mapping between texelcoordinates and memory locations irrespective of the format, with onlythe interpretation of the bit pattern changing.</para>
/// <para>Values intended to be used with one view format may not be exactlypreserved when written or read through a different format.For example, an integer value that happens to have the bit pattern of afloating point denorm or NaN may be flushed or canonicalized when writtenor read through a view with a floating point format.Similarly, a value written through a signed normalized format that has a bitpattern exactly equal to -2b  may be changed to -2b +  1as described in Conversion from NormalizedFixed-Point to Floating-Point.</para>
/// <para>If image was created with theVK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, format must be compatible with the image’s format as described above, or mustbe an uncompressed format in which case it must be size-compatible withthe image’s format, as defined forcopying data between images Inthis case the resulting image view’s texel dimensions equal the dimensionsof the selected mip level divided by the compressed texel block size androunded up.</para>
/// <para>If the image view is to be used with a sampler which supportssampler Y’CBCR conversion, an identicallydefined object of type VkSamplerYcbcrConversion to that used tocreate the sampler must be passed to vkCreateImageView in aVkSamplerYcbcrConversionInfo added to the pNext chain ofVkImageViewCreateInfo.</para>
/// <para>If the image has amulti-planar format andsubresourceRange.aspectMask is VK_IMAGE_ASPECT_COLOR_BIT,format must be identical to the image format, and the samplerto be used with the image view must enablesampler Y’CBCR conversion.</para>
/// <para>If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BITand the image has amulti-planar format,and if subresourceRange.aspectMask isVK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, orVK_IMAGE_ASPECT_PLANE_2_BIT, format must becompatible with the corresponding plane of theimage, and the sampler to be used with the image view must not enablesampler Y’CBCR conversion.The width and height of the single-plane image view must bederived from the multi-planar image’s dimensions in the manner listed forplane compatibility for the plane.</para>
/// <para>Any view of an image plane will have the same mapping between texelcoordinates and memory locations as used by the channels of the coloraspect, subject to the formulae relating texel coordinates tolower-resolution planes as described in Chroma Reconstruction.That is, if an R or B plane has a reduced resolution relative to the G planeof the multi-planar image, the image view operates using the (uplane ,vplane ) unnormalized coordinates of the reduced-resolution plane, andthese coordinates access the same memory locations as the (ucolor ,vcolor ) unnormalized coordinates of the color aspect for which chromareconstruction operations operate on the same (uplane , vplane ) or(iplane , jplane ) coordinates.</para>
/// <para>class="tableblock">  <code>imageType</code> = ci.<code>imageType</code><br /><code>width</code> = ci.<code>extent.width</code><br /><code>height</code> = ci.<code>extent.height</code><br /><code>depth</code> = ci.<code>extent.depth</code><br /><code>arrayLayers</code> = ci.<code>arrayLayers</code><br /><code>samples</code> = ci.<code>samples</code><br /><code>flags</code> = ci.<code>flags</code><br />    where ci is the <a href="#VkImageCreateInfo">VkImageCreateInfo</a> used to create <code>image</code>.</para>
/// <para>class="tableblock">  <code>baseArrayLayer</code>, <code>layerCount</code>, and <code>levelCount</code>    are members of the <code>subresourceRange</code> member.</para>
/// <para>class="tableblock">1D, 0, 0</para>
/// <para>class="tableblock">  <code>imageType</code> = <code>VK_IMAGE_TYPE_1D</code><br /><code>width</code> ≥ 1<br /><code>height</code> = 1<br /><code>depth</code> = 1<br /><code>arrayLayers</code> ≥ 1<br /><code>samples</code> = 1</para>
/// <para>class="tableblock">  <code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_1D</code><br /><code>baseArrayLayer</code> ≥ 0<br /><code>layerCount</code> = 1</para>
/// <para>class="tableblock">1D, 1, 0</para>
/// <para>class="tableblock">  <code>imageType</code> = <code>VK_IMAGE_TYPE_1D</code><br /><code>width</code> ≥ 1<br /><code>height</code> = 1<br /><code>depth</code> = 1<br /><code>arrayLayers</code> ≥ 1<br /><code>samples</code> = 1</para>
/// <para>class="tableblock">  <code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_1D_ARRAY</code><br /><code>baseArrayLayer</code> ≥ 0<br /><code>layerCount</code> ≥ 1</para>
/// <para>class="tableblock">2D, 0, 0</para>
/// <para>class="tableblock">  <code>imageType</code> = <code>VK_IMAGE_TYPE_2D</code><br /><code>width</code> ≥ 1<br /><code>height</code> ≥ 1<br /><code>depth</code> = 1<br /><code>arrayLayers</code> ≥ 1<br /><code>samples</code> = 1</para>
/// <para>class="tableblock">  <code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_2D</code><br /><code>baseArrayLayer</code> ≥ 0<br /><code>layerCount</code> = 1</para>
/// <para>class="tableblock">2D, 1, 0</para>
/// <para>class="tableblock">  <code>imageType</code> = <code>VK_IMAGE_TYPE_2D</code><br /><code>width</code> ≥ 1<br /><code>height</code> ≥ 1<br /><code>depth</code> = 1<br /><code>arrayLayers</code> ≥ 1<br /><code>samples</code> = 1</para>
/// <para>class="tableblock">  <code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_2D_ARRAY</code><br /><code>baseArrayLayer</code> ≥ 0<br /><code>layerCount</code> ≥ 1</para>
/// <para>class="tableblock">2D, 0, 1</para>
/// <para>class="tableblock">  <code>imageType</code> = <code>VK_IMAGE_TYPE_2D</code><br /><code>width</code> ≥ 1<br /><code>height</code> ≥ 1<br /><code>depth</code> = 1<br /><code>arrayLayers</code> ≥ 1<br /><code>samples</code> &gt; 1</para>
/// <para>class="tableblock">  <code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_2D</code><br /><code>baseArrayLayer</code> ≥ 0<br /><code>layerCount</code> = 1</para>
/// <para>class="tableblock">2D, 1, 1</para>
/// <para>class="tableblock">  <code>imageType</code> = <code>VK_IMAGE_TYPE_2D</code><br /><code>width</code> ≥ 1<br /><code>height</code> ≥ 1<br /><code>depth</code> = 1<br /><code>arrayLayers</code> ≥ 1<br /><code>samples</code> &gt; 1</para>
/// <para>class="tableblock">  <code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_2D_ARRAY</code><br /><code>baseArrayLayer</code> ≥ 0<br /><code>layerCount</code> ≥ 1</para>
/// <para>class="tableblock">CUBE, 0, 0</para>
/// <para>class="tableblock">  <code>imageType</code> = <code>VK_IMAGE_TYPE_2D</code><br /><code>width</code> ≥ 1<br /><code>height</code> = <code>width</code><br /><code>depth</code> = 1<br /><code>arrayLayers</code> ≥ 6<br /><code>samples</code> = 1<br /><code>flags</code> includes <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code></para>
/// <para>class="tableblock">  <code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_CUBE</code><br /><code>baseArrayLayer</code> ≥ 0<br /><code>layerCount</code> = 6</para>
/// <para>class="tableblock">CUBE, 1, 0</para>
/// <para>class="tableblock">  <code>imageType</code> = <code>VK_IMAGE_TYPE_2D</code><br /><code>width</code> ≥ 1<br /><code>height</code> = width<br /><code>depth</code> = 1<br /><em>N</em> ≥ 1<br /><code>arrayLayers</code> ≥ 6 × <em>N</em><br /><code>samples</code> = 1<br /><code>flags</code> includes <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code></para>
/// <para>class="tableblock">  <code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code><br /><code>baseArrayLayer</code> ≥ 0<br /><code>layerCount</code> = 6 × <em>N</em>, <em>N</em> ≥ 1</para>
/// <para>class="tableblock">3D, 0, 0</para>
/// <para>class="tableblock">  <code>imageType</code> = <code>VK_IMAGE_TYPE_3D</code><br /><code>width</code> ≥ 1<br /><code>height</code> ≥ 1<br /><code>depth</code> ≥ 1<br /><code>arrayLayers</code> = 1<br /><code>samples</code> = 1</para>
/// <para>class="tableblock">  <code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_3D</code><br /><code>baseArrayLayer</code> = 0<br /><code>layerCount</code> = 1</para>
/// <para>class="tableblock">3D, 0, 0</para>
/// <para>class="tableblock">  <code>imageType</code> = <code>VK_IMAGE_TYPE_3D</code><br /><code>width</code> ≥ 1<br /><code>height</code> ≥ 1<br /><code>depth</code> ≥ 1<br /><code>arrayLayers</code> = 1<br /><code>samples</code> = 1<br /><code>flags</code> includes <code>VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT</code><br /><code>flags</code> does not include <code>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</code>, <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code>, and <code>VK_IMAGE_CREATE_SPARSE_ALIASED_BIT</code></para>
/// <para>class="tableblock">  <code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_2D</code><br /><code>levelCount</code> = 1<br /><code>baseArrayLayer</code> ≥ 0<br /><code>layerCount</code> = 1</para>
/// <para>class="tableblock">3D, 0, 0</para>
/// <para>class="tableblock">  <code>imageType</code> = <code>VK_IMAGE_TYPE_3D</code><br /><code>width</code> ≥ 1<br /><code>height</code> ≥ 1<br /><code>depth</code> ≥ 1<br /><code>arrayLayers</code> = 1<br /><code>samples</code> = 1<br /><code>flags</code> includes <code>VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT</code><br /><code>flags</code> does not include <code>VK_IMAGE_CREATE_SPARSE_BINDING_BIT</code>, <code>VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT</code>, and <code>VK_IMAGE_CREATE_SPARSE_ALIASED_BIT</code></para>
/// <para>class="tableblock">  <code>viewType</code> = <code>VK_IMAGE_VIEW_TYPE_2D_ARRAY</code><br /><code>levelCount</code> = 1<br /><code>baseArrayLayer</code> ≥ 0<br /><code>layerCount</code> ≥ 1</para>
/// <para>  If image was not created withVK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT then viewType must notbe VK_IMAGE_VIEW_TYPE_CUBE or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY </para>
/// <para>  If the image cubemap arrays feature is notenabled, viewType must not be VK_IMAGE_VIEW_TYPE_CUBE_ARRAY </para>
/// <para>  If image was created with VK_IMAGE_TYPE_3D but withoutVK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set then viewType must not be VK_IMAGE_VIEW_TYPE_2D orVK_IMAGE_VIEW_TYPE_2D_ARRAY </para>
/// <para>   image must have been created with a usage value containingat least one of VK_IMAGE_USAGE_SAMPLED_BIT,VK_IMAGE_USAGE_STORAGE_BIT,VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, orVK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT </para>
/// <para>  The format features of theresultant image view must contain at least one bit.</para>
/// <para>  If usage contains VK_IMAGE_USAGE_SAMPLED_BIT, then theformat features of theresultant image view must containVK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT.</para>
/// <para>  If usage contains VK_IMAGE_USAGE_STORAGE_BIT, then the imageview’s format features mustcontain VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT.</para>
/// <para>  If usage contains VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, thenthe image view’s formatfeatures must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT.</para>
/// <para>  If usage containsVK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, then the image view’sformat features must containVK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT.</para>
/// <para>  If usage contains VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, thenthe image view’s formatfeatures must contain at least one ofVK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT orVK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT.</para>
/// <para>   subresourceRange.baseMipLevel must be less than themipLevels specified in VkImageCreateInfo when imagewas created</para>
/// <para>  If subresourceRange.levelCount is notVK_REMAINING_MIP_LEVELS,  subresourceRange.baseMipLevel+  subresourceRange.levelCount  must be less than or equal tothe mipLevels specified in VkImageCreateInfo whenimage was created</para>
/// <para>  If image was created with usage containingVK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,subresourceRange.levelCount must be 1 </para>
/// <para>  If image is not a 3D image created withVK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, or viewType isnot VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY,subresourceRange::baseArrayLayer must be less than thearrayLayers specified in VkImageCreateInfo when imagewas created</para>
/// <para>  If subresourceRange::layerCount is notVK_REMAINING_ARRAY_LAYERS, image is not a 3D image createdwith VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, orviewType is not VK_IMAGE_VIEW_TYPE_2D orVK_IMAGE_VIEW_TYPE_2D_ARRAY,subresourceRange::layerCount must be non-zero and subresourceRange::baseArrayLayer + subresourceRange::layerCount  must be less than or equal tothe arrayLayers specified in VkImageCreateInfo whenimage was created</para>
/// <para>  If image is a 3D image created withVK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, and viewType isVK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY,subresourceRange::baseArrayLayer must be less than theextent.depth specified in VkImageCreateInfo when imagewas created</para>
/// <para>  If subresourceRange::layerCount is notVK_REMAINING_ARRAY_LAYERS, image is a 3D image created withVK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, and viewType isVK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY,subresourceRange::layerCount must be non-zero and subresourceRange::baseArrayLayer + subresourceRange::layerCount  must be less than or equal tothe extent.depth specified in VkImageCreateInfo whenimage was created</para>
/// <para>  If image was created with theVK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, format must becompatible with the format used to create image, as definedin Format Compatibility Classes </para>
/// <para>  If image was created with theVK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag,but without the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BITflag,and if the format of the image is not amulti-planar format,format must be compatible with the format used to createimage, as defined in FormatCompatibility Classes </para>
/// <para>  If image was created with theVK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, format must be compatible with, or must be an uncompressed format that issize-compatible with, the format used to create image.</para>
/// <para>  If image was created with theVK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, thelevelCount and layerCount members of subresourceRange must both be 1.</para>
/// <para>  If a VkImageFormatListCreateInfoKHR structure was included in thepNext chain of the VkImageCreateInfo struct used whencreating image and the viewFormatCount field ofVkImageFormatListCreateInfoKHR is not zero then format mustbe one of the formats inVkImageFormatListCreateInfoKHR::pViewFormats.</para>
/// <para>  If image was created with theVK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, if the format ofthe image is amulti-planar format, andif subresourceRange.aspectMask is one ofVK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, orVK_IMAGE_ASPECT_PLANE_2_BIT, then format must be compatiblewith the VkFormat for the plane of the image formatindicated by subresourceRange.aspectMask, as defined inhtml/vkspec.html#formats-compatible-planes </para>
/// <para>  If image was not created with theVK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag,or if the format of the image is amulti-planar format andif subresourceRange.aspectMask is VK_IMAGE_ASPECT_COLOR_BIT,format must be identical to the format used to createimage </para>
/// <para>  If the pNext chain contains an instance ofVkSamplerYcbcrConversionInfo with a conversion value otherthan VK_NULL_HANDLE, all members of components must havethe value VK_COMPONENT_SWIZZLE_IDENTITY.</para>
/// <para>  If image is non-sparse then it must be bound completely andcontiguously to a single VkDeviceMemory object</para>
/// <para>   subresourceRange and viewType must be compatible with theimage, as described in thecompatibility table </para>
/// <para>  If image has anexternalformat, format must be VK_FORMAT_UNDEFINED.</para>
/// <para>  If image has anexternalformat, the pNext chain must contain an instance ofVkSamplerYcbcrConversionInfo with a conversion objectcreated with the same external format as image.</para>
/// <para>  If image has anexternalformat, all members of components must beVK_COMPONENT_SWIZZLE_IDENTITY.</para>
/// <para>  If image was created with usage containingVK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, viewType must beVK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY </para>
/// <para>  If image was created with usage containingVK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, format must beVK_FORMAT_R8_UINT </para>
/// <para>  If dynamic fragment density mapfeature is not enabled, flags must not containVK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT </para>
/// <para>      If dynamic fragment density map    feature is not enabled and image was created with usage    containing VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,    flags must not contain any of    VK_IMAGE_CREATE_PROTECTED_BIT,    VK_IMAGE_CREATE_SPARSE_BINDING_BIT,    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or    VK_IMAGE_CREATE_SPARSE_ALIASED_BITifdef::VK_VERSION_1_1,VK_KHR_maintenance2</para>
/// <para>  If the pNext chain includes an instance ofVkImageViewUsageCreateInfo, and image was not created withan instance of VkImageStencilUsageCreateInfoEXT in the pNextchain of VkImageCreateInfo, its usage member must notinclude any bits that were not set in the usage member of theVkImageCreateInfo structure used to create image </para>
/// <para>  If the pNext chain includes an instance ofVkImageViewUsageCreateInfo, image was created with aninstance of VkImageStencilUsageCreateInfoEXT in the pNextchain of VkImageCreateInfo, and subResourceRange.aspectMaskincludes VK_IMAGE_ASPECT_STENCIL_BIT, the usage member ofthe VkImageViewUsageCreateInfo instance must not include any bitsthat were not set in the usage member of theVkImageStencilUsageCreateInfoEXT structure used to createimage </para>
/// <para>      If the pNext chain includes an instance of    VkImageViewUsageCreateInfo, image was created with an    instance of VkImageStencilUsageCreateInfoEXT in the pNext    chain of VkImageCreateInfo, and subResourceRange.aspectMask    includes bits other than VK_IMAGE_ASPECT_STENCIL_BIT, the    usage member of the VkImageViewUsageCreateInfo instance    must not include any bits that were not set in the usage member    of the VkImageCreateInfo structure used to create imageendif::VK_VERSION_1_1,VK_KHR_maintenance2</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkImageViewASTCDecodeModeEXT, VkImageViewUsageCreateInfo, or VkSamplerYcbcrConversionInfo </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   flags must be a valid combination of VkImageViewCreateFlagBits values</para>
/// <para>   image must be a valid VkImage handle</para>
/// <para>   viewType must be a valid VkImageViewType value</para>
/// <para>   format must be a valid VkFormat value</para>
/// <para>   components must be a valid VkComponentMapping structure</para>
/// <para>   subresourceRange must be a valid VkImageSubresourceRange structure</para>
/// </summary>
public unsafe struct VkImageViewCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                pNext;
    /// <summary> flags is a bitmask of VkImageViewCreateFlagBits describing
    /// additional parameters of the image view.</summary>
    public VkImageViewCreateFlags     flags;
    /// <summary> image is a VkImage on which the view will be created.</summary>
    public VkImage                    image;
    /// <summary> viewType is a VkImageViewType value specifying the type of
    /// the image view.</summary>
    public VkImageViewType            viewType;
    /// <summary> format is a VkFormat describing the format and type used to
    /// interpret texel blocks in the image.</summary>
    public VkFormat                   format;
    /// <summary> components is a VkComponentMapping specifies a remapping of
    /// color components (or of depth or stencil components after they have been
    /// converted into color components).</summary>
    public VkComponentMapping         components;
    /// <summary> subresourceRange is a VkImageSubresourceRange selecting the
    /// set of mipmap levels and array layers to be accessible to the view.</summary>
    public VkImageSubresourceRange    subresourceRange;
}
// Struct: 178
/// <summary>VkImageViewHandleInfoNVX - Structure specifying the image view for handle queries
/// <para>   descriptorType must be VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, orVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER </para>
/// <para>   sampler must be a valid VkSampler if descriptorTypeis VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER </para>
/// <para>     If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or   VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the image that   imageView was created from must have been created with the   VK_IMAGE_USAGE_SAMPLED_BITusage bit set</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, the imagethat imageView was created from must have been created with theVK_IMAGE_USAGE_STORAGE_BIT usage bit set</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX </para>
/// <para>   pNext must be NULL </para>
/// <para>   imageView must be a valid VkImageView handle</para>
/// <para>   descriptorType must be a valid VkDescriptorType value</para>
/// <para>   If sampler is not VK_NULL_HANDLE, sampler must be a valid VkSampler handle</para>
/// <para>   Both of imageView, and sampler that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkImageViewHandleInfoNVX {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType     sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*         pNext;
    /// <summary> imageView is the image view to query.</summary>
    public VkImageView         imageView;
    /// <summary> descriptorType is the type of descriptor for which to query a
    /// handle.</summary>
    public VkDescriptorType    descriptorType;
    /// <summary> sampler is the sampler to combine with the image view when
    /// generating the handle.</summary>
    public VkSampler           sampler;
}
// Struct: 179
/// <summary>VkImageViewUsageCreateInfo - Specify the intended usage of an image view
/// <para>When this structure is chained to VkImageViewCreateInfo theusage field overrides the implicit usage parameter inheritedfrom image creation time and its value is used instead for the purposes ofdetermining the valid usage conditions of VkImageViewCreateInfo.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO </para>
/// <para>   usage must be a valid combination of VkImageUsageFlagBits values</para>
/// <para>   usage must not be 0 </para>
/// </summary>
public unsafe struct VkImageViewUsageCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*          pNext;
    /// <summary> usage is a bitmask describing the allowed usages of the image
    /// view.
    /// See VkImageUsageFlagBits for a description of the supported bits.</summary>
    public VkImageUsageFlags    usage;
}
// Struct: 180
/// <summary>VkImportAndroidHardwareBufferInfoANDROID - Import memory from an Android hardware buffer
/// <para>If the vkAllocateMemory command succeeds, the implementation mustacquire a reference to the imported hardware buffer, which it must releasewhen the device memory object is freed.If the command fails, the implementation must not retain a reference.</para>
/// <para>  If buffer is not NULL, Android hardware buffers must besupported for import, as reported byVkExternalImageFormatProperties orVkExternalBufferProperties.</para>
/// <para>  If buffer is not NULL, it must be a valid Android hardwarebuffer object with AHardwareBuffer_Desc::format andAHardwareBuffer_Desc::usage compatible with Vulkan asdescribed in Android HardwareBuffers.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID </para>
/// <para>   buffer must be a valid pointer to a AHardwareBuffer value</para>
/// </summary>
public unsafe struct VkImportAndroidHardwareBufferInfoANDROID {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                pNext;
    /// <summary> buffer is the Android hardware buffer to import.</summary>
    public /* struct */ AHardwareBuffer*    buffer;
}
// Struct: 181
/// <summary>VkImportFenceFdInfoKHR - (None)
/// <para>The handle types supported by handleType are:</para>
/// <para>class="tableblock">  <code>VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT</code></para>
/// <para>class="tableblock">Reference</para>
/// <para>class="tableblock">Temporary,Permanent</para>
/// <para>class="tableblock">  <code>VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT</code></para>
/// <para>class="tableblock">Copy</para>
/// <para>class="tableblock">Temporary</para>
/// <para>   handleType must be a value included in theHandle Types Supported byVkImportFenceFdInfoKHR table.</para>
/// <para>   fd must obey any requirements listed for handleType inexternal fence handle typescompatibility.</para>
/// <para>If handleType is VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT, thespecial value -1 for fd is treated like a valid sync file descriptorreferring to an object that has already signaled.The import operation will succeed and the VkFence will have atemporarily imported payload as if a valid file descriptor had beenprovided.</para>
/// <para>This special behavior for importing an invalid sync file descriptor allowseasier interoperability with other system APIs which use the convention thatan invalid sync file descriptor represents work that has already completedand does not need to be waited for.It is consistent with the option for implementations to return a -1 filedescriptor when exporting a VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BITfrom a VkFence which is signaled.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   fence must be a valid VkFence handle</para>
/// <para>   flags must be a valid combination of VkFenceImportFlagBits values</para>
/// <para>   handleType must be a valid VkExternalFenceHandleTypeFlagBits value</para>
/// <para>Host access to fence must be externally synchronized</para>
/// </summary>
public unsafe struct VkImportFenceFdInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                          pNext;
    /// <summary> fence is the fence into which the payload will be imported.</summary>
    public VkFence                              fence;
    /// <summary> flags is a bitmask of VkFenceImportFlagBits specifying
    /// additional parameters for the fence payload import operation.</summary>
    public VkFenceImportFlags                   flags;
    /// <summary> handleType specifies the type of fd.</summary>
    public VkExternalFenceHandleTypeFlagBits    handleType;
    /// <summary> fd is the external handle to import.</summary>
    public int                                  fd;
}
// Struct: 182
/// <summary>VkImportFenceWin32HandleInfoKHR - (None)
/// <para>The handle types supported by handleType are:</para>
/// <para>class="tableblock">  <code>VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT</code></para>
/// <para>class="tableblock">Reference</para>
/// <para>class="tableblock">Temporary,Permanent</para>
/// <para>class="tableblock">  <code>VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT</code></para>
/// <para>class="tableblock">Reference</para>
/// <para>class="tableblock">Temporary,Permanent</para>
/// <para>   handleType must be a value included in theHandle Types Supported byVkImportFenceWin32HandleInfoKHR table.</para>
/// <para>  If handleType is notVK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT, name mustbe NULL.</para>
/// <para>  If handleType is not 0 and handle is NULL, name must name a valid synchronization primitive of the type specified byhandleType.</para>
/// <para>  If handleType is not 0 and name is NULL, handle must be a valid handle of the type specified by handleType.</para>
/// <para>  If handle is not NULL, name must be NULL.</para>
/// <para>  If handle is not NULL, it must obey any requirements listed forhandleType in externalfence handle types compatibility.</para>
/// <para>  If name is not NULL, it must obey any requirements listed forhandleType in externalfence handle types compatibility.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   fence must be a valid VkFence handle</para>
/// <para>   flags must be a valid combination of VkFenceImportFlagBits values</para>
/// <para>   If handleType is not 0, handleType must be a valid VkExternalFenceHandleTypeFlagBits value</para>
/// <para>Host access to fence must be externally synchronized</para>
/// </summary>
public unsafe struct VkImportFenceWin32HandleInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                          pNext;
    /// <summary> fence is the fence into which the state will be imported.</summary>
    public VkFence                              fence;
    /// <summary> flags is a bitmask of VkFenceImportFlagBits specifying
    /// additional parameters for the fence payload import operation.</summary>
    public VkFenceImportFlags                   flags;
    /// <summary> handleType specifies the type of handle.</summary>
    public VkExternalFenceHandleTypeFlagBits    handleType;
    /// <summary> handle is the external handle to import, or NULL.</summary>
    public HANDLE                               handle;
    /// <summary> name is the NULL-terminated UTF-16 string naming the underlying
    /// synchronization primitive to import, or NULL.</summary>
    public LPCWSTR                              name;
}
// Struct: 183
/// <summary>VkImportMemoryFdInfoKHR - import memory created on the same physical device from a file descriptor
/// <para>Importing memory from a file descriptor transfers ownership of the filedescriptor from the application to the Vulkan implementation.The application must not perform any operations on the file descriptorafter a successful import.</para>
/// <para>Applications can import the same underlying memory into multiple instancesof Vulkan, into the same instance from which it was exported, and multipletimes into a given Vulkan instance.In all cases, each import operation must create a distinctVkDeviceMemory object.</para>
/// <para>  If handleType is not 0, it must be supported for import, asreported by VkExternalImageFormatProperties orVkExternalBufferProperties.</para>
/// <para>  The memory from which fd was exported must have been created onthe same underlying physical device as device.</para>
/// <para>  If handleType is not 0, it must be defined as a POSIX filedescriptor handle.</para>
/// <para>  If handleType is not 0, fd must be a valid handle of thetype specified by handleType.</para>
/// <para>  The memory represented by fd must have been created from aphysical device and driver that is compatible with device andhandleType, as described inhtml/vkspec.html#external-memory-handle-types-compatibility.</para>
/// <para>   fd must obey any requirements listed for handleType inexternal memory handletypes compatibility.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR </para>
/// <para>   If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</para>
/// </summary>
public unsafe struct VkImportMemoryFdInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                           pNext;
    /// <summary> handleType specifies the handle type of fd.</summary>
    public VkExternalMemoryHandleTypeFlagBits    handleType;
    /// <summary> fd is the external handle to import.</summary>
    public int                                   fd;
}
// Struct: 184
/// <summary>VkImportMemoryHostPointerInfoEXT - import memory from a host pointer
/// <para>Importing memory from a host pointer shares ownership of the memory betweenthe host and the Vulkan implementation.The application can continue to access the memory through the host pointerbut it is the application’s responsibility to synchronize device andnon-device access to the underlying memory as defined inHost Access to Device Memory Objects.</para>
/// <para>Applications can import the same underlying memory into multiple instancesof Vulkan and multiple times into a given Vulkan instance.However, implementations may fail to import the same underlying memorymultiple times into a given physical device due to platform constraints.</para>
/// <para>Importing memory from a particular host pointer may not be possible due toadditional platform-specific restrictions beyond the scope of thisspecification in which case the implementation must fail the memory importoperation with the error code VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR.</para>
/// <para>The application must ensure that the imported memory range remains validand accessible for the lifetime of the imported memory object.</para>
/// <para>  If handleType is not 0, it must be supported for import, asreported in VkExternalMemoryPropertiesKHR </para>
/// <para>  If handleType is not 0, it must beVK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT orVK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT </para>
/// <para>   pHostPointer must be a pointer aligned to an integer multiple ofVkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment </para>
/// <para>  If handleType isVK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT,pHostPointer must be a pointer to allocationSize number ofbytes of host memory, where allocationSize is the member of theVkMemoryAllocateInfo structure this structure is chained to</para>
/// <para>  If handleType isVK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT,pHostPointer must be a pointer to allocationSize number ofbytes of host mapped foreign memory, where allocationSize is themember of the VkMemoryAllocateInfo structure this structure ischained to</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT </para>
/// <para>   handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</para>
/// </summary>
public unsafe struct VkImportMemoryHostPointerInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                           pNext;
    /// <summary> handleType specifies the handle type.</summary>
    public VkExternalMemoryHandleTypeFlagBits    handleType;
    /// <summary> pHostPointer is the host pointer to import from.</summary>
    public void*                                 pHostPointer;
}
// Struct: 185
/// <summary>VkImportMemoryWin32HandleInfoKHR - import Win32 memory created on the same physical device
/// <para>Importing memory objects from Windows handles does not transfer ownership ofthe handle to the Vulkan implementation.For handle types defined as NT handles, the application must releaseownership using the CloseHandle system call when the handle is nolonger needed.</para>
/// <para>Applications can import the same underlying memory into multiple instancesof Vulkan, into the same instance from which it was exported, and multipletimes into a given Vulkan instance.In all cases, each import operation must create a distinctVkDeviceMemory object.</para>
/// <para>  If handleType is not 0, it must be supported for import, asreported by VkExternalImageFormatProperties orVkExternalBufferProperties.</para>
/// <para>  The memory from which handle was exported, or the memory named byname must have been created on the same underlying physicaldevice as device.</para>
/// <para>  If handleType is not 0, it must be defined as an NT handle or aglobal share handle.</para>
/// <para>  If handleType is notVK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, orVK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, name must be NULL.</para>
/// <para>  If handleType is not 0 and handle is NULL, name must name a valid memory resource of the type specified byhandleType.</para>
/// <para>  If handleType is not 0 and name is NULL, handle must be a valid handle of the type specified by handleType.</para>
/// <para>  if handle is not NULL, name must be NULL.</para>
/// <para>  If handle is not NULL, it must obey any requirements listed forhandleType inexternal memory handletypes compatibility.</para>
/// <para>  If name is not NULL, it must obey any requirements listed forhandleType inexternal memory handletypes compatibility.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR </para>
/// <para>   If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</para>
/// </summary>
public unsafe struct VkImportMemoryWin32HandleInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                           pNext;
    /// <summary> handleType specifies the type of handle or name.</summary>
    public VkExternalMemoryHandleTypeFlagBits    handleType;
    /// <summary> handle is the external handle to import, or NULL.</summary>
    public HANDLE                                handle;
    /// <summary> name is a NULL-terminated UTF-16 string naming the underlying
    /// memory resource to import, or NULL.</summary>
    public LPCWSTR                               name;
}
// Struct: 186
/// <summary>VkImportMemoryWin32HandleInfoNV - import Win32 memory created on the same physical device
/// <para>If handleType is 0, this structure is ignored by consumers of theVkMemoryAllocateInfo structure it is chained from.</para>
/// <para>   handleType must not have more than one bit set.</para>
/// <para>   handle must be a valid handle to memory, obtained as specified byhandleType.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV </para>
/// <para>   handleType must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values</para>
/// </summary>
public unsafe struct VkImportMemoryWin32HandleInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                          pNext;
    /// <summary> handleType is 0 or a VkExternalMemoryHandleTypeFlagBitsNV
    /// value specifying the type of memory handle in handle.</summary>
    public VkExternalMemoryHandleTypeFlagsNV    handleType;
    /// <summary> handle is a Windows HANDLE referring to the memory.</summary>
    public HANDLE                               handle;
}
// Struct: 187
/// <summary>VkImportSemaphoreFdInfoKHR - Structure specifying POSIX file descriptor to import to a semaphore
/// <para>The handle types supported by handleType are:</para>
/// <para>class="tableblock">  <code>VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT</code></para>
/// <para>class="tableblock">Reference</para>
/// <para>class="tableblock">Temporary,Permanent</para>
/// <para>class="tableblock">  <code>VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT</code></para>
/// <para>class="tableblock">Copy</para>
/// <para>class="tableblock">Temporary</para>
/// <para>   handleType must be a value included in theHandle Types Supported byVkImportSemaphoreFdInfoKHR table.</para>
/// <para>   fd must obey any requirements listed for handleType inexternal semaphorehandle types compatibility.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   semaphore must be a valid VkSemaphore handle</para>
/// <para>   flags must be a valid combination of VkSemaphoreImportFlagBits values</para>
/// <para>   handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value</para>
/// <para>Host access to semaphore must be externally synchronized</para>
/// </summary>
public unsafe struct VkImportSemaphoreFdInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                              pNext;
    /// <summary> semaphore is the semaphore into which the payload will be
    /// imported.</summary>
    public VkSemaphore                              semaphore;
    /// <summary> flags is a bitmask of VkSemaphoreImportFlagBits specifying
    /// additional parameters for the semaphore payload import operation.</summary>
    public VkSemaphoreImportFlags                   flags;
    /// <summary> handleType specifies the type of fd.</summary>
    public VkExternalSemaphoreHandleTypeFlagBits    handleType;
    /// <summary> fd is the external handle to import.</summary>
    public int                                      fd;
}
// Struct: 188
/// <summary>VkImportSemaphoreWin32HandleInfoKHR - Structure specifying Windows handle to import to a semaphore
/// <para>The handle types supported by handleType are:</para>
/// <para>class="tableblock">  <code>VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT</code></para>
/// <para>class="tableblock">Reference</para>
/// <para>class="tableblock">Temporary,Permanent</para>
/// <para>class="tableblock">  <code>VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT</code></para>
/// <para>class="tableblock">Reference</para>
/// <para>class="tableblock">Temporary,Permanent</para>
/// <para>class="tableblock">  <code>VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT</code></para>
/// <para>class="tableblock">Reference</para>
/// <para>class="tableblock">Temporary,Permanent</para>
/// <para>   handleType must be a value included in theHandle Types Supported byVkImportSemaphoreWin32HandleInfoKHR table.</para>
/// <para>  If handleType is notVK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT orVK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT, name must be NULL.</para>
/// <para>  If handleType is not 0 and handle is NULL, name must name a valid synchronization primitive of the type specified byhandleType.</para>
/// <para>  If handleType is not 0 and name is NULL, handle must be a valid handle of the type specified by handleType.</para>
/// <para>  If handle is not NULL, name must be NULL.</para>
/// <para>  If handle is not NULL, it must obey any requirements listed forhandleType inexternal semaphorehandle types compatibility.</para>
/// <para>  If name is not NULL, it must obey any requirements listed forhandleType inexternal semaphorehandle types compatibility.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   semaphore must be a valid VkSemaphore handle</para>
/// <para>   flags must be a valid combination of VkSemaphoreImportFlagBits values</para>
/// <para>   If handleType is not 0, handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value</para>
/// <para>Host access to semaphore must be externally synchronized</para>
/// </summary>
public unsafe struct VkImportSemaphoreWin32HandleInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                              pNext;
    /// <summary> semaphore is the semaphore into which the payload will be
    /// imported.</summary>
    public VkSemaphore                              semaphore;
    /// <summary> flags is a bitmask of VkSemaphoreImportFlagBits specifying
    /// additional parameters for the semaphore payload import operation.</summary>
    public VkSemaphoreImportFlags                   flags;
    /// <summary> handleType specifies the type of handle.</summary>
    public VkExternalSemaphoreHandleTypeFlagBits    handleType;
    /// <summary> handle is the external handle to import, or NULL.</summary>
    public HANDLE                                   handle;
    /// <summary> name is a NULL-terminated UTF-16 string naming the underlying
    /// synchronization primitive to import, or NULL.</summary>
    public LPCWSTR                                  name;
}
// Struct: 189
/// <summary>VkIndirectCommandsLayoutCreateInfoNVX - Structure specifying the parameters of a newly created indirect commands layout object
/// <para>The following code illustrates some of the key flags:</para>
/// <para>   tokenCount must be greater than 0 and belowVkDeviceGeneratedCommandsLimitsNVX::maxIndirectCommandsLayoutTokenCount </para>
/// <para>  If theVkDeviceGeneratedCommandsFeaturesNVX::computeBindingPointSupportfeature is not enabled, then pipelineBindPoint must not beVK_PIPELINE_BIND_POINT_COMPUTE </para>
/// <para>  If pTokens contains an entry ofVK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX it must be the firstelement of the array and there must be only a single element of suchtoken type.</para>
/// <para>  All state binding tokens in pTokens must occur prior workprovoking tokens (VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX,VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX,VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX).</para>
/// <para>  The content of pTokens must include one single work provokingtoken that is compatible with the pipelineBindPoint.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX </para>
/// <para>   pNext must be NULL </para>
/// <para>   pipelineBindPoint must be a valid VkPipelineBindPoint value</para>
/// <para>   flags must be a valid combination of VkIndirectCommandsLayoutUsageFlagBitsNVX values</para>
/// <para>   flags must not be 0 </para>
/// <para>   pTokens must be a valid pointer to an array of tokenCount valid VkIndirectCommandsLayoutTokenNVX structures</para>
/// <para>   tokenCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkIndirectCommandsLayoutCreateInfoNVX {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                pNext;
    /// <summary> pipelineBindPoint is the VkPipelineBindPoint that this
    /// layout targets.</summary>
    public VkPipelineBindPoint                        pipelineBindPoint;
    /// <summary> flags is a bitmask of
    /// VkIndirectCommandsLayoutUsageFlagBitsNVX specifying usage hints of
    /// this layout.</summary>
    public VkIndirectCommandsLayoutUsageFlagsNVX      flags;
    /// <summary> tokenCount is the length of the individual command sequnce.</summary>
    public UInt32                                   tokenCount;
    /// <summary> pTokens is an array describing each command token in detail.
    /// See VkIndirectCommandsTokenTypeNVX and
    /// VkIndirectCommandsLayoutTokenNVX below for details.</summary>
    public /* const */ VkIndirectCommandsLayoutTokenNVX*    pTokens;
}
// Struct: 190
/// <summary>VkIndirectCommandsLayoutTokenNVX - Struct specifying the details of an indirect command layout token
/// <para>   bindingUnit must stay within device supported limits for theappropriate commands.</para>
/// <para>   dynamicCount must stay within device supported limits for theappropriate commands.</para>
/// <para>   divisor must be greater than 0 and a power of two.</para>
/// <para>   tokenType must be a valid VkIndirectCommandsTokenTypeNVX value</para>
/// </summary>
public unsafe struct VkIndirectCommandsLayoutTokenNVX {
    public VkIndirectCommandsTokenTypeNVX    tokenType;
    /// <summary> bindingUnit has a different meaning depending on the type, please
    /// refer pseudo code further down for details.</summary>
    public UInt32                          bindingUnit;
    /// <summary> dynamicCount has a different meaning depending on the type, please
    /// refer pseudo code further down for details.</summary>
    public UInt32                          dynamicCount;
    /// <summary> divisor defines the rate at which the input data buffers are
    /// accessed.</summary>
    public UInt32                          divisor;
}
// Struct: 191
/// <summary>VkIndirectCommandsTokenNVX - Structure specifying parameters for the reservation of command buffer space
/// <para>  The buffer’s usage flag must have theVK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set.</para>
/// <para>  The offset must be aligned toVkDeviceGeneratedCommandsLimitsNVX::minCommandsTokenBufferOffsetAlignment.</para>
/// <para>   tokenType must be a valid VkIndirectCommandsTokenTypeNVX value</para>
/// <para>   buffer must be a valid VkBuffer handle</para>
/// </summary>
public unsafe struct VkIndirectCommandsTokenNVX {
    /// <summary> tokenType specifies the token command type.</summary>
    public VkIndirectCommandsTokenTypeNVX    tokenType;
    /// <summary> buffer specifies the VkBuffer storing the functional
    /// arguments for each squence.
    /// These argumetns can be written by the device.</summary>
    public VkBuffer                          buffer;
    /// <summary> offset specified an offset into buffer where the arguments
    /// start.</summary>
    public VkDeviceSize                      offset;
}
// Struct: 192
/// <summary>VkInputAttachmentAspectReference - Structure specifying a subpass/input attachment pair and an aspect mask that <strong class="purple">can</strong> be read.
/// <para>   aspectMask must not include VK_IMAGE_ASPECT_METADATA_BIT </para>
/// <para>   aspectMask must not includeVK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i.</para>
/// <para>   aspectMask must be a valid combination of VkImageAspectFlagBits values</para>
/// <para>   aspectMask must not be 0 </para>
/// </summary>
public unsafe struct VkInputAttachmentAspectReference {
    /// <summary> subpass is an index into the pSubpasses array of the parent
    /// VkRenderPassCreateInfo structure.</summary>
    public UInt32              subpass;
    /// <summary> inputAttachmentIndex is an index into the pInputAttachments
    /// of the specified subpass.</summary>
    public UInt32              inputAttachmentIndex;
    /// <summary> aspectMask is a mask of which aspect(s) can be accessed within
    /// the specified subpass.</summary>
    public VkImageAspectFlags    aspectMask;
}
// Struct: 193
/// <summary>VkInstanceCreateInfo - Structure specifying parameters of a newly created instance
/// <para>   sType must be VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDebugReportCallbackCreateInfoEXT, VkDebugUtilsMessengerCreateInfoEXT, VkValidationFeaturesEXT, or VkValidationFlagsEXT </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   flags must be 0 </para>
/// <para>   If pApplicationInfo is not NULL, pApplicationInfo must be a valid pointer to a valid VkApplicationInfo structure</para>
/// <para>   If enabledLayerCount is not 0, ppEnabledLayerNames must be a valid pointer to an array of enabledLayerCount null-terminated UTF-8 strings</para>
/// <para>   If enabledExtensionCount is not 0, ppEnabledExtensionNames must be a valid pointer to an array of enabledExtensionCount null-terminated UTF-8 strings</para>
/// </summary>
public unsafe struct VkInstanceCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                 pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkInstanceCreateFlags       flags;
    /// <summary> pApplicationInfo is NULL or a pointer to an instance of
    /// VkApplicationInfo.
    /// If not NULL, this information helps implementations recognize behavior
    /// inherent to classes of applications.
    /// VkApplicationInfo is defined in detail below.</summary>
    public /* const */ VkApplicationInfo*    pApplicationInfo;
    /// <summary> enabledLayerCount is the number of global layers to enable.</summary>
    public UInt32                    enabledLayerCount;
    /// <summary> ppEnabledLayerNames is a pointer to an array of
    /// enabledLayerCount null-terminated UTF-8 strings containing the
    /// names of layers to enable for the created instance.
    /// See the html/vkspec.html#extendingvulkan-layers section for further details.</summary>
    public IntPtr const*          ppEnabledLayerNames;
    /// <summary> enabledExtensionCount is the number of global extensions to
    /// enable.</summary>
    public UInt32                    enabledExtensionCount;
    /// <summary> ppEnabledExtensionNames is a pointer to an array of
    /// enabledExtensionCount null-terminated UTF-8 strings containing the
    /// names of extensions to enable.</summary>
    public IntPtr const*          ppEnabledExtensionNames;
}
// Struct: 194
/// <summary>VkLayerProperties - Structure specifying layer properties
/// </summary>
public unsafe struct VkLayerProperties {
    public fixed char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
    /// <summary> specVersion is the Vulkan version the layer was written to,
    /// encoded as described in html/vkspec.html#extendingvulkan-coreversions-versionnumbers.</summary>
    public UInt32    specVersion;
    /// <summary> implementationVersion is the version of this layer.
    /// It is an integer, increasing with backward compatible changes.</summary>
    public UInt32    implementationVersion;
    public fixed char        description[VK_MAX_DESCRIPTION_SIZE];
}
// Struct: 195
/// <summary>VkMacOSSurfaceCreateInfoMVK - Structure specifying parameters of a newly created macOS surface object
/// <para>   pView must be a valid NSView and must be backed by aCALayer instance of type CAMetalLayer.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkMacOSSurfaceCreateInfoMVK {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                 sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                     pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkMacOSSurfaceCreateFlagsMVK    flags;
    /// <summary> pView is a reference to a NSView object which will display
    /// this surface.
    /// This NSView must be backed by a CALayer instance of type
    /// CAMetalLayer.</summary>
    public /* const */ void*                     pView;
}
// Struct: 196
/// <summary>VkMappedMemoryRange - Structure specifying a mapped memory range
/// <para>   memory must be currently host mapped</para>
/// <para>  If size is not equal to VK_WHOLE_SIZE, offset andsize must specify a range contained within the currently mappedrange of memory </para>
/// <para>  If size is equal to VK_WHOLE_SIZE, offset must bewithin the currently mapped range of memory </para>
/// <para>  If size is equal to VK_WHOLE_SIZE, the end of the currentmapping of memory must be a multiple ofVkPhysicalDeviceLimits::nonCoherentAtomSize bytes from thebeginning of the memory object.</para>
/// <para>   offset must be a multiple ofVkPhysicalDeviceLimits::nonCoherentAtomSize </para>
/// <para>  If size is not equal to VK_WHOLE_SIZE, size musteither be a multiple ofVkPhysicalDeviceLimits::nonCoherentAtomSize, or offsetplus size must equal the size of memory.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE </para>
/// <para>   pNext must be NULL </para>
/// <para>   memory must be a valid VkDeviceMemory handle</para>
/// </summary>
public unsafe struct VkMappedMemoryRange {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> memory is the memory object to which this range belongs.</summary>
    public VkDeviceMemory     memory;
    /// <summary> offset is the zero-based byte offset from the beginning of the
    /// memory object.</summary>
    public VkDeviceSize       offset;
    /// <summary> size is either the size of range, or VK_WHOLE_SIZE to affect
    /// the range from offset to the end of the current mapping of the
    /// allocation.</summary>
    public VkDeviceSize       size;
}
// Struct: 197
/// <summary>VkMemoryAllocateFlagsInfo - Structure controlling how many instances of memory will be allocated
/// <para>If VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is not set, the number ofinstances allocated depends on whetherVK_MEMORY_HEAP_MULTI_INSTANCE_BIT is set in the memory heap.If VK_MEMORY_HEAP_MULTI_INSTANCE_BIT is set, then memory is allocatedfor every physical device in the logical device (as if deviceMask hasbits set for all device indices).If VK_MEMORY_HEAP_MULTI_INSTANCE_BIT is not set, then a singleinstance of memory is allocated (as if deviceMask is set to one).</para>
/// <para>On some implementations, allocations from a multi-instance heap may consumememory on all physical devices even if the deviceMask excludes somedevices.If VkPhysicalDeviceGroupProperties::subsetAllocation isVK_TRUE, then memory is only consumed for the devices in the devicemask.</para>
/// <para>In practice, most allocations on a multi-instance heap will be allocatedacross all physical devices.Unicast allocation support is an optional optimization for a minority ofallocations.</para>
/// <para>  If VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is set, deviceMask must be a valid device mask.</para>
/// <para>  If VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is set, deviceMask must not be zero</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO </para>
/// <para>   flags must be a valid combination of VkMemoryAllocateFlagBits values</para>
/// </summary>
public unsafe struct VkMemoryAllocateFlagsInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*              pNext;
    /// <summary> flags is a bitmask of VkMemoryAllocateFlagBits controlling
    /// the allocation.</summary>
    public VkMemoryAllocateFlags    flags;
    /// <summary> deviceMask is a mask of physical devices in the logical device,
    /// indicating that memory must be allocated on each device in the mask, if
    /// VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is set in flags.</summary>
    public UInt32                 deviceMask;
}
// Struct: 198
/// <summary>VkMemoryAllocateInfo - Structure containing parameters of a memory allocation
/// <para>An instance of the VkMemoryAllocateInfo structure defines a memoryimport operation if the pNext chain contains an instance of one of thefollowing structures:</para>
/// <para> VkImportMemoryWin32HandleInfoKHR with non-zero handleTypevalue</para>
/// <para> VkImportMemoryFdInfoKHR with a non-zero handleType value</para>
/// <para> VkImportMemoryHostPointerInfoEXT with a non-zero handleTypevalue</para>
/// <para> VkImportAndroidHardwareBufferInfoANDROID with a non-NULL buffer value</para>
/// <para>Importing memory must not modify the content of the memory.Implementations must ensure that importing memory does not enable theimporting Vulkan instance to access any memory or resources in other Vulkaninstances other than that corresponding to the memory object imported.Implementations must also ensure accessing imported memory which has notbeen initialized does not allow the importing Vulkan instance to obtain datafrom the exporting Vulkan instance or vice-versa.</para>
/// <para>How exported and imported memory is isolated is left to the implementation,but applications should be aware that such isolation may preventimplementations from placing multiple exportable memory objects in the samephysical or virtual page.Hence, applications should avoid creating many small external memoryobjects whenever possible.</para>
/// <para>When performing a memory import operation, it is the responsibility of theapplication to ensure the external handles meet all valid usagerequirements.However, implementations must perform sufficient validation of externalhandles to ensure that the operation results in a valid memory object whichwill not cause program termination, device loss, queue stalls, or corruptionof other resources when used as allowed according to its allocationparameters.If the external handle provided does not meet these requirements, theimplementation must fail the memory import operation with the error codeVK_ERROR_INVALID_EXTERNAL_HANDLE.</para>
/// <para>      If the pNext chain contains an instance of    VkExportMemoryAllocateInfo, and any of the handle types specified    in VkExportMemoryAllocateInfo::handleTypes require a    dedicated allocation, as reported by    vkGetPhysicalDeviceImageFormatProperties2 in    VkExternalImageFormatProperties::externalMemoryProperties::externalMemoryFeatures    or    VkExternalBufferProperties::externalMemoryProperties::externalMemoryFeatures,    the pNext chain must contain an instance ofVkMemoryDedicatedAllocateInfoorVkDedicatedAllocationMemoryAllocateInfoNV    with either its image or buffer field set to a value other    than VK_NULL_HANDLE.</para>
/// <para>  If the pNext chain contains an instance ofVkExportMemoryAllocateInfo, it must not contain an instance ofVkExportMemoryAllocateInfoNV orVkExportMemoryWin32HandleInfoNV.</para>
/// <para>  If the pNext chain contains an instance ofVkImportMemoryWin32HandleInfoKHR, it must not contain an instanceof VkImportMemoryWin32HandleInfoNV.</para>
/// <para>  If the parameters define an import operation, the external handlespecified was created by the Vulkan API, and the external handle type isVK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR, then the valuesof allocationSize and memoryTypeIndex must match thosespecified when the memory object being imported was created.</para>
/// <para>  If the parameters define an import operation and the external handlespecified was created by the Vulkan API, the device mask specified byVkMemoryAllocateFlagsInfo must match that specified when thememory object being imported was allocated.</para>
/// <para>  If the parameters define an import operation and the external handlespecified was created by the Vulkan API, the list of physical devicesthat comprise the logical device passed to vkAllocateMemory mustmatch the list of physical devices that comprise the logical device onwhich the memory was originally allocated.</para>
/// <para>  If the parameters define an import operation and the external handle isan NT handle or a global share handle created outside of the Vulkan API,the value of memoryTypeIndex must be one of those returned byvkGetMemoryWin32HandlePropertiesKHR.</para>
/// <para>  If the parameters define an import operation, the external handle wascreated by the Vulkan API, and the external handle type isVK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR orVK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR, then thevalues of allocationSize and memoryTypeIndex must matchthose specified when the memory object being imported was created.</para>
/// <para>  If the parameters define an import operation and the external handletype is VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, orVK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,allocationSize must match the size reported in the memoryrequirements of the image or buffer member of the instanceof VkDedicatedAllocationMemoryAllocateInfoNV included in thepNext chain.</para>
/// <para>  If the parameters define an import operation and the external handletype is VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,allocationSize must match the size specified when creating theDirect3D 12 heap from which the external handle was extracted.</para>
/// <para>  If the parameters define an import operation and the external handle isa POSIX file descriptor created outside of the Vulkan API, the value ofmemoryTypeIndex must be one of those returned byvkGetMemoryFdPropertiesKHR.</para>
/// <para>  If the protected memory feature is not enabled, theVkMemoryAllocateInfo::memoryTypeIndex must not indicate amemory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT.</para>
/// <para>  If the parameters define an import operation and the external handle isa host pointer, the value of memoryTypeIndex must be one of thosereturned by vkGetMemoryHostPointerPropertiesEXT </para>
/// <para>  If the parameters define an import operation and the external handle isa host pointer, allocationSize must be an integer multiple ofVkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment </para>
/// <para>  If the parameters define an import operation and the external handletype isVK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,allocationSize must be the size returned byvkGetAndroidHardwareBufferPropertiesANDROID for the Androidhardware buffer.</para>
/// <para>  If the parameters define an import operation and the external handletype isVK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,and the pNext chain does not contain an instance ofVkMemoryDedicatedAllocateInfo orVkMemoryDedicatedAllocateInfo::image isVK_NULL_HANDLE, the Android hardware buffer must have aAHardwareBuffer_Desc::format ofAHARDWAREBUFFER_FORMAT_BLOB and aAHardwareBuffer_Desc::usage that includesAHARDWAREBUFFER_USAGE_GPU_DATA_BUFFER.</para>
/// <para>  If the parameters define an import operation and the external handletype isVK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,memoryTypeIndex must be one of those returned byvkGetAndroidHardwareBufferPropertiesANDROID for the Androidhardware buffer.</para>
/// <para>  If the parameters do not define an import operation, and the pNextchain contains an instance of VkExportMemoryAllocateInfo withVK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROIDincluded in its handleTypes member, and the pNext containsan instance of VkMemoryDedicatedAllocateInfo with image notequal to VK_NULL_HANDLE, then allocationSize must be 0,otherwise allocationSize must be greater than 0.</para>
/// <para>  If the parameters define an import operation, the external handle is anAndroid hardware buffer, and the pNext chain includes an instanceof VkMemoryDedicatedAllocateInfo with image that is notVK_NULL_HANDLE, the Android hardware buffer’sAHardwareBuffer::usage must include at least one ofAHARDWAREBUFFER_USAGE_GPU_COLOR_OUTPUT orAHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE.</para>
/// <para>  If the parameters define an import operation, the external handle is anAndroid hardware buffer, and the pNext chain includes an instanceof VkMemoryDedicatedAllocateInfo with image that is notVK_NULL_HANDLE, the format of image must beVK_FORMAT_UNDEFINED or the format returned byvkGetAndroidHardwareBufferPropertiesANDROID inVkAndroidHardwareBufferFormatPropertiesANDROID::format forthe Android hardware buffer.</para>
/// <para>  If the parameters define an import operation, the external handle is anAndroid hardware buffer, and the pNext chain includes an instanceof VkMemoryDedicatedAllocateInfo with image that is notVK_NULL_HANDLE, the width, height, and array layer dimensions ofimage and the Android hardware buffer’s AHardwareBuffer_Desc must be identical.</para>
/// <para>  If the parameters define an import operation, the external handle is anAndroid hardware buffer, and the pNext chain includes an instanceof VkMemoryDedicatedAllocateInfo with image that is notVK_NULL_HANDLE, and the Android hardware buffer’sAHardwareBuffer::usage includesAHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE, the image musthave a complete mipmap chain.</para>
/// <para>  If the parameters define an import operation, the external handle is anAndroid hardware buffer, and the pNext chain includes an instanceof VkMemoryDedicatedAllocateInfo with image that is notVK_NULL_HANDLE, and the Android hardware buffer’sAHardwareBuffer::usage does not includeAHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE, the image musthave exactly one mipmap level.</para>
/// <para>  If the parameters define an import operation, the external handle is anAndroid hardware buffer, and the pNext chain includes an instanceof VkMemoryDedicatedAllocateInfo with image that is notVK_NULL_HANDLE, each bit set in the usage of image must belisted inAHardwareBuffer UsageEquivalence, and if there is a correspondingAHARDWAREBUFFER_USAGE bit listed that bit must be included in theAndroid hardware buffer’s AHardwareBuffer_Desc::usage.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDedicatedAllocationMemoryAllocateInfoNV, VkExportMemoryAllocateInfo, VkExportMemoryAllocateInfoNV, VkExportMemoryWin32HandleInfoKHR, VkExportMemoryWin32HandleInfoNV, VkImportAndroidHardwareBufferInfoANDROID, VkImportMemoryFdInfoKHR, VkImportMemoryHostPointerInfoEXT, VkImportMemoryWin32HandleInfoKHR, VkImportMemoryWin32HandleInfoNV, VkMemoryAllocateFlagsInfo, VkMemoryDedicatedAllocateInfo, or VkMemoryPriorityAllocateInfoEXT </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// </summary>
public unsafe struct VkMemoryAllocateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> allocationSize is the size of the allocation in bytes</summary>
    public VkDeviceSize       allocationSize;
    /// <summary> memoryTypeIndex is an index identifying a memory type from the
    /// memoryTypes array of the VkPhysicalDeviceMemoryProperties
    /// structure</summary>
    public UInt32           memoryTypeIndex;
}
// Struct: 199
/// <summary>VkMemoryBarrier - Structure specifying a global memory barrier
/// <para>The first access scope islimited to access types in the source accessmask specified by srcAccessMask.</para>
/// <para>The second access scope islimited to access types in the destinationaccess mask specified by dstAccessMask.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_MEMORY_BARRIER </para>
/// <para>   pNext must be NULL </para>
/// <para>   srcAccessMask must be a valid combination of VkAccessFlagBits values</para>
/// <para>   dstAccessMask must be a valid combination of VkAccessFlagBits values</para>
/// </summary>
public unsafe struct VkMemoryBarrier {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> srcAccessMask is a bitmask of VkAccessFlagBits specifying a
    /// source access mask.</summary>
    public VkAccessFlags      srcAccessMask;
    /// <summary> dstAccessMask is a bitmask of VkAccessFlagBits specifying a
    /// destination access mask.</summary>
    public VkAccessFlags      dstAccessMask;
}
// Struct: 200
/// <summary>VkMemoryDedicatedAllocateInfo - Specify a dedicated memory allocation resource
/// <para>  At least one of image and buffer must beVK_NULL_HANDLE </para>
/// <para>  If image is not VK_NULL_HANDLE,VkMemoryAllocateInfo::allocationSize must equal theVkMemoryRequirements::size of the image</para>
/// <para>  If image is not VK_NULL_HANDLE, image must have beencreated without VK_IMAGE_CREATE_SPARSE_BINDING_BIT set inVkImageCreateInfo::flags </para>
/// <para>  If buffer is not VK_NULL_HANDLE,VkMemoryAllocateInfo::allocationSize must equal theVkMemoryRequirements::size of the buffer</para>
/// <para>  If buffer is not VK_NULL_HANDLE, buffer must havebeen created without VK_BUFFER_CREATE_SPARSE_BINDING_BIT set inVkBufferCreateInfo::flags </para>
/// <para>  If image is not VK_NULL_HANDLE andVkMemoryAllocateInfo defines a memory import operation with handletype VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, orVK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, and theexternal handle was created by the Vulkan API, then the memory beingimported must also be a dedicated image allocation and image mustbe identical to the image associated with the imported memory.</para>
/// <para>  If buffer is not VK_NULL_HANDLE andVkMemoryAllocateInfo defines a memory import operation with handletype VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, orVK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, and theexternal handle was created by the Vulkan API, then the memory beingimported must also be a dedicated buffer allocation and buffermust be identical to the buffer associated with the imported memory.</para>
/// <para>  If image is not VK_NULL_HANDLE andVkMemoryAllocateInfo defines a memory import operation with handletype VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, the memorybeing imported must also be a dedicated image allocation andimage must be identical to the image associated with the importedmemory.</para>
/// <para>  If buffer is not VK_NULL_HANDLE andVkMemoryAllocateInfo defines a memory import operation with handletype VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, the memorybeing imported must also be a dedicated buffer allocation andbuffer must be identical to the buffer associated with theimported memory.</para>
/// <para>  If image is not VK_NULL_HANDLE, image must not havebeen created with VK_IMAGE_CREATE_DISJOINT_BIT set inVkImageCreateInfo::flags </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO </para>
/// <para>   If image is not VK_NULL_HANDLE, image must be a valid VkImage handle</para>
/// <para>   If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle</para>
/// <para>   Both of buffer, and image that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkMemoryDedicatedAllocateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> image is VK_NULL_HANDLE or a handle of an image which this
    /// memory will be bound to.</summary>
    public VkImage            image;
    /// <summary> buffer is VK_NULL_HANDLE or a handle of a buffer which this
    /// memory will be bound to.</summary>
    public VkBuffer           buffer;
}
// Struct: 201
/// <summary>VkMemoryDedicatedRequirements - Structure describing dedicated allocation requirements of buffer and image resources
/// <para>When the implementation sets requiresDedicatedAllocation toVK_TRUE, it must also set prefersDedicatedAllocation toVK_TRUE.</para>
/// <para>If the VkMemoryDedicatedRequirements structure is included in thepNext chain of the VkMemoryRequirements2 structure passed as thepMemoryRequirements parameter of avkGetBufferMemoryRequirements2 call, requiresDedicatedAllocation may be VK_TRUE under one of the following conditions:</para>
/// <para>The pNext chain of VkBufferCreateInfo for the call tovkCreateBuffer used to create the buffer being queried containedan instance of VkExternalMemoryBufferCreateInfo, and any of thehandle types specified inVkExternalMemoryBufferCreateInfo::handleTypes requiresdedicated allocation, as reported byvkGetPhysicalDeviceExternalBufferProperties inVkExternalBufferProperties::externalMemoryProperties::externalMemoryFeatures,the requiresDedicatedAllocation field will be set toVK_TRUE.</para>
/// <para>In all other cases, requiresDedicatedAllocation must be set toVK_FALSE by the implementation whenever aVkMemoryDedicatedRequirements structure is included in the pNextchain of the VkMemoryRequirements2 structure passed to a call tovkGetBufferMemoryRequirements2.</para>
/// <para>If the VkMemoryDedicatedRequirements structure is included in thepNext chain of the VkMemoryRequirements2 structure passed as thepMemoryRequirements parameter of avkGetBufferMemoryRequirements2 call andVK_BUFFER_CREATE_SPARSE_BINDING_BIT was set inVkBufferCreateInfo::flags when buffer was created then theimplementation must set both prefersDedicatedAllocation andrequiresDedicatedAllocation to VK_FALSE.</para>
/// <para>If the VkMemoryDedicatedRequirements structure is included in thepNext chain of the VkMemoryRequirements2 structure passed as thepMemoryRequirements parameter of a vkGetImageMemoryRequirements2call, requiresDedicatedAllocation may be VK_TRUE under one ofthe following conditions:</para>
/// <para>The pNext chain of VkImageCreateInfo for the call tovkCreateImage used to create the image being queried contained aninstance of VkExternalMemoryImageCreateInfo, and any of the handletypes specified inVkExternalMemoryImageCreateInfo::handleTypes requiresdedicated allocation, as reported byvkGetPhysicalDeviceImageFormatProperties2 inVkExternalImageFormatProperties::externalMemoryProperties::externalMemoryFeatures,the requiresDedicatedAllocation field will be set toVK_TRUE.</para>
/// <para>In all other cases, requiresDedicatedAllocation must be set toVK_FALSE by the implementation whenever aVkMemoryDedicatedRequirements structure is included in the pNextchain of the VkMemoryRequirements2 structure passed to a call tovkGetImageMemoryRequirements2.</para>
/// <para>If the VkMemoryDedicatedRequirements structure is included in thepNext chain of the VkMemoryRequirements2 structure passed as thepMemoryRequirements parameter of a vkGetImageMemoryRequirements2call and VK_IMAGE_CREATE_SPARSE_BINDING_BIT was set inVkImageCreateInfo::flags when image was created then theimplementation must set both prefersDedicatedAllocation andrequiresDedicatedAllocation to VK_FALSE.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS </para>
/// </summary>
public unsafe struct VkMemoryDedicatedRequirements {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> prefersDedicatedAllocation specifies that the implementation would
    /// prefer a dedicated allocation for this resource.
    /// The application is still free to suballocate the resource but it may
    /// get better performance if a dedicated allocation is used.</summary>
    public VkBool32           prefersDedicatedAllocation;
    /// <summary> requiresDedicatedAllocation specifies that a dedicated allocation
    /// is required for this resource.</summary>
    public VkBool32           requiresDedicatedAllocation;
}
// Struct: 202
/// <summary>VkMemoryFdPropertiesKHR - Properties of External Memory File Descriptors
/// <para>   sType must be VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkMemoryFdPropertiesKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> memoryTypeBits is a bitmask containing one bit set for every
    /// memory type which the specified file descriptor can be imported as.</summary>
    public UInt32           memoryTypeBits;
}
// Struct: 203
/// <summary>VkMemoryGetAndroidHardwareBufferInfoANDROID - Structure describing an Android hardware buffer memory export operation
/// <para>   VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID must have been included inVkExportMemoryAllocateInfoKHR::handleTypes when memorywas created.</para>
/// <para>  If the pNext chain of the VkMemoryAllocateInfo used toallocate memory included a VkMemoryDedicatedAllocateInfowith non-NULL image member, then that image must alreadybe bound to memory.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID </para>
/// <para>   pNext must be NULL </para>
/// <para>   memory must be a valid VkDeviceMemory handle</para>
/// </summary>
public unsafe struct VkMemoryGetAndroidHardwareBufferInfoANDROID {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> memory is the memory object from which the Android hardware buffer
    /// will be exported.</summary>
    public VkDeviceMemory     memory;
}
// Struct: 204
/// <summary>VkMemoryGetFdInfoKHR - Structure describing a POSIX FD semaphore export operation
/// <para>The properties of the file descriptor exported depend on the value ofhandleType.See VkExternalMemoryHandleTypeFlagBits for a description of theproperties of the defined external memory handle types.</para>
/// <para>The size of the exported file may be larger than the size requested byVkMemoryAllocateInfo::allocationSize.If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,then the application can query the file’s actual size withlseek(2).</para>
/// <para>   handleType must have been included inVkExportMemoryAllocateInfo::handleTypes when memorywas created.</para>
/// <para>   handleType must be defined as a POSIX file descriptor handle.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   memory must be a valid VkDeviceMemory handle</para>
/// <para>   handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</para>
/// </summary>
public unsafe struct VkMemoryGetFdInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                           pNext;
    /// <summary> memory is the memory object from which the handle will be
    /// exported.</summary>
    public VkDeviceMemory                        memory;
    /// <summary> handleType is the type of handle requested.</summary>
    public VkExternalMemoryHandleTypeFlagBits    handleType;
}
// Struct: 205
/// <summary>VkMemoryGetWin32HandleInfoKHR - Structure describing a Win32 handle semaphore export operation
/// <para>The properties of the handle returned depend on the value ofhandleType.See VkExternalMemoryHandleTypeFlagBits for a description of theproperties of the defined external memory handle types.</para>
/// <para>   handleType must have been included inVkExportMemoryAllocateInfo::handleTypes when memorywas created.</para>
/// <para>  If handleType is defined as an NT handle,vkGetMemoryWin32HandleKHR must be called no more than once foreach valid unique combination of memory and handleType.</para>
/// <para>   handleType must be defined as an NT handle or a global sharehandle.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   memory must be a valid VkDeviceMemory handle</para>
/// <para>   handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</para>
/// </summary>
public unsafe struct VkMemoryGetWin32HandleInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                           pNext;
    /// <summary> memory is the memory object from which the handle will be
    /// exported.</summary>
    public VkDeviceMemory                        memory;
    /// <summary> handleType is the type of handle requested.</summary>
    public VkExternalMemoryHandleTypeFlagBits    handleType;
}
// Struct: 206
/// <summary>VkMemoryHeap - Structure specifying a memory heap
/// </summary>
public unsafe struct VkMemoryHeap {
    /// <summary> size is the total memory size in bytes in the heap.</summary>
    public VkDeviceSize         size;
    /// <summary> flags is a bitmask of VkMemoryHeapFlagBits specifying
    /// attribute flags for the heap.</summary>
    public VkMemoryHeapFlags    flags;
}
// Struct: 207
/// <summary>VkMemoryHostPointerPropertiesEXT - Properties of external memory host pointer
/// <para>The value returned by memoryTypeBits must only include bits thatidentify memory types which are host visible.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkMemoryHostPointerPropertiesEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> memoryTypeBits is a bitmask containing one bit set for every
    /// memory type which the specified host pointer can be imported as.</summary>
    public UInt32           memoryTypeBits;
}
// Struct: 208
/// <summary>VkMemoryPriorityAllocateInfoEXT - Specify a memory allocation priority
/// <para>Memory allocations with higher priority may be more likely to stay indevice-local memory when the system is under memory pressure.</para>
/// <para>If this structure is not included, it is as if the priority value were0.5.</para>
/// <para>   priority must be between 0 and 1, inclusive</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT </para>
/// </summary>
public unsafe struct VkMemoryPriorityAllocateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> priority is a floating-point value between 0 and 1, indicating
    /// the priority of the allocation relative to other memory allocations.
    /// Larger values are higher priority.
    /// The granularity of the priorities is implementation-dependent.</summary>
    public float              priority;
}
// Struct: 209
/// <summary>VkMemoryRequirements - Structure specifying memory requirements
/// </summary>
public unsafe struct VkMemoryRequirements {
    /// <summary> size is the size, in bytes, of the memory allocation required for
    /// the resource.</summary>
    public VkDeviceSize    size;
    /// <summary> alignment is the alignment, in bytes, of the offset within the
    /// allocation required for the resource.</summary>
    public VkDeviceSize    alignment;
    /// <summary> memoryTypeBits is a bitmask and contains one bit set for every
    /// supported memory type for the resource.
    /// Bit i is set if and only if the memory type i in the
    /// VkPhysicalDeviceMemoryProperties structure for the physical device
    /// is supported for the resource.</summary>
    public UInt32        memoryTypeBits;
}
// Struct: 210
/// <summary>VkMemoryRequirements2 - Structure specifying memory requirements
/// <para>   sType must be VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkMemoryDedicatedRequirements </para>
/// </summary>
public unsafe struct VkMemoryRequirements2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType         sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                   pNext;
    /// <summary> memoryRequirements is a structure of type
    /// VkMemoryRequirements describing the memory requirements of the
    /// resource.</summary>
    public VkMemoryRequirements    memoryRequirements;
}
// Struct: 211
/// <summary>VkMemoryType - Structure specifying memory type
/// </summary>
public unsafe struct VkMemoryType {
    /// <summary> propertyFlags is a bitmask of VkMemoryPropertyFlagBits of
    /// properties for this memory type.</summary>
    public VkMemoryPropertyFlags    propertyFlags;
    /// <summary> heapIndex describes which memory heap this memory type corresponds
    /// to, and must be less than memoryHeapCount from the
    /// VkPhysicalDeviceMemoryProperties structure.</summary>
    public UInt32                 heapIndex;
}
// Struct: 212
/// <summary>VkMemoryWin32HandlePropertiesKHR - Properties of External Memory Windows Handles
/// <para>   sType must be VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkMemoryWin32HandlePropertiesKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> memoryTypeBits is a bitmask containing one bit set for every
    /// memory type which the specified windows handle can be imported as.</summary>
    public UInt32           memoryTypeBits;
}
// Struct: 213
/// <summary>VkMetalSurfaceCreateInfoEXT - Structure specifying parameters of a newly created Metal surface object
/// <para>   sType must be VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkMetalSurfaceCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                 sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                     pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkMetalSurfaceCreateFlagsEXT    flags;
    /// <summary> pLayer is a reference to a CAMetalLayer object that
    /// represents a renderable surface.</summary>
    public /* const */ CAMetalLayer*             pLayer;
}
// Struct: 214
/// <summary>VkMultisamplePropertiesEXT - Structure returning information about sample count specific additional multisampling capabilities
/// <para>   sType must be VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkMultisamplePropertiesEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> maxSampleLocationGridSize is the maximum size of the pixel grid in
    /// which sample locations can vary.</summary>
    public VkExtent2D         maxSampleLocationGridSize;
}
// Struct: 215
/// <summary>VkObjectTableCreateInfoNVX - Structure specifying the parameters of a newly created object table
/// <para>  If theVkDeviceGeneratedCommandsFeaturesNVX::computeBindingPointSupportfeature is not enabled, pObjectEntryUsageFlags must not containVK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX </para>
/// <para>  Any value within pObjectEntryCounts must not exceedVkDeviceGeneratedCommandsLimitsNVX::maxObjectEntryCounts </para>
/// <para>   maxUniformBuffersPerDescriptor must be within the limitssupported by the device.</para>
/// <para>   maxStorageBuffersPerDescriptor must be within the limitssupported by the device.</para>
/// <para>   maxStorageImagesPerDescriptor must be within the limits supportedby the device.</para>
/// <para>   maxSampledImagesPerDescriptor must be within the limits supportedby the device.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX </para>
/// <para>   pNext must be NULL </para>
/// <para>   pObjectEntryTypes must be a valid pointer to an array of objectCount valid VkObjectEntryTypeNVX values</para>
/// <para>   pObjectEntryCounts must be a valid pointer to an array of objectCount uint32_t values</para>
/// <para>   pObjectEntryUsageFlags must be a valid pointer to an array of objectCount valid combinations of VkObjectEntryUsageFlagBitsNVX values</para>
/// <para>   Each element of pObjectEntryUsageFlags must not be 0 </para>
/// <para>   objectCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkObjectTableCreateInfoNVX {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                          pNext;
    /// <summary> objectCount is the number of entry configurations that the object
    /// table supports.</summary>
    public UInt32                             objectCount;
    /// <summary> pObjectEntryTypes is an array of VkObjectEntryTypeNVX values
    /// providing the entry type of a given configuration.</summary>
    public /* const */ VkObjectEntryTypeNVX*          pObjectEntryTypes;
    /// <summary> pObjectEntryCounts is an array of counts of how many objects can
    /// be registered in the table.</summary>
    public /* const */ UInt32*                      pObjectEntryCounts;
    /// <summary> pObjectEntryUsageFlags is an array of bitmasks of
    /// VkObjectEntryUsageFlagBitsNVX specifying the binding usage of the
    /// entry.</summary>
    public /* const */ VkObjectEntryUsageFlagsNVX*    pObjectEntryUsageFlags;
    /// <summary> maxUniformBuffersPerDescriptor is the maximum number of
    /// VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    /// VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC used by any single
    /// registered VkDescriptorSet in this table.</summary>
    public UInt32                             maxUniformBuffersPerDescriptor;
    /// <summary> maxStorageBuffersPerDescriptor is the maximum number of
    /// VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    /// VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC used by any single
    /// registered VkDescriptorSet in this table.</summary>
    public UInt32                             maxStorageBuffersPerDescriptor;
    /// <summary> maxStorageImagesPerDescriptor is the maximum number of
    /// VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or
    /// VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER used by any single
    /// registered VkDescriptorSet in this table.</summary>
    public UInt32                             maxStorageImagesPerDescriptor;
    /// <summary> maxSampledImagesPerDescriptor is the maximum number of
    /// VK_DESCRIPTOR_TYPE_SAMPLER,
    /// VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    /// VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or
    /// VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT used by any single registered
    /// VkDescriptorSet in this table.</summary>
    public UInt32                             maxSampledImagesPerDescriptor;
    /// <summary> maxPipelineLayouts is the maximum number of unique
    /// VkPipelineLayout used by any registered VkDescriptorSet or
    /// VkPipeline in this table.</summary>
    public UInt32                             maxPipelineLayouts;
}
// Struct: 216
/// <summary>VkObjectTableDescriptorSetEntryNVX - Parameters of an object table descriptor set entry
/// <para>   type must be VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX </para>
/// <para>   type must be a valid VkObjectEntryTypeNVX value</para>
/// <para>   flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values</para>
/// <para>   flags must not be 0 </para>
/// <para>   pipelineLayout must be a valid VkPipelineLayout handle</para>
/// <para>   descriptorSet must be a valid VkDescriptorSet handle</para>
/// <para>   Both of descriptorSet, and pipelineLayout must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkObjectTableDescriptorSetEntryNVX {
    public VkObjectEntryTypeNVX          type;
    public VkObjectEntryUsageFlagsNVX    flags;
    /// <summary> pipelineLayout specifies the VkPipelineLayout that the
    /// descriptorSet is used with.</summary>
    public VkPipelineLayout              pipelineLayout;
    /// <summary> descriptorSet specifies the VkDescriptorSet that can be
    /// bound with this entry.</summary>
    public VkDescriptorSet               descriptorSet;
}
// Struct: 217
/// <summary>VkObjectTableEntryNVX - Common parameters of an object table resource entry
/// <para>  If theVkDeviceGeneratedCommandsFeaturesNVX::computeBindingPointSupportfeature is not enabled, flags must not containVK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX </para>
/// <para>   type must be a valid VkObjectEntryTypeNVX value</para>
/// <para>   flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values</para>
/// <para>   flags must not be 0 </para>
/// </summary>
public unsafe struct VkObjectTableEntryNVX {
    /// <summary> type defines the entry type</summary>
    public VkObjectEntryTypeNVX          type;
    /// <summary> flags defines which VkPipelineBindPoint the resource can be
    /// used with.
    /// Some entry types allow only a single flag to be set.</summary>
    public VkObjectEntryUsageFlagsNVX    flags;
}
// Struct: 218
/// <summary>VkObjectTableIndexBufferEntryNVX - Parameters of an object table index buffer entry
/// <para>   type must be VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX </para>
/// <para>   type must be a valid VkObjectEntryTypeNVX value</para>
/// <para>   flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values</para>
/// <para>   flags must not be 0 </para>
/// <para>   buffer must be a valid VkBuffer handle</para>
/// <para>   indexType must be a valid VkIndexType value</para>
/// </summary>
public unsafe struct VkObjectTableIndexBufferEntryNVX {
    public VkObjectEntryTypeNVX          type;
    public VkObjectEntryUsageFlagsNVX    flags;
    /// <summary> buffer specifies the VkBuffer that can be bound as index
    /// buffer</summary>
    public VkBuffer                      buffer;
    /// <summary> indexType specifies the VkIndexType used with this index
    /// buffer</summary>
    public VkIndexType                   indexType;
}
// Struct: 219
/// <summary>VkObjectTablePipelineEntryNVX - Parameters of an object table pipeline entry
/// <para>   type must be VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX </para>
/// <para>   type must be a valid VkObjectEntryTypeNVX value</para>
/// <para>   flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values</para>
/// <para>   flags must not be 0 </para>
/// <para>   pipeline must be a valid VkPipeline handle</para>
/// </summary>
public unsafe struct VkObjectTablePipelineEntryNVX {
    public VkObjectEntryTypeNVX          type;
    public VkObjectEntryUsageFlagsNVX    flags;
    /// <summary> pipeline specifies the VkPipeline that this resource entry
    /// references.</summary>
    public VkPipeline                    pipeline;
}
// Struct: 220
/// <summary>VkObjectTablePushConstantEntryNVX - Parameters of an object table push constant entry
/// <para>   type must be VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX </para>
/// <para>   type must be a valid VkObjectEntryTypeNVX value</para>
/// <para>   flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values</para>
/// <para>   flags must not be 0 </para>
/// <para>   pipelineLayout must be a valid VkPipelineLayout handle</para>
/// <para>   stageFlags must be a valid combination of VkShaderStageFlagBits values</para>
/// <para>   stageFlags must not be 0 </para>
/// </summary>
public unsafe struct VkObjectTablePushConstantEntryNVX {
    public VkObjectEntryTypeNVX          type;
    public VkObjectEntryUsageFlagsNVX    flags;
    /// <summary> pipelineLayout specifies the VkPipelineLayout that the
    /// pushconstants are used with</summary>
    public VkPipelineLayout              pipelineLayout;
    /// <summary> stageFlags specifies the VkShaderStageFlags that the
    /// pushconstants are used with</summary>
    public VkShaderStageFlags            stageFlags;
}
// Struct: 221
/// <summary>VkObjectTableVertexBufferEntryNVX - Parameters of an object table vertex buffer entry
/// <para>   type must be VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX </para>
/// <para>   type must be a valid VkObjectEntryTypeNVX value</para>
/// <para>   flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values</para>
/// <para>   flags must not be 0 </para>
/// <para>   buffer must be a valid VkBuffer handle</para>
/// </summary>
public unsafe struct VkObjectTableVertexBufferEntryNVX {
    public VkObjectEntryTypeNVX          type;
    public VkObjectEntryUsageFlagsNVX    flags;
    /// <summary> buffer specifies the VkBuffer that can be bound as vertex
    /// bufer</summary>
    public VkBuffer                      buffer;
}
// Struct: 222
/// <summary>VkOffset2D - Structure specifying a two-dimensional offset
/// </summary>
public unsafe struct VkOffset2D {
    /// <summary> x is the x offset.</summary>
    public Int32    x;
    /// <summary> y is the y offset.</summary>
    public Int32    y;
}
// Struct: 223
/// <summary>VkOffset3D - Structure specifying a three-dimensional offset
/// </summary>
public unsafe struct VkOffset3D {
    /// <summary> x is the x offset.</summary>
    public Int32    x;
    /// <summary> y is the y offset.</summary>
    public Int32    y;
    /// <summary> z is the z offset.</summary>
    public Int32    z;
}
// Struct: 224
/// <summary>VkPastPresentationTimingGOOGLE - Structure containing timing information about a previously-presented image
/// <para>The results for a given swapchain and presentID are onlyreturned once from vkGetPastPresentationTimingGOOGLE.</para>
/// <para>The application can use the VkPastPresentationTimingGOOGLE values tooccasionally adjust its timing.For example, if actualPresentTime is later than expected (e.g. onerefreshDuration late), the application may increase its target IPD toa higher multiple of refreshDuration (e.g. decrease its frame ratefrom 60Hz to 30Hz).If actualPresentTime and earliestPresentTime are consistentlydifferent, and if presentMargin is consistently large enough, theapplication may decrease its target IPD to a smaller multiple ofrefreshDuration (e.g. increase its frame rate from 30Hz to 60Hz).If actualPresentTime and earliestPresentTime are same, and ifpresentMargin is consistently high, the application may delay thestart of its input-render-present loop in order to decrease the latencybetween user input and the corresponding present (always leaving some marginin case a new image takes longer to render than the previous image).An application that desires its target IPD to always be the same asrefreshDuration, can also adjust features untilactualPresentTime is never late and presentMargin issatisfactory.</para>
/// </summary>
public unsafe struct VkPastPresentationTimingGOOGLE {
    /// <summary> presentID is an application-provided value that was given to a
    /// previous vkQueuePresentKHR command via
    /// VkPresentTimeGOOGLE::presentID (see below).
    /// It can be used to uniquely identify a previous present with the
    /// vkQueuePresentKHR command.</summary>
    public UInt32    presentID;
    /// <summary> desiredPresentTime is an application-provided value that was given
    /// to a previous vkQueuePresentKHR command via
    /// VkPresentTimeGOOGLE::desiredPresentTime.
    /// If non-zero, it was used by the application to indicate that an image
    /// not be presented any sooner than desiredPresentTime.</summary>
    public UInt64    desiredPresentTime;
    /// <summary> actualPresentTime is the time when the image of the
    /// swapchain was actually displayed.</summary>
    public UInt64    actualPresentTime;
    /// <summary> earliestPresentTime is the time when the image of the
    /// swapchain could have been displayed.
    /// This may differ from actualPresentTime if the application
    /// requested that the image be presented no sooner than
    /// VkPresentTimeGOOGLE::desiredPresentTime.</summary>
    public UInt64    earliestPresentTime;
    /// <summary> presentMargin is an indication of how early the
    /// vkQueuePresentKHR command was processed compared to how soon it
    /// needed to be processed, and still be presented at
    /// earliestPresentTime.</summary>
    public UInt64    presentMargin;
}
// Struct: 225
/// <summary>VkPhysicalDevice16BitStorageFeatures - Structure describing features supported by VK_KHR_16bit_storage
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES </para>
/// </summary>
public unsafe struct VkPhysicalDevice16BitStorageFeatures {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary>  
    ///   storageBuffer16BitAccess
    /// specifies whether objects in the StorageBuffer
    /// or PhysicalStorageBufferEXT
    /// storage class with the Block decoration can have 16-bit integer
    /// and 16-bit floating-point members.
    /// If this feature is not enabled, 16-bit integer or 16-bit floating-point
    /// members must not be used in such objects.
    /// This also specifies whether shader modules can declare the
    /// StorageBuffer16BitAccess capability.</summary>
    public VkBool32           storageBuffer16BitAccess;
    /// <summary>  
    ///   uniformAndStorageBuffer16BitAccess specifies whether objects in
    /// the Uniform storage class with the Block decoration and in the
    /// StorageBuffer
    /// or PhysicalStorageBufferEXT
    /// storage class with the same decoration can have 16-bit integer and
    /// 16-bit floating-point members.
    /// If this feature is not enabled, 16-bit integer or 16-bit floating-point
    /// members must not be used in such objects.
    /// This also specifies whether shader modules can declare the
    /// UniformAndStorageBuffer16BitAccess capability.</summary>
    public VkBool32           uniformAndStorageBuffer16BitAccess;
    /// <summary>  
    ///   storagePushConstant16 specifies
    /// whether objects in the PushConstant storage class can have 16-bit
    /// integer and 16-bit floating-point members.
    /// If this feature is not enabled, 16-bit integer or floating-point members
    /// must not be used in such objects.
    /// This also specifies whether shader modules can declare the
    /// StoragePushConstant16 capability.</summary>
    public VkBool32           storagePushConstant16;
    /// <summary>  
    ///   storageInputOutput16 specifies
    /// whether objects in the Input and Output storage classes can
    /// have 16-bit integer and 16-bit floating-point members.
    /// If this feature is not enabled, 16-bit integer or 16-bit floating-point
    /// members must not be used in such objects.
    /// This also specifies whether shader modules can declare the
    /// StorageInputOutput16 capability.</summary>
    public VkBool32           storageInputOutput16;
}
// Struct: 226
/// <summary>VkPhysicalDevice8BitStorageFeaturesKHR - Structure describing features supported by VK_KHR_8bit_storage
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR </para>
/// </summary>
public unsafe struct VkPhysicalDevice8BitStorageFeaturesKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary>  
    ///   storageBuffer8BitAccess
    /// indicates whether objects in the StorageBuffer
    /// or PhysicalStorageBufferEXT
    /// storage class with the Block decoration can have 8-bit integer
    /// members.
    /// If this feature is not enabled, 8-bit integer members must not be used
    /// in such objects.
    /// This also indicates whether shader modules can declare the
    /// StorageBuffer8BitAccess capability.</summary>
    public VkBool32           storageBuffer8BitAccess;
    /// <summary>  
    ///   uniformAndStorageBuffer8BitAccess indicates whether objects in the
    /// Uniform storage class with the Block decoration and in the
    /// StorageBuffer
    /// or PhysicalStorageBufferEXT
    /// storage class with the same decoration can have 8-bit integer members.
    /// If this feature is not enabled, 8-bit integer members must not be used
    /// in such objects.
    /// This also indicates whether shader modules can declare the
    /// UniformAndStorageBuffer8BitAccess capability.</summary>
    public VkBool32           uniformAndStorageBuffer8BitAccess;
    /// <summary>  
    ///   storagePushConstant8 indicates
    /// whether objects in the PushConstant storage class can have 8-bit
    /// integer members.
    /// If this feature is not enabled, 8-bit integer members must not be used
    /// in such objects.
    /// This also indicates whether shader modules can declare the
    /// StoragePushConstant8 capability.</summary>
    public VkBool32           storagePushConstant8;
}
// Struct: 227
/// <summary>VkPhysicalDeviceASTCDecodeFeaturesEXT - Structure describing ASTC decode mode features
/// <para>   decodeModeSharedExponent indicates whether the implementationsupports decoding ASTC compressed formats toVK_FORMAT_E5B9G9R9_UFLOAT_PACK32 internal precision.</para>
/// <para>If the VkPhysicalDeviceASTCDecodeFeaturesEXT structure is included inthe pNext chain of vkGetPhysicalDeviceFeatures2KHR, it is filledwith values indicating whether each feature is supported.VkPhysicalDeviceASTCDecodeFeaturesEXT can also be used in thepNext chain of vkCreateDevice to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceASTCDecodeFeaturesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           decodeModeSharedExponent;
}
// Struct: 228
/// <summary>VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT - Structure describing advanced blending features that can be supported by an implementation
/// <para>   advancedBlendCoherentOperations specifies whether blending usingadvanced blend operations is guaranteedto execute atomically and in primitiveorder.If this is VK_TRUE,VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT is treated thesame as VK_ACCESS_COLOR_ATTACHMENT_READ_BIT, and advanced blendingneeds no additional synchronization over basic blending.If this is VK_FALSE, then memory dependencies are required toguarantee order between two advanced blending operations that occur onthe same sample.</para>
/// <para>If the VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2, it isfilled with values indicating whether each feature is supported.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT can also be used inpNext chain of VkDeviceCreateInfo to enable the features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           advancedBlendCoherentOperations;
}
// Struct: 229
/// <summary>VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT - Structure describing advanced blending limits that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   advancedBlendMaxColorAttachments is one greater than the highestcolor attachment index that can be used in a subpass, for a pipelinethat uses an advanced blend operation.</para>
/// <para>   advancedBlendIndependentBlend specifies whether advanced blendoperations can vary per-attachment.</para>
/// <para>   advancedBlendNonPremultipliedSrcColor specifies whether the sourcecolor can be treated as non-premultiplied.If this is VK_FALSE, thenVkPipelineColorBlendAdvancedStateCreateInfoEXT::srcPremultiplied must be VK_TRUE.</para>
/// <para>   advancedBlendNonPremultipliedDstColor specifies whether thedestination color can be treated as non-premultiplied.If this is VK_FALSE, thenVkPipelineColorBlendAdvancedStateCreateInfoEXT::dstPremultiplied must be VK_TRUE.</para>
/// <para>   advancedBlendCorrelatedOverlap specifies whether the overlap modecan be treated as correlated.If this is VK_FALSE, thenVkPipelineColorBlendAdvancedStateCreateInfoEXT::blendOverlap must be VK_BLEND_OVERLAP_UNCORRELATED_EXT.</para>
/// <para>   advancedBlendAllOperationsspecifies whether all advanced blend operation enums are supported.See the valid usage of VkPipelineColorBlendAttachmentState.</para>
/// <para>If the VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT structureis included in the pNext chain of VkPhysicalDeviceProperties2,it is filled with the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public UInt32           advancedBlendMaxColorAttachments;
    public VkBool32           advancedBlendIndependentBlend;
    public VkBool32           advancedBlendNonPremultipliedSrcColor;
    public VkBool32           advancedBlendNonPremultipliedDstColor;
    public VkBool32           advancedBlendCorrelatedOverlap;
    public VkBool32           advancedBlendAllOperations;
}
// Struct: 230
/// <summary>VkPhysicalDeviceBufferDeviceAddressFeaturesEXT - Structure describing buffer address features that can be supported by an implementation
/// <para>   bufferDeviceAddress indicatesthat the implementation supports accessing buffer memory in shaders asstorage buffers via an address queried fromvkGetBufferDeviceAddressEXT.</para>
/// <para>   bufferDeviceAddressCaptureReplay indicates that the implementationsupports saving and reusing buffer addresses, e.g. for trace capture andreplay.</para>
/// <para>   bufferDeviceAddressMultiDevice indicates that the implementationsupports the bufferDeviceAddress feature for logical devicescreated with multiple physical devices.If this feature is not supported, buffer addresses must not be queriedon a logical device created with more than one physical device.</para>
/// <para> bufferDeviceAddressMultiDevice exists to allow certain legacyplatforms to be able to support bufferDeviceAddress without needing tosupport shared GPU virtual addresses for multi-device configurations.</para>
/// <para>See vkGetBufferDeviceAddressEXT for more information.</para>
/// <para>If the VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2KHR, itis filled with values indicating whether the feature is supported.VkPhysicalDeviceBufferDeviceAddressFeaturesEXT can also be used inthe pNext chain of VkDeviceCreateInfo to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           bufferDeviceAddress;
    public VkBool32           bufferDeviceAddressCaptureReplay;
    public VkBool32           bufferDeviceAddressMultiDevice;
}
// Struct: 231
/// <summary>VkPhysicalDeviceComputeShaderDerivativesFeaturesNV - Structure describing compute shader derivative features that can be supported by an implementation
/// <para>   computeDerivativeGroupQuads indicates that the implementationsupports the ComputeDerivativeGroupQuadsNV SPIR-V capability.</para>
/// <para>   computeDerivativeGroupLinear indicates that the implementationsupports the ComputeDerivativeGroupLinearNV SPIR-V capability.</para>
/// <para>See Compute Shader Derivatives for moreinformation.</para>
/// <para>If the VkPhysicalDeviceComputeShaderDerivativesFeaturesNV structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2KHR, itis filled with values indicating whether each feature is supported.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV can also be usedin the pNext chain of VkDeviceCreateInfo to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNV {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           computeDerivativeGroupQuads;
    public VkBool32           computeDerivativeGroupLinear;
}
// Struct: 232
/// <summary>VkPhysicalDeviceConditionalRenderingFeaturesEXT - Structure describing if a secondary command buffer can be executed if conditional rendering is active in the primary command buffer
/// <para>If the VkPhysicalDeviceConditionalRenderingFeaturesEXT structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2, it isfilled with values indicating the implementation-dependent behavior.VkPhysicalDeviceConditionalRenderingFeaturesEXT can also be used inpNext chain of VkDeviceCreateInfo to enable the features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceConditionalRenderingFeaturesEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary>  
    ///   conditionalRendering specifies
    /// whether conditional rendering is supported.</summary>
    public VkBool32           conditionalRendering;
    /// <summary>  
    ///   inheritedConditionalRendering specifies whether a secondary
    /// command buffer can be executed while conditional rendering is active in
    /// the primary command buffer.</summary>
    public VkBool32           inheritedConditionalRendering;
}
// Struct: 233
/// <summary>VkPhysicalDeviceConservativeRasterizationPropertiesEXT - Structure describing conservative raster properties that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   primitiveOverestimationSizeis the size in pixels the generating primitive is increased at each ofits edges during conservative rasterization overestimation mode.Even with a size of 0.0, conservative rasterization overestimation rulesstill apply and if any part of the pixel rectangle is covered by thegenerating primitive, fragments are generated for the entire pixel.However implementations may make the pixel coverage area even moreconservative by increasing the size of the generating primitive.</para>
/// <para>   maxExtraPrimitiveOverestimationSize is the maximum size in pixelsof extra overestimation the implementation supports in the pipelinestate.A value of 0.0 means the implementation does not support any additionaloverestimation of the generating primitive during conservativerasterization.A value above 0.0 allows the application to further increase the size ofthe generating primitive during conservative rasterizationoverestimation.</para>
/// <para>   extraPrimitiveOverestimationSizeGranularity is the granularity ofextra overestimation that can be specified in the pipeline state between0.0 and maxExtraPrimitiveOverestimationSize inclusive.A value of 0.0 means the implementation can use the smallestrepresentable non-zero value in the screen space pixel fixed-point grid.</para>
/// <para>   primitiveUnderestimation istrue if the implementation supports theVK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT conservativerasterization mode in addition toVK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT.Otherwise the implementation only supportsVK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT.</para>
/// <para>   conservativePointAndLineRasterization is true if theimplementation supports conservative rasterization of point and lineprimitives as well as triangle primitives.Otherwise the implementation only supports triangle primitives.</para>
/// <para>   degenerateTrianglesRasterized is false if the implementation cullsprimitives generated from triangles that become zero area after they arequantized to the fixed-point rasterization pixel grid.degenerateTrianglesRasterized is true if these primitives are notculled and the provoking vertex attributes and depth value are used forthe fragments.The primitive area calculation is done on the primitive generated fromthe clipped triangle if applicable.Zero area primitives are backfacing and the application can enablebackface culling if desired.</para>
/// <para>   degenerateLinesRasterized isfalse if the implementation culls lines that become zero length afterthey are quantized to the fixed-point rasterization pixel grid.degenerateLinesRasterized is true if zero length lines are notculled and the provoking vertex attributes and depth value are used forthe fragments.</para>
/// <para>   fullyCoveredFragmentShaderInputVariable is true if theimplementation supports the SPIR-V builtin fragment shader inputvariable FullyCoveredEXT which specifies that conservative rasterizationis enabled and the fragment area is fully covered by the generatingprimitive.</para>
/// <para>   conservativeRasterizationPostDepthCoverage is true if theimplementation supports conservative rasterization with the PostDepthCoverage execution mode enabled.When supported the SampleMask built-in input variable will reflectthe coverage after the early per-fragment depth and stencil tests areapplied even when conservative rasterization is enabled.Otherwise PostDepthCoverage execution mode must not be used when conservative rasterization isenabled.</para>
/// <para>If the VkPhysicalDeviceConservativeRasterizationPropertiesEXTstructure is included in the pNext chain ofVkPhysicalDeviceProperties2, it is filled with theimplementation-dependent limits and properties.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public float              primitiveOverestimationSize;
    public float              maxExtraPrimitiveOverestimationSize;
    public float              extraPrimitiveOverestimationSizeGranularity;
    public VkBool32           primitiveUnderestimation;
    public VkBool32           conservativePointAndLineRasterization;
    public VkBool32           degenerateTrianglesRasterized;
    public VkBool32           degenerateLinesRasterized;
    public VkBool32           fullyCoveredFragmentShaderInputVariable;
    public VkBool32           conservativeRasterizationPostDepthCoverage;
}
// Struct: 234
/// <summary>VkPhysicalDeviceCooperativeMatrixFeaturesNV - Structure describing cooperative matrix features that can be supported by an implementation
/// <para>   cooperativeMatrix indicates thatthe implementation supports the CooperativeMatrixNV SPIR-Vcapability.</para>
/// <para>   cooperativeMatrixRobustBufferAccess indicates that theimplementation supports robust buffer access for SPIR-VOpCooperativeMatrixLoadNV and OpCooperativeMatrixStoreNVinstructions.</para>
/// <para>If the VkPhysicalDeviceCooperativeMatrixFeaturesNV structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2KHR, itis filled with values indicating whether the feature is supported.VkPhysicalDeviceCooperativeMatrixFeaturesNV can also be used in thepNext chain of VkDeviceCreateInfo to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceCooperativeMatrixFeaturesNV {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           cooperativeMatrix;
    public VkBool32           cooperativeMatrixRobustBufferAccess;
}
// Struct: 235
/// <summary>VkPhysicalDeviceCooperativeMatrixPropertiesNV - Structure describing cooperative matrix properties supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   cooperativeMatrixSupportedStages is a bitfield ofVkShaderStageFlagBits describing the shader stages thatcooperative matrix instructions are supported in.cooperativeMatrixSupportedStages will have theVK_SHADER_STAGE_COMPUTE_BIT bit set if any of the physicaldevice’s queues support VK_QUEUE_COMPUTE_BIT.</para>
/// <para>If the VkPhysicalDeviceCooperativeMatrixPropertiesNV structure isincluded in the pNext chain of VkPhysicalDeviceProperties2, itis filled with the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceCooperativeMatrixPropertiesNV {
    public VkStructureType       sType;
    public void*                 pNext;
    public VkShaderStageFlags    cooperativeMatrixSupportedStages;
}
// Struct: 236
/// <summary>VkPhysicalDeviceCornerSampledImageFeaturesNV - Structure describing corner sampled image features that can be supported by an implementation
/// <para>   cornerSampledImage specifieswhether images can be created with aVkImageCreateInfo::flags containingVK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV.See Corner-Sampled Images.</para>
/// <para>If the VkPhysicalDeviceCornerSampledImageFeaturesNV structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2KHR, itis filled with values indicating whether each feature is supported.VkPhysicalDeviceCornerSampledImageFeaturesNV can also be used in thepNext chain of VkDeviceCreateInfo to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceCornerSampledImageFeaturesNV {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           cornerSampledImage;
}
// Struct: 237
/// <summary>VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV - Structure describing dedicated allocation image aliasing features that can be supported by an implementation
/// <para>   dedicatedAllocationImageAliasing indicates that the implementationsupports aliasing of compatible image objects on a dedicated allocation.</para>
/// <para>If the VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNVstructure is included in the pNext chain ofVkPhysicalDeviceFeatures2KHR, it is filled with values indicatingwhether each feature is supported.VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV can alsobe used in the pNext chain of VkDeviceCreateInfo to enablefeatures.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           dedicatedAllocationImageAliasing;
}
// Struct: 238
/// <summary>VkPhysicalDeviceDepthClipEnableFeaturesEXT - Structure indicating support for explicit enable of depth clip
/// <para>   depthClipEnable indicates that theimplementation supports setting the depth clipping operation explicitlyvia the VkPipelineRasterizationDepthClipStateCreateInfoEXTpipeline state.Otherwise depth clipping is only enabled whenVkPipelineRasterizationStateCreateInfo::depthClampEnable isset to VK_FALSE.</para>
/// <para>If the VkPhysicalDeviceDepthClipEnableFeaturesEXT structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2KHR, itis filled with values indicating whether the feature is supported.VkPhysicalDeviceDepthClipEnableFeaturesEXT can also be used in thepNext chain of VkDeviceCreateInfo to enable this feature.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceDepthClipEnableFeaturesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           depthClipEnable;
}
// Struct: 239
/// <summary>VkPhysicalDeviceDepthStencilResolvePropertiesKHR - Structure describing depth/stencil resolve properties that can be supported by an implementation
/// <para>   supportedDepthResolveModes is abitmask of VkResolveModeFlagBitsKHR indicating the set ofsupported depth resolve modes.VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR must be included in the setbut implementations may support additional modes.</para>
/// <para>   supportedStencilResolveModes is abitmask of VkResolveModeFlagBitsKHR indicating the set ofsupported stencil resolve modes.VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR must be included in the setbut implementations may support additional modes.VK_RESOLVE_MODE_AVERAGE_BIT_KHR must not be included in the set.</para>
/// <para>   independentResolveNone isVK_TRUE if the implementation supports setting the depth andstencil resolve modes to different values when one of those modes isVK_RESOLVE_MODE_NONE_KHR.Otherwise the implementation only supports setting both modes to thesame value.</para>
/// <para>   independentResolve isVK_TRUE if the implementation supports all combinations of thesupported depth and stencil resolve modes.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR </para>
/// </summary>
public unsafe struct VkPhysicalDeviceDepthStencilResolvePropertiesKHR {
    public VkStructureType          sType;
    public void*                    pNext;
    public VkResolveModeFlagsKHR    supportedDepthResolveModes;
    public VkResolveModeFlagsKHR    supportedStencilResolveModes;
    public VkBool32                 independentResolveNone;
    public VkBool32                 independentResolve;
}
// Struct: 240
/// <summary>VkPhysicalDeviceDescriptorIndexingFeaturesEXT - Structure describing descriptor indexing features that can be supported by an implementation
/// <para>   shaderInputAttachmentArrayDynamicIndexing indicates whether arraysof input attachments can be indexed by dynamically uniform integerexpressions in shader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must be indexed only byconstant integral expressions when aggregated into arrays in shadercode.This also indicates whether shader modules can declare theInputAttachmentArrayDynamicIndexingEXT capability.</para>
/// <para>   shaderUniformTexelBufferArrayDynamicIndexing indicates whetherarrays of uniform texel buffers can be indexed by dynamically uniforminteger expressions in shader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must be indexed only byconstant integral expressions when aggregated into arrays in shadercode.This also indicates whether shader modules can declare theUniformTexelBufferArrayDynamicIndexingEXT capability.</para>
/// <para>   shaderStorageTexelBufferArrayDynamicIndexing indicates whetherarrays of storage texel buffers can be indexed by dynamically uniforminteger expressions in shader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must be indexed only byconstant integral expressions when aggregated into arrays in shadercode.This also indicates whether shader modules can declare theStorageTexelBufferArrayDynamicIndexingEXT capability.</para>
/// <para>   shaderUniformBufferArrayNonUniformIndexing indicates whetherarrays of uniform buffers can be indexed by non-uniform integerexpressions in shader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER orVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must not be indexed bynon-uniform integer expressions when aggregated into arrays in shadercode.This also indicates whether shader modules can declare theUniformBufferArrayNonUniformIndexingEXT capability.</para>
/// <para>   shaderSampledImageArrayNonUniformIndexing indicates whether arraysof samplers or sampled images can be indexed by non-uniform integerexpressions in shader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_SAMPLER,VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, orVK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must not be indexed bynon-uniform integer expressions when aggregated into arrays in shadercode.This also indicates whether shader modules can declare theSampledImageArrayNonUniformIndexingEXT capability.</para>
/// <para>   shaderStorageBufferArrayNonUniformIndexing indicates whetherarrays of storage buffers can be indexed by non-uniform integerexpressions in shader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_STORAGE_BUFFER orVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must not be indexed bynon-uniform integer expressions when aggregated into arrays in shadercode.This also indicates whether shader modules can declare theStorageBufferArrayNonUniformIndexingEXT capability.</para>
/// <para>   shaderStorageImageArrayNonUniformIndexing indicates whether arraysof storage images can be indexed by non-uniform integer expressions inshader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_STORAGE_IMAGE must not be indexed bynon-uniform integer expressions when aggregated into arrays in shadercode.This also indicates whether shader modules can declare theStorageImageArrayNonUniformIndexingEXT capability.</para>
/// <para>   shaderInputAttachmentArrayNonUniformIndexing indicates whetherarrays of input attachments can be indexed by non-uniform integerexpressions in shader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must not be indexed bynon-uniform integer expressions when aggregated into arrays in shadercode.This also indicates whether shader modules can declare theInputAttachmentArrayNonUniformIndexingEXT capability.</para>
/// <para>   shaderUniformTexelBufferArrayNonUniformIndexing indicates whetherarrays of uniform texel buffers can be indexed by non-uniform integerexpressions in shader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must not be indexed bynon-uniform integer expressions when aggregated into arrays in shadercode.This also indicates whether shader modules can declare theUniformTexelBufferArrayNonUniformIndexingEXT capability.</para>
/// <para>   shaderStorageTexelBufferArrayNonUniformIndexing indicates whetherarrays of storage texel buffers can be indexed by non-uniform integerexpressions in shader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must not be indexed bynon-uniform integer expressions when aggregated into arrays in shadercode.This also indicates whether shader modules can declare theStorageTexelBufferArrayNonUniformIndexingEXT capability.</para>
/// <para>   descriptorBindingUniformBufferUpdateAfterBind indicates whetherthe implementation supports updating uniform buffer descriptors after aset is bound.If this feature is not enabled,VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be usedwith VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER.</para>
/// <para>   descriptorBindingSampledImageUpdateAfterBind indicates whether theimplementation supports updating sampled image descriptors after a setis bound.If this feature is not enabled,VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be usedwith VK_DESCRIPTOR_TYPE_SAMPLER,VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, orVK_DESCRIPTOR_TYPE_SAMPLED_IMAGE.</para>
/// <para>   descriptorBindingStorageImageUpdateAfterBind indicates whether theimplementation supports updating storage image descriptors after a setis bound.If this feature is not enabled,VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be usedwith VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.</para>
/// <para>   descriptorBindingStorageBufferUpdateAfterBind indicates whetherthe implementation supports updating storage buffer descriptors after aset is bound.If this feature is not enabled,VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be usedwith VK_DESCRIPTOR_TYPE_STORAGE_BUFFER.</para>
/// <para>   descriptorBindingUniformTexelBufferUpdateAfterBind indicateswhether the implementation supports updating uniform texel bufferdescriptors after a set is bound.If this feature is not enabled,VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be usedwith VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.</para>
/// <para>   descriptorBindingStorageTexelBufferUpdateAfterBind indicateswhether the implementation supports updating storage texel bufferdescriptors after a set is bound.If this feature is not enabled,VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be usedwith VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.</para>
/// <para>   descriptorBindingUpdateUnusedWhilePending indicates whether theimplementation supports updating descriptors while the set is in use.If this feature is not enabled,VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT mustnot be used.</para>
/// <para>   descriptorBindingPartiallyBound indicates whether theimplementation supports statically using a descriptor set binding inwhich some descriptors are not valid.If this feature is not enabled,VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT must not be used.</para>
/// <para>   descriptorBindingVariableDescriptorCount indicates whether theimplementation supports descriptor sets with a variable-sized lastbinding.If this feature is not enabled,VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT must notbe used.</para>
/// <para>   runtimeDescriptorArrayindicates whether the implementation supports the SPIR-VRuntimeDescriptorArrayEXT capability.If this feature is not enabled, descriptors must not be declared inruntime arrays.</para>
/// <para>If the VkPhysicalDeviceDescriptorIndexingFeaturesEXT structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2KHR, itis filled with values indicating whether each feature is supported.VkPhysicalDeviceDescriptorIndexingFeaturesEXT can also be used in thepNext chain of VkDeviceCreateInfo to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceDescriptorIndexingFeaturesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           shaderInputAttachmentArrayDynamicIndexing;
    public VkBool32           shaderUniformTexelBufferArrayDynamicIndexing;
    public VkBool32           shaderStorageTexelBufferArrayDynamicIndexing;
    public VkBool32           shaderUniformBufferArrayNonUniformIndexing;
    public VkBool32           shaderSampledImageArrayNonUniformIndexing;
    public VkBool32           shaderStorageBufferArrayNonUniformIndexing;
    public VkBool32           shaderStorageImageArrayNonUniformIndexing;
    public VkBool32           shaderInputAttachmentArrayNonUniformIndexing;
    public VkBool32           shaderUniformTexelBufferArrayNonUniformIndexing;
    public VkBool32           shaderStorageTexelBufferArrayNonUniformIndexing;
    public VkBool32           descriptorBindingUniformBufferUpdateAfterBind;
    public VkBool32           descriptorBindingSampledImageUpdateAfterBind;
    public VkBool32           descriptorBindingStorageImageUpdateAfterBind;
    public VkBool32           descriptorBindingStorageBufferUpdateAfterBind;
    public VkBool32           descriptorBindingUniformTexelBufferUpdateAfterBind;
    public VkBool32           descriptorBindingStorageTexelBufferUpdateAfterBind;
    public VkBool32           descriptorBindingUpdateUnusedWhilePending;
    public VkBool32           descriptorBindingPartiallyBound;
    public VkBool32           descriptorBindingVariableDescriptorCount;
    public VkBool32           runtimeDescriptorArray;
}
// Struct: 241
/// <summary>VkPhysicalDeviceDescriptorIndexingPropertiesEXT - Structure describing descriptor indexing properties that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   maxUpdateAfterBindDescriptorsInAllPools is the maximum number ofdescriptors (summed over all descriptor types) that can be createdacross all pools that are created with theVK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT bit set.Pool creation may fail when this limit is exceeded, or when the spacethis limit represents is unable to satisfy a pool creation due tofragmentation.</para>
/// <para>   shaderUniformBufferArrayNonUniformIndexingNative is a booleanvalue indicating whether uniform buffer descriptors natively supportnonuniform indexing.If this is VK_FALSE, then a single dynamic instance of aninstruction that nonuniformly indexes an array of uniform buffers mayexecute multiple times in order to access all the descriptors.</para>
/// <para>   shaderSampledImageArrayNonUniformIndexingNative is a boolean valueindicating whether sampler and image descriptors natively supportnonuniform indexing.If this is VK_FALSE, then a single dynamic instance of aninstruction that nonuniformly indexes an array of samplers or imagesmay execute multiple times in order to access all the descriptors.</para>
/// <para>   shaderStorageBufferArrayNonUniformIndexingNative is a booleanvalue indicating whether storage buffer descriptors natively supportnonuniform indexing.If this is VK_FALSE, then a single dynamic instance of aninstruction that nonuniformly indexes an array of storage buffers mayexecute multiple times in order to access all the descriptors.</para>
/// <para>   shaderStorageImageArrayNonUniformIndexingNative is a boolean valueindicating whether storage image descriptors natively support nonuniformindexing.If this is VK_FALSE, then a single dynamic instance of aninstruction that nonuniformly indexes an array of storage images mayexecute multiple times in order to access all the descriptors.</para>
/// <para>   shaderInputAttachmentArrayNonUniformIndexingNative is a booleanvalue indicating whether input attachment descriptors natively supportnonuniform indexing.If this is VK_FALSE, then a single dynamic instance of aninstruction that nonuniformly indexes an array of input attachments mayexecute multiple times in order to access all the descriptors.</para>
/// <para>   robustBufferAccessUpdateAfterBind is a boolean value indicatingwhether  robustBufferAccess  canbe enabled in a device simultaneously withdescriptorBindingUniformBufferUpdateAfterBind,descriptorBindingStorageBufferUpdateAfterBind,descriptorBindingUniformTexelBufferUpdateAfterBind, and/ordescriptorBindingStorageTexelBufferUpdateAfterBind.If this is VK_FALSE, then either robustBufferAccess must bedisabled or all of these update-after-bind features must be disabled.</para>
/// <para>   quadDivergentImplicitLod is aboolean value indicating whether implicit level of detail calculationsfor image operations have well-defined results when the image and/orsampler objects used for the instruction are not uniform within a quad.See Derivative ImageOperations.</para>
/// <para>   maxPerStageDescriptorUpdateAfterBindSamplers is similar tomaxPerStageDescriptorSamplers but counts descriptors fromdescriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxPerStageDescriptorUpdateAfterBindUniformBuffers is similar tomaxPerStageDescriptorUniformBuffers but counts descriptors fromdescriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxPerStageDescriptorUpdateAfterBindStorageBuffers is similar tomaxPerStageDescriptorStorageBuffers but counts descriptors fromdescriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxPerStageDescriptorUpdateAfterBindSampledImages is similar tomaxPerStageDescriptorSampledImages but counts descriptors fromdescriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxPerStageDescriptorUpdateAfterBindStorageImages is similar tomaxPerStageDescriptorStorageImages but counts descriptors fromdescriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxPerStageDescriptorUpdateAfterBindInputAttachments is similar tomaxPerStageDescriptorInputAttachments but counts descriptors fromdescriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxPerStageUpdateAfterBindResources is similar tomaxPerStageResources but counts descriptors from descriptor setscreated with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxDescriptorSetUpdateAfterBindSamplers is similar tomaxDescriptorSetSamplers but counts descriptors from descriptorsets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxDescriptorSetUpdateAfterBindUniformBuffers is similar tomaxDescriptorSetUniformBuffers but counts descriptors fromdescriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxDescriptorSetUpdateAfterBindUniformBuffersDynamic is similar tomaxDescriptorSetUniformBuffersDynamic but counts descriptors fromdescriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxDescriptorSetUpdateAfterBindStorageBuffers is similar tomaxDescriptorSetStorageBuffers but counts descriptors fromdescriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxDescriptorSetUpdateAfterBindStorageBuffersDynamic is similar tomaxDescriptorSetStorageBuffersDynamic but counts descriptors fromdescriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxDescriptorSetUpdateAfterBindSampledImages is similar tomaxDescriptorSetSampledImages but counts descriptors fromdescriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxDescriptorSetUpdateAfterBindStorageImages is similar tomaxDescriptorSetStorageImages but counts descriptors fromdescriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxDescriptorSetUpdateAfterBindInputAttachments is similar tomaxDescriptorSetInputAttachments but counts descriptors fromdescriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>If the VkPhysicalDeviceDescriptorIndexingPropertiesEXT structure isincluded in the pNext chain of VkPhysicalDeviceProperties2, itis filled with the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceDescriptorIndexingPropertiesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public UInt32           maxUpdateAfterBindDescriptorsInAllPools;
    public VkBool32           shaderUniformBufferArrayNonUniformIndexingNative;
    public VkBool32           shaderSampledImageArrayNonUniformIndexingNative;
    public VkBool32           shaderStorageBufferArrayNonUniformIndexingNative;
    public VkBool32           shaderStorageImageArrayNonUniformIndexingNative;
    public VkBool32           shaderInputAttachmentArrayNonUniformIndexingNative;
    public VkBool32           robustBufferAccessUpdateAfterBind;
    public VkBool32           quadDivergentImplicitLod;
    public UInt32           maxPerStageDescriptorUpdateAfterBindSamplers;
    public UInt32           maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    public UInt32           maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    public UInt32           maxPerStageDescriptorUpdateAfterBindSampledImages;
    public UInt32           maxPerStageDescriptorUpdateAfterBindStorageImages;
    public UInt32           maxPerStageDescriptorUpdateAfterBindInputAttachments;
    public UInt32           maxPerStageUpdateAfterBindResources;
    public UInt32           maxDescriptorSetUpdateAfterBindSamplers;
    public UInt32           maxDescriptorSetUpdateAfterBindUniformBuffers;
    public UInt32           maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    public UInt32           maxDescriptorSetUpdateAfterBindStorageBuffers;
    public UInt32           maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    public UInt32           maxDescriptorSetUpdateAfterBindSampledImages;
    public UInt32           maxDescriptorSetUpdateAfterBindStorageImages;
    public UInt32           maxDescriptorSetUpdateAfterBindInputAttachments;
}
// Struct: 242
/// <summary>VkPhysicalDeviceDiscardRectanglePropertiesEXT - Structure describing discard rectangle limits that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   maxDiscardRectangles is themaximum number of active discard rectangles that can be specified.</para>
/// <para>If the VkPhysicalDeviceDiscardRectanglePropertiesEXT structure isincluded in the pNext chain of VkPhysicalDeviceProperties2, itis filled with the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceDiscardRectanglePropertiesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public UInt32           maxDiscardRectangles;
}
// Struct: 243
/// <summary>VkPhysicalDeviceDriverPropertiesKHR - Structure containing driver identification information
/// <para> driverID must be immutable for a given driver across instances,processes, driver versions, and system reboots.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR </para>
/// </summary>
public unsafe struct VkPhysicalDeviceDriverPropertiesKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType            sType;
    /// <summary> pNext is NULL or a pointer to an extension specific structure.</summary>
    public void*                      pNext;
    /// <summary> driverID is a unique identifier for the driver of the physical
    /// device.</summary>
    public VkDriverIdKHR              driverID;
    public fixed char                       driverName[VK_MAX_DRIVER_NAME_SIZE_KHR];
    public fixed char                       driverInfo[VK_MAX_DRIVER_INFO_SIZE_KHR];
    /// <summary> conformanceVersion is the version of the Vulkan conformance test
    /// this driver is conformant against (see VkConformanceVersionKHR).</summary>
    public VkConformanceVersionKHR    conformanceVersion;
}
// Struct: 244
/// <summary>VkPhysicalDeviceExclusiveScissorFeaturesNV - Structure describing exclusive scissor features that can be supported by an implementation
/// <para>   exclusiveScissor indicates that theimplementation supports the exclusive scissor test.</para>
/// <para>See Exclusive Scissor Test for moreinformation.</para>
/// <para>If the VkPhysicalDeviceExclusiveScissorFeaturesNV structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2KHR, itis filled with values indicating whether the feature is supported.VkPhysicalDeviceExclusiveScissorFeaturesNV can also be used in thepNext chain of VkDeviceCreateInfo to enable the feature.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceExclusiveScissorFeaturesNV {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           exclusiveScissor;
}
// Struct: 245
/// <summary>VkPhysicalDeviceExternalBufferInfo - Structure specifying buffer creation parameters
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be a valid combination of VkBufferCreateFlagBits values</para>
/// <para>   usage must be a valid combination of VkBufferUsageFlagBits values</para>
/// <para>   usage must not be 0 </para>
/// <para>   handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</para>
/// </summary>
public unsafe struct VkPhysicalDeviceExternalBufferInfo {
    /// <summary> sType is the type of this structure</summary>
    public VkStructureType                       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                           pNext;
    /// <summary> flags is a bitmask of VkBufferCreateFlagBits describing
    /// additional parameters of the buffer, corresponding to
    /// VkBufferCreateInfo::flags.</summary>
    public VkBufferCreateFlags                   flags;
    /// <summary> usage is a bitmask of VkBufferUsageFlagBits describing the
    /// intended usage of the buffer, corresponding to
    /// VkBufferCreateInfo::usage.</summary>
    public VkBufferUsageFlags                    usage;
    /// <summary> handleType is a VkExternalMemoryHandleTypeFlagBits value
    /// specifying the memory handle type that will be used with the memory
    /// associated with the buffer.</summary>
    public VkExternalMemoryHandleTypeFlagBits    handleType;
}
// Struct: 246
/// <summary>VkPhysicalDeviceExternalFenceInfo - Structure specifying fence creation parameters.
/// <para>Handles of type VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT generated bythe implementation may represent either Linux Sync Files or Android Fencesat the implementation’s discretion.Applications should only use operations defined for both types of filedescriptors, unless they know via means external to Vulkan the type of thefile descriptor, or are prepared to deal with the system-defined operationfailures resulting from using the wrong type.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   handleType must be a valid VkExternalFenceHandleTypeFlagBits value</para>
/// </summary>
public unsafe struct VkPhysicalDeviceExternalFenceInfo {
    /// <summary> sType is the type of this structure</summary>
    public VkStructureType                      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                          pNext;
    /// <summary> handleType is a VkExternalFenceHandleTypeFlagBits value
    /// indicating an external fence handle type for which capabilities will be
    /// returned.</summary>
    public VkExternalFenceHandleTypeFlagBits    handleType;
}
// Struct: 247
/// <summary>VkPhysicalDeviceExternalImageFormatInfo - Structure specifying external image creation parameters
/// <para>If handleType is 0, vkGetPhysicalDeviceImageFormatProperties2will behave as if VkPhysicalDeviceExternalImageFormatInfo was notpresent, and VkExternalImageFormatProperties will be ignored.</para>
/// <para>If handleType is not compatible with the format, type,tiling, usage, and flags specified inVkPhysicalDeviceImageFormatInfo2, thenvkGetPhysicalDeviceImageFormatProperties2 returnsVK_ERROR_FORMAT_NOT_SUPPORTED.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO </para>
/// <para>   If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value</para>
/// </summary>
public unsafe struct VkPhysicalDeviceExternalImageFormatInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                           pNext;
    /// <summary> handleType is a VkExternalMemoryHandleTypeFlagBits value
    /// specifying the memory handle type that will be used with the memory
    /// associated with the image.</summary>
    public VkExternalMemoryHandleTypeFlagBits    handleType;
}
// Struct: 248
/// <summary>VkPhysicalDeviceExternalMemoryHostPropertiesEXT - Structure describing external memory host pointer limits that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   minImportedHostPointerAlignment is the minimum requiredalignment, in bytes, for the base address and size of host pointers thatcan be imported to a Vulkan memory object.</para>
/// <para>If the VkPhysicalDeviceExternalMemoryHostPropertiesEXT structure isincluded in the pNext chain of VkPhysicalDeviceProperties2, itis filled with the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkDeviceSize       minImportedHostPointerAlignment;
}
// Struct: 249
/// <summary>VkPhysicalDeviceExternalSemaphoreInfo - Structure specifying semaphore creation parameters.
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value</para>
/// </summary>
public unsafe struct VkPhysicalDeviceExternalSemaphoreInfo {
    /// <summary> sType is the type of this structure</summary>
    public VkStructureType                          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                              pNext;
    /// <summary> handleType is a VkExternalSemaphoreHandleTypeFlagBits value
    /// specifying the external semaphore handle type for which capabilities
    /// will be returned.</summary>
    public VkExternalSemaphoreHandleTypeFlagBits    handleType;
}
// Struct: 250
/// <summary>VkPhysicalDeviceFeatures - Structure describing the fine-grained features that can be supported by an implementation
/// <para>   robustBufferAccess specifies thataccesses to buffers are bounds-checked against the range of the bufferdescriptor (as determined by VkDescriptorBufferInfo::range,VkBufferViewCreateInfo::range, or the size of the buffer).Out of bounds accesses must not cause application termination, and theeffects of shader loads, stores, and atomics must conform to animplementation-dependent behavior as described below.</para>
/// <para>A buffer access is considered to be out of bounds if any of thefollowing are true:</para>
/// <para>The pointer was formed by OpImageTexelPointer and the coordinateis less than zero or greater than or equal to the number of wholeelements in the bound range.</para>
/// <para>The pointer was not formed by OpImageTexelPointer and the objectpointed to is not wholly contained within the bound range.This includes accesses performed via variable pointers where thebuffer descriptor being accessed cannot be statically determined.Uninitialized pointers and pointers equal to OpConstantNull aretreated as pointing to a zero-sized object, so all accesses throughsuch pointers are considered to be out of bounds.Buffer accesses through buffer device addresses are notbounds-checked.If the cooperativeMatrixRobustBufferAccess feature is not enabled, then accesses usingOpCooperativeMatrixLoadNV and OpCooperativeMatrixStoreNV may not be bounds-checked.</para>
/// <para>If a SPIR-V OpLoad instruction loads a structure and the tail end ofthe structure is out of bounds, then all members of the structure areconsidered out of bounds even if the members at the end are not staticallyused.</para>
/// <para>If any buffer access in a given SPIR-V block is determined to be outof bounds, then any other access of the same type (load, store, oratomic) in the same SPIR-V block that accesses an address less than 16bytes away from the out of bounds address may also be considered outof bounds.</para>
/// <para>Out-of-bounds buffer loads will return any of the following values:</para>
/// <para>Values from anywhere within the memory range(s) bound to the buffer(possibly including bytes of memory past the end of the buffer, up tothe end of the bound range).</para>
/// <para>Zero values, or (0,0,0,x) vectors for vector reads where x is avalid value represented in the type of the vector components and maybe any of:</para>
/// <para>0, 1, or the maximum representable positive integer value, for signedor unsigned integer components</para>
/// <para>0.0 or 1.0, for floating-point components</para>
/// <para>Out-of-bounds writes may modify values within the memory range(s)bound to the buffer, but must not modify any other memory.</para>
/// <para>Out-of-bounds atomics may modify values within the memory range(s)bound to the buffer, but must not modify any other memory, and returnan undefined value.</para>
/// <para>Vertex input attributes are considered out of bounds if the offset ofthe attribute in the bound vertex buffer range plus the size of theattribute is greater than either:</para>
/// <para> vertexBufferRangeSize, if  bindingStride == 0; or</para>
/// <para> (vertexBufferRangeSize - (vertexBufferRangeSize %bindingStride)) </para>
/// <para>where vertexBufferRangeSize is the byte size of the memory range boundto the vertex buffer binding and bindingStride is the byte stride ofthe corresponding vertex input binding.Further, if any vertex input attribute using a specific vertex input bindingis out of bounds, then all vertex input attributes using that vertex inputbinding for that vertex shader invocation are considered out of bounds.</para>
/// <para>If a vertex input attribute is out of bounds, it will be assigned oneof the following values:</para>
/// <para>Values from anywhere within the memory range(s) bound to the buffer,converted according to the format of the attribute.</para>
/// <para>Zero values, format converted according to the format of theattribute.</para>
/// <para>Zero values, or (0,0,0,x) vectors, as described above.</para>
/// <para>If robustBufferAccess is not enabled, applications must notperform out of bounds accesses.</para>
/// <para>   fullDrawIndexUint32 specifies thefull 32-bit range of indices is supported for indexed draw calls whenusing a VkIndexType of VK_INDEX_TYPE_UINT32.maxDrawIndexedIndexValue is the maximum index value that may beused (aside from the primitive restart index, which is always 232-1when the VkIndexType is VK_INDEX_TYPE_UINT32).If this feature is supported, maxDrawIndexedIndexValue must be232-1; otherwise it must be no smaller than 224-1.See maxDrawIndexedIndexValue.</para>
/// <para>   imageCubeArray specifies whether imageviews with a VkImageViewType ofVK_IMAGE_VIEW_TYPE_CUBE_ARRAY can be created, and that thecorresponding SampledCubeArray and ImageCubeArray SPIR-Vcapabilities can be used in shader code.</para>
/// <para>   independentBlend specifies whetherthe VkPipelineColorBlendAttachmentState settings are controlledindependently per-attachment.If this feature is not enabled, theVkPipelineColorBlendAttachmentState settings for all colorattachments must be identical.Otherwise, a different VkPipelineColorBlendAttachmentState can beprovided for each bound color attachment.</para>
/// <para>   geometryShader specifies whethergeometry shaders are supported.If this feature is not enabled, the VK_SHADER_STAGE_GEOMETRY_BITand VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT enum values must not beused.This also specifies whether shader modules can declare theGeometry capability.</para>
/// <para>   tessellationShader specifieswhether tessellation control and evaluation shaders are supported.If this feature is not enabled, theVK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, andVK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO enumvalues must not be used.This also specifies whether shader modules can declare theTessellation capability.</para>
/// <para>   sampleRateShading specifies whetherSample Shading and multisample interpolationare supported.If this feature is not enabled, the sampleShadingEnable member ofthe VkPipelineMultisampleStateCreateInfo structure must be set toVK_FALSE and the minSampleShading member is ignored.This also specifies whether shader modules can declare theSampleRateShading capability.</para>
/// <para>   dualSrcBlend specifies whether blendoperations which take two sources are supported.If this feature is not enabled, the VK_BLEND_FACTOR_SRC1_COLOR,VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,VK_BLEND_FACTOR_SRC1_ALPHA, andVK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA enum values must not be usedas source or destination blending factors.See html/vkspec.html#framebuffer-dsb.</para>
/// <para>   logicOp specifies whether logic operationsare supported.If this feature is not enabled, the logicOpEnable member of theVkPipelineColorBlendStateCreateInfo structure must be set toVK_FALSE, and the logicOp member is ignored.</para>
/// <para>   multiDrawIndirect specifies whethermultiple draw indirect is supported.If this feature is not enabled, the drawCount parameter to thevkCmdDrawIndirect and vkCmdDrawIndexedIndirect commandsmust be 0 or 1.The maxDrawIndirectCount member of theVkPhysicalDeviceLimits structure must also be 1 if this featureis not supported.See maxDrawIndirectCount.</para>
/// <para>   drawIndirectFirstInstancespecifies whether indirect draw calls support the firstInstanceparameter.If this feature is not enabled, the firstInstance member of allVkDrawIndirectCommand and VkDrawIndexedIndirectCommandstructures that are provided to the vkCmdDrawIndirect andvkCmdDrawIndexedIndirect commands must be 0.</para>
/// <para>   depthClamp specifies whether depthclamping is supported.If this feature is not enabled, the depthClampEnable member of theVkPipelineRasterizationStateCreateInfo structure must be set toVK_FALSE.Otherwise, setting depthClampEnable to VK_TRUE will enabledepth clamping.</para>
/// <para>   depthBiasClamp specifies whether depthbias clamping is supported.If this feature is not enabled, the depthBiasClamp member of theVkPipelineRasterizationStateCreateInfo structure must be set to0.0 unless the VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state isenabled, and the depthBiasClamp parameter tovkCmdSetDepthBias must be set to 0.0.</para>
/// <para>   fillModeNonSolid specifies whetherpoint and wireframe fill modes are supported.If this feature is not enabled, the VK_POLYGON_MODE_POINT andVK_POLYGON_MODE_LINE enum values must not be used.</para>
/// <para>   depthBounds specifies whether depthbounds tests are supported.If this feature is not enabled, the depthBoundsTestEnable memberof the VkPipelineDepthStencilStateCreateInfo structure must beset to VK_FALSE.When depthBoundsTestEnable is set to VK_FALSE, theminDepthBounds and maxDepthBounds members of theVkPipelineDepthStencilStateCreateInfo structure are ignored.</para>
/// <para>   wideLines specifies whether lines withwidth other than 1.0 are supported.If this feature is not enabled, the lineWidth member of theVkPipelineRasterizationStateCreateInfo structure must be set to1.0 unless the VK_DYNAMIC_STATE_LINE_WIDTH dynamic state isenabled, and the lineWidth parameter to vkCmdSetLineWidth must be set to 1.0.When this feature is supported, the range and granularity of supportedline widths are indicated by the lineWidthRange andlineWidthGranularity members of the VkPhysicalDeviceLimitsstructure, respectively.</para>
/// <para>   largePoints specifies whether points withsize greater than 1.0 are supported.If this feature is not enabled, only a point size of 1.0 written by ashader is supported.The range and granularity of supported point sizes are indicated by thepointSizeRange and pointSizeGranularity members of theVkPhysicalDeviceLimits structure, respectively.</para>
/// <para>   alphaToOne specifies whether theimplementation is able to replace the alpha value of the color fragmentoutput from the fragment shader with the maximum representable alphavalue for fixed-point colors or 1.0 for floating-point colors.If this feature is not enabled, then the alphaToOneEnable memberof the VkPipelineMultisampleStateCreateInfo structure must be setto VK_FALSE.Otherwise setting alphaToOneEnable to VK_TRUE will enablealpha-to-one behavior.</para>
/// <para>   multiViewport specifies whether morethan one viewport is supported.If this feature is not enabled:</para>
/// <para>The viewportCount and scissorCount members of theVkPipelineViewportStateCreateInfo structure must be set to 1.</para>
/// <para>The firstViewport and viewportCount parameters to thevkCmdSetViewport command must be set to 0 and 1, respectively.</para>
/// <para>The firstScissor and scissorCount parameters to thevkCmdSetScissor command must be set to 0 and 1, respectively.</para>
/// <para>The exclusiveScissorCount member of theVkPipelineViewportExclusiveScissorStateCreateInfoNV structuremust be set to 0 or 1.</para>
/// <para>The firstExclusiveScissor and exclusiveScissorCountparameters to the vkCmdSetExclusiveScissorNV command must be setto 0 and 1, respectively.</para>
/// <para>   samplerAnisotropy specifies whetheranisotropic filtering is supported.If this feature is not enabled, the anisotropyEnable member of theVkSamplerCreateInfo structure must be VK_FALSE.</para>
/// <para>   textureCompressionETC2specifies whether all of the ETC2 and EAC compressed texture formats aresupported.If this feature is enabled, then theVK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,VK_FORMAT_FEATURE_BLIT_SRC_BIT andVK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features mustbe supported in optimalTilingFeatures for the following formats:</para>
/// <para> VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK </para>
/// <para> VK_FORMAT_EAC_R11_UNORM_BLOCK </para>
/// <para> VK_FORMAT_EAC_R11_SNORM_BLOCK </para>
/// <para> VK_FORMAT_EAC_R11G11_UNORM_BLOCK </para>
/// <para> VK_FORMAT_EAC_R11G11_SNORM_BLOCK </para>
/// <para>To query for additional properties, or if the feature is not enabled,vkGetPhysicalDeviceFormatProperties andvkGetPhysicalDeviceImageFormatProperties can be used to check forsupported properties of individual formats as normal.</para>
/// <para>   textureCompressionASTC_LDRspecifies whether all of the ASTC LDR compressed texture formats aresupported.If this feature is enabled, then theVK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,VK_FORMAT_FEATURE_BLIT_SRC_BIT andVK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features mustbe supported in optimalTilingFeatures for the following formats:</para>
/// <para> VK_FORMAT_ASTC_4x4_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_4x4_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ASTC_5x4_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_5x4_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ASTC_5x5_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_5x5_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ASTC_6x5_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_6x5_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ASTC_6x6_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_6x6_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ASTC_8x5_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_8x5_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ASTC_8x6_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_8x6_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ASTC_8x8_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_8x8_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ASTC_10x5_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_10x5_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ASTC_10x6_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_10x6_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ASTC_10x8_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_10x8_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ASTC_10x10_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_10x10_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ASTC_12x10_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_12x10_SRGB_BLOCK </para>
/// <para> VK_FORMAT_ASTC_12x12_UNORM_BLOCK </para>
/// <para> VK_FORMAT_ASTC_12x12_SRGB_BLOCK </para>
/// <para>To query for additional properties, or if the feature is not enabled,vkGetPhysicalDeviceFormatProperties andvkGetPhysicalDeviceImageFormatProperties can be used to check forsupported properties of individual formats as normal.</para>
/// <para>   textureCompressionBC specifieswhether all of the BC compressed texture formats are supported.If this feature is enabled, then theVK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,VK_FORMAT_FEATURE_BLIT_SRC_BIT andVK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features mustbe supported in optimalTilingFeatures for the following formats:</para>
/// <para> VK_FORMAT_BC1_RGB_UNORM_BLOCK </para>
/// <para> VK_FORMAT_BC1_RGB_SRGB_BLOCK </para>
/// <para> VK_FORMAT_BC1_RGBA_UNORM_BLOCK </para>
/// <para> VK_FORMAT_BC1_RGBA_SRGB_BLOCK </para>
/// <para> VK_FORMAT_BC2_UNORM_BLOCK </para>
/// <para> VK_FORMAT_BC2_SRGB_BLOCK </para>
/// <para> VK_FORMAT_BC3_UNORM_BLOCK </para>
/// <para> VK_FORMAT_BC3_SRGB_BLOCK </para>
/// <para> VK_FORMAT_BC4_UNORM_BLOCK </para>
/// <para> VK_FORMAT_BC4_SNORM_BLOCK </para>
/// <para> VK_FORMAT_BC5_UNORM_BLOCK </para>
/// <para> VK_FORMAT_BC5_SNORM_BLOCK </para>
/// <para> VK_FORMAT_BC6H_UFLOAT_BLOCK </para>
/// <para> VK_FORMAT_BC6H_SFLOAT_BLOCK </para>
/// <para> VK_FORMAT_BC7_UNORM_BLOCK </para>
/// <para> VK_FORMAT_BC7_SRGB_BLOCK </para>
/// <para>To query for additional properties, or if the feature is not enabled,vkGetPhysicalDeviceFormatProperties andvkGetPhysicalDeviceImageFormatProperties can be used to check forsupported properties of individual formats as normal.</para>
/// <para>   occlusionQueryPrecise specifieswhether occlusion queries returning actual sample counts are supported.Occlusion queries are created in a VkQueryPool by specifying thequeryType of VK_QUERY_TYPE_OCCLUSION in theVkQueryPoolCreateInfo structure which is passed tovkCreateQueryPool.If this feature is enabled, queries of this type can enableVK_QUERY_CONTROL_PRECISE_BIT in the flags parameter tovkCmdBeginQuery.If this feature is not supported, the implementation supports onlyboolean occlusion queries.When any samples are passed, boolean queries will return a non-zeroresult value, otherwise a result value of zero is returned.When this feature is enabled and VK_QUERY_CONTROL_PRECISE_BIT isset, occlusion queries will report the actual number of samples passed.</para>
/// <para>   pipelineStatisticsQueryspecifies whether the pipeline statistics queries are supported.If this feature is not enabled, queries of typeVK_QUERY_TYPE_PIPELINE_STATISTICS cannot be created, and none ofthe VkQueryPipelineStatisticFlagBits bits can be set in thepipelineStatistics member of the VkQueryPoolCreateInfostructure.</para>
/// <para>   vertexPipelineStoresAndAtomics specifies whether storage buffersand images support stores and atomic operations in the vertex,tessellation, and geometry shader stages.If this feature is not enabled, all storage image, storage texelbuffers, and storage buffer variables used by these stages in shadermodules must be decorated with the NonWritable decoration (or thereadonly memory qualifier in GLSL).</para>
/// <para>   fragmentStoresAndAtomicsspecifies whether storage buffers and images support stores and atomicoperations in the fragment shader stage.If this feature is not enabled, all storage image, storage texelbuffers, and storage buffer variables used by the fragment stage inshader modules must be decorated with the NonWritable decoration(or the readonly memory qualifier in GLSL).</para>
/// <para>   shaderTessellationAndGeometryPointSize specifies whether thePointSize built-in decoration is available in the tessellationcontrol, tessellation evaluation, and geometry shader stages.If this feature is not enabled, members decorated with thePointSize built-in decoration must not be read from or written toand all points written from a tessellation or geometry shader will havea size of 1.0.This also specifies whether shader modules can declare theTessellationPointSize capability for tessellation control andevaluation shaders, or if the shader modules can declare theGeometryPointSize capability for geometry shaders.An implementation supporting this feature must also support one or bothof the  tessellationShader  or geometryShader  features.</para>
/// <para>   shaderImageGatherExtendedspecifies whether the extended set of image gather instructions areavailable in shader code.If this feature is not enabled, the OpImage*Gatherinstructions do not support the Offset and ConstOffsetsoperands.This also specifies whether shader modules can declare theImageGatherExtended capability.</para>
/// <para>   shaderStorageImageExtendedFormats specifies whether all theextended storage image formats are available in shader code.If this feature is enabled then theVK_FORMAT_FEATURE_STORAGE_IMAGE_BIT feature must be supported inoptimalTilingFeatures for all of the extended formats.To query for additional properties, or if the feature is not enabled,vkGetPhysicalDeviceFormatProperties andvkGetPhysicalDeviceImageFormatProperties can be used to check forsupported properties of individual formats as normal.</para>
/// <para>   shaderStorageImageMultisample specifies whether multisampledstorage images are supported.If this feature is not enabled, images that are created with ausage that includes VK_IMAGE_USAGE_STORAGE_BIT must becreated with samples equal to VK_SAMPLE_COUNT_1_BIT.This also specifies whether shader modules can declare theStorageImageMultisample capability.</para>
/// <para>   shaderStorageImageReadWithoutFormat specifies whether storageimages require a format qualifier to be specified when reading fromstorage images.If this feature is not enabled, the OpImageRead instruction mustnot have an OpTypeImage of Unknown.This also specifies whether shader modules can declare theStorageImageReadWithoutFormat capability.</para>
/// <para>   shaderStorageImageWriteWithoutFormat specifies whether storageimages require a format qualifier to be specified when writing tostorage images.If this feature is not enabled, the OpImageWrite instruction mustnot have an OpTypeImage of Unknown.This also specifies whether shader modules can declare theStorageImageWriteWithoutFormat capability.</para>
/// <para>   shaderUniformBufferArrayDynamicIndexing specifies whether arraysof uniform buffers can be indexed by dynamically uniform integerexpressions in shader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER orVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must be indexed only byconstant integral expressions when aggregated into arrays in shadercode.This also specifies whether shader modules can declare theUniformBufferArrayDynamicIndexing capability.</para>
/// <para>   shaderSampledImageArrayDynamicIndexing specifies whether arrays ofsamplers or sampled images can be indexed by dynamically uniforminteger expressions in shader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_SAMPLER,VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, orVK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must be indexed only by constantintegral expressions when aggregated into arrays in shader code.This also specifies whether shader modules can declare theSampledImageArrayDynamicIndexing capability.</para>
/// <para>   shaderStorageBufferArrayDynamicIndexing specifies whether arraysof storage buffers can be indexed by dynamically uniform integerexpressions in shader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_STORAGE_BUFFER orVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must be indexed only byconstant integral expressions when aggregated into arrays in shadercode.This also specifies whether shader modules can declare theStorageBufferArrayDynamicIndexing capability.</para>
/// <para>   shaderStorageImageArrayDynamicIndexing specifies whether arrays ofstorage images can be indexed by dynamically uniform integerexpressions in shader code.If this feature is not enabled, resources with a descriptor type ofVK_DESCRIPTOR_TYPE_STORAGE_IMAGE must be indexed only by constantintegral expressions when aggregated into arrays in shader code.This also specifies whether shader modules can declare theStorageImageArrayDynamicIndexing capability.</para>
/// <para>   shaderClipDistance specifieswhether clip distances are supported in shader code.If this feature is not enabled, any members decorated with theClipDistance built-in decoration must not be read from or writtento in shader modules.This also specifies whether shader modules can declare theClipDistance capability.</para>
/// <para>   shaderCullDistance specifieswhether cull distances are supported in shader code.If this feature is not enabled, any members decorated with theCullDistance built-in decoration must not be read from or writtento in shader modules.This also specifies whether shader modules can declare theCullDistance capability.</para>
/// <para>   shaderFloat64 specifies whether 64-bitfloats (doubles) are supported in shader code.If this feature is not enabled, 64-bit floating-point types must not beused in shader code.This also specifies whether shader modules can declare the Float64capability.</para>
/// <para>   shaderInt64 specifies whether 64-bitintegers (signed and unsigned) are supported in shader code.If this feature is not enabled, 64-bit integer types must not be usedin shader code.This also specifies whether shader modules can declare the Int64capability.</para>
/// <para>   shaderInt16 specifies whether 16-bitintegers (signed and unsigned) are supported in shader code.If this feature is not enabled, 16-bit integer types must not be usedin shader code.This also specifies whether shader modules can declare the Int16capability.</para>
/// <para>   shaderResourceResidencyspecifies whether image operations that return resource residencyinformation are supported in shader code.If this feature is not enabled, the OpImageSparse* instructionsmust not be used in shader code.This also specifies whether shader modules can declare theSparseResidency capability.The feature requires at least one of the sparseResidency* featuresto be supported.</para>
/// <para>   shaderResourceMinLod specifieswhether image operations that specify the minimum resource LOD aresupported in shader code.If this feature is not enabled, the MinLod image operand must notbe used in shader code.This also specifies whether shader modules can declare the MinLodcapability.</para>
/// <para>   sparseBinding specifies whetherresource memory can be managed at opaque sparse block level instead ofat the object level.If this feature is not enabled, resource memory must be bound only on aper-object basis using the vkBindBufferMemory andvkBindImageMemory commands.In this case, buffers and images must not be created withVK_BUFFER_CREATE_SPARSE_BINDING_BIT andVK_IMAGE_CREATE_SPARSE_BINDING_BIT set in the flags memberof the VkBufferCreateInfo and VkImageCreateInfo structures,respectively.Otherwise resource memory can be managed as described inSparse Resource Features.</para>
/// <para>   sparseResidencyBuffer specifieswhether the device can access partially resident buffers.If this feature is not enabled, buffers must not be created withVK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT set in the flagsmember of the VkBufferCreateInfo structure.</para>
/// <para>   sparseResidencyImage2Dspecifies whether the device can access partially resident 2D imageswith 1 sample per pixel.If this feature is not enabled, images with an imageType ofVK_IMAGE_TYPE_2D and samples set toVK_SAMPLE_COUNT_1_BIT must not be created withVK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags memberof the VkImageCreateInfo structure.</para>
/// <para>   sparseResidencyImage3Dspecifies whether the device can access partially resident 3D images.If this feature is not enabled, images with an imageType ofVK_IMAGE_TYPE_3D must not be created withVK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags memberof the VkImageCreateInfo structure.</para>
/// <para>   sparseResidency2Samplesspecifies whether the physical device can access partially resident 2Dimages with 2 samples per pixel.If this feature is not enabled, images with an imageType ofVK_IMAGE_TYPE_2D and samples set toVK_SAMPLE_COUNT_2_BIT must not be created withVK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags memberof the VkImageCreateInfo structure.</para>
/// <para>   sparseResidency4Samplesspecifies whether the physical device can access partially resident 2Dimages with 4 samples per pixel.If this feature is not enabled, images with an imageType ofVK_IMAGE_TYPE_2D and samples set toVK_SAMPLE_COUNT_4_BIT must not be created withVK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags memberof the VkImageCreateInfo structure.</para>
/// <para>   sparseResidency8Samplesspecifies whether the physical device can access partially resident 2Dimages with 8 samples per pixel.If this feature is not enabled, images with an imageType ofVK_IMAGE_TYPE_2D and samples set toVK_SAMPLE_COUNT_8_BIT must not be created withVK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags memberof the VkImageCreateInfo structure.</para>
/// <para>   sparseResidency16Samplesspecifies whether the physical device can access partially resident 2Dimages with 16 samples per pixel.If this feature is not enabled, images with an imageType ofVK_IMAGE_TYPE_2D and samples set toVK_SAMPLE_COUNT_16_BIT must not be created withVK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags memberof the VkImageCreateInfo structure.</para>
/// <para>   sparseResidencyAliasedspecifies whether the physical device can correctly access data aliasedinto multiple locations.If this feature is not enabled, theVK_BUFFER_CREATE_SPARSE_ALIASED_BIT andVK_IMAGE_CREATE_SPARSE_ALIASED_BIT enum values must not be usedin flags members of the VkBufferCreateInfo andVkImageCreateInfo structures, respectively.</para>
/// <para>   variableMultisampleRatespecifies whether all pipelines that will be bound to a command bufferduring a subpass with no attachments must have the same value forVkPipelineMultisampleStateCreateInfo::rasterizationSamples.If set to VK_TRUE, the implementation supports variablemultisample rates in a subpass with no attachments.If set to VK_FALSE, then all pipelines bound in such a subpassmust have the same multisample rate.This has no effect in situations where a subpass uses any attachments.</para>
/// <para>   inheritedQueries specifies whether asecondary command buffer may be executed while a query is active.</para>
/// </summary>
public unsafe struct VkPhysicalDeviceFeatures {
    public VkBool32    robustBufferAccess;
    public VkBool32    fullDrawIndexUint32;
    public VkBool32    imageCubeArray;
    public VkBool32    independentBlend;
    public VkBool32    geometryShader;
    public VkBool32    tessellationShader;
    public VkBool32    sampleRateShading;
    public VkBool32    dualSrcBlend;
    public VkBool32    logicOp;
    public VkBool32    multiDrawIndirect;
    public VkBool32    drawIndirectFirstInstance;
    public VkBool32    depthClamp;
    public VkBool32    depthBiasClamp;
    public VkBool32    fillModeNonSolid;
    public VkBool32    depthBounds;
    public VkBool32    wideLines;
    public VkBool32    largePoints;
    public VkBool32    alphaToOne;
    public VkBool32    multiViewport;
    public VkBool32    samplerAnisotropy;
    public VkBool32    textureCompressionETC2;
    public VkBool32    textureCompressionASTC_LDR;
    public VkBool32    textureCompressionBC;
    public VkBool32    occlusionQueryPrecise;
    public VkBool32    pipelineStatisticsQuery;
    public VkBool32    vertexPipelineStoresAndAtomics;
    public VkBool32    fragmentStoresAndAtomics;
    public VkBool32    shaderTessellationAndGeometryPointSize;
    public VkBool32    shaderImageGatherExtended;
    public VkBool32    shaderStorageImageExtendedFormats;
    public VkBool32    shaderStorageImageMultisample;
    public VkBool32    shaderStorageImageReadWithoutFormat;
    public VkBool32    shaderStorageImageWriteWithoutFormat;
    public VkBool32    shaderUniformBufferArrayDynamicIndexing;
    public VkBool32    shaderSampledImageArrayDynamicIndexing;
    public VkBool32    shaderStorageBufferArrayDynamicIndexing;
    public VkBool32    shaderStorageImageArrayDynamicIndexing;
    public VkBool32    shaderClipDistance;
    public VkBool32    shaderCullDistance;
    public VkBool32    shaderFloat64;
    public VkBool32    shaderInt64;
    public VkBool32    shaderInt16;
    public VkBool32    shaderResourceResidency;
    public VkBool32    shaderResourceMinLod;
    public VkBool32    sparseBinding;
    public VkBool32    sparseResidencyBuffer;
    public VkBool32    sparseResidencyImage2D;
    public VkBool32    sparseResidencyImage3D;
    public VkBool32    sparseResidency2Samples;
    public VkBool32    sparseResidency4Samples;
    public VkBool32    sparseResidency8Samples;
    public VkBool32    sparseResidency16Samples;
    public VkBool32    sparseResidencyAliased;
    public VkBool32    variableMultisampleRate;
    public VkBool32    inheritedQueries;
}
// Struct: 251
/// <summary>VkPhysicalDeviceFeatures2 - Structure describing the fine-grained features that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para> features is a structure of type VkPhysicalDeviceFeaturesdescribing the fine-grained features of the Vulkan 1.0 API.</para>
/// <para>The pNext chain of this structure is used to extend the structure withfeatures defined by extensions.This structure can be used in vkGetPhysicalDeviceFeatures2 or can bein the pNext chain of a VkDeviceCreateInfo structure, in whichcase it controls which features are enabled in the device in lieu ofpEnabledFeatures.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 </para>
/// </summary>
public unsafe struct VkPhysicalDeviceFeatures2 {
    public VkStructureType             sType;
    public void*                       pNext;
    public VkPhysicalDeviceFeatures    features;
}
// Struct: 252
/// <summary>VkPhysicalDeviceFloat16Int8FeaturesKHR - Structure describing features supported by VK_KHR_shader_float16_int8
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR </para>
/// </summary>
public unsafe struct VkPhysicalDeviceFloat16Int8FeaturesKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary>  
    ///   shaderFloat16 indicates whether 16-bit
    /// floats (halfs) are supported in shader code.
    /// This also indicates whether shader modules can declare the Float16
    /// capability.</summary>
    public VkBool32           shaderFloat16;
    /// <summary>  
    ///   shaderInt8 indicates whether 8-bit
    /// integers (signed and unsigned) are supported in shader code.
    /// This also indicates whether shader modules can declare the Int8
    /// capability.</summary>
    public VkBool32           shaderInt8;
}
// Struct: 253
/// <summary>VkPhysicalDeviceFloatControlsPropertiesKHR - Structure describing properties supported by VK_KHR_shader_float_controls
/// <para>Implementations may not be able to control behavior of denorms forfloating-point atomics.This needs to be taken into account when such atomics will be added toVulkan.</para>
/// <para>If the VkPhysicalDeviceFloatControlsPropertiesKHR structure isincluded in the pNext chain of VkPhysicalDeviceProperties2, itis filled with the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR </para>
/// </summary>
public unsafe struct VkPhysicalDeviceFloatControlsPropertiesKHR {
    public VkStructureType    sType;
    public void*              pNext;
    /// <summary>  
    ///   separateDenormSettings is a
    /// boolean value indicating whether the implementation supports separate
    /// settings for 16-bit and 64-bit denormals.</summary>
    public VkBool32           separateDenormSettings;
    /// <summary>  
    ///   separateRoundingModeSettings is a boolean value indicating whether
    /// the implementation supports separate rounding modes for 16-bit and
    /// 64-bit floating point instructions.</summary>
    public VkBool32           separateRoundingModeSettings;
    /// <summary>  
    ///   shaderSignedZeroInfNanPreserveFloat16 is a boolean value
    /// indicating whether sign of a zero, Nans and
    /// \(\pm\infty\) can be preserved in 16-bit floating-point
    /// computations.
    /// It also indicates whether the SignedZeroInfNanPreserve execution
    /// mode can be used for 16-bit floating-point types.</summary>
    public VkBool32           shaderSignedZeroInfNanPreserveFloat16;
    /// <summary>  
    ///   shaderSignedZeroInfNanPreserveFloat32 is a boolean value
    /// indicating whether sign of a zero, Nans and
    /// \(\pm\infty\) can be preserved in 32-bit floating-point
    /// computations.
    /// It also indicates whether the SignedZeroInfNanPreserve execution
    /// mode can be used for 32-bit floating-point types.</summary>
    public VkBool32           shaderSignedZeroInfNanPreserveFloat32;
    /// <summary>  
    ///   shaderSignedZeroInfNanPreserveFloat64 is a boolean value
    /// indicating whether sign of a zero, Nans and
    /// \(\pm\infty\) can be preserved in 64-bit floating-point
    /// computations.
    /// It also indicates whether the SignedZeroInfNanPreserve execution
    /// mode can be used for 64-bit floating-point types.</summary>
    public VkBool32           shaderSignedZeroInfNanPreserveFloat64;
    /// <summary>  
    ///   shaderDenormPreserveFloat16 is a boolean value indicating whether
    /// denormals can be preserved in 16-bit floating-point computations.
    /// It also indicates whether the DenormPreserve execution mode can be
    /// used for 16-bit floating-point types.</summary>
    public VkBool32           shaderDenormPreserveFloat16;
    /// <summary>  
    ///   shaderDenormPreserveFloat32 is a boolean value indicating whether
    /// denormals can be preserved in 32-bit floating-point computations.
    /// It also indicates whether the DenormPreserve execution mode can be
    /// used for 32-bit floating-point types.</summary>
    public VkBool32           shaderDenormPreserveFloat32;
    /// <summary>  
    ///   shaderDenormPreserveFloat64 is a boolean value indicating whether
    /// denormals can be preserved in 64-bit floating-point computations.
    /// It also indicates whether the DenormPreserve execution mode can be
    /// used for 64-bit floating-point types.</summary>
    public VkBool32           shaderDenormPreserveFloat64;
    /// <summary>  
    ///   shaderDenormFlushToZeroFloat16 is a boolean value indicating
    /// whether denormals can be flushed to zero in 16-bit floating-point
    /// computations.
    /// It also indicates whether the DenormFlushToZero execution mode can
    /// be used for 16-bit floating-point types.</summary>
    public VkBool32           shaderDenormFlushToZeroFloat16;
    /// <summary>  
    ///   shaderDenormFlushToZeroFloat32 is a boolean value indicating
    /// whether denormals can be flushed to zero in 32-bit floating-point
    /// computations.
    /// It also indicates whether the DenormFlushToZero execution mode can
    /// be used for 32-bit floating-point types.</summary>
    public VkBool32           shaderDenormFlushToZeroFloat32;
    /// <summary>  
    ///   shaderDenormFlushToZeroFloat64 is a boolean value indicating
    /// whether denormals can be flushed to zero in 64-bit floating-point
    /// computations.
    /// It also indicates whether the DenormFlushToZero execution mode can
    /// be used for 64-bit floating-point types.</summary>
    public VkBool32           shaderDenormFlushToZeroFloat64;
    /// <summary>  
    ///   shaderRoundingModeRTEFloat16 is a boolean value indicating whether
    /// an implementation supports the round-to-nearest-even rounding mode for
    /// 16-bit floating-point arithmetic and conversion instructions.
    /// It also indicates whether the RoundingModeRTE execution mode can
    /// be used for 16-bit floating-point types.</summary>
    public VkBool32           shaderRoundingModeRTEFloat16;
    /// <summary>  
    ///   shaderRoundingModeRTEFloat32 is a boolean value indicating whether
    /// an implementation supports the round-to-nearest-even rounding mode for
    /// 32-bit floating-point arithmetic and conversion instructions.
    /// It also indicates whether the RoundingModeRTE execution mode can
    /// be used for 32-bit floating-point types.</summary>
    public VkBool32           shaderRoundingModeRTEFloat32;
    /// <summary>  
    ///   shaderRoundingModeRTEFloat64 is a boolean value indicating whether
    /// an implementation supports the round-to-nearest-even rounding mode for
    /// 64-bit floating-point arithmetic and conversion instructions.
    /// It also indicates whether the RoundingModeRTE execution mode can
    /// be used for 64-bit floating-point types.</summary>
    public VkBool32           shaderRoundingModeRTEFloat64;
    /// <summary>  
    ///   shaderRoundingModeRTZFloat16 is a boolean value indicating whether
    /// an implementation supports the round-towards-zero rounding mode for
    /// 16-bit floating-point arithmetic and conversion instructions.
    /// It also indicates whether the RoundingModeRTZ execution mode can
    /// be used for 16-bit floating-point types.</summary>
    public VkBool32           shaderRoundingModeRTZFloat16;
    /// <summary>  
    ///   shaderRoundingModeRTZFloat32 is a boolean value indicating whether
    /// an implementation supports the round-towards-zero rounding mode for
    /// 32-bit floating-point arithmetic and conversion instructions.
    /// It also indicates whether the RoundingModeRTZ execution mode can
    /// be used for 32-bit floating-point types.</summary>
    public VkBool32           shaderRoundingModeRTZFloat32;
    /// <summary>  
    ///   shaderRoundingModeRTZFloat64 is a boolean value indicating whether
    /// an implementation supports the round-towards-zero rounding mode for
    /// 64-bit floating-point arithmetic and conversion instructions.
    /// It also indicates whether the RoundingModeRTZ execution mode can
    /// be used for 64-bit floating-point types.</summary>
    public VkBool32           shaderRoundingModeRTZFloat64;
}
// Struct: 254
/// <summary>VkPhysicalDeviceFragmentDensityMapFeaturesEXT - Structure describing fragment density map features that can be supported by an implementation
/// <para>   fragmentDensityMap specifieswhether the implementation supports render passes with a fragmentdensity map attachment.If this feature is not enabled and the pNext chain ofVkRenderPassCreateInfo containsVkRenderPassFragmentDensityMapCreateInfoEXT,fragmentDensityMapAttachment must be VK_ATTACHMENT_UNUSED.</para>
/// <para>   fragmentDensityMapDynamicspecifies whether the implementation supports dynamic fragment densitymap image views.If this feature is not enabled,VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT mustnot be included in VkImageViewCreateInfo::flags.</para>
/// <para>   fragmentDensityMapNonSubsampledImages specifies whether theimplementation supports regular non-subsampled image attachments withfragment density map render passes.If this feature is not enabled, render passes with afragment density mapattachment must only have subsampledattachments bound.</para>
/// <para>If the VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2, it isfilled with values indicating whether each feature is supported.VkPhysicalDeviceFragmentDensityMapFeaturesEXT can also be used inpNext chain of VkDeviceCreateInfo to enable the features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           fragmentDensityMap;
    public VkBool32           fragmentDensityMapDynamic;
    public VkBool32           fragmentDensityMapNonSubsampledImages;
}
// Struct: 255
/// <summary>VkPhysicalDeviceFragmentDensityMapPropertiesEXT - Structure describing fragment density map properties that can be supported by an implementation
/// <para>   minFragmentDensityTexelSizeis the minimum fragment densitytexel size.</para>
/// <para>   maxFragmentDensityTexelSizeis the maximum fragment density texel size.</para>
/// <para>   fragmentDensityInvocationsspecifies whether the implementation may invoke additional fragmentshader invocations for each covered sample.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT </para>
/// <para>If the VkPhysicalDeviceFragmentDensityMapPropertiesEXT structure isincluded in the pNext chain of VkPhysicalDeviceProperties2KHR,it is filled with the implementation-dependent limits and properties.</para>
/// </summary>
public unsafe struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkExtent2D         minFragmentDensityTexelSize;
    public VkExtent2D         maxFragmentDensityTexelSize;
    public VkBool32           fragmentDensityInvocations;
}
// Struct: 256
/// <summary>VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV - Structure describing barycentric support in fragment shaders that can be supported by an implementation
/// <para>   fragmentShaderBarycentricindicates that the implementation supports the BaryCoordNV andBaryCoordNoPerspNV SPIR-V fragment shader built-ins and supportsthe PerVertexNV SPIR-V decoration on fragment shader inputvariables.</para>
/// <para>See Barycentric Interpolation for moreinformation.</para>
/// <para>If the VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV structureis included in the pNext chain of VkPhysicalDeviceFeatures2KHR,it is filled with values indicating whether the feature is supported.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV can also be usedin the pNext chain of VkDeviceCreateInfo to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           fragmentShaderBarycentric;
}
// Struct: 257
/// <summary>VkPhysicalDeviceGroupProperties - Structure specifying physical device group properties
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkPhysicalDeviceGroupProperties {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType     sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*               pNext;
    /// <summary> physicalDeviceCount is the number of physical devices in the
    /// group.</summary>
    public UInt32            physicalDeviceCount;
    public fixed VkPhysicalDevice    physicalDevices[VK_MAX_DEVICE_GROUP_SIZE];
    /// <summary> subsetAllocation specifies whether logical devices created from
    /// the group support allocating device memory on a subset of devices, via
    /// the deviceMask member of the VkMemoryAllocateFlagsInfo.
    /// If this is VK_FALSE, then all device memory allocations are made
    /// across all physical devices in the group.
    /// If physicalDeviceCount is 1, then subsetAllocation must
    /// be VK_FALSE.</summary>
    public VkBool32            subsetAllocation;
}
// Struct: 258
/// <summary>VkPhysicalDeviceHostQueryResetFeaturesEXT - Structure describing whether queries can be reset from the host
/// <para>   hostQueryReset indicates that theimplementation supports resetting queries from the host withvkResetQueryPoolEXT.</para>
/// <para>If the VkPhysicalDeviceHostQueryResetFeaturesEXT structure is includedin the pNext chain of VkPhysicalDeviceFeatures2, it is filledwith values indicating whether the feature is supported.VkPhysicalDeviceHostQueryResetFeaturesEXT can also be used in thepNext chain of VkDeviceCreateInfo to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceHostQueryResetFeaturesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           hostQueryReset;
}
// Struct: 259
/// <summary>VkPhysicalDeviceIDProperties - Structure specifying IDs related to the physical device
/// <para> deviceUUID must be immutable for a given device across instances,processes, driver APIs, driver versions, and system reboots.</para>
/// <para>Applications can compare the driverUUID value across instance andprocess boundaries, and can make similar queries in external APIs todetermine whether they are capable of sharing memory objects and resourcesusing them with the device.</para>
/// <para> deviceUUID and/or driverUUID must be used to determine whethera particular external object can be shared between driver components, wheresuch a restriction exists as defined in the compatibility table for theparticular object type:</para>
/// <para> External memory handletypes compatibility </para>
/// <para> External semaphorehandle types compatibility </para>
/// <para> External fence handle typescompatibility </para>
/// <para>If deviceLUIDValid is VK_FALSE, the values of deviceLUIDand deviceNodeMask are undefined.If deviceLUIDValid is VK_TRUE and Vulkan is running on theWindows operating system, the contents of deviceLUID can be cast toan LUID object and must be equal to the locally unique identifier of aIDXGIAdapter1 object that corresponds to physicalDevice.If deviceLUIDValid is VK_TRUE, deviceNodeMask mustcontain exactly one bit.If Vulkan is running on an operating system that supports the Direct3D 12API and physicalDevice corresponds to an individual device in a linkeddevice adapter, deviceNodeMask identifies the Direct3D 12 nodecorresponding to physicalDevice.Otherwise, deviceNodeMask must be 1.</para>
/// <para>Although they have identical descriptions,VkPhysicalDeviceIDProperties::deviceUUID may differ fromVkPhysicalDeviceProperties2::pipelineCacheUUID.The former is intended to identify and correlate devices across API anddriver boundaries, while the latter is used to identify a compatible deviceand driver combination to use when serializing and de-serializing pipelinestate.</para>
/// <para>While VkPhysicalDeviceIDProperties::deviceUUID is specified toremain consistent across driver versions and system reboots, it is notintended to be usable as a serializable persistent identifier for a device.It may change when a device is physically added to, removed from, or movedto a different connector in a system while that system is powered down.Further, there is no reasonable way to verify with conformance testing thata given device retains the same UUID in a given system across all driverversions supported in that system.While implementations should make every effort to report consistent deviceUUIDs across driver versions, applications should avoid relying on thepersistence of this value for uses other than identifying compatible devicesfor external object sharing purposes.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES </para>
/// </summary>
public unsafe struct VkPhysicalDeviceIDProperties {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    public fixed byte            deviceUUID[VK_UUID_SIZE];
    public fixed byte            driverUUID[VK_UUID_SIZE];
    public fixed byte            deviceLUID[VK_LUID_SIZE];
    /// <summary> deviceNodeMask is a bitfield identifying the node within a linked
    /// device adapter corresponding to the device.</summary>
    public UInt32           deviceNodeMask;
    /// <summary> deviceLUIDValid is a boolean value that will be VK_TRUE if
    /// deviceLUID contains a valid LUID and deviceNodeMask contains
    /// a valid node mask, and VK_FALSE if they do not.</summary>
    public VkBool32           deviceLUIDValid;
}
// Struct: 260
/// <summary>VkPhysicalDeviceImageDrmFormatModifierInfoEXT - Structure specifying a DRM format modifier as image creation parameter
/// <para>If the drmFormatModifier is incompatible with the parameters specifiedin VkPhysicalDeviceImageFormatInfo2 and its pNext chain, thenvkGetPhysicalDeviceImageFormatProperties2 returnsVK_ERROR_FORMAT_NOT_SUPPORTED.The implementation must support the query of any drmFormatModifier,including unknown and invalid modifier values.</para>
/// <para>  If sharingMode is VK_SHARING_MODE_CONCURRENT, thenpQueueFamilyIndices must be a valid pointer to an array ofqueueFamilyIndexCount uint32_t values.</para>
/// <para>  If sharingMode is VK_SHARING_MODE_CONCURRENT, thenqueueFamilyIndexCount must be greater than 1.</para>
/// <para>  If sharingMode is VK_SHARING_MODE_CONCURRENT, each elementof pQueueFamilyIndices must be unique and must be less than thepQueueFamilyPropertyCount returned byvkGetPhysicalDeviceQueueFamilyProperties2 for thephysicalDevice that was used to create device.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT </para>
/// <para>   sharingMode must be a valid VkSharingMode value</para>
/// </summary>
public unsafe struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> drmFormatModifier is the image’s Linux DRM format modifier,
    /// corresponding to
    /// VkImageDrmFormatModifierExplicitCreateInfoEXT::modifier or
    /// to VkImageDrmFormatModifierListCreateInfoEXT::pModifiers.</summary>
    public UInt64           drmFormatModifier;
    /// <summary> sharingMode specifies how the image will be accessed by multiple
    /// queue families.</summary>
    public VkSharingMode      sharingMode;
    /// <summary> queueFamilyIndexCount is the number of entries in the
    /// pQueueFamilyIndices array.</summary>
    public UInt32           queueFamilyIndexCount;
    /// <summary> pQueueFamilyIndices is a list of queue families that will access
    /// the image (ignored if sharingMode is not
    /// VK_SHARING_MODE_CONCURRENT).</summary>
    public /* const */ UInt32*    pQueueFamilyIndices;
}
// Struct: 261
/// <summary>VkPhysicalDeviceImageFormatInfo2 - Structure specifying image creation parameters
/// <para>The members of VkPhysicalDeviceImageFormatInfo2 correspond to thearguments to vkGetPhysicalDeviceImageFormatProperties, withsType and pNext added for extensibility.</para>
/// <para>   tiling must be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT ifand only if the pNext chain containsVkPhysicalDeviceImageDrmFormatModifierInfoEXT.</para>
/// <para>  If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT andflags contains VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, then thepNext chain must contain VkImageFormatListCreateInfoKHRwith non-zero viewFormatCount.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkImageFormatListCreateInfoKHR, VkImageStencilUsageCreateInfoEXT, VkPhysicalDeviceExternalImageFormatInfo, VkPhysicalDeviceImageDrmFormatModifierInfoEXT, or VkPhysicalDeviceImageViewImageFormatInfoEXT </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   format must be a valid VkFormat value</para>
/// <para>   type must be a valid VkImageType value</para>
/// <para>   tiling must be a valid VkImageTiling value</para>
/// <para>   usage must be a valid combination of VkImageUsageFlagBits values</para>
/// <para>   usage must not be 0 </para>
/// <para>   flags must be a valid combination of VkImageCreateFlagBits values</para>
/// </summary>
public unsafe struct VkPhysicalDeviceImageFormatInfo2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.
    /// The pNext chain of VkPhysicalDeviceImageFormatInfo2 is used
    /// to provide additional image parameters to
    /// vkGetPhysicalDeviceImageFormatProperties2.</summary>
    public /* const */ void*           pNext;
    /// <summary> format is a VkFormat value indicating the image format,
    /// corresponding to VkImageCreateInfo::format.</summary>
    public VkFormat              format;
    /// <summary> type is a VkImageType value indicating the image type,
    /// corresponding to VkImageCreateInfo::imageType.</summary>
    public VkImageType           type;
    /// <summary> tiling is a VkImageTiling value indicating the image tiling,
    /// corresponding to VkImageCreateInfo::tiling.</summary>
    public VkImageTiling         tiling;
    /// <summary> usage is a bitmask of VkImageUsageFlagBits indicating the
    /// intended usage of the image, corresponding to
    /// VkImageCreateInfo::usage.</summary>
    public VkImageUsageFlags     usage;
    /// <summary> flags is a bitmask of VkImageCreateFlagBits indicating
    /// additional parameters of the image, corresponding to
    /// VkImageCreateInfo::flags.</summary>
    public VkImageCreateFlags    flags;
}
// Struct: 262
/// <summary>VkPhysicalDeviceImageViewImageFormatInfoEXT - Structure for providing image view type
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT </para>
/// <para>   imageViewType must be a valid VkImageViewType value</para>
/// </summary>
public unsafe struct VkPhysicalDeviceImageViewImageFormatInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> imageViewType is a VkImageViewType value specifying the type
    /// of the image view.</summary>
    public VkImageViewType    imageViewType;
}
// Struct: 263
/// <summary>VkPhysicalDeviceInlineUniformBlockFeaturesEXT - Structure describing inline uniform block features that can be supported by an implementation
/// <para>   inlineUniformBlock indicateswhether the implementation supports inline uniform block descriptors.If this feature is not enabled,VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT must not be used.</para>
/// <para>   descriptorBindingInlineUniformBlockUpdateAfterBindindicates whether the implementation supports updating inline uniformblock descriptors after a set is bound.If this feature is not enabled,VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be usedwith VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT.</para>
/// <para>If the VkPhysicalDeviceInlineUniformBlockFeaturesEXT structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2, it isfilled with values indicating whether each feature is supported.VkPhysicalDeviceInlineUniformBlockFeaturesEXT can also be used in thepNext chain of VkDeviceCreateInfo to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceInlineUniformBlockFeaturesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           inlineUniformBlock;
    public VkBool32           descriptorBindingInlineUniformBlockUpdateAfterBind;
}
// Struct: 264
/// <summary>VkPhysicalDeviceInlineUniformBlockPropertiesEXT - Structure describing inline uniform block properties that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   maxInlineUniformBlockSize isthe maximum size in bytes of an inline uniform block binding.</para>
/// <para>   maxPerStageDescriptorInlineUniformBlock is the maximum number ofinline uniform block bindings that can be accessible to a single shaderstage in a pipeline layout.Descriptor bindings with a descriptor type ofVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT count against thislimit.Only descriptor bindings in descriptor set layouts created without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset count against this limit.</para>
/// <para>   maxPerStageDescriptorUpdateAfterBindInlineUniformBlocksis similar to maxPerStageDescriptorInlineUniformBlocks but countsdescriptor bindings from descriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>   maxDescriptorSetInlineUniformBlocks is the maximum number ofinline uniform block bindings that can be included in descriptorbindings in a pipeline layout across all pipeline shader stages anddescriptor set numbers.Descriptor bindings with a descriptor type ofVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT count against thislimit.Only descriptor bindings in descriptor set layouts created without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset count against this limit.</para>
/// <para>   maxDescriptorSetUpdateAfterBindInlineUniformBlocksis similar to maxDescriptorSetInlineUniformBlocks but countsdescriptor bindings from descriptor sets created with or without theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset.</para>
/// <para>If the VkPhysicalDeviceInlineUniformBlockPropertiesEXT structure isincluded in the pNext chain of VkPhysicalDeviceProperties2, itis filled with the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceInlineUniformBlockPropertiesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public UInt32           maxInlineUniformBlockSize;
    public UInt32           maxPerStageDescriptorInlineUniformBlocks;
    public UInt32           maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
    public UInt32           maxDescriptorSetInlineUniformBlocks;
    public UInt32           maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
}
// Struct: 265
/// <summary>VkPhysicalDeviceLimits - Structure reporting implementation-dependent physical device limits
/// <para>For all bitmasks of VkSampleCountFlagBits, the sample count limitsdefined above represent the minimum supported sample counts for eachimage type.Individual images may support additional sample counts, which arequeried using vkGetPhysicalDeviceImageFormatProperties asdescribed in Supported SampleCounts.</para>
/// </summary>
public unsafe struct VkPhysicalDeviceLimits {
    /// <summary>  
    ///   maxImageDimension1D is the maximum
    /// dimension (width) supported for all images created with an
    /// imageType of VK_IMAGE_TYPE_1D.</summary>
    public UInt32              maxImageDimension1D;
    /// <summary>  
    ///   maxImageDimension2D is the maximum
    /// dimension (width or height) supported for all images created
    /// with an imageType of VK_IMAGE_TYPE_2D and without
    /// VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in flags.</summary>
    public UInt32              maxImageDimension2D;
    /// <summary>  
    ///   maxImageDimension3D is the maximum
    /// dimension (width, height, or depth) supported for all
    /// images created with an imageType of VK_IMAGE_TYPE_3D.</summary>
    public UInt32              maxImageDimension3D;
    /// <summary>  
    ///   maxImageDimensionCube is the
    /// maximum dimension (width or height) supported for all images
    /// created with an imageType of VK_IMAGE_TYPE_2D and with
    /// VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in flags.</summary>
    public UInt32              maxImageDimensionCube;
    /// <summary>  
    ///   maxImageArrayLayers is the maximum
    /// number of layers (arrayLayers) for an image.</summary>
    public UInt32              maxImageArrayLayers;
    /// <summary>  
    ///   maxTexelBufferElements is the
    /// maximum number of addressable texels for a buffer view created on a
    /// buffer which was created with the
    /// VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or
    /// VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the usage
    /// member of the VkBufferCreateInfo structure.</summary>
    public UInt32              maxTexelBufferElements;
    /// <summary>  
    ///   maxUniformBufferRange is the
    /// maximum value that can be specified in the range member of any
    /// VkDescriptorBufferInfo structures passed to a call to
    /// vkUpdateDescriptorSets for descriptors of type
    /// VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    /// VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.</summary>
    public UInt32              maxUniformBufferRange;
    /// <summary>  
    ///   maxStorageBufferRange is the
    /// maximum value that can be specified in the range member of any
    /// VkDescriptorBufferInfo structures passed to a call to
    /// vkUpdateDescriptorSets for descriptors of type
    /// VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    /// VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.</summary>
    public UInt32              maxStorageBufferRange;
    /// <summary>  
    ///   maxPushConstantsSize is the
    /// maximum size, in bytes, of the pool of push constant memory.
    /// For each of the push constant ranges indicated by the
    /// pPushConstantRanges member of the VkPipelineLayoutCreateInfo
    /// structure, (offset +  size) must be less than or
    /// equal to this limit.</summary>
    public UInt32              maxPushConstantsSize;
    /// <summary>  
    ///   maxMemoryAllocationCount is
    /// the maximum number of device memory allocations, as created by
    /// vkAllocateMemory, which can simultaneously exist.</summary>
    public UInt32              maxMemoryAllocationCount;
    /// <summary>  
    ///   maxSamplerAllocationCount is
    /// the maximum number of sampler objects, as created by
    /// vkCreateSampler, which can simultaneously exist on a device.</summary>
    public UInt32              maxSamplerAllocationCount;
    /// <summary>  
    ///   bufferImageGranularity is the
    /// granularity, in bytes, at which buffer or linear image resources, and
    /// optimal image resources can be bound to adjacent offsets in the same
    /// VkDeviceMemory object without aliasing.
    /// See Buffer-Image Granularity for
    /// more details.</summary>
    public VkDeviceSize          bufferImageGranularity;
    /// <summary>  
    ///   sparseAddressSpaceSize is the
    /// total amount of address space available, in bytes, for sparse memory
    /// resources.
    /// This is an upper bound on the sum of the size of all sparse resources,
    /// regardless of whether any memory is bound to them.</summary>
    public VkDeviceSize          sparseAddressSpaceSize;
    /// <summary>  
    ///   maxBoundDescriptorSets is the
    /// maximum number of descriptor sets that can be simultaneously used by a
    /// pipeline.
    /// All DescriptorSet decorations in shader modules must have a value
    /// less than maxBoundDescriptorSets.
    /// See html/vkspec.html#descriptorsets-sets.</summary>
    public UInt32              maxBoundDescriptorSets;
    /// <summary>  
    ///   maxPerStageDescriptorSamplers is the maximum number of samplers
    /// that can be accessible to a single shader stage in a pipeline layout.
    /// Descriptors with a type of VK_DESCRIPTOR_TYPE_SAMPLER or
    /// VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this
    /// limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// A descriptor is accessible to a shader stage when the stageFlags
    /// member of the VkDescriptorSetLayoutBinding structure has the bit
    /// for that shader stage set.
    /// See html/vkspec.html#descriptorsets-sampler and
    /// html/vkspec.html#descriptorsets-combinedimagesampler.</summary>
    public UInt32              maxPerStageDescriptorSamplers;
    /// <summary>  
    ///   maxPerStageDescriptorUniformBuffers is the maximum number of
    /// uniform buffers that can be accessible to a single shader stage in a
    /// pipeline layout.
    /// Descriptors with a type of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    /// VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
    /// limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// A descriptor is accessible to a shader stage when the stageFlags
    /// member of the VkDescriptorSetLayoutBinding structure has the bit
    /// for that shader stage set.
    /// See html/vkspec.html#descriptorsets-uniformbuffer and
    /// html/vkspec.html#descriptorsets-uniformbufferdynamic.</summary>
    public UInt32              maxPerStageDescriptorUniformBuffers;
    /// <summary>  
    ///   maxPerStageDescriptorStorageBuffers is the maximum number of
    /// storage buffers that can be accessible to a single shader stage in a
    /// pipeline layout.
    /// Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    /// VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
    /// limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// A descriptor is accessible to a pipeline shader stage when the
    /// stageFlags member of the VkDescriptorSetLayoutBinding
    /// structure has the bit for that shader stage set.
    /// See html/vkspec.html#descriptorsets-storagebuffer and
    /// html/vkspec.html#descriptorsets-storagebufferdynamic.</summary>
    public UInt32              maxPerStageDescriptorStorageBuffers;
    /// <summary>  
    ///   maxPerStageDescriptorSampledImages is the maximum number of
    /// sampled images that can be accessible to a single shader stage in a
    /// pipeline layout.
    /// Descriptors with a type of
    /// VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    /// VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or
    /// VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// A descriptor is accessible to a pipeline shader stage when the
    /// stageFlags member of the VkDescriptorSetLayoutBinding
    /// structure has the bit for that shader stage set.
    /// See html/vkspec.html#descriptorsets-combinedimagesampler,
    /// html/vkspec.html#descriptorsets-sampledimage, and
    /// html/vkspec.html#descriptorsets-uniformtexelbuffer.</summary>
    public UInt32              maxPerStageDescriptorSampledImages;
    /// <summary>  
    ///   maxPerStageDescriptorStorageImages is the maximum number of
    /// storage images that can be accessible to a single shader stage in a
    /// pipeline layout.
    /// Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
    /// VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// A descriptor is accessible to a pipeline shader stage when the
    /// stageFlags member of the VkDescriptorSetLayoutBinding
    /// structure has the bit for that shader stage set.
    /// See html/vkspec.html#descriptorsets-storageimage, and
    /// html/vkspec.html#descriptorsets-storagetexelbuffer.</summary>
    public UInt32              maxPerStageDescriptorStorageImages;
    /// <summary>  
    ///   maxPerStageDescriptorInputAttachments is the maximum number of
    /// input attachments that can be accessible to a single shader stage in a
    /// pipeline layout.
    /// Descriptors with a type of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT
    /// count against this limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// A descriptor is accessible to a pipeline shader stage when the
    /// stageFlags member of the VkDescriptorSetLayoutBinding
    /// structure has the bit for that shader stage set.
    /// These are only supported for the fragment stage.
    /// See html/vkspec.html#descriptorsets-inputattachment.</summary>
    public UInt32              maxPerStageDescriptorInputAttachments;
    /// <summary>  
    ///   maxPerStageResources is the
    /// maximum number of resources that can be accessible to a single shader
    /// stage in a pipeline layout.
    /// Descriptors with a type of
    /// VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    /// VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    /// VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    /// VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
    /// VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
    /// VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    /// VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
    /// VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
    /// VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, or
    /// VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// For the fragment shader stage the framebuffer color attachments also
    /// count against this limit.</summary>
    public UInt32              maxPerStageResources;
    /// <summary>  
    ///   maxDescriptorSetSamplers is
    /// the maximum number of samplers that can be included in descriptor
    /// bindings in a pipeline layout across all pipeline shader stages and
    /// descriptor set numbers.
    /// Descriptors with a type of VK_DESCRIPTOR_TYPE_SAMPLER or
    /// VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this
    /// limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// See html/vkspec.html#descriptorsets-sampler and
    /// html/vkspec.html#descriptorsets-combinedimagesampler.</summary>
    public UInt32              maxDescriptorSetSamplers;
    /// <summary>  
    ///   maxDescriptorSetUniformBuffers is the maximum number of uniform
    /// buffers that can be included in descriptor bindings in a pipeline
    /// layout across all pipeline shader stages and descriptor set numbers.
    /// Descriptors with a type of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    /// VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
    /// limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// See html/vkspec.html#descriptorsets-uniformbuffer and
    /// html/vkspec.html#descriptorsets-uniformbufferdynamic.</summary>
    public UInt32              maxDescriptorSetUniformBuffers;
    /// <summary>  
    ///   maxDescriptorSetUniformBuffersDynamic is the maximum number of
    /// dynamic uniform buffers that can be included in descriptor bindings in
    /// a pipeline layout across all pipeline shader stages and descriptor set
    /// numbers.
    /// Descriptors with a type of
    /// VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this
    /// limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// See html/vkspec.html#descriptorsets-uniformbufferdynamic.</summary>
    public UInt32              maxDescriptorSetUniformBuffersDynamic;
    /// <summary>  
    ///   maxDescriptorSetStorageBuffers is the maximum number of storage
    /// buffers that can be included in descriptor bindings in a pipeline
    /// layout across all pipeline shader stages and descriptor set numbers.
    /// Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    /// VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
    /// limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// See html/vkspec.html#descriptorsets-storagebuffer and
    /// html/vkspec.html#descriptorsets-storagebufferdynamic.</summary>
    public UInt32              maxDescriptorSetStorageBuffers;
    /// <summary>  
    ///   maxDescriptorSetStorageBuffersDynamic is the maximum number of
    /// dynamic storage buffers that can be included in descriptor bindings in
    /// a pipeline layout across all pipeline shader stages and descriptor set
    /// numbers.
    /// Descriptors with a type of
    /// VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this
    /// limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// See html/vkspec.html#descriptorsets-storagebufferdynamic.</summary>
    public UInt32              maxDescriptorSetStorageBuffersDynamic;
    /// <summary>  
    ///   maxDescriptorSetSampledImages is the maximum number of sampled
    /// images that can be included in descriptor bindings in a pipeline layout
    /// across all pipeline shader stages and descriptor set numbers.
    /// Descriptors with a type of
    /// VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    /// VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or
    /// VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// See html/vkspec.html#descriptorsets-combinedimagesampler,
    /// html/vkspec.html#descriptorsets-sampledimage, and
    /// html/vkspec.html#descriptorsets-uniformtexelbuffer.</summary>
    public UInt32              maxDescriptorSetSampledImages;
    /// <summary>  
    ///   maxDescriptorSetStorageImages is the maximum number of storage
    /// images that can be included in descriptor bindings in a pipeline layout
    /// across all pipeline shader stages and descriptor set numbers.
    /// Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or
    /// VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// See html/vkspec.html#descriptorsets-storageimage, and
    /// html/vkspec.html#descriptorsets-storagetexelbuffer.</summary>
    public UInt32              maxDescriptorSetStorageImages;
    /// <summary>  
    ///   maxDescriptorSetInputAttachments is the maximum number of input
    /// attachments that can be included in descriptor bindings in a pipeline
    /// layout across all pipeline shader stages and descriptor set numbers.
    /// Descriptors with a type of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT
    /// count against this limit.
    /// Only descriptors in descriptor set layouts created without the
    /// VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit
    /// set count against this limit.
    /// See html/vkspec.html#descriptorsets-inputattachment.</summary>
    public UInt32              maxDescriptorSetInputAttachments;
    /// <summary>  
    ///   maxVertexInputAttributes is
    /// the maximum number of vertex input attributes that can be specified for
    /// a graphics pipeline.
    /// These are described in the array of
    /// VkVertexInputAttributeDescription structures that are provided at
    /// graphics pipeline creation time via the
    /// pVertexAttributeDescriptions member of the
    /// VkPipelineVertexInputStateCreateInfo structure.
    /// See html/vkspec.html#fxvertex-attrib and html/vkspec.html#fxvertex-input.</summary>
    public UInt32              maxVertexInputAttributes;
    /// <summary>  
    ///   maxVertexInputBindings is the
    /// maximum number of vertex buffers that can be specified for providing
    /// vertex attributes to a graphics pipeline.
    /// These are described in the array of
    /// VkVertexInputBindingDescription structures that are provided at
    /// graphics pipeline creation time via the pVertexBindingDescriptions
    /// member of the VkPipelineVertexInputStateCreateInfo structure.
    /// The binding member of VkVertexInputBindingDescription must
    /// be less than this limit.
    /// See html/vkspec.html#fxvertex-input.</summary>
    public UInt32              maxVertexInputBindings;
    /// <summary>  
    ///   maxVertexInputAttributeOffset is the maximum vertex input
    /// attribute offset that can be added to the vertex input binding stride.
    /// The offset member of the VkVertexInputAttributeDescription
    /// structure must be less than or equal to this limit.
    /// See html/vkspec.html#fxvertex-input.</summary>
    public UInt32              maxVertexInputAttributeOffset;
    /// <summary>  
    ///   maxVertexInputBindingStride
    /// is the maximum vertex input binding stride that can be specified in a
    /// vertex input binding.
    /// The stride member of the VkVertexInputBindingDescription
    /// structure must be less than or equal to this limit.
    /// See html/vkspec.html#fxvertex-input.</summary>
    public UInt32              maxVertexInputBindingStride;
    /// <summary>  
    ///   maxVertexOutputComponents is
    /// the maximum number of components of output variables which can be
    /// output by a vertex shader.
    /// See html/vkspec.html#shaders-vertex.</summary>
    public UInt32              maxVertexOutputComponents;
    /// <summary>  
    ///   maxTessellationGenerationLevel is the maximum tessellation
    /// generation level supported by the fixed-function tessellation primitive
    /// generator.
    /// See html/vkspec.html#tessellation.</summary>
    public UInt32              maxTessellationGenerationLevel;
    /// <summary>  
    ///   maxTessellationPatchSize is
    /// the maximum patch size, in vertices, of patches that can be processed
    /// by the tessellation control shader and tessellation primitive generator.
    /// The patchControlPoints member of the
    /// VkPipelineTessellationStateCreateInfo structure specified at
    /// pipeline creation time and the value provided in the OutputVertices
    /// execution mode of shader modules must be less than or equal to this
    /// limit.
    /// See html/vkspec.html#tessellation.</summary>
    public UInt32              maxTessellationPatchSize;
    /// <summary>  
    ///   maxTessellationControlPerVertexInputComponents is the maximum
    /// number of components of input variables which can be provided as
    /// per-vertex inputs to the tessellation control shader stage.</summary>
    public UInt32              maxTessellationControlPerVertexInputComponents;
    /// <summary>  
    ///   maxTessellationControlPerVertexOutputComponents is the maximum
    /// number of components of per-vertex output variables which can be output
    /// from the tessellation control shader stage.</summary>
    public UInt32              maxTessellationControlPerVertexOutputComponents;
    /// <summary>  
    ///   maxTessellationControlPerPatchOutputComponents is the maximum
    /// number of components of per-patch output variables which can be output
    /// from the tessellation control shader stage.</summary>
    public UInt32              maxTessellationControlPerPatchOutputComponents;
    /// <summary>  
    ///   maxTessellationControlTotalOutputComponents is the maximum total
    /// number of components of per-vertex and per-patch output variables which
    /// can be output from the tessellation control shader stage.</summary>
    public UInt32              maxTessellationControlTotalOutputComponents;
    /// <summary>  
    ///   maxTessellationEvaluationInputComponents is the maximum number of
    /// components of input variables which can be provided as per-vertex
    /// inputs to the tessellation evaluation shader stage.</summary>
    public UInt32              maxTessellationEvaluationInputComponents;
    /// <summary>  
    ///   maxTessellationEvaluationOutputComponents is the maximum number of
    /// components of per-vertex output variables which can be output from the
    /// tessellation evaluation shader stage.</summary>
    public UInt32              maxTessellationEvaluationOutputComponents;
    /// <summary>  
    ///   maxGeometryShaderInvocations is the maximum invocation count
    /// supported for instanced geometry shaders.
    /// The value provided in the Invocations execution mode of shader
    /// modules must be less than or equal to this limit.
    /// See html/vkspec.html#geometry.</summary>
    public UInt32              maxGeometryShaderInvocations;
    /// <summary>  
    ///   maxGeometryInputComponents
    /// is the maximum number of components of input variables which can be
    /// provided as inputs to the geometry shader stage.</summary>
    public UInt32              maxGeometryInputComponents;
    /// <summary>  
    ///   maxGeometryOutputComponents
    /// is the maximum number of components of output variables which can be
    /// output from the geometry shader stage.</summary>
    public UInt32              maxGeometryOutputComponents;
    /// <summary>  
    ///   maxGeometryOutputVertices is
    /// the maximum number of vertices which can be emitted by any geometry
    /// shader.</summary>
    public UInt32              maxGeometryOutputVertices;
    /// <summary>  
    ///   maxGeometryTotalOutputComponents is the maximum total number of
    /// components of output, across all emitted vertices, which can be output
    /// from the geometry shader stage.</summary>
    public UInt32              maxGeometryTotalOutputComponents;
    /// <summary>  
    ///   maxFragmentInputComponents
    /// is the maximum number of components of input variables which can be
    /// provided as inputs to the fragment shader stage.</summary>
    public UInt32              maxFragmentInputComponents;
    /// <summary>  
    ///   maxFragmentOutputAttachments is the maximum number of output
    /// attachments which can be written to by the fragment shader stage.</summary>
    public UInt32              maxFragmentOutputAttachments;
    /// <summary>  
    ///   maxFragmentDualSrcAttachments is the maximum number of output
    /// attachments which can be written to by the fragment shader stage when
    /// blending is enabled and one of the dual source blend modes is in use.
    /// See html/vkspec.html#framebuffer-dsb and dualSrcBlend.</summary>
    public UInt32              maxFragmentDualSrcAttachments;
    /// <summary>  
    ///   maxFragmentCombinedOutputResources is the total number of storage
    /// buffers, storage images, and output buffers which can be used in the
    /// fragment shader stage.</summary>
    public UInt32              maxFragmentCombinedOutputResources;
    /// <summary>  
    ///   maxComputeSharedMemorySize
    /// is the maximum total storage size, in bytes, available for variables
    /// declared with the Workgroup storage class in shader modules (or
    /// with the shared storage qualifier in GLSL) in the compute shader
    /// stage.
    /// The amount of storage consumed by the variables declared with the
    /// Workgroup storage class is implementation-dependent.
    /// However, the amount of storage consumed may not exceed the largest block
    /// size that would be obtained if all active variables declared with
    /// Workgroup storage class were assigned offsets in an arbitrary order
    /// by successively taking the smallest valid offset according to the
    /// Standard Storage Buffer Layout
    /// rules.
    /// (This is equivalent to using the GLSL std430 layout rules.)</summary>
    public UInt32              maxComputeSharedMemorySize;
    public fixed UInt32              maxComputeWorkGroupCount[3];
    /// <summary>  
    ///   maxComputeWorkGroupInvocations is the maximum total number of
    /// compute shader invocations in a single local workgroup.
    /// The product of the X, Y, and Z sizes as specified by the LocalSize
    /// execution mode in shader modules and by the object decorated by the
    /// WorkgroupSize decoration must be less than or equal to this limit.</summary>
    public UInt32              maxComputeWorkGroupInvocations;
    public fixed UInt32              maxComputeWorkGroupSize[3];
    /// <summary>  
    ///   subPixelPrecisionBits is the
    /// number of bits of subpixel precision in framebuffer coordinates
    /// xf  and yf .
    /// See html/vkspec.html#primsrast.</summary>
    public UInt32              subPixelPrecisionBits;
    /// <summary>  
    ///   subTexelPrecisionBits is the
    /// number of bits of precision in the division along an axis of an image
    /// used for minification and magnification filters.
    /// 2 subTexelPrecisionBits   is the actual number of divisions
    /// along each axis of the image represented.
    /// Sub-texel values calculated during image sampling will snap to these
    /// locations when generating the filtered results.</summary>
    public UInt32              subTexelPrecisionBits;
    /// <summary>  
    ///   mipmapPrecisionBits is the number
    /// of bits of division that the LOD calculation for mipmap fetching get
    /// snapped to when determining the contribution from each mip level to the
    /// mip filtered results.
    /// 2 mipmapPrecisionBits   is the actual number of divisions.</summary>
    public UInt32              mipmapPrecisionBits;
    /// <summary>  
    ///   maxDrawIndexedIndexValue is
    /// the maximum index value that can be used for indexed draw calls when
    /// using 32-bit indices.
    /// This excludes the primitive restart index value of 0xFFFFFFFF.
    /// See fullDrawIndexUint32.</summary>
    public UInt32              maxDrawIndexedIndexValue;
    /// <summary>  
    ///   maxDrawIndirectCount is the
    /// maximum draw count that is supported for indirect draw calls.
    /// See multiDrawIndirect.</summary>
    public UInt32              maxDrawIndirectCount;
    /// <summary>  
    ///   maxSamplerLodBias is the maximum
    /// absolute sampler LOD bias.
    /// The sum of the mipLodBias member of the VkSamplerCreateInfo
    /// structure and the Bias operand of image sampling operations in
    /// shader modules (or 0 if no Bias operand is provided to an image
    /// sampling operation) are clamped to the range
    /// [-maxSamplerLodBias,+maxSamplerLodBias].
    /// See html/vkspec.html#samplers-mipLodBias.</summary>
    public float                 maxSamplerLodBias;
    /// <summary>  
    ///   maxSamplerAnisotropy is the
    /// maximum degree of sampler anisotropy.
    /// The maximum degree of anisotropic filtering used for an image sampling
    /// operation is the minimum of the maxAnisotropy member of the
    /// VkSamplerCreateInfo structure and this limit.
    /// See html/vkspec.html#samplers-maxAnisotropy.</summary>
    public float                 maxSamplerAnisotropy;
    /// <summary>  
    ///   maxViewports is the maximum number of
    /// active viewports.
    /// The viewportCount member of the
    /// VkPipelineViewportStateCreateInfo structure that is provided at
    /// pipeline creation must be less than or equal to this limit.</summary>
    public UInt32              maxViewports;
    public fixed UInt32              maxViewportDimensions[2];
    public fixed float                 viewportBoundsRange[2];
    /// <summary>  
    ///   viewportSubPixelBits is the number
    /// of bits of subpixel precision for viewport bounds.
    /// The subpixel precision that floating-point viewport bounds are
    /// interpreted at is given by this limit.</summary>
    public UInt32              viewportSubPixelBits;
    /// <summary>  
    ///   minMemoryMapAlignment is the
    /// minimum required alignment, in bytes, of host visible memory
    /// allocations within the host address space.
    /// When mapping a memory allocation with vkMapMemory, subtracting
    /// offset bytes from the returned pointer will always produce an
    /// integer multiple of this limit.
    /// See html/vkspec.html#memory-device-hostaccess.</summary>
    public size_t                minMemoryMapAlignment;
    /// <summary>  
    ///   minTexelBufferOffsetAlignment is the minimum required alignment,
    /// in bytes, for the offset member of the
    /// VkBufferViewCreateInfo structure for texel buffers.
    /// When a buffer view is created for a buffer which was created with
    /// VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or
    /// VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the usage
    /// member of the VkBufferCreateInfo structure, the offset must
    /// be an integer multiple of this limit.</summary>
    public VkDeviceSize          minTexelBufferOffsetAlignment;
    /// <summary>  
    ///   minUniformBufferOffsetAlignment is the minimum required
    /// alignment, in bytes, for the offset member of the
    /// VkDescriptorBufferInfo structure for uniform buffers.
    /// When a descriptor of type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or
    /// VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC is updated, the
    /// offset must be an integer multiple of this limit.
    /// Similarly, dynamic offsets for uniform buffers must be multiples of
    /// this limit.</summary>
    public VkDeviceSize          minUniformBufferOffsetAlignment;
    /// <summary>  
    ///   minStorageBufferOffsetAlignment is the minimum required
    /// alignment, in bytes, for the offset member of the
    /// VkDescriptorBufferInfo structure for storage buffers.
    /// When a descriptor of type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or
    /// VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC is updated, the
    /// offset must be an integer multiple of this limit.
    /// Similarly, dynamic offsets for storage buffers must be multiples of
    /// this limit.</summary>
    public VkDeviceSize          minStorageBufferOffsetAlignment;
    /// <summary>  
    ///   minTexelOffset is the minimum offset
    /// value for the ConstOffset image operand of any of the
    /// OpImageSample* or OpImageFetch* image instructions.</summary>
    public Int32               minTexelOffset;
    /// <summary>  
    ///   maxTexelOffset is the maximum offset
    /// value for the ConstOffset image operand of any of the
    /// OpImageSample* or OpImageFetch* image instructions.</summary>
    public UInt32              maxTexelOffset;
    /// <summary>  
    ///   minTexelGatherOffset is the
    /// minimum offset value for the Offset or ConstOffsets image
    /// operands of any of the OpImage*Gather image instructions.</summary>
    public Int32               minTexelGatherOffset;
    /// <summary>  
    ///   maxTexelGatherOffset is the
    /// maximum offset value for the Offset or ConstOffsets image
    /// operands of any of the OpImage*Gather image instructions.</summary>
    public UInt32              maxTexelGatherOffset;
    /// <summary>  
    ///   minInterpolationOffset is the
    /// minimum negative offset value for the offset operand of the
    /// InterpolateAtOffset extended instruction.</summary>
    public float                 minInterpolationOffset;
    /// <summary>  
    ///   maxInterpolationOffset is the
    /// maximum positive offset value for the offset operand of the
    /// InterpolateAtOffset extended instruction.</summary>
    public float                 maxInterpolationOffset;
    /// <summary>  
    ///   subPixelInterpolationOffsetBits is the number of subpixel
    /// fractional bits that the x and y offsets to the
    /// InterpolateAtOffset extended instruction may be rounded to as
    /// fixed-point values.</summary>
    public UInt32              subPixelInterpolationOffsetBits;
    /// <summary>  
    ///   maxFramebufferWidth is the maximum
    /// width for a framebuffer.
    /// The width member of the VkFramebufferCreateInfo structure
    /// must be less than or equal to this limit.</summary>
    public UInt32              maxFramebufferWidth;
    /// <summary>  
    ///   maxFramebufferHeight is the
    /// maximum height for a framebuffer.
    /// The height member of the VkFramebufferCreateInfo structure
    /// must be less than or equal to this limit.</summary>
    public UInt32              maxFramebufferHeight;
    /// <summary>  
    ///   maxFramebufferLayers is the
    /// maximum layer count for a layered framebuffer.
    /// The layers member of the VkFramebufferCreateInfo structure
    /// must be less than or equal to this limit.</summary>
    public UInt32              maxFramebufferLayers;
    /// <summary>  
    ///   framebufferColorSampleCounts is a bitmask1 of
    /// VkSampleCountFlagBits indicating the color sample counts that are
    /// supported for all framebuffer color attachments with floating- or
    /// fixed-point formats.
    /// There is no limit that specifies the color sample counts that are
    /// supported for all color attachments with integer formats.</summary>
    public VkSampleCountFlags    framebufferColorSampleCounts;
    /// <summary>  
    ///   framebufferDepthSampleCounts is a bitmask1 of
    /// VkSampleCountFlagBits indicating the supported depth sample counts
    /// for all framebuffer depth/stencil attachments, when the format includes
    /// a depth component.</summary>
    public VkSampleCountFlags    framebufferDepthSampleCounts;
    /// <summary> framebufferStencilSampleCounts is a bitmask1 of
    /// VkSampleCountFlagBits indicating the supported stencil sample
    /// counts for all framebuffer depth/stencil attachments, when the format
    /// includes a stencil component.</summary>
    public VkSampleCountFlags    framebufferStencilSampleCounts;
    /// <summary> framebufferNoAttachmentsSampleCounts is a bitmask1 of
    /// VkSampleCountFlagBits indicating the supported sample counts for a
    /// framebuffer with no attachments.</summary>
    public VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
    /// <summary>  
    ///   maxColorAttachments is the maximum
    /// number of color attachments that can be used by a subpass in a render
    /// pass.
    /// The colorAttachmentCount member of the VkSubpassDescription
    /// structure must be less than or equal to this limit.</summary>
    public UInt32              maxColorAttachments;
    /// <summary>  
    ///   sampledImageColorSampleCounts is a bitmask1 of
    /// VkSampleCountFlagBits indicating the sample counts supported for
    /// all 2D images created with VK_IMAGE_TILING_OPTIMAL, usage
    /// containing VK_IMAGE_USAGE_SAMPLED_BIT, and a non-integer color
    /// format.</summary>
    public VkSampleCountFlags    sampledImageColorSampleCounts;
    /// <summary>  
    ///   sampledImageIntegerSampleCounts is a bitmask1 of
    /// VkSampleCountFlagBits indicating the sample counts supported for
    /// all 2D images created with VK_IMAGE_TILING_OPTIMAL, usage
    /// containing VK_IMAGE_USAGE_SAMPLED_BIT, and an integer color
    /// format.</summary>
    public VkSampleCountFlags    sampledImageIntegerSampleCounts;
    /// <summary>  
    ///   sampledImageDepthSampleCounts is a bitmask1 of
    /// VkSampleCountFlagBits indicating the sample counts supported for
    /// all 2D images created with VK_IMAGE_TILING_OPTIMAL, usage
    /// containing VK_IMAGE_USAGE_SAMPLED_BIT, and a depth format.</summary>
    public VkSampleCountFlags    sampledImageDepthSampleCounts;
    /// <summary>  
    ///   sampledImageStencilSampleCounts is a bitmask1 of
    /// VkSampleCountFlagBits indicating the sample supported for all 2D
    /// images created with VK_IMAGE_TILING_OPTIMAL, usage
    /// containing VK_IMAGE_USAGE_SAMPLED_BIT, and a stencil format.</summary>
    public VkSampleCountFlags    sampledImageStencilSampleCounts;
    /// <summary>  
    ///   storageImageSampleCounts is a
    /// bitmask1 of VkSampleCountFlagBits indicating the sample counts
    /// supported for all 2D images created with VK_IMAGE_TILING_OPTIMAL,
    /// and usage containing VK_IMAGE_USAGE_STORAGE_BIT.</summary>
    public VkSampleCountFlags    storageImageSampleCounts;
    /// <summary>  
    ///   maxSampleMaskWords is the maximum
    /// number of array elements of a variable decorated with the
    /// SampleMask built-in decoration.</summary>
    public UInt32              maxSampleMaskWords;
    /// <summary>  
    ///   timestampComputeAndGraphics
    /// specifies support for timestamps on all graphics and compute queues.
    /// If this limit is set to VK_TRUE, all queues that advertise the
    /// VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT in the
    /// VkQueueFamilyProperties::queueFlags support
    /// VkQueueFamilyProperties::timestampValidBits of at least 36.
    /// See Timestamp Queries.</summary>
    public VkBool32              timestampComputeAndGraphics;
    /// <summary>  
    ///   timestampPeriod is the number of
    /// nanoseconds required for a timestamp query to be incremented by 1.
    /// See Timestamp Queries.</summary>
    public float                 timestampPeriod;
    /// <summary>  
    ///   maxClipDistances is the maximum number
    /// of clip distances that can be used in a single shader stage.
    /// The size of any array declared with the ClipDistance built-in
    /// decoration in a shader module must be less than or equal to this limit.</summary>
    public UInt32              maxClipDistances;
    /// <summary>  
    ///   maxCullDistances is the maximum number
    /// of cull distances that can be used in a single shader stage.
    /// The size of any array declared with the CullDistance built-in
    /// decoration in a shader module must be less than or equal to this limit.</summary>
    public UInt32              maxCullDistances;
    /// <summary>  
    ///   maxCombinedClipAndCullDistances is the maximum combined number of
    /// clip and cull distances that can be used in a single shader stage.
    /// The sum of the sizes of any pair of arrays declared with the
    /// ClipDistance and CullDistance built-in decoration used by a
    /// single shader stage in a shader module must be less than or equal to
    /// this limit.</summary>
    public UInt32              maxCombinedClipAndCullDistances;
    /// <summary>  
    ///   discreteQueuePriorities is the
    /// number of discrete priorities that can be assigned to a queue based on
    /// the value of each member of
    /// VkDeviceQueueCreateInfo::pQueuePriorities.
    /// This must be at least 2, and levels must be spread evenly over the
    /// range, with at least one level at 1.0, and another at 0.0.
    /// See html/vkspec.html#devsandqueues-priority.</summary>
    public UInt32              discreteQueuePriorities;
    public fixed float                 pointSizeRange[2];
    public fixed float                 lineWidthRange[2];
    /// <summary>  
    ///   pointSizeGranularity is the
    /// granularity of supported point sizes.
    /// Not all point sizes in the range defined by pointSizeRange are
    /// supported.
    /// This limit specifies the granularity (or increment) between successive
    /// supported point sizes.</summary>
    public float                 pointSizeGranularity;
    /// <summary>  
    ///   lineWidthGranularity is the
    /// granularity of supported line widths.
    /// Not all line widths in the range defined by lineWidthRange are
    /// supported.
    /// This limit specifies the granularity (or increment) between successive
    /// supported line widths.</summary>
    public float                 lineWidthGranularity;
    /// <summary>  
    ///   strictLines specifies whether lines are
    /// rasterized according to the preferred method of rasterization.
    /// If set to VK_FALSE, lines may be rasterized under a relaxed set
    /// of rules.
    /// If set to VK_TRUE, lines are rasterized as per the strict
    /// definition.
    /// See Basic Line Segment Rasterization.</summary>
    public VkBool32              strictLines;
    /// <summary>  
    ///   standardSampleLocations
    /// specifies whether rasterization uses the standard sample locations as
    /// documented in Multisampling.
    /// If set to VK_TRUE, the implementation uses the documented sample
    /// locations.
    /// If set to VK_FALSE, the implementation may use different sample
    /// locations.</summary>
    public VkBool32              standardSampleLocations;
    /// <summary>  
    ///   optimalBufferCopyOffsetAlignment is the optimal buffer offset
    /// alignment in bytes for vkCmdCopyBufferToImage and
    /// vkCmdCopyImageToBuffer.
    /// The per texel alignment requirements are enforced, but applications
    /// should use the optimal alignment for optimal performance and power use.</summary>
    public VkDeviceSize          optimalBufferCopyOffsetAlignment;
    /// <summary>  
    ///   optimalBufferCopyRowPitchAlignment is the optimal buffer row pitch
    /// alignment in bytes for vkCmdCopyBufferToImage and
    /// vkCmdCopyImageToBuffer.
    /// Row pitch is the number of bytes between texels with the same X
    /// coordinate in adjacent rows (Y coordinates differ by one).
    /// The per texel alignment requirements are enforced, but applications
    /// should use the optimal alignment for optimal performance and power use.</summary>
    public VkDeviceSize          optimalBufferCopyRowPitchAlignment;
    /// <summary>  
    ///   nonCoherentAtomSize is the size and
    /// alignment in bytes that bounds concurrent access to
    /// host-mapped device memory.</summary>
    public VkDeviceSize          nonCoherentAtomSize;
}
// Struct: 266
/// <summary>VkPhysicalDeviceMaintenance3Properties - Structure describing descriptor set properties
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   maxPerSetDescriptors is a maximumnumber of descriptors (summed over all descriptor types) in a singledescriptor set that is guaranteed to satisfy anyimplementation-dependent constraints on the size of a descriptor setitself.Applications can query whether a descriptor set that goes beyond thislimit is supported using vkGetDescriptorSetLayoutSupport.</para>
/// <para>   maxMemoryAllocationSize is themaximum size of a memory allocation that can be created, even if thereis more space available in the heap.</para>
/// <para>If the VkPhysicalDeviceMaintenance3Properties structure is included inthe pNext chain of VkPhysicalDeviceProperties2, it is filledwith the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES </para>
/// </summary>
public unsafe struct VkPhysicalDeviceMaintenance3Properties {
    public VkStructureType    sType;
    public void*              pNext;
    public UInt32           maxPerSetDescriptors;
    public VkDeviceSize       maxMemoryAllocationSize;
}
// Struct: 267
/// <summary>VkPhysicalDeviceMemoryBudgetPropertiesEXT - Structure specifying physical device memory budget and usage
/// <para>The values returned in this structure are not invariant.The heapBudget and heapUsage values must be zero for arrayelements greater than or equal toVkPhysicalDeviceMemoryProperties::memoryHeapCount.The heapBudget value must be non-zero for array elements less thanVkPhysicalDeviceMemoryProperties::memoryHeapCount.The heapBudget value must be less than or equal toVkMemoryHeap::size for each heap.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceMemoryBudgetPropertiesEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    public fixed VkDeviceSize       heapBudget[VK_MAX_MEMORY_HEAPS];
    public fixed VkDeviceSize       heapUsage[VK_MAX_MEMORY_HEAPS];
}
// Struct: 268
/// <summary>VkPhysicalDeviceMemoryPriorityFeaturesEXT - Structure describing memory priority features that can be supported by an implementation
/// <para>   memoryPriority indicates that theimplementation supports memory priorities specified at memory allocationtime via VkMemoryPriorityAllocateInfoEXT.</para>
/// <para>If the VkPhysicalDeviceMemoryPriorityFeaturesEXT structure is includedin the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filledwith values indicating whether the feature is supported.VkPhysicalDeviceMemoryPriorityFeaturesEXT can also be used in thepNext chain of VkDeviceCreateInfo to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceMemoryPriorityFeaturesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           memoryPriority;
}
// Struct: 269
/// <summary>VkPhysicalDeviceMemoryProperties - Structure specifying physical device memory properties
/// <para>The VkPhysicalDeviceMemoryProperties structure describes a number ofmemory heaps as well as a number of memory types that can be used toaccess memory allocated in those heaps.Each heap describes a memory resource of a particular size, and each memorytype describes a set of memory properties (e.g. host cached vs uncached)that can be used with a given memory heap.Allocations using a particular memory type will consume resources from theheap indicated by that memory type’s heap index.More than one memory type may share each heap, and the heaps and memorytypes provide a mechanism to advertise an accurate size of the physicalmemory resources while allowing the memory to be used with a variety ofdifferent properties.</para>
/// <para>The number of memory heaps is given by memoryHeapCount and is lessthan or equal to VK_MAX_MEMORY_HEAPS.Each heap is described by an element of the memoryHeaps array as aVkMemoryHeap structure.The number of memory types available across all memory heaps is given bymemoryTypeCount and is less than or equal toVK_MAX_MEMORY_TYPES.Each memory type is described by an element of the memoryTypes arrayas a VkMemoryType structure.</para>
/// <para>At least one heap must include VK_MEMORY_HEAP_DEVICE_LOCAL_BIT inVkMemoryHeap::flags.If there are multiple heaps that all have similar performancecharacteristics, they may all includeVK_MEMORY_HEAP_DEVICE_LOCAL_BIT.In a unified memory architecture (UMA) system there is often only a singlememory heap which is considered to be equally “local” to the host and tothe device, and such an implementation must advertise the heap asdevice-local.</para>
/// <para>Each memory type returned by vkGetPhysicalDeviceMemoryProperties musthave its propertyFlags set to one of the following values:</para>
/// <para>0</para>
/// <para> VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT </para>
/// <para> VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT </para>
/// <para> VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT </para>
/// <para> VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT </para>
/// <para> VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT </para>
/// <para> VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT </para>
/// <para> VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT </para>
/// <para> VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT </para>
/// <para> VK_MEMORY_PROPERTY_PROTECTED_BIT </para>
/// <para> VK_MEMORY_PROPERTY_PROTECTED_BIT |VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT </para>
/// <para>There must be at least one memory type with both theVK_MEMORY_PROPERTY_HOST_VISIBLE_BIT andVK_MEMORY_PROPERTY_HOST_COHERENT_BIT bits set in itspropertyFlags.There must be at least one memory type with theVK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT bit set in itspropertyFlags.</para>
/// <para>For each pair of elements X and Y returned in memoryTypes, X must be placed at a lower index position than Y if:</para>
/// <para>either the set of bit flags returned in the propertyFlags memberof X is a strict subset of the set of bit flags returned in thepropertyFlags member of Y.</para>
/// <para>or the propertyFlags members of X and Y are equal, and Xbelongs to a memory heap with greater performance (as determined in animplementation-specific manner).</para>
/// <para>There is no ordering requirement between X and Y elements for the casetheir propertyFlags members are not in a subset relation.That potentially allows more than one possible way to order the same set ofmemory types.Notice that the list of all allowed memoryproperty flag combinations is written in a valid order.But if instead VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT was beforeVK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, the list would still be in avalid order.</para>
/// <para>This ordering requirement enables applications to use a simple search loopto select the desired memory type along the lines of:</para>
/// </summary>
public unsafe struct VkPhysicalDeviceMemoryProperties {
    /// <summary> memoryTypeCount is the number of valid elements in the
    /// memoryTypes array.</summary>
    public UInt32        memoryTypeCount;
    public fixed VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
    /// <summary> memoryHeapCount is the number of valid elements in the
    /// memoryHeaps array.</summary>
    public UInt32        memoryHeapCount;
    public fixed VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
}
// Struct: 270
/// <summary>VkPhysicalDeviceMemoryProperties2 - Structure specifying physical device memory properties
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkPhysicalDeviceMemoryBudgetPropertiesEXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceMemoryProperties2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                     sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                               pNext;
    /// <summary> memoryProperties is a structure of type
    /// VkPhysicalDeviceMemoryProperties which is populated with the same
    /// values as in vkGetPhysicalDeviceMemoryProperties.</summary>
    public VkPhysicalDeviceMemoryProperties    memoryProperties;
}
// Struct: 271
/// <summary>VkPhysicalDeviceMeshShaderFeaturesNV - Structure describing mesh shading features that can be supported by an implementation
/// <para>If the VkPhysicalDeviceMeshShaderFeaturesNV structure is included inthe pNext chain of VkPhysicalDeviceFeatures2, it is filled witha value indicating whether the feature is supported.VkPhysicalDeviceMeshShaderFeaturesNV can also be used in pNextchain of VkDeviceCreateInfo to enable the features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceMeshShaderFeaturesNV {
    public VkStructureType    sType;
    public void*              pNext;
    /// <summary>  
    ///   taskShader indicates whether the task
    /// shader stage is supported.</summary>
    public VkBool32           taskShader;
    /// <summary>  
    ///   meshShader indicates whether the mesh
    /// shader stage is supported.</summary>
    public VkBool32           meshShader;
}
// Struct: 272
/// <summary>VkPhysicalDeviceMeshShaderPropertiesNV - Structure describing mesh shading properties
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para> maxDrawMeshTasksCount is the maximum number of local workgroupsthat can be launched by a single draw mesh tasks command.See html/vkspec.html#drawing-mesh-shading.</para>
/// <para> maxTaskWorkGroupInvocations is the maximum total number of taskshader invocations in a single local workgroup.The product of the X, Y, and Z sizes as specified by the LocalSizeexecution mode in shader modules and by the object decorated by theWorkgroupSize decoration must be less than or equal to this limit.</para>
/// <para> maxTaskWorkGroupSize[3] is the maximum size of a local taskworkgroup.These three values represent the maximum local workgroup size in the X,Y, and Z dimensions, respectively.The x, y, and z sizes specified by the LocalSizeexecution mode and by the object decorated by the WorkgroupSizedecoration in shader modules must be less than or equal to thecorresponding limit.</para>
/// <para> maxTaskTotalMemorySize is the maximum number of bytes that thetask shader can use in total for shared and output memory combined.</para>
/// <para> maxTaskOutputCount is the maximum number of output tasks a singletask shader workgroup can emit.</para>
/// <para> maxMeshWorkGroupInvocations is the maximum total number of meshshader invocations in a single local workgroup.The product of the X, Y, and Z sizes as specified by the LocalSizeexecution mode in shader modules and by the object decorated by theWorkgroupSize decoration must be less than or equal to this limit.</para>
/// <para> maxMeshWorkGroupSize[3] is the maximum size of a local meshworkgroup.These three values represent the maximum local workgroup size in the X,Y, and Z dimensions, respectively.The x, y, and z sizes specified by the LocalSizeexecution mode and by the object decorated by the WorkgroupSizedecoration in shader modules must be less than or equal to thecorresponding limit.</para>
/// <para> maxMeshTotalMemorySize is the maximum number of bytes that themesh shader can use in total for shared and output memory combined.</para>
/// <para> maxMeshOutputVertices is the maximum number of vertices a meshshader output can store.</para>
/// <para> maxMeshOutputPrimitives is the maximum number of primitives a meshshader output can store.</para>
/// <para> maxMeshMultiviewViewCount is the maximum number of multi-viewviews a mesh shader can use.</para>
/// <para> meshOutputPerVertexGranularity is the granularity with which meshvertex outputs are allocated.The value can be used to compute the memory size used by the meshshader, which must be less than or equal tomaxMeshTotalMemorySize.</para>
/// <para> meshOutputPerPrimitiveGranularity is the granularity with whichmesh outputs qualified as per-primitive are allocated.The value can be used to compute the memory size used by the meshshader, which must be less than or equal tomaxMeshTotalMemorySize.</para>
/// <para>If the VkPhysicalDeviceMeshShaderPropertiesNV structure is included inthe pNext chain of VkPhysicalDeviceProperties2, it is filledwith the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceMeshShaderPropertiesNV {
    public VkStructureType    sType;
    public void*              pNext;
    public UInt32           maxDrawMeshTasksCount;
    public UInt32           maxTaskWorkGroupInvocations;
    public fixed UInt32           maxTaskWorkGroupSize[3];
    public UInt32           maxTaskTotalMemorySize;
    public UInt32           maxTaskOutputCount;
    public UInt32           maxMeshWorkGroupInvocations;
    public fixed UInt32           maxMeshWorkGroupSize[3];
    public UInt32           maxMeshTotalMemorySize;
    public UInt32           maxMeshOutputVertices;
    public UInt32           maxMeshOutputPrimitives;
    public UInt32           maxMeshMultiviewViewCount;
    public UInt32           meshOutputPerVertexGranularity;
    public UInt32           meshOutputPerPrimitiveGranularity;
}
// Struct: 273
/// <summary>VkPhysicalDeviceMultiviewFeatures - Structure describing multiview features that can be supported by an implementation
/// <para>   multiview specifies whether theimplementation supports multiview rendering within a render pass.If this feature is not enabled, the view mask of each subpass mustalways be zero.</para>
/// <para>   multiviewGeometryShader specifieswhether the implementation supports multiview rendering within a renderpass, with geometry shaders.If this feature is not enabled, then a pipeline compiled against asubpass with a non-zero view mask must not include a geometry shader.</para>
/// <para>   multiviewTessellationShader specifieswhether the implementation supports multiview rendering within a renderpass, with tessellation shaders.If this feature is not enabled, then a pipeline compiled against asubpass with a non-zero view mask must not include any tessellationshaders.</para>
/// <para>If the VkPhysicalDeviceMultiviewFeatures structure is included in thepNext chain of VkPhysicalDeviceFeatures2, it is filled withvalues indicating whether each feature is supported.VkPhysicalDeviceMultiviewFeatures can also be used in the pNextchain of VkDeviceCreateInfo to enable the features.</para>
/// <para>  If multiviewGeometryShader is enabled then multiview mustalso be enabled.</para>
/// <para>  If multiviewTessellationShader is enabled then multiview must also be enabled.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES </para>
/// </summary>
public unsafe struct VkPhysicalDeviceMultiviewFeatures {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           multiview;
    public VkBool32           multiviewGeometryShader;
    public VkBool32           multiviewTessellationShader;
}
// Struct: 274
/// <summary>VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX - Structure describing multiview limits that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   perViewPositionAllComponents is VK_TRUE if theimplementation supports per-view position values that differ incomponents other than the X component.</para>
/// <para>If the VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXstructure is included in the pNext chain ofVkPhysicalDeviceProperties2, it is filled with theimplementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX </para>
/// </summary>
public unsafe struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           perViewPositionAllComponents;
}
// Struct: 275
/// <summary>VkPhysicalDeviceMultiviewProperties - Structure describing multiview limits that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   maxMultiviewViewCount is onegreater than the maximum view index that can be used in a subpass.</para>
/// <para>   maxMultiviewInstanceIndex isthe maximum valid value of instance index allowed to be generated by adrawing command recorded within a subpass of a multiview render passinstance.</para>
/// <para>If the VkPhysicalDeviceMultiviewProperties structure is included inthe pNext chain of VkPhysicalDeviceProperties2, it is filledwith the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES </para>
/// </summary>
public unsafe struct VkPhysicalDeviceMultiviewProperties {
    public VkStructureType    sType;
    public void*              pNext;
    public UInt32           maxMultiviewViewCount;
    public UInt32           maxMultiviewInstanceIndex;
}
// Struct: 276
/// <summary>VkPhysicalDevicePCIBusInfoPropertiesEXT - Structure containing PCI bus information of a physical device
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDevicePCIBusInfoPropertiesEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> pciDomain is the PCI bus domain.</summary>
    public UInt32           pciDomain;
    /// <summary> pciBus is the PCI bus identifier.</summary>
    public UInt32           pciBus;
    /// <summary> pciDevice is the PCI device identifier.</summary>
    public UInt32           pciDevice;
    /// <summary> pciFunction is the PCI device function identifier.</summary>
    public UInt32           pciFunction;
}
// Struct: 277
/// <summary>VkPhysicalDevicePointClippingProperties - Structure describing the point clipping behavior supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   pointClippingBehavior is the pointclipping behavior supported by the implementation, and is of typeVkPointClippingBehavior.</para>
/// <para>If the VkPhysicalDevicePointClippingProperties structure is includedin the pNext chain of VkPhysicalDeviceProperties2, it is filledwith the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES </para>
/// </summary>
public unsafe struct VkPhysicalDevicePointClippingProperties {
    public VkStructureType            sType;
    public void*                      pNext;
    public VkPointClippingBehavior    pointClippingBehavior;
}
// Struct: 278
/// <summary>VkPhysicalDeviceProperties - Structure specifying physical device properties
/// <para>The value of apiVersion may be different than the version returned byvkEnumerateInstanceVersion; either higher or lower.In such cases, the application must not use functionality that exceeds theversion of Vulkan associated with a given object.The pApiVersion parameter returned by vkEnumerateInstanceVersionis the version associated with a VkInstance and its children, exceptfor a VkPhysicalDevice and its children.VkPhysicalDeviceProperties::apiVersion is the version associatedwith a VkPhysicalDevice and its children.</para>
/// <para>The vendorID and deviceID fields are provided to allowapplications to adapt to device characteristics that are not adequatelyexposed by other Vulkan queries.</para>
/// <para>These may include performance profiles, hardware errata, or othercharacteristics.</para>
/// <para>The vendor identified by vendorID is the entity responsible for themost salient characteristics of the underlying implementation of theVkPhysicalDevice being queried.</para>
/// <para>For example, in the case of a discrete GPU implementation, this should bethe GPU chipset vendor.In the case of a hardware accelerator integrated into a system-on-chip(SoC), this should be the supplier of the silicon IP used to create theaccelerator.</para>
/// <para>If the vendor has a PCIvendor ID, the low 16 bits of vendorID must contain that PCI vendorID, and the remaining bits must be set to zero.Otherwise, the value returned must be a valid Khronos vendor ID, obtainedas described in the Vulkan Documentation and Extensions:Procedures and Conventions document in the section “Registering a VendorID with Khronos”.Khronos vendor IDs are allocated starting at 0x10000, to distinguish themfrom the PCI vendor ID namespace.Khronos vendor IDs are symbolically defined in the VkVendorId type.</para>
/// <para>The vendor is also responsible for the value returned in deviceID.If the implementation is driven primarily by a PCIdevice with a PCI device ID, the low 16 bits ofdeviceID must contain that PCI device ID, and the remaining bitsmust be set to zero.Otherwise, the choice of what values to return may be dictated by operatingsystem or platform policies - but should uniquely identify both the deviceversion and any major configuration options (for example, core count in thecase of multicore devices).</para>
/// <para>The same device ID should be used for all physical implementations of thatdevice version and configuration.For example, all uses of a specific silicon IP GPU version and configurationshould use the same device ID, even if those uses occur in different SoCs.</para>
/// </summary>
public unsafe struct VkPhysicalDeviceProperties {
    /// <summary> apiVersion is the version of Vulkan supported by the device,
    /// encoded as described in html/vkspec.html#extendingvulkan-coreversions-versionnumbers.</summary>
    public UInt32                            apiVersion;
    /// <summary> driverVersion is the vendor-specified version of the driver.</summary>
    public UInt32                            driverVersion;
    /// <summary> vendorID is a unique identifier for the vendor (see below) of
    /// the physical device.</summary>
    public UInt32                            vendorID;
    /// <summary> deviceID is a unique identifier for the physical device among
    /// devices available from the vendor.</summary>
    public UInt32                            deviceID;
    /// <summary> deviceType is a VkPhysicalDeviceType specifying the type of
    /// device.</summary>
    public VkPhysicalDeviceType                deviceType;
    public fixed char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    public fixed byte                             pipelineCacheUUID[VK_UUID_SIZE];
    /// <summary> limits is the VkPhysicalDeviceLimits structure which
    /// specifies device-specific limits of the physical device.
    /// See Limits for details.</summary>
    public VkPhysicalDeviceLimits              limits;
    /// <summary> sparseProperties is the VkPhysicalDeviceSparseProperties
    /// structure which specifies various sparse related properties of the
    /// physical device.
    /// See Sparse Properties for details.</summary>
    public VkPhysicalDeviceSparseProperties    sparseProperties;
}
// Struct: 279
/// <summary>VkPhysicalDeviceProperties2 - Structure specifying physical device properties
/// <para>The pNext chain of this structure is used to extend the structure withproperties defined by extensions.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkPhysicalDeviceDepthStencilResolvePropertiesKHR, VkPhysicalDeviceDescriptorIndexingPropertiesEXT, VkPhysicalDeviceDiscardRectanglePropertiesEXT, VkPhysicalDeviceDriverPropertiesKHR, VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceFloatControlsPropertiesKHR, VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceIDProperties, VkPhysicalDeviceInlineUniformBlockPropertiesEXT, VkPhysicalDeviceMaintenance3Properties, VkPhysicalDeviceMeshShaderPropertiesNV, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, VkPhysicalDeviceMultiviewProperties, VkPhysicalDevicePCIBusInfoPropertiesEXT, VkPhysicalDevicePointClippingProperties, VkPhysicalDeviceProtectedMemoryProperties, VkPhysicalDevicePushDescriptorPropertiesKHR, VkPhysicalDeviceRayTracingPropertiesNV, VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, VkPhysicalDeviceShaderCorePropertiesAMD, VkPhysicalDeviceShadingRateImagePropertiesNV, VkPhysicalDeviceSubgroupProperties, VkPhysicalDeviceTransformFeedbackPropertiesEXT, or VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// </summary>
public unsafe struct VkPhysicalDeviceProperties2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                         pNext;
    /// <summary> properties is a structure of type VkPhysicalDeviceProperties
    /// describing the properties of the physical device.
    /// This structure is written with the same values as if it were written by
    /// vkGetPhysicalDeviceProperties.</summary>
    public VkPhysicalDeviceProperties    properties;
}
// Struct: 280
/// <summary>VkPhysicalDeviceProtectedMemoryFeatures - Structure describing protected memory features that can be supported by an implementation
/// <para>If the VkPhysicalDeviceProtectedMemoryFeatures structure is includedin the pNext chain of VkPhysicalDeviceFeatures2, it is filledwith a value indicating whether the feature is supported.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES </para>
/// </summary>
public unsafe struct VkPhysicalDeviceProtectedMemoryFeatures {
    public VkStructureType    sType;
    public void*              pNext;
    /// <summary>  
    ///   protectedMemory specifies
    /// whether protected memory is supported.</summary>
    public VkBool32           protectedMemory;
}
// Struct: 281
/// <summary>VkPhysicalDeviceProtectedMemoryProperties - Structure describing protected memory properties that can be supported by an implementation
/// <para>If the VkPhysicalDeviceProtectedMemoryProperties structure is includedin the pNext chain of VkPhysicalDeviceProperties2, it is filledwith a value indicating the implementation-dependent behavior.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES </para>
/// </summary>
public unsafe struct VkPhysicalDeviceProtectedMemoryProperties {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> protectedNoFault specifies the behavior of the implementation when
    /// protected memory access rules are
    /// broken.
    /// If protectedNoFault is VK_TRUE, breaking those rules will
    /// not result in process termination or device loss.</summary>
    public VkBool32           protectedNoFault;
}
// Struct: 282
/// <summary>VkPhysicalDevicePushDescriptorPropertiesKHR - Structure describing push descriptor limits that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   maxPushDescriptors is the maximumnumber of descriptors that can be used in a descriptor set created withVK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set.</para>
/// <para>If the VkPhysicalDevicePushDescriptorPropertiesKHR structure isincluded in the pNext chain of VkPhysicalDeviceProperties2, itis filled with the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR </para>
/// </summary>
public unsafe struct VkPhysicalDevicePushDescriptorPropertiesKHR {
    public VkStructureType    sType;
    public void*              pNext;
    public UInt32           maxPushDescriptors;
}
// Struct: 283
/// <summary>VkPhysicalDeviceRayTracingPropertiesNV - Properties of the physical device for ray tracing
/// <para>If the VkPhysicalDeviceRayTracingPropertiesNV structure is included inthe pNext chain of VkPhysicalDeviceProperties2, it is filledwith the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceRayTracingPropertiesNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> shaderGroupHandleSize size in bytes of the shader header.</summary>
    public UInt32           shaderGroupHandleSize;
    /// <summary> maxRecursionDepth is the maximum number of levels of recursion
    /// allowed in a trace command.</summary>
    public UInt32           maxRecursionDepth;
    /// <summary> maxShaderGroupStride is the maximum stride in bytes allowed
    /// between shader groups in the SBT.</summary>
    public UInt32           maxShaderGroupStride;
    /// <summary> shaderGroupBaseAlignment is the required alignment in bytes for
    /// the base of the SBTs.</summary>
    public UInt32           shaderGroupBaseAlignment;
    /// <summary> maxGeometryCount is the maximum number of geometries in the bottom
    /// level acceleration structure.</summary>
    public UInt64           maxGeometryCount;
    /// <summary> maxInstanceCount is the maximum number of instances in the top
    /// level acceleration structure.</summary>
    public UInt64           maxInstanceCount;
    /// <summary> maxTriangleCount is the maximum number of triangles in all
    /// geometries in the bottom level acceleration structure.</summary>
    public UInt64           maxTriangleCount;
    /// <summary> maxDescriptorSetAccelerationStructures is the maximum number of
    /// acceleration structure descriptors that are allowed in a descriptor set.</summary>
    public UInt32           maxDescriptorSetAccelerationStructures;
}
// Struct: 284
/// <summary>VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV - Structure describing the representative fragment test features that can be supported by an implementation
/// <para>   representativeFragmentTestindicates whether the implementation supports the representativefragment test.See Representative Fragment Test.</para>
/// <para>If the VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structureis included in the pNext chain of VkPhysicalDeviceFeatures2KHR,it is filled with values indicating whether the feature is supported.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV can also be usedin the pNext chain of VkDeviceCreateInfo to enable the feature.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           representativeFragmentTest;
}
// Struct: 285
/// <summary>VkPhysicalDeviceSampleLocationsPropertiesEXT - Structure describing sample location limits that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   sampleLocationSampleCountsis a bitmask of VkSampleCountFlagBits indicating the sample countssupporting custom sample locations.</para>
/// <para>   maxSampleLocationGridSize isthe maximum size of the pixel grid in which sample locations can varythat is supported for all sample counts insampleLocationSampleCounts.</para>
/// <para>   sampleLocationCoordinateRange[2] is the range of supported samplelocation coordinates.</para>
/// <para>   sampleLocationSubPixelBitsis the number of bits of subpixel precision for sample locations.</para>
/// <para>   variableSampleLocationsspecifies whether the sample locations used by all pipelines that willbe bound to a command buffer during a subpass must match.If set to VK_TRUE, the implementation supports variable samplelocations in a subpass.If set to VK_FALSE, then the sample locations must stay constantin each subpass.</para>
/// <para>If the VkPhysicalDeviceSampleLocationsPropertiesEXT structure isincluded in the pNext chain of VkPhysicalDeviceProperties2, itis filled with the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceSampleLocationsPropertiesEXT {
    public VkStructureType       sType;
    public void*                 pNext;
    public VkSampleCountFlags    sampleLocationSampleCounts;
    public VkExtent2D            maxSampleLocationGridSize;
    public fixed float                 sampleLocationCoordinateRange[2];
    public UInt32              sampleLocationSubPixelBits;
    public VkBool32              variableSampleLocations;
}
// Struct: 286
/// <summary>VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT - Structure describing sampler filter minmax limits that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   filterMinmaxSingleComponentFormats is a boolean value indicatingwhether a minimum set of required formats support min/max filtering.</para>
/// <para>   filterMinmaxImageComponentMapping is a boolean value indicatingwhether the implementation supports non-identity component mapping ofthe image when doing min/max filtering.</para>
/// <para>If the VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT structure isincluded in the pNext chain of VkPhysicalDeviceProperties2, itis filled with the implementation-dependent limits.</para>
/// <para>If filterMinmaxSingleComponentFormats is VK_TRUE, the followingformats must support theVK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT feature withVK_IMAGE_TILING_OPTIMAL, if they supportVK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT.</para>
/// <para> VK_FORMAT_R8_UNORM </para>
/// <para> VK_FORMAT_R8_SNORM </para>
/// <para> VK_FORMAT_R16_UNORM </para>
/// <para> VK_FORMAT_R16_SNORM </para>
/// <para> VK_FORMAT_R16_SFLOAT </para>
/// <para> VK_FORMAT_R32_SFLOAT </para>
/// <para> VK_FORMAT_D16_UNORM </para>
/// <para> VK_FORMAT_X8_D24_UNORM_PACK32 </para>
/// <para> VK_FORMAT_D32_SFLOAT </para>
/// <para> VK_FORMAT_D16_UNORM_S8_UINT </para>
/// <para> VK_FORMAT_D24_UNORM_S8_UINT </para>
/// <para> VK_FORMAT_D32_SFLOAT_S8_UINT </para>
/// <para>If the format is a depth/stencil format, this bit only specifies that thedepth aspect (not the stencil aspect) of an image of this format supportsmin/max filtering, and that min/max filtering of the depth aspect issupported when depth compare is disabled in the sampler.</para>
/// <para>If filterMinmaxImageComponentMapping is VK_FALSE the componentmapping of the image view used with min/max filtering must have beencreated with the r component set toVK_COMPONENT_SWIZZLE_IDENTITY.Only the r component of the sampled image value is defined and theother component values are undefined.If filterMinmaxImageComponentMapping is VK_TRUE this restrictiondoes not apply and image component mapping works as normal.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           filterMinmaxSingleComponentFormats;
    public VkBool32           filterMinmaxImageComponentMapping;
}
// Struct: 287
/// <summary>VkPhysicalDeviceSamplerYcbcrConversionFeatures - Structure describing Y’CbCr conversion features that can be supported by an implementation
/// <para>   samplerYcbcrConversionspecifies whether the implementation supportssampler Y’CBCR conversion.If samplerYcbcrConversion is VK_FALSE, sampler Y’CBCRconversion is not supported, and samplers using sampler Y’CBCRconversion must not be used.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES </para>
/// </summary>
public unsafe struct VkPhysicalDeviceSamplerYcbcrConversionFeatures {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           samplerYcbcrConversion;
}
// Struct: 288
/// <summary>VkPhysicalDeviceScalarBlockLayoutFeaturesEXT - Structure indicating support for scalar block layouts
/// <para>   scalarBlockLayout indicates thatthe implementation supports the layout of resource blocks in shadersusing scalar alignment.</para>
/// <para>If the VkPhysicalDeviceScalarBlockLayoutFeaturesEXT structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2KHR, itis filled with values indicating whether the feature is supported.VkPhysicalDeviceScalarBlockLayoutFeaturesEXT can also be used in thepNext chain of VkDeviceCreateInfo to enable this feature.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceScalarBlockLayoutFeaturesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           scalarBlockLayout;
}
// Struct: 289
/// <summary>VkPhysicalDeviceShaderAtomicInt64FeaturesKHR - Structure describing features supported by VK_KHR_shader_atomic_int64
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR </para>
/// </summary>
public unsafe struct VkPhysicalDeviceShaderAtomicInt64FeaturesKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary>  
    ///   shaderBufferInt64Atomics
    /// indicates whether shaders can support 64-bit unsigned and signed
    /// integer atomic operations on buffers.</summary>
    public VkBool32           shaderBufferInt64Atomics;
    /// <summary>  
    ///   shaderSharedInt64Atomics
    /// indicates whether shaders can support 64-bit unsigned and signed
    /// integer atomic operations on shared memory.</summary>
    public VkBool32           shaderSharedInt64Atomics;
}
// Struct: 290
/// <summary>VkPhysicalDeviceShaderCorePropertiesAMD - Structure describing shader core properties that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   shaderEngineCount is an unsignedinteger value indicating the number of shader engines found inside theshader core of the physical device.</para>
/// <para>   shaderArraysPerEngineCountis an unsigned integer value indicating the number of shader arraysinside a shader engine.Each shader array has its own scan converter, set of compute units, anda render back end (color and depth buffers).Shader arrays within a shader engine share shader processor input (wavelauncher) and shader export (export buffer) units.Currently, a shader engine can have one or two shader arrays.</para>
/// <para>   computeUnitsPerShaderArrayis an unsigned integer value indicating the number of compute unitswithin a shader array.A compute unit houses a set of SIMDs along with a sequencer module and alocal data store.</para>
/// <para>   simdPerComputeUnit is an unsignedinteger value indicating the number of SIMDs inside a compute unit.Each SIMD processes a single instruction at a time.</para>
/// <para>   wavefrontSize is an unsigned integervalue indicating the number of channels (or threads) in a wavefront.</para>
/// <para>   sgprsPerSimd is an unsigned integer valueindicating the number of physical Scalar General Purpose Registers(SGPRs) per SIMD.</para>
/// <para>   minSgprAllocation is an unsignedinteger value indicating the minimum number of SGPRs allocated for awave.</para>
/// <para>   maxSgprAllocation is an unsignedinteger value indicating the maximum number of SGPRs allocated for awave.</para>
/// <para>   sgprAllocationGranularity isan unsigned integer value indicating the granularity of SGPR allocationfor a wave.</para>
/// <para>   vgprsPerSimd is an unsigned integer valueindicating the number of physical Vector General Purpose Registers(VGPRs) per SIMD.</para>
/// <para>   minVgprAllocation is an unsignedinteger value indicating the minimum number of VGPRs allocated for awave.</para>
/// <para>   maxVgprAllocation is an unsignedinteger value indicating the maximum number of VGPRs allocated for awave.</para>
/// <para>   vgprAllocationGranularity isan unsigned integer value indicating the granularity of VGPR allocationfor a wave.</para>
/// <para>If the VkPhysicalDeviceShaderCorePropertiesAMD structure is includedin the pNext chain of VkPhysicalDeviceProperties2, it is filledwith the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD </para>
/// </summary>
public unsafe struct VkPhysicalDeviceShaderCorePropertiesAMD {
    public VkStructureType    sType;
    public void*              pNext;
    public UInt32           shaderEngineCount;
    public UInt32           shaderArraysPerEngineCount;
    public UInt32           computeUnitsPerShaderArray;
    public UInt32           simdPerComputeUnit;
    public UInt32           wavefrontsPerSimd;
    public UInt32           wavefrontSize;
    public UInt32           sgprsPerSimd;
    public UInt32           minSgprAllocation;
    public UInt32           maxSgprAllocation;
    public UInt32           sgprAllocationGranularity;
    public UInt32           vgprsPerSimd;
    public UInt32           minVgprAllocation;
    public UInt32           maxVgprAllocation;
    public UInt32           vgprAllocationGranularity;
}
// Struct: 291
/// <summary>VkPhysicalDeviceShaderDrawParametersFeatures - Structure describing shader draw parameter features that can be supported by an implementation
/// <para>If the VkPhysicalDeviceShaderDrawParametersFeatures structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2, it isfilled with a value indicating whether the feature is supported.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES </para>
/// </summary>
public unsafe struct VkPhysicalDeviceShaderDrawParametersFeatures {
    public VkStructureType    sType;
    public void*              pNext;
    /// <summary>  
    ///   shaderDrawParameters specifies
    /// whether shader draw parameters are supported.</summary>
    public VkBool32           shaderDrawParameters;
}
// Struct: 292
/// <summary>VkPhysicalDeviceShaderImageFootprintFeaturesNV - Structure describing shader image footprint features that can be supported by an implementation
/// <para>See Texel Footprint Evaluation for more information.</para>
/// <para>If the VkPhysicalDeviceShaderImageFootprintFeaturesNV structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2KHR, itis filled with values indicating whether each feature is supported.VkPhysicalDeviceShaderImageFootprintFeaturesNV can also be used inthe pNext chain of VkDeviceCreateInfo to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceShaderImageFootprintFeaturesNV {
    public VkStructureType    sType;
    public void*              pNext;
    /// <summary>  
    ///   imageFootprint specifies whether the
    /// implementation supports the ImageFootprintNV SPIR-V capability.</summary>
    public VkBool32           imageFootprint;
}
// Struct: 293
/// <summary>VkPhysicalDeviceShadingRateImageFeaturesNV - Structure describing shading rate image features that can be supported by an implementation
/// <para>   shadingRateImage indicates that theimplementation supports the use of a shading rate image to derive aneffective shading rate for fragment processing.It also indicates that the implementation supports theShadingRateNV SPIR-V execution mode.</para>
/// <para>   shadingRateCoarseSampleOrder indicates that the implementationsupports a user-configurable ordering of coverage samples in fragmentslarger than one pixel.</para>
/// <para>See Shading Rate Image for moreinformation.</para>
/// <para>If the VkPhysicalDeviceShadingRateImageFeaturesNV structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2KHR, itis filled with values indicating whether the feature is supported.VkPhysicalDeviceShadingRateImageFeaturesNV can also be used in thepNext chain of VkDeviceCreateInfo to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceShadingRateImageFeaturesNV {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           shadingRateImage;
    public VkBool32           shadingRateCoarseSampleOrder;
}
// Struct: 294
/// <summary>VkPhysicalDeviceShadingRateImagePropertiesNV - Structure describing shading rate image limits that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   shadingRateTexelSize indicatesthe width and height of the portion of the framebuffer corresponding toeach texel in the shading rate image.</para>
/// <para>   shadingRatePaletteSizeindicates the maximum number of palette entries supported for theshading rate image.</para>
/// <para>   shadingRateMaxCoarseSamples specifies the maximum number ofcoverage samples supported in a single fragment.If the product of the fragment size derived from the base shading rateand the number of coverage samples per pixel exceeds this limit, thefinal shading rate will be adjusted so that its product does not exceedthe limit.</para>
/// <para>If the VkPhysicalDeviceShadingRateImagePropertiesNV structure isincluded in the pNext chain of VkPhysicalDeviceProperties2, itis filled with the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV </para>
/// </summary>
public unsafe struct VkPhysicalDeviceShadingRateImagePropertiesNV {
    public VkStructureType    sType;
    public void*              pNext;
    public VkExtent2D         shadingRateTexelSize;
    public UInt32           shadingRatePaletteSize;
    public UInt32           shadingRateMaxCoarseSamples;
}
// Struct: 295
/// <summary>VkPhysicalDeviceSparseImageFormatInfo2 - Structure specifying sparse image format inputs
/// <para>   samples must be a bit value that is set inVkImageFormatProperties::sampleCounts returned byvkGetPhysicalDeviceImageFormatProperties with format,type, tiling, and usage equal to those in this commandand flags equal to the value that is set inVkImageCreateInfo::flags when the image is created</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 </para>
/// <para>   pNext must be NULL </para>
/// <para>   format must be a valid VkFormat value</para>
/// <para>   type must be a valid VkImageType value</para>
/// <para>   samples must be a valid VkSampleCountFlagBits value</para>
/// <para>   usage must be a valid combination of VkImageUsageFlagBits values</para>
/// <para>   usage must not be 0 </para>
/// <para>   tiling must be a valid VkImageTiling value</para>
/// </summary>
public unsafe struct VkPhysicalDeviceSparseImageFormatInfo2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*              pNext;
    /// <summary> format is the image format.</summary>
    public VkFormat                 format;
    /// <summary> type is the dimensionality of image.</summary>
    public VkImageType              type;
    /// <summary> samples is the number of samples per texel as defined in
    /// VkSampleCountFlagBits.</summary>
    public VkSampleCountFlagBits    samples;
    /// <summary> usage is a bitmask describing the intended usage of the image.</summary>
    public VkImageUsageFlags        usage;
    /// <summary> tiling is the tiling arrangement of the texel blocks in memory.</summary>
    public VkImageTiling            tiling;
}
// Struct: 296
/// <summary>VkPhysicalDeviceSparseProperties - Structure specifying physical device sparse memory properties
/// </summary>
public unsafe struct VkPhysicalDeviceSparseProperties {
    /// <summary> residencyStandard2DBlockShape is VK_TRUE if the physical
    /// device will access all single-sample 2D sparse resources using the
    /// standard sparse image block shapes (based on image format), as described
    /// in the Standard Sparse Image
    /// Block Shapes (Single Sample) table.
    /// If this property is not supported the value returned in the
    /// imageGranularity member of the VkSparseImageFormatProperties
    /// structure for single-sample 2D images is not required to match the
    /// standard sparse image block dimensions listed in the table.</summary>
    public VkBool32    residencyStandard2DBlockShape;
    /// <summary> residencyStandard2DMultisampleBlockShape is VK_TRUE if the
    /// physical device will access all multisample 2D sparse resources using
    /// the standard sparse image block shapes (based on image format), as
    /// described in the Standard Sparse
    /// Image Block Shapes (MSAA) table.
    /// If this property is not supported, the value returned in the
    /// imageGranularity member of the VkSparseImageFormatProperties
    /// structure for multisample 2D images is not required to match the
    /// standard sparse image block dimensions listed in the table.</summary>
    public VkBool32    residencyStandard2DMultisampleBlockShape;
    /// <summary> residencyStandard3DBlockShape is VK_TRUE if the physical
    /// device will access all 3D sparse resources using the standard sparse
    /// image block shapes (based on image format), as described in the
    /// Standard Sparse Image Block
    /// Shapes (Single Sample) table.
    /// If this property is not supported, the value returned in the
    /// imageGranularity member of the VkSparseImageFormatProperties
    /// structure for 3D images is not required to match the standard sparse
    /// image block dimensions listed in the table.</summary>
    public VkBool32    residencyStandard3DBlockShape;
    /// <summary> residencyAlignedMipSize is VK_TRUE if images with mip level
    /// dimensions that are not integer multiples of the corresponding
    /// dimensions of the sparse image block may be placed in the mip tail.
    /// If this property is not reported, only mip levels with dimensions
    /// smaller than the imageGranularity member of the
    /// VkSparseImageFormatProperties structure will be placed in the mip
    /// tail.
    /// If this property is reported the implementation is allowed to return
    /// VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT in the flags
    /// member of VkSparseImageFormatProperties, indicating that mip level
    /// dimensions that are not integer multiples of the corresponding
    /// dimensions of the sparse image block will be placed in the mip tail.</summary>
    public VkBool32    residencyAlignedMipSize;
    /// <summary> residencyNonResidentStrict specifies whether the physical device
    /// can consistently access non-resident regions of a resource.
    /// If this property is VK_TRUE, access to non-resident regions of
    /// resources will be guaranteed to return values as if the resource were
    /// populated with 0; writes to non-resident regions will be discarded.</summary>
    public VkBool32    residencyNonResidentStrict;
}
// Struct: 297
/// <summary>VkPhysicalDeviceSubgroupProperties - Structure describing subgroup support for an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para> subgroupSize is the number of invocations in each subgroup.This will match any  SubgroupSize  decorated variable used in any shader module createdon this device.subgroupSize is at least 1 if any of the physical device’s queuessupport VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT.</para>
/// <para> supportedStages is a bitfield of VkShaderStageFlagBitsdescribing the shader stages that subgroup operations are supported in.supportedStages will have the VK_SHADER_STAGE_COMPUTE_BITbit set if any of the physical device’s queues supportVK_QUEUE_COMPUTE_BIT.</para>
/// <para> supportedOperations is a bitmask ofVkSubgroupFeatureFlagBits specifying the sets of subgroupoperations supported on this device.supportedOperations will have theVK_SUBGROUP_FEATURE_BASIC_BIT bit set if any of the physicaldevice’s queues support VK_QUEUE_GRAPHICS_BIT orVK_QUEUE_COMPUTE_BIT.</para>
/// <para> quadOperationsInAllStages is a boolean that specifies whetherquad subgroup operations are available in allstages, or are restricted to fragment and compute stages.</para>
/// <para>If the VkPhysicalDeviceSubgroupProperties structure is included in thepNext chain of VkPhysicalDeviceProperties2, it is filled withthe implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES </para>
/// </summary>
public unsafe struct VkPhysicalDeviceSubgroupProperties {
    public VkStructureType           sType;
    public void*                     pNext;
    public UInt32                  subgroupSize;
    public VkShaderStageFlags        supportedStages;
    public VkSubgroupFeatureFlags    supportedOperations;
    public VkBool32                  quadOperationsInAllStages;
}
// Struct: 298
/// <summary>VkPhysicalDeviceSurfaceInfo2KHR - Structure specifying a surface and related swapchain creation parameters
/// <para>The members of VkPhysicalDeviceSurfaceInfo2KHR correspond to thearguments to vkGetPhysicalDeviceSurfaceCapabilitiesKHR, withsType and pNext added for extensibility.</para>
/// <para>Additional capabilities of a surface may be available to swapchains createdwith different full-screen exclusive settings - particularly if exclusivefull-screen access is application controlled.These additional capabilities can be queried by including theVkSurfaceFullScreenExclusiveInfoEXT structure in the pNext chainof this structure when used to query surface properties.Additionally, for Win32 surfaces with application controlled exclusivefull-screen access, chaining a valid instance of theVkSurfaceFullScreenExclusiveWin32InfoEXT structure may also reportadditional surface capabilities.These additional capabilities only apply to swapchains created with the sameparameters passed into the pNext chain ofVkSwapchainCreateInfoKHR.</para>
/// <para>  If the pNext chain includes an instance ofVkSurfaceFullScreenExclusiveInfoEXT with itsfullScreenExclusive member set toVK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, andsurface was created using vkCreateWin32SurfaceKHR, aninstance of VkSurfaceFullScreenExclusiveWin32InfoEXT must bepresent in the pNext chain</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkSurfaceFullScreenExclusiveInfoEXT or VkSurfaceFullScreenExclusiveWin32InfoEXT </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   surface must be a valid VkSurfaceKHR handle</para>
/// </summary>
public unsafe struct VkPhysicalDeviceSurfaceInfo2KHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> surface is the surface that will be associated with the swapchain.</summary>
    public VkSurfaceKHR       surface;
}
// Struct: 299
/// <summary>VkPhysicalDeviceTransformFeedbackFeaturesEXT - Structure describing transform feedback features that can be supported by an implementation
/// <para>   transformFeedback indicates whetherthe implementation supports transform feedback and shader modules candeclare the TransformFeedback capability.</para>
/// <para>   geometryStreams indicates whether theimplementation supports the GeometryStreams SPIR-V capability.</para>
/// <para>If the VkPhysicalDeviceTransformFeedbackFeaturesEXT structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2KHR, itis filled with values indicating whether each feature is supported.VkPhysicalDeviceTransformFeedbackFeaturesEXT can also be used in thepNext chain of VkDeviceCreateInfo to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceTransformFeedbackFeaturesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           transformFeedback;
    public VkBool32           geometryStreams;
}
// Struct: 300
/// <summary>VkPhysicalDeviceTransformFeedbackPropertiesEXT - Structure describing transform feedback properties that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   maxTransformFeedbackStreamsis the maximum number of vertex streams that can be output from geometryshaders declared with the GeometryStreams capability.If the implementation does not supportVkPhysicalDeviceTransformFeedbackFeaturesEXT::geometryStreamsthen maxTransformFeedbackStreams must be set to 1.</para>
/// <para>   maxTransformFeedbackBuffersis the maximum number of transform feedback buffers that can be boundfor capturing shader outputs from the last vertex processing stage.</para>
/// <para>   maxTransformFeedbackBufferSize is the maximum size that can bespecified when binding a buffer for transform feedback invkCmdBindTransformFeedbackBuffersEXT.</para>
/// <para>   maxTransformFeedbackStreamDataSize is the maximum amount of datain bytes for each vertex that captured to one or more transform feedbackbuffers associated with a specific vertex stream.</para>
/// <para>   maxTransformFeedbackBufferDataSize is the maximum amount of datain bytes for each vertex that can be captured to a specific transformfeedback buffer.</para>
/// <para>   maxTransformFeedbackBufferDataStride is the maximum stride betweeneach capture of vertex data to the buffer.</para>
/// <para>   transformFeedbackQueries istrue if the implementation supports theVK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT query type.transformFeedbackQueries is false if queries of this type cannotbe created.</para>
/// <para>   transformFeedbackStreamsLinesTriangles is true if theimplementation supports the geometry shader OpExecutionMode ofOutputLineStrip and OutputTriangleStrip in addition toOutputPoints when more than one vertex stream is output.If transformFeedbackStreamsLinesTriangles is false theimplementation only supports an OpExecutionMode ofOutputPoints when more than one vertex stream is output from thegeometry shader.</para>
/// <para>   transformFeedbackRasterizationStreamSelect is true if theimplementation supports the GeometryStreams SPIR-V capability andthe application can useVkPipelineRasterizationStateStreamCreateInfoEXT to modify whichvertex stream output is used for rasterization.Otherwise vertex stream 0 must always be used for rasterization.</para>
/// <para>   transformFeedbackDraw is true ifthe implementation supports the vkCmdDrawIndirectByteCountEXTfunction otherwise the function must not be called.</para>
/// <para>If the VkPhysicalDeviceTransformFeedbackPropertiesEXT structure isincluded in the pNext chain of VkPhysicalDeviceProperties2, itis filled with the implementation-dependent limits and properties.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceTransformFeedbackPropertiesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public UInt32           maxTransformFeedbackStreams;
    public UInt32           maxTransformFeedbackBuffers;
    public VkDeviceSize       maxTransformFeedbackBufferSize;
    public UInt32           maxTransformFeedbackStreamDataSize;
    public UInt32           maxTransformFeedbackBufferDataSize;
    public UInt32           maxTransformFeedbackBufferDataStride;
    public VkBool32           transformFeedbackQueries;
    public VkBool32           transformFeedbackStreamsLinesTriangles;
    public VkBool32           transformFeedbackRasterizationStreamSelect;
    public VkBool32           transformFeedbackDraw;
}
// Struct: 301
/// <summary>VkPhysicalDeviceVariablePointersFeatures - Structure describing variable pointers features that can be supported by an implementation
/// <para>   variablePointersStorageBuffer specifies whether the implementationsupports the SPIR-V VariablePointersStorageBuffer capability.When this feature is not enabled, shader modules must not declare theSPV_KHR_variable_pointers extension or theVariablePointersStorageBuffer capability.</para>
/// <para>   variablePointers specifies whetherthe implementation supports the SPIR-V VariablePointers capability.When this feature is not enabled, shader modules must not declare theVariablePointers capability.</para>
/// <para>If the VkPhysicalDeviceVariablePointersFeatures structure is includedin the pNext chain of VkPhysicalDeviceFeatures2, it is filledwith values indicating whether each feature is supported.VkPhysicalDeviceVariablePointersFeatures can also be used in thepNext chain of VkDeviceCreateInfo to enable the features.</para>
/// <para>  If variablePointers is enabled thenvariablePointersStorageBuffer must also be enabled.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES </para>
/// </summary>
public unsafe struct VkPhysicalDeviceVariablePointersFeatures {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           variablePointersStorageBuffer;
    public VkBool32           variablePointers;
}
// Struct: 302
/// <summary>VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT - Structure describing if fetching of vertex attribute may be repeated for instanced rendering
/// <para>If the VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2, it isfilled with values indicating the implementation-dependent behavior.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT can also be used inpNext chain of VkDeviceCreateInfo to enable the feature.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary>  
    ///   vertexAttributeInstanceRateDivisor specifies whether vertex
    /// attribute fetching may be repeated in case of instanced rendering.</summary>
    public VkBool32           vertexAttributeInstanceRateDivisor;
    /// <summary>  
    ///   vertexAttributeInstanceRateZeroDivisor specifies whether a zero
    /// value for VkVertexInputBindingDivisorDescriptionEXT::divisor
    /// is supported.</summary>
    public VkBool32           vertexAttributeInstanceRateZeroDivisor;
}
// Struct: 303
/// <summary>VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT - Structure describing max value of vertex attribute divisor that can be supported by an implementation
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para>   maxVertexAttribDivisor is themaximum value of the number of instances that will repeat the value ofvertex attribute data when instanced rendering is enabled.</para>
/// <para>If the VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structureis included in the pNext chain of VkPhysicalDeviceProperties2,it is filled with the implementation-dependent limits.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public UInt32           maxVertexAttribDivisor;
}
// Struct: 304
/// <summary>VkPhysicalDeviceVulkanMemoryModelFeaturesKHR - Structure describing features supported by VK_KHR_vulkan_memory_model
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR </para>
/// </summary>
public unsafe struct VkPhysicalDeviceVulkanMemoryModelFeaturesKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary>  
    ///   vulkanMemoryModel indicates whether
    /// the Vulkan Memory Model is supported, as defined in
    /// Vulkan Memory Model.
    /// This also indicates whether shader modules can declare the
    /// VulkanMemoryModelKHR capability.</summary>
    public VkBool32           vulkanMemoryModel;
    /// <summary>  
    ///   vulkanMemoryModelDeviceScope indicates whether the Vulkan Memory
    /// Model can use Device scope synchronization.
    /// This also indicates whether shader modules can declare the
    /// VulkanMemoryModelDeviceScopeKHR capability.</summary>
    public VkBool32           vulkanMemoryModelDeviceScope;
    /// <summary>  
    ///   vulkanMemoryModelAvailabilityVisibilityChains indicates whether
    /// the Vulkan Memory Model can use availability and visibility chains with more than one element.</summary>
    public VkBool32           vulkanMemoryModelAvailabilityVisibilityChains;
}
// Struct: 305
/// <summary>VkPhysicalDeviceYcbcrImageArraysFeaturesEXT - Structure describing extended Y
/// <para>   ycbcrImageArrays indicates that theimplementation supports creating images with a format that requiresY’CBCR conversionand has multiple array layers.</para>
/// <para>If the VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure isincluded in the pNext chain of VkPhysicalDeviceFeatures2KHR, itis filled with values indicating whether the feature is supported.VkPhysicalDeviceYcbcrImageArraysFeaturesEXT can also be used in thepNext chain of VkDeviceCreateInfo to enable features.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT </para>
/// </summary>
public unsafe struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
    public VkStructureType    sType;
    public void*              pNext;
    public VkBool32           ycbcrImageArrays;
}
// Struct: 306
/// <summary>VkPipelineCacheCreateInfo - Structure specifying parameters of a newly created pipeline cache
/// <para>  If initialDataSize is not 0, it must be equal to the size ofpInitialData, as returned by vkGetPipelineCacheData whenpInitialData was originally retrieved</para>
/// <para>  If initialDataSize is not 0, pInitialData must have beenretrieved from a previous call to vkGetPipelineCacheData </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   If initialDataSize is not 0, pInitialData must be a valid pointer to an array of initialDataSize bytes</para>
/// </summary>
public unsafe struct VkPipelineCacheCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                   pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineCacheCreateFlags    flags;
    /// <summary> initialDataSize is the number of bytes in pInitialData.
    /// If initialDataSize is zero, the pipeline cache will initially be
    /// empty.</summary>
    public size_t                        initialDataSize;
    /// <summary> pInitialData is a pointer to previously retrieved pipeline cache
    /// data.
    /// If the pipeline cache data is incompatible (as defined below) with the
    /// device, the pipeline cache will be initially empty.
    /// If initialDataSize is zero, pInitialData is ignored.</summary>
    public /* const */ void*                   pInitialData;
}
// Struct: 307
/// <summary>VkPipelineColorBlendAdvancedStateCreateInfoEXT - Structure specifying parameters that affect advanced blend operations
/// <para>If this structure is not present, srcPremultiplied anddstPremultiplied are both considered to be VK_TRUE, andblendOverlap is considered to beVK_BLEND_OVERLAP_UNCORRELATED_EXT.</para>
/// <para>  If the non-premultipliedsource color property is not supported, srcPremultiplied mustbe VK_TRUE </para>
/// <para>  If the non-premultiplieddestination color property is not supported, dstPremultiplied must be VK_TRUE </para>
/// <para>  If the correlated overlapproperty is not supported, blendOverlap must beVK_BLEND_OVERLAP_UNCORRELATED_EXT </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT </para>
/// <para>   blendOverlap must be a valid VkBlendOverlapEXT value</para>
/// </summary>
public unsafe struct VkPipelineColorBlendAdvancedStateCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*          pNext;
    /// <summary> srcPremultiplied specifies whether the source color of the blend
    /// operation is treated as premultiplied.</summary>
    public VkBool32             srcPremultiplied;
    /// <summary> dstPremultiplied specifies whether the destination color of the
    /// blend operation is treated as premultiplied.</summary>
    public VkBool32             dstPremultiplied;
    /// <summary> blendOverlap is a VkBlendOverlapEXT value specifying how the
    /// source and destination sample’s coverage is correlated.</summary>
    public VkBlendOverlapEXT    blendOverlap;
}
// Struct: 308
/// <summary>VkPipelineColorBlendAttachmentState - Structure specifying a pipeline color blend attachment state
/// <para>  If the dual source blending feature is notenabled, srcColorBlendFactor must not beVK_BLEND_FACTOR_SRC1_COLOR,VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,VK_BLEND_FACTOR_SRC1_ALPHA, orVK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA </para>
/// <para>  If the dual source blending feature is notenabled, dstColorBlendFactor must not beVK_BLEND_FACTOR_SRC1_COLOR,VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,VK_BLEND_FACTOR_SRC1_ALPHA, orVK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA </para>
/// <para>  If the dual source blending feature is notenabled, srcAlphaBlendFactor must not beVK_BLEND_FACTOR_SRC1_COLOR,VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,VK_BLEND_FACTOR_SRC1_ALPHA, orVK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA </para>
/// <para>  If the dual source blending feature is notenabled, dstAlphaBlendFactor must not beVK_BLEND_FACTOR_SRC1_COLOR,VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,VK_BLEND_FACTOR_SRC1_ALPHA, orVK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA </para>
/// <para>  If either of colorBlendOp or alphaBlendOp is anadvanced blend operation, thencolorBlendOp must equal alphaBlendOp </para>
/// <para>  IfVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendIndependentBlendis VK_FALSE and colorBlendOp is anadvanced blend operation, thencolorBlendOp must be the same for all attachments.</para>
/// <para>  IfVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendIndependentBlendis VK_FALSE and alphaBlendOp is anadvanced blend operation, thenalphaBlendOp must be the same for all attachments.</para>
/// <para>  IfVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendAllOperationsis VK_FALSE, then colorBlendOp must not beVK_BLEND_OP_ZERO_EXT, VK_BLEND_OP_SRC_EXT,VK_BLEND_OP_DST_EXT, VK_BLEND_OP_SRC_OVER_EXT,VK_BLEND_OP_DST_OVER_EXT, VK_BLEND_OP_SRC_IN_EXT,VK_BLEND_OP_DST_IN_EXT, VK_BLEND_OP_SRC_OUT_EXT,VK_BLEND_OP_DST_OUT_EXT, VK_BLEND_OP_SRC_ATOP_EXT,VK_BLEND_OP_DST_ATOP_EXT, VK_BLEND_OP_XOR_EXT,VK_BLEND_OP_INVERT_EXT, VK_BLEND_OP_INVERT_RGB_EXT,VK_BLEND_OP_LINEARDODGE_EXT, VK_BLEND_OP_LINEARBURN_EXT,VK_BLEND_OP_VIVIDLIGHT_EXT, VK_BLEND_OP_LINEARLIGHT_EXT,VK_BLEND_OP_PINLIGHT_EXT, VK_BLEND_OP_HARDMIX_EXT,VK_BLEND_OP_PLUS_EXT, VK_BLEND_OP_PLUS_CLAMPED_EXT,VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT,VK_BLEND_OP_PLUS_DARKER_EXT, VK_BLEND_OP_MINUS_EXT,VK_BLEND_OP_MINUS_CLAMPED_EXT, VK_BLEND_OP_CONTRAST_EXT,VK_BLEND_OP_INVERT_OVG_EXT, VK_BLEND_OP_RED_EXT,VK_BLEND_OP_GREEN_EXT, or VK_BLEND_OP_BLUE_EXT </para>
/// <para>  If colorBlendOp or alphaBlendOp is anadvanced blend operation, thenVkSubpassDescription::colorAttachmentCount of the subpassthis pipeline is compiled against must be less than or equal toVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendMaxColorAttachments</para>
/// <para>   srcColorBlendFactor must be a valid VkBlendFactor value</para>
/// <para>   dstColorBlendFactor must be a valid VkBlendFactor value</para>
/// <para>   colorBlendOp must be a valid VkBlendOp value</para>
/// <para>   srcAlphaBlendFactor must be a valid VkBlendFactor value</para>
/// <para>   dstAlphaBlendFactor must be a valid VkBlendFactor value</para>
/// <para>   alphaBlendOp must be a valid VkBlendOp value</para>
/// <para>   colorWriteMask must be a valid combination of VkColorComponentFlagBits values</para>
/// </summary>
public unsafe struct VkPipelineColorBlendAttachmentState {
    /// <summary> blendEnable controls whether blending is enabled for the
    /// corresponding color attachment.
    /// If blending is not enabled, the source fragment’s color for that
    /// attachment is passed through unmodified.</summary>
    public VkBool32                 blendEnable;
    /// <summary> srcColorBlendFactor selects which blend factor is used to
    /// determine the source factors (Sr,Sg,Sb).</summary>
    public VkBlendFactor            srcColorBlendFactor;
    /// <summary> dstColorBlendFactor selects which blend factor is used to
    /// determine the destination factors (Dr,Dg,Db).</summary>
    public VkBlendFactor            dstColorBlendFactor;
    /// <summary> colorBlendOp selects which blend operation is used to calculate
    /// the RGB values to write to the color attachment.</summary>
    public VkBlendOp                colorBlendOp;
    /// <summary> srcAlphaBlendFactor selects which blend factor is used to
    /// determine the source factor Sa .</summary>
    public VkBlendFactor            srcAlphaBlendFactor;
    /// <summary> dstAlphaBlendFactor selects which blend factor is used to
    /// determine the destination factor Da .</summary>
    public VkBlendFactor            dstAlphaBlendFactor;
    /// <summary> alphaBlendOp selects which blend operation is use to calculate the
    /// alpha values to write to the color attachment.</summary>
    public VkBlendOp                alphaBlendOp;
    /// <summary> colorWriteMask is a bitmask of VkColorComponentFlagBits
    /// specifying which of the R, G, B, and/or A components are enabled for
    /// writing, as described for the Color Write
    /// Mask.</summary>
    public VkColorComponentFlags    colorWriteMask;
}
// Struct: 309
/// <summary>VkPipelineColorBlendStateCreateInfo - Structure specifying parameters of a newly created pipeline color blend state
/// <para>Each element of the pAttachments array is aVkPipelineColorBlendAttachmentState structure specifying per-targetblending state for each individual color attachment.If the independent blending feature is notenabled on the device, all VkPipelineColorBlendAttachmentStateelements in the pAttachments array must be identical.</para>
/// <para>  If the independent blending feature is notenabled, all elements of pAttachments must be identical</para>
/// <para>  If the logic operations feature is not enabled,logicOpEnable must be VK_FALSE </para>
/// <para>  If logicOpEnable is VK_TRUE, logicOp must be a validVkLogicOp value</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkPipelineColorBlendAdvancedStateCreateInfoEXT </para>
/// <para>   flags must be 0 </para>
/// <para>   If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkPipelineColorBlendAttachmentState structures</para>
/// </summary>
public unsafe struct VkPipelineColorBlendStateCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                   pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineColorBlendStateCreateFlags          flags;
    /// <summary> logicOpEnable controls whether to apply Logical Operations.</summary>
    public VkBool32                                      logicOpEnable;
    /// <summary> logicOp selects which logical operation to apply.</summary>
    public VkLogicOp                                     logicOp;
    /// <summary> attachmentCount is the number of
    /// VkPipelineColorBlendAttachmentState elements in
    /// pAttachments.
    /// This value must equal the colorAttachmentCount for the subpass in
    /// which this pipeline is used.</summary>
    public UInt32                                      attachmentCount;
    /// <summary> pAttachments: is a pointer to array of per target attachment
    /// states.</summary>
    public /* const */ VkPipelineColorBlendAttachmentState*    pAttachments;
    public fixed float                                         blendConstants[4];
}
// Struct: 310
/// <summary>VkPipelineCoverageModulationStateCreateInfoNV - Structure specifying parameters controlling coverage modulation
/// <para>If coverageModulationTableEnable is VK_FALSE, then for eachcolor sample the associated bits of the fragment’s coverage are counted anddivided by the number of associated bits to produce a modulation factorR in the range (0,1] (a value of zero would have been killed dueto a color coverage of 0).Specifically:</para>
/// <para> N = value of rasterizationSamples </para>
/// <para> M = value of VkAttachmentDescription::samples for anycolor attachments</para>
/// <para> R = popcount(associated coverage bits) / (N / M) </para>
/// <para>If coverageModulationTableEnable is VK_TRUE, the value Ris computed using a programmable lookup table.The lookup table has N / M elements, and the element of the table isselected by:</para>
/// <para> R = pCoverageModulationTable[popcount(associated coveragebits)-1] </para>
/// <para>Note that the table does not have an entry for popcount(associatedcoverage bits) = 0, because such samples would have been killed.</para>
/// <para>The values of pCoverageModulationTable may be rounded to animplementation-dependent precision, which is at least as fine as 1 /N, and clamped to [0,1].</para>
/// <para>For each color attachment with a floating point or normalized color format,each fragment output color value is replicated to M values which caneach be modulated (multiplied) by that color sample’s associated value ofR.Which components are modulated is controlled bycoverageModulationMode.</para>
/// <para>If this structure is not present, it is as if coverageModulationModeis VK_COVERAGE_MODULATION_MODE_NONE_NV.</para>
/// <para>  If coverageModulationTableEnable is VK_TRUE,coverageModulationTableCount must be equal to the number ofrasterization samples divided by the number of color samples in thesubpass.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV </para>
/// <para>   flags must be 0 </para>
/// <para>   coverageModulationMode must be a valid VkCoverageModulationModeNV value</para>
/// </summary>
public unsafe struct VkPipelineCoverageModulationStateCreateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                                   sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                       pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineCoverageModulationStateCreateFlagsNV    flags;
    /// <summary> coverageModulationMode controls which color components are
    /// modulated and is of type VkCoverageModulationModeNV.</summary>
    public VkCoverageModulationModeNV                        coverageModulationMode;
    /// <summary> coverageModulationTableEnable controls whether the modulation
    /// factor is looked up from a table in pCoverageModulationTable.</summary>
    public VkBool32                                          coverageModulationTableEnable;
    /// <summary> coverageModulationTableCount is the number of elements in
    /// pCoverageModulationTable.</summary>
    public UInt32                                          coverageModulationTableCount;
    /// <summary> pCoverageModulationTable is a table of modulation factors
    /// containing a value for each number of covered samples.</summary>
    public /* const */ float*                                      pCoverageModulationTable;
}
// Struct: 311
/// <summary>VkPipelineCoverageToColorStateCreateInfoNV - Structure specifying whether fragment coverage replaces a color
/// <para>If coverageToColorEnable is VK_TRUE, the fragment coverageinformation is treated as a bitmask with one bit for each sample (as in theSample Mask section), and this bitmask replaces thefirst component of the color value corresponding to the fragment shaderoutput location with Location equal to coverageToColorLocationand Index equal to zero.If the color attachment format has fewer bits than the sample coverage, thelow bits of the sample coverage bitmask are taken without any clamping.If the color attachment format has more bits than the sample coverage, thehigh bits of the sample coverage bitmask are filled with zeros.</para>
/// <para>If Sample Shading is in use, the coveragebitmask only has bits set for samples that correspond to the fragment shaderinvocation that shades those samples.</para>
/// <para>This pipeline stage occurs after sample counting and before blending, and isalways performed after fragment shading regardless of the setting ofEarlyFragmentTests.</para>
/// <para>If coverageToColorEnable is VK_FALSE, these operations areskipped.If this structure is not present, it is as if coverageToColorEnable isVK_FALSE.</para>
/// <para>  If coverageToColorEnable is VK_TRUE, then the render passsubpass indicated byVkGraphicsPipelineCreateInfo::renderPass andVkGraphicsPipelineCreateInfo::subpass must have a colorattachment at the location selected by coverageToColorLocation,with a VkFormat of VK_FORMAT_R8_UINT,VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT,VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, orVK_FORMAT_R32_SINT </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkPipelineCoverageToColorStateCreateInfoNV {
    /// <summary> sType is the type of this structure</summary>
    public VkStructureType                                sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure</summary>
    public /* const */ void*                                    pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineCoverageToColorStateCreateFlagsNV    flags;
    /// <summary> coverageToColorEnable controls whether the fragment coverage value
    /// replaces a fragment color output.</summary>
    public VkBool32                                       coverageToColorEnable;
    /// <summary> coverageToColorLocation controls which fragment shader color
    /// output value is replaced.</summary>
    public UInt32                                       coverageToColorLocation;
}
// Struct: 312
/// <summary>VkPipelineCreationFeedbackCreateInfoEXT - Request for feedback about the creation of a pipeline
/// <para>An implementation should write pipeline creation feedback topPipelineCreationFeedback and may write pipeline stage creationfeedback to pPipelineStageCreationFeedbacks.An implementation must set or clear theVK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT inVkPipelineCreationFeedbackEXT::flags forpPipelineCreationFeedback and every element ofpPipelineStageCreationFeedbacks.</para>
/// <para>One common scenario for an implementation to skip per-stage feedback is whenVK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXTis set in pPipelineCreationFeedback.</para>
/// <para>When chained toVkRayTracingPipelineCreateInfoNV orVkGraphicsPipelineCreateInfo, the i element ofpPipelineStageCreationFeedbacks corresponds to the i element ofVkRayTracingPipelineCreateInfoNV::pStages orVkGraphicsPipelineCreateInfo::pStages.When chained to VkComputePipelineCreateInfo, the first element ofpPipelineStageCreationFeedbacks corresponds toVkComputePipelineCreateInfo::stage.</para>
/// <para>  When chained to VkGraphicsPipelineCreateInfo,VkPipelineCreationFeedbackEXT::pipelineStageCreationFeedbackCount must equal VkGraphicsPipelineCreateInfo::stageCount </para>
/// <para>  When chained to VkComputePipelineCreateInfo,VkPipelineCreationFeedbackEXT::pipelineStageCreationFeedbackCount must equal 1</para>
/// <para>  When chained to VkRayTracingPipelineCreateInfoNV,VkPipelineCreationFeedbackEXT::pipelineStageCreationFeedbackCount must equal VkRayTracingPipelineCreateInfoNV::stageCount </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT </para>
/// <para>   pPipelineCreationFeedback must be a valid pointer to a VkPipelineCreationFeedbackEXT structure</para>
/// <para>   pPipelineStageCreationFeedbacks must be a valid pointer to an array of pipelineStageCreationFeedbackCount VkPipelineCreationFeedbackEXT structures</para>
/// <para>   pipelineStageCreationFeedbackCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkPipelineCreationFeedbackCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                   sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                       pNext;
    /// <summary> pPipelineCreationFeedback is a pointer to a
    /// VkPipelineCreationFeedbackEXT structure.</summary>
    public VkPipelineCreationFeedbackEXT*    pPipelineCreationFeedback;
    /// <summary> pipelineStageCreationFeedbackCount is the number of elements in
    /// pPipelineStageCreationFeedbacks.</summary>
    public UInt32                          pipelineStageCreationFeedbackCount;
    /// <summary> pPipelineStageCreationFeedbacks is an array of size
    /// pipelineStageCreationFeedbackCount of
    /// VkPipelineCreationFeedbackEXT structures.</summary>
    public VkPipelineCreationFeedbackEXT*    pPipelineStageCreationFeedbacks;
}
// Struct: 313
/// <summary>VkPipelineCreationFeedbackEXT - Feedback about the creation of a pipeline or pipeline stage
/// <para>If the VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT is not set inflags, an implementation must not set any other bits in flags,and all other VkPipelineCreationFeedbackEXT data members areundefined.</para>
/// </summary>
public unsafe struct VkPipelineCreationFeedbackEXT {
    /// <summary> flags is a bitmask of VkPipelineCreationFeedbackFlagBitsEXT
    /// providing feedback about the creation of a pipeline or of a pipeline
    /// stage.</summary>
    public VkPipelineCreationFeedbackFlagsEXT    flags;
    /// <summary> duration is the duration spent creating a pipeline or pipeline
    /// stage in nanoseconds.</summary>
    public UInt64                              duration;
}
// Struct: 314
/// <summary>VkPipelineDepthStencilStateCreateInfo - Structure specifying parameters of a newly created pipeline depth stencil state
/// <para>  If the depth bounds testing feature is notenabled, depthBoundsTestEnable must be VK_FALSE </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   depthCompareOp must be a valid VkCompareOp value</para>
/// <para>   front must be a valid VkStencilOpState structure</para>
/// <para>   back must be a valid VkStencilOpState structure</para>
/// </summary>
public unsafe struct VkPipelineDepthStencilStateCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                           sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                               pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineDepthStencilStateCreateFlags    flags;
    /// <summary> depthTestEnable controls whether depth testing
    /// is enabled.</summary>
    public VkBool32                                  depthTestEnable;
    /// <summary> depthWriteEnable controls whether depth
    /// writes are enabled when depthTestEnable is VK_TRUE.
    /// Depth writes are always disabled when depthTestEnable is
    /// VK_FALSE.</summary>
    public VkBool32                                  depthWriteEnable;
    /// <summary> depthCompareOp is the comparison operator used in the
    /// depth test.</summary>
    public VkCompareOp                               depthCompareOp;
    /// <summary> depthBoundsTestEnable controls whether depth bounds
    /// testing is enabled.</summary>
    public VkBool32                                  depthBoundsTestEnable;
    /// <summary> stencilTestEnable controls whether stencil
    /// testing is enabled.</summary>
    public VkBool32                                  stencilTestEnable;
    /// <summary> front and back control the parameters of the
    /// stencil test.</summary>
    public VkStencilOpState                          front;
    public VkStencilOpState                          back;
    /// <summary> minDepthBounds and maxDepthBounds define the range of values
    /// used in the depth bounds test.</summary>
    public float                                     minDepthBounds;
    public float                                     maxDepthBounds;
}
// Struct: 315
/// <summary>VkPipelineDiscardRectangleStateCreateInfoEXT - Structure specifying discard rectangle
/// <para>   discardRectangleCount must be between 0 andVkPhysicalDeviceDiscardRectanglePropertiesEXT::maxDiscardRectangles,inclusive</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT </para>
/// <para>   flags must be 0 </para>
/// <para>   discardRectangleMode must be a valid VkDiscardRectangleModeEXT value</para>
/// </summary>
public unsafe struct VkPipelineDiscardRectangleStateCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                                  sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                      pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineDiscardRectangleStateCreateFlagsEXT    flags;
    /// <summary> discardRectangleMode is the mode used to determine whether
    /// fragments that lie within the discard rectangle are discarded or not.</summary>
    public VkDiscardRectangleModeEXT                        discardRectangleMode;
    /// <summary> discardRectangleCount is the number of discard rectangles used by
    /// the pipeline.</summary>
    public UInt32                                         discardRectangleCount;
    /// <summary> pDiscardRectangles is a pointer to an array of VkRect2D
    /// structures, defining the discard rectangles.
    /// If the discard rectangle state is dynamic, this member is ignored.</summary>
    public /* const */ VkRect2D*                                  pDiscardRectangles;
}
// Struct: 316
/// <summary>VkPipelineDynamicStateCreateInfo - Structure specifying parameters of a newly created pipeline dynamic state
/// <para>  Each element of pDynamicStates must be unique</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   If dynamicStateCount is not 0, pDynamicStates must be a valid pointer to an array of dynamicStateCount valid VkDynamicState values</para>
/// </summary>
public unsafe struct VkPipelineDynamicStateCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                          pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineDynamicStateCreateFlags    flags;
    /// <summary> dynamicStateCount is the number of elements in the
    /// pDynamicStates array.</summary>
    public UInt32                             dynamicStateCount;
    /// <summary> pDynamicStates is an array of VkDynamicState values
    /// specifying which pieces of pipeline state will use the values from
    /// dynamic state commands rather than from pipeline state creation info.</summary>
    public /* const */ VkDynamicState*                pDynamicStates;
}
// Struct: 317
/// <summary>VkPipelineInputAssemblyStateCreateInfo - Structure specifying parameters of a newly created pipeline input assembly state
/// <para>Restarting the assembly of primitives discards the most recent index valuesif those elements formed an incomplete primitive, and restarts the primitiveassembly using the subsequent indices, but only assembling the immediatelyfollowing element through the end of the originally specified elements.The primitive restart index value comparison is performed before adding thevertexOffset value to the index value.</para>
/// <para>  If topology is VK_PRIMITIVE_TOPOLOGY_POINT_LIST,VK_PRIMITIVE_TOPOLOGY_LINE_LIST,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY orVK_PRIMITIVE_TOPOLOGY_PATCH_LIST, primitiveRestartEnable must be VK_FALSE </para>
/// <para>  If the geometry shaders feature is notenabled, topology must not be any ofVK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY orVK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY </para>
/// <para>  If the tessellation shaders feature isnot enabled, topology must not beVK_PRIMITIVE_TOPOLOGY_PATCH_LIST </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   topology must be a valid VkPrimitiveTopology value</para>
/// </summary>
public unsafe struct VkPipelineInputAssemblyStateCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineInputAssemblyStateCreateFlags    flags;
    /// <summary> topology is a VkPrimitiveTopology defining the primitive
    /// topology, as described below.</summary>
    public VkPrimitiveTopology                        topology;
    /// <summary> primitiveRestartEnable controls whether a special vertex index
    /// value is treated as restarting the assembly of primitives.
    /// This enable only applies to indexed draws (vkCmdDrawIndexed and
    /// vkCmdDrawIndexedIndirect), and the special index value is either
    /// 0xFFFFFFFF when the indexType parameter of
    /// vkCmdBindIndexBuffer is equal to VK_INDEX_TYPE_UINT32, or
    /// 0xFFFF when indexType is equal to VK_INDEX_TYPE_UINT16.
    /// Primitive restart is not allowed for “list” topologies.</summary>
    public VkBool32                                   primitiveRestartEnable;
}
// Struct: 318
/// <summary>VkPipelineLayoutCreateInfo - Structure specifying the parameters of a newly created pipeline layout object
/// <para>   setLayoutCount must be less than or equal toVkPhysicalDeviceLimits::maxBoundDescriptorSets </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER andVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any givenshader stage across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceLimits::maxPerStageDescriptorSamplers </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType ofVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER andVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any givenshader stage across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceLimits::maxPerStageDescriptorUniformBuffers </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType ofVK_DESCRIPTOR_TYPE_STORAGE_BUFFER andVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any givenshader stage across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceLimits::maxPerStageDescriptorStorageBuffers </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType ofVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, andVK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any givenshader stage across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceLimits::maxPerStageDescriptorSampledImages </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType ofVK_DESCRIPTOR_TYPE_STORAGE_IMAGE, andVK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any givenshader stage across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceLimits::maxPerStageDescriptorStorageImages </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType ofVK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shaderstage across all elements of pSetLayouts must be less than orequal toVkPhysicalDeviceLimits::maxPerStageDescriptorInputAttachments </para>
/// <para>  The total number of bindings in descriptor set layouts created withoutthe VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXTbit set with a descriptorType ofVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible to anygiven shader stage across all elements of pSetLayouts must beless than or equal toVkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxPerStageDescriptorInlineUniformBlocks </para>
/// <para>  The total number of descriptors with a descriptorType ofVK_DESCRIPTOR_TYPE_SAMPLER andVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any givenshader stage across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindSamplers </para>
/// <para>  The total number of descriptors with a descriptorType ofVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER andVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any givenshader stage across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindUniformBuffers </para>
/// <para>  The total number of descriptors with a descriptorType ofVK_DESCRIPTOR_TYPE_STORAGE_BUFFER andVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any givenshader stage across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindStorageBuffers </para>
/// <para>  The total number of descriptors with a descriptorType ofVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, andVK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any givenshader stage across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindSampledImages </para>
/// <para>  The total number of descriptors with a descriptorType ofVK_DESCRIPTOR_TYPE_STORAGE_IMAGE, andVK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any givenshader stage across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindStorageImages </para>
/// <para>  The total number of descriptors with a descriptorType ofVK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shaderstage across all elements of pSetLayouts must be less than orequal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindInputAttachments </para>
/// <para>  The total number of bindings with a descriptorType ofVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible to anygiven shader stage across all elements of pSetLayouts must beless than or equal toVkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER andVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across allshader stages and across all elements of pSetLayouts must be lessthan or equal toVkPhysicalDeviceLimits::maxDescriptorSetSamplers </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType ofVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shaderstages and across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceLimits::maxDescriptorSetUniformBuffers </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType ofVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across allshader stages and across all elements of pSetLayouts must be lessthan or equal toVkPhysicalDeviceLimits::maxDescriptorSetUniformBuffersDynamic </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType ofVK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shaderstages and across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceLimits::maxDescriptorSetStorageBuffers </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType ofVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across allshader stages and across all elements of pSetLayouts must be lessthan or equal toVkPhysicalDeviceLimits::maxDescriptorSetStorageBuffersDynamic </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType ofVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, andVK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across allshader stages and across all elements of pSetLayouts must be lessthan or equal toVkPhysicalDeviceLimits::maxDescriptorSetSampledImages </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType ofVK_DESCRIPTOR_TYPE_STORAGE_IMAGE, andVK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across allshader stages and across all elements of pSetLayouts must be lessthan or equal toVkPhysicalDeviceLimits::maxDescriptorSetStorageImages </para>
/// <para>  The total number of descriptors in descriptor set layouts createdwithout theVK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bitset with a descriptorType ofVK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shaderstages and across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceLimits::maxDescriptorSetInputAttachments </para>
/// <para>  The total number of bindings in descriptor set layouts created withoutthe VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXTbit set with a descriptorType ofVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible across allshader stages and across all elements of pSetLayouts must be lessthan or equal toVkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxDescriptorSetInlineUniformBlocks </para>
/// <para>  The total number of descriptors of the typeVK_DESCRIPTOR_TYPE_SAMPLER andVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across allshader stages and across all elements of pSetLayouts must be lessthan or equal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindSamplers </para>
/// <para>  The total number of descriptors of the typeVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shaderstages and across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindUniformBuffers </para>
/// <para>  The total number of descriptors of the typeVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across allshader stages and across all elements of pSetLayouts must be lessthan or equal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindUniformBuffersDynamic </para>
/// <para>  The total number of descriptors of the typeVK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shaderstages and across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindStorageBuffers </para>
/// <para>  The total number of descriptors of the typeVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across allshader stages and across all elements of pSetLayouts must be lessthan or equal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindStorageBuffersDynamic </para>
/// <para>  The total number of descriptors of the typeVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, andVK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across allshader stages and across all elements of pSetLayouts must be lessthan or equal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindSampledImages </para>
/// <para>  The total number of descriptors of the typeVK_DESCRIPTOR_TYPE_STORAGE_IMAGE, andVK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across allshader stages and across all elements of pSetLayouts must be lessthan or equal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindStorageImages </para>
/// <para>  The total number of descriptors of the typeVK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shaderstages and across all elements of pSetLayouts must be less thanor equal toVkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindInputAttachments </para>
/// <para>  The total number of bindings with a descriptorType ofVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible across allshader stages and across all elements of pSetLayouts must be lessthan or equal toVkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxDescriptorSetUpdateAfterBindInlineUniformBlocks </para>
/// <para>  Any two elements of pPushConstantRanges must not include the samestage in stageFlags </para>
/// <para>   pSetLayouts must not contain more than one descriptor set layoutthat was created withVK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set</para>
/// <para>  The total number of bindings with a descriptorType ofVK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV accessible across allshader stages and across all elements of pSetLayouts must be lessthan or equal toVkPhysicalDeviceRayTracingPropertiesNV::maxDescriptorSetAccelerationStructures </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   If setLayoutCount is not 0, pSetLayouts must be a valid pointer to an array of setLayoutCount valid VkDescriptorSetLayout handles</para>
/// <para>   If pushConstantRangeCount is not 0, pPushConstantRanges must be a valid pointer to an array of pushConstantRangeCount valid VkPushConstantRange structures</para>
/// </summary>
public unsafe struct VkPipelineLayoutCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                 sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                     pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineLayoutCreateFlags     flags;
    /// <summary> setLayoutCount is the number of descriptor sets included in the
    /// pipeline layout.</summary>
    public UInt32                        setLayoutCount;
    /// <summary> pSetLayouts is a pointer to an array of
    /// VkDescriptorSetLayout objects.</summary>
    public /* const */ VkDescriptorSetLayout*    pSetLayouts;
    /// <summary> pushConstantRangeCount is the number of push constant ranges
    /// included in the pipeline layout.</summary>
    public UInt32                        pushConstantRangeCount;
    /// <summary> pPushConstantRanges is a pointer to an array of
    /// VkPushConstantRange structures defining a set of push constant
    /// ranges for use in a single pipeline layout.
    /// In addition to descriptor set layouts, a pipeline layout also describes
    /// how many push constants can be accessed by each stage of the pipeline.</summary>
    public /* const */ VkPushConstantRange*      pPushConstantRanges;
}
// Struct: 319
/// <summary>VkPipelineMultisampleStateCreateInfo - Structure specifying parameters of a newly created pipeline multisample state
/// <para>  If the sample rate shading feature is notenabled, sampleShadingEnable must be VK_FALSE </para>
/// <para>  If the alpha to one feature is not enabled,alphaToOneEnable must be VK_FALSE </para>
/// <para>   minSampleShading must be in the range [0,1] </para>
/// <para>  If the VK_NV_framebuffer_mixed_samples extension is enabled, and ifthe subpass has any color attachments and rasterizationSamples isgreater than the number of color samples, then sampleShadingEnable must be VK_FALSE </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineCoverageModulationStateCreateInfoNV, VkPipelineCoverageToColorStateCreateInfoNV, or VkPipelineSampleLocationsStateCreateInfoEXT </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   flags must be 0 </para>
/// <para>   rasterizationSamples must be a valid VkSampleCountFlagBits value</para>
/// <para>   If pSampleMask is not NULL, pSampleMask must be a valid pointer to an array of \(\lceil{\mathit{rasterizationSamples} \over 32}\rceil\) VkSampleMask values</para>
/// </summary>
public unsafe struct VkPipelineMultisampleStateCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                              pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineMultisampleStateCreateFlags    flags;
    /// <summary> rasterizationSamples is a VkSampleCountFlagBits specifying
    /// the number of samples used in rasterization.</summary>
    public VkSampleCountFlagBits                    rasterizationSamples;
    /// <summary> sampleShadingEnable
    ///   can be used to enable
    /// Sample Shading.</summary>
    public VkBool32                                 sampleShadingEnable;
    /// <summary> minSampleShading specifies a minimum fraction of sample shading if
    /// sampleShadingEnable is set to VK_TRUE.</summary>
    public float                                    minSampleShading;
    /// <summary> pSampleMask is a bitmask of static coverage information that is
    /// ANDed with the coverage information generated during rasterization, as
    /// described in Sample Mask.</summary>
    public /* const */ VkSampleMask*                      pSampleMask;
    /// <summary> alphaToCoverageEnable controls whether a temporary coverage value
    /// is generated based on the alpha component of the fragment’s first color
    /// output as specified in the Multisample Coverage
    /// section.</summary>
    public VkBool32                                 alphaToCoverageEnable;
    /// <summary> alphaToOneEnable controls whether the alpha component of the
    /// fragment’s first color output is replaced with one as described in
    /// Multisample Coverage.</summary>
    public VkBool32                                 alphaToOneEnable;
}
// Struct: 320
/// <summary>VkPipelineRasterizationConservativeStateCreateInfoEXT - Structure specifying conservative raster state
/// <para>   extraPrimitiveOverestimationSize must be in the range of 0.0 toVkPhysicalDeviceConservativeRasterizationPropertiesEXT::maxExtraPrimitiveOverestimationSizeinclusive</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT </para>
/// <para>   flags must be 0 </para>
/// <para>   conservativeRasterizationMode must be a valid VkConservativeRasterizationModeEXT value</para>
/// </summary>
public unsafe struct VkPipelineRasterizationConservativeStateCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                                           sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                               pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineRasterizationConservativeStateCreateFlagsEXT    flags;
    /// <summary> conservativeRasterizationMode is the conservative rasterization
    /// mode to use.</summary>
    public VkConservativeRasterizationModeEXT                        conservativeRasterizationMode;
    /// <summary> extraPrimitiveOverestimationSize is the extra size in pixels to
    /// increase the generating primitive during conservative rasterization at
    /// each of its edges in X and Y equally in screen space beyond the base
    /// overestimation specified in
    /// VkPhysicalDeviceConservativeRasterizationPropertiesEXT::primitiveOverestimationSize.</summary>
    public float                                                     extraPrimitiveOverestimationSize;
}
// Struct: 321
/// <summary>VkPipelineRasterizationDepthClipStateCreateInfoEXT - Structure specifying depth clipping state
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkPipelineRasterizationDepthClipStateCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                                        sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                            pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineRasterizationDepthClipStateCreateFlagsEXT    flags;
    /// <summary> depthClipEnable controls whether depth clipping is enabled as
    /// described in Primitive Clipping.</summary>
    public VkBool32                                               depthClipEnable;
}
// Struct: 322
/// <summary>VkPipelineRasterizationStateCreateInfo - Structure specifying parameters of a newly created pipeline rasterization state
/// <para>The application can also add aVkPipelineRasterizationStateRasterizationOrderAMD structure to thepNext chain of a VkPipelineRasterizationStateCreateInfostructure.This structure enables selecting the rasterization order to use whenrendering with the corresponding graphics pipeline as described inRasterization Order.</para>
/// <para>  If the depth clamping feature is not enabled,depthClampEnable must be VK_FALSE </para>
/// <para>  If the non-solid fill modes feature is notenabled, polygonMode must be VK_POLYGON_MODE_FILL orVK_POLYGON_MODE_FILL_RECTANGLE_NV </para>
/// <para>  If the  html/vkspec.html#VK_NV_fill_rectangle  extension is not enabled,polygonMode must not be VK_POLYGON_MODE_FILL_RECTANGLE_NV </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineRasterizationConservativeStateCreateInfoEXT, VkPipelineRasterizationDepthClipStateCreateInfoEXT, VkPipelineRasterizationStateRasterizationOrderAMD, or VkPipelineRasterizationStateStreamCreateInfoEXT </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   flags must be 0 </para>
/// <para>   polygonMode must be a valid VkPolygonMode value</para>
/// <para>   cullMode must be a valid combination of VkCullModeFlagBits values</para>
/// <para>   frontFace must be a valid VkFrontFace value</para>
/// </summary>
public unsafe struct VkPipelineRasterizationStateCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineRasterizationStateCreateFlags    flags;
    /// <summary> depthClampEnable controls whether to clamp the fragment’s depth
    /// values as described in Depth Test.
    /// If the pipeline is not created with
    /// VkPipelineRasterizationDepthClipStateCreateInfoEXT present then
    /// enabling depth clamp will also disable clipping primitives to the z
    /// planes of the frustrum as described in Primitive Clipping.
    /// Otherwise depth clipping is controlled by the state set in
    /// VkPipelineRasterizationDepthClipStateCreateInfoEXT.</summary>
    public VkBool32                                   depthClampEnable;
    /// <summary> rasterizerDiscardEnable controls whether primitives are discarded
    /// immediately before the rasterization stage.</summary>
    public VkBool32                                   rasterizerDiscardEnable;
    /// <summary> polygonMode is the triangle rendering mode.
    /// See VkPolygonMode.</summary>
    public VkPolygonMode                              polygonMode;
    /// <summary> cullMode is the triangle facing direction used for primitive
    /// culling.
    /// See VkCullModeFlagBits.</summary>
    public VkCullModeFlags                            cullMode;
    /// <summary> frontFace is a VkFrontFace value specifying the front-facing
    /// triangle orientation to be used for culling.</summary>
    public VkFrontFace                                frontFace;
    /// <summary> depthBiasEnable controls whether to bias fragment depth values.</summary>
    public VkBool32                                   depthBiasEnable;
    /// <summary> depthBiasConstantFactor is a scalar factor controlling the
    /// constant depth value added to each fragment.</summary>
    public float                                      depthBiasConstantFactor;
    /// <summary> depthBiasClamp is the maximum (or minimum) depth bias of a
    /// fragment.</summary>
    public float                                      depthBiasClamp;
    /// <summary> depthBiasSlopeFactor is a scalar factor applied to a fragment’s
    /// slope in depth bias calculations.</summary>
    public float                                      depthBiasSlopeFactor;
    /// <summary> lineWidth is the width of rasterized line segments.</summary>
    public float                                      lineWidth;
}
// Struct: 323
/// <summary>VkPipelineRasterizationStateRasterizationOrderAMD - Structure defining rasterization order for a graphics pipeline
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD </para>
/// <para>   rasterizationOrder must be a valid VkRasterizationOrderAMD value</para>
/// <para>If the  html/vkspec.html#VK_AMD_rasterization_order  device extension is not enabled orthe application does not request a particular rasterization order throughspecifying a VkPipelineRasterizationStateRasterizationOrderAMDstructure then the rasterization order used by the graphics pipelinedefaults to VK_RASTERIZATION_ORDER_STRICT_AMD.</para>
/// </summary>
public unsafe struct VkPipelineRasterizationStateRasterizationOrderAMD {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                pNext;
    /// <summary> rasterizationOrder is a VkRasterizationOrderAMD value
    /// specifying the primitive rasterization order to use.</summary>
    public VkRasterizationOrderAMD    rasterizationOrder;
}
// Struct: 324
/// <summary>VkPipelineRasterizationStateStreamCreateInfoEXT - Structure defining the geometry stream used for rasterization
/// <para>If this structure is not present, rasterizationStream is assumed to bezero.</para>
/// <para>   VkPhysicalDeviceTransformFeedbackFeaturesEXT::geometryStreams must be enabled</para>
/// <para>   rasterizationStream must be less thanVkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams </para>
/// <para>   rasterizationStream must be zero ifVkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackRasterizationStreamSelectis VK_FALSE </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkPipelineRasterizationStateStreamCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                                     sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                         pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineRasterizationStateStreamCreateFlagsEXT    flags;
    /// <summary> rasterizationStream is the vertex stream selected for
    /// rasterization.</summary>
    public UInt32                                            rasterizationStream;
}
// Struct: 325
/// <summary>VkPipelineRepresentativeFragmentTestStateCreateInfoNV - Structure specifying representative fragment test
/// <para>If this structure is not present, representativeFragmentTestEnable isconsidered to be VK_FALSE, and the representative fragment test isdisabled.</para>
/// <para>If early fragment tests are not enabled in theactive fragment shader, the representative fragment shader test has noeffect, even if enabled.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV </para>
/// </summary>
public unsafe struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> representativeFragmentTestEnable controls whether the
    /// representative fragment test is enabled.</summary>
    public VkBool32           representativeFragmentTestEnable;
}
// Struct: 326
/// <summary>VkPipelineSampleLocationsStateCreateInfoEXT - Structure specifying sample locations for a pipeline
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT </para>
/// <para>   sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure</para>
/// </summary>
public unsafe struct VkPipelineSampleLocationsStateCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                 pNext;
    /// <summary> sampleLocationsEnable controls whether custom sample locations are
    /// used.
    /// If sampleLocationsEnable is VK_FALSE, the default sample
    /// locations are used and the values specified in sampleLocationsInfo
    /// are ignored.</summary>
    public VkBool32                    sampleLocationsEnable;
    /// <summary> sampleLocationsInfo is the sample locations to use during
    /// rasterization if sampleLocationsEnable is VK_TRUE and the
    /// graphics pipeline is not created with
    /// VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT.</summary>
    public VkSampleLocationsInfoEXT    sampleLocationsInfo;
}
// Struct: 327
/// <summary>VkPipelineShaderStageCreateInfo - Structure specifying parameters of a newly created pipeline shader stage
/// <para>  If the geometry shaders feature is notenabled, stage must not be VK_SHADER_STAGE_GEOMETRY_BIT </para>
/// <para>  If the tessellation shaders feature isnot enabled, stage must not beVK_SHADER_STAGE_TESSELLATION_CONTROL_BIT orVK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT </para>
/// <para>  If the mesh shader feature is not enabled,stage must not be VK_SHADER_STAGE_MESH_BIT_NV </para>
/// <para>  If the task shader feature is not enabled,stage must not be VK_SHADER_STAGE_TASK_BIT_NV </para>
/// <para>   stage must not be VK_SHADER_STAGE_ALL_GRAPHICS, orVK_SHADER_STAGE_ALL </para>
/// <para>   pName must be the name of an OpEntryPoint in modulewith an execution model that matches stage </para>
/// <para>  If the identified entry point includes any variable in its interfacethat is declared with the ClipDistance BuiltIn decoration,that variable must not have an array size greater thanVkPhysicalDeviceLimits::maxClipDistances </para>
/// <para>  If the identified entry point includes any variable in its interfacethat is declared with the CullDistance BuiltIn decoration,that variable must not have an array size greater thanVkPhysicalDeviceLimits::maxCullDistances </para>
/// <para>  If the identified entry point includes any variables in its interfacethat are declared with the ClipDistance or CullDistance BuiltIn decoration, those variables must not have array sizeswhich sum to more thanVkPhysicalDeviceLimits::maxCombinedClipAndCullDistances </para>
/// <para>  If the identified entry point includes any variable in its interfacethat is declared with the SampleMask BuiltIn decoration, thatvariable must not have an array size greater thanVkPhysicalDeviceLimits::maxSampleMaskWords </para>
/// <para>  If stage is VK_SHADER_STAGE_VERTEX_BIT, the identified entrypoint must not include any input variable in its interface that isdecorated with CullDistance </para>
/// <para>  If stage is VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT orVK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, and the identifiedentry point has an OpExecutionMode instruction that specifies apatch size with OutputVertices, the patch size must be greaterthan 0 and less than or equal toVkPhysicalDeviceLimits::maxTessellationPatchSize </para>
/// <para>  If stage is VK_SHADER_STAGE_GEOMETRY_BIT, the identifiedentry point must have an OpExecutionMode instruction thatspecifies a maximum output vertex count that is greater than 0 andless than or equal toVkPhysicalDeviceLimits::maxGeometryOutputVertices </para>
/// <para>  If stage is VK_SHADER_STAGE_GEOMETRY_BIT, the identifiedentry point must have an OpExecutionMode instruction thatspecifies an invocation count that is greater than 0 and less than orequal toVkPhysicalDeviceLimits::maxGeometryShaderInvocations </para>
/// <para>  If stage is a vertex processing stage, and the identified entrypoint writes to Layer for any primitive, it must write the samevalue to Layer for all vertices of a given primitive</para>
/// <para>  If stage is a vertex processing stage, and the identified entrypoint writes to ViewportIndex for any primitive, it must write thesame value to ViewportIndex for all vertices of a given primitive</para>
/// <para>  If stage is VK_SHADER_STAGE_FRAGMENT_BIT, the identifiedentry point must not include any output variables in its interfacedecorated with CullDistance </para>
/// <para>  If stage is VK_SHADER_STAGE_FRAGMENT_BIT, and the identifiedentry point writes to FragDepth in any execution path, it mustwrite to FragDepth in all execution paths</para>
/// <para>  If stage is VK_SHADER_STAGE_FRAGMENT_BIT, and the identifiedentry point writes to FragStencilRefEXT in any execution path, itmust write to FragStencilRefEXT in all execution paths</para>
/// <para>  If stage is VK_SHADER_STAGE_MESH_BIT_NV, the identifiedentry point must have an OpExecutionMode instruction thatspecifies a maximum output vertex count, OutputVertices, that isgreater than 0 and less than or equal toVkPhysicalDeviceMeshShaderPropertiesNV::maxMeshOutputVertices.</para>
/// <para>  If stage is VK_SHADER_STAGE_MESH_BIT_NV, the identifiedentry point must have an OpExecutionMode instruction thatspecifies a maximum output primitive count, OutputPrimitivesNV,that is greater than 0 and less than or equal toVkPhysicalDeviceMeshShaderPropertiesNV::maxMeshOutputPrimitives.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   stage must be a valid VkShaderStageFlagBits value</para>
/// <para>   module must be a valid VkShaderModule handle</para>
/// <para>   pName must be a null-terminated UTF-8 string</para>
/// <para>   If pSpecializationInfo is not NULL, pSpecializationInfo must be a valid pointer to a valid VkSpecializationInfo structure</para>
/// </summary>
public unsafe struct VkPipelineShaderStageCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                     sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                         pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineShaderStageCreateFlags    flags;
    /// <summary> stage is a VkShaderStageFlagBits value specifying a single
    /// pipeline stage.</summary>
    public VkShaderStageFlagBits               stage;
    /// <summary> module is a VkShaderModule object that contains the shader
    /// for this stage.</summary>
    public VkShaderModule                      module;
    /// <summary> pName is a pointer to a null-terminated UTF-8 string specifying
    /// the entry point name of the shader for this stage.</summary>
    public IntPtr                         pName;
    /// <summary> pSpecializationInfo is a pointer to VkSpecializationInfo, as
    /// described in Specialization
    /// Constants, and can be NULL.</summary>
    public /* const */ VkSpecializationInfo*         pSpecializationInfo;
}
// Struct: 328
/// <summary>VkPipelineTessellationDomainOriginStateCreateInfo - Structure specifying the orientation of the tessellation domain
/// <para>If the VkPipelineTessellationDomainOriginStateCreateInfo structure isincluded in the pNext chain ofVkPipelineTessellationStateCreateInfo, it controls the origin of thetessellation domain.If this structure is not present, it is as if domainOrigin wereVK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO </para>
/// <para>   domainOrigin must be a valid VkTessellationDomainOrigin value</para>
/// </summary>
public unsafe struct VkPipelineTessellationDomainOriginStateCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                   pNext;
    /// <summary> domainOrigin controls the origin of the tessellation domain space,
    /// and is of type VkTessellationDomainOrigin.</summary>
    public VkTessellationDomainOrigin    domainOrigin;
}
// Struct: 329
/// <summary>VkPipelineTessellationStateCreateInfo - Structure specifying parameters of a newly created pipeline tessellation state
/// <para>   patchControlPoints must be greater than zero and less than orequal to VkPhysicalDeviceLimits::maxTessellationPatchSize </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkPipelineTessellationDomainOriginStateCreateInfo </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkPipelineTessellationStateCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                           sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                               pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineTessellationStateCreateFlags    flags;
    /// <summary> patchControlPoints number of control points per patch.</summary>
    public UInt32                                  patchControlPoints;
}
// Struct: 330
/// <summary>VkPipelineVertexInputDivisorStateCreateInfoEXT - Structure specifying vertex attributes assignment during instanced rendering
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT </para>
/// <para>   pVertexBindingDivisors must be a valid pointer to an array of vertexBindingDivisorCount VkVertexInputBindingDivisorDescriptionEXT structures</para>
/// <para>   vertexBindingDivisorCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkPipelineVertexInputDivisorStateCreateInfoEXT {
    /// <summary> sType is the type of this structure</summary>
    public VkStructureType                                     sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure</summary>
    public /* const */ void*                                         pNext;
    /// <summary> vertexBindingDivisorCount is the number of elements in the
    /// pVertexBindingDivisors array.</summary>
    public UInt32                                            vertexBindingDivisorCount;
    /// <summary> pVertexBindingDivisors is a pointer to an array of
    /// VkVertexInputBindingDivisorDescriptionEXT structures, which
    /// specifies the divisor value for each binding.</summary>
    public /* const */ VkVertexInputBindingDivisorDescriptionEXT*    pVertexBindingDivisors;
}
// Struct: 331
/// <summary>VkPipelineVertexInputStateCreateInfo - Structure specifying parameters of a newly created pipeline vertex input state
/// <para>   vertexBindingDescriptionCount must be less than or equal toVkPhysicalDeviceLimits::maxVertexInputBindings </para>
/// <para>   vertexAttributeDescriptionCount must be less than or equal toVkPhysicalDeviceLimits::maxVertexInputAttributes </para>
/// <para>  For every binding specified by each element ofpVertexAttributeDescriptions, aVkVertexInputBindingDescription must exist inpVertexBindingDescriptions with the same value of binding </para>
/// <para>  All elements of pVertexBindingDescriptions must describe distinctbinding numbers</para>
/// <para>  All elements of pVertexAttributeDescriptions must describedistinct attribute locations</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkPipelineVertexInputDivisorStateCreateInfoEXT </para>
/// <para>   flags must be 0 </para>
/// <para>   If vertexBindingDescriptionCount is not 0, pVertexBindingDescriptions must be a valid pointer to an array of vertexBindingDescriptionCount valid VkVertexInputBindingDescription structures</para>
/// <para>   If vertexAttributeDescriptionCount is not 0, pVertexAttributeDescriptions must be a valid pointer to an array of vertexAttributeDescriptionCount valid VkVertexInputAttributeDescription structures</para>
/// </summary>
public unsafe struct VkPipelineVertexInputStateCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                 pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineVertexInputStateCreateFlags       flags;
    /// <summary> vertexBindingDescriptionCount is the number of vertex binding
    /// descriptions provided in pVertexBindingDescriptions.</summary>
    public UInt32                                    vertexBindingDescriptionCount;
    /// <summary> pVertexBindingDescriptions is a pointer to an array of
    /// VkVertexInputBindingDescription structures.</summary>
    public /* const */ VkVertexInputBindingDescription*      pVertexBindingDescriptions;
    /// <summary> vertexAttributeDescriptionCount is the number of vertex attribute
    /// descriptions provided in pVertexAttributeDescriptions.</summary>
    public UInt32                                    vertexAttributeDescriptionCount;
    /// <summary> pVertexAttributeDescriptions is a pointer to an array of
    /// VkVertexInputAttributeDescription structures.</summary>
    public /* const */ VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
}
// Struct: 332
/// <summary>VkPipelineViewportCoarseSampleOrderStateCreateInfoNV - Structure specifying parameters controlling sample order in coarse fragments
/// <para>If this structure is not present, sampleOrderType is considered to beVK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV.</para>
/// <para>If sampleOrderType is VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, thecoverage sample order used for any combination of fragment area and coveragesample count not enumerated in pCustomSampleOrders will be identicalto that used for VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV.</para>
/// <para>If the pipeline was created withVK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV, the contents of thisstructure (if present) are ignored, and the coverage sample order is insteadspecified by vkCmdSetCoarseSampleOrderNV.</para>
/// <para>  If sampleOrderType is notVK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,customSamplerOrderCount must be 0 </para>
/// <para>  The array pCustomSampleOrders must not contain two structureswith matching values for both the shadingRate andsampleCount members.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV </para>
/// <para>   sampleOrderType must be a valid VkCoarseSampleOrderTypeNV value</para>
/// <para>   If customSampleOrderCount is not 0, pCustomSampleOrders must be a valid pointer to an array of customSampleOrderCount valid VkCoarseSampleOrderCustomNV structures</para>
/// </summary>
public unsafe struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                           pNext;
    /// <summary> sampleOrderType specifies the mechanism used to order coverage
    /// samples in fragments larger than one pixel.</summary>
    public VkCoarseSampleOrderTypeNV             sampleOrderType;
    /// <summary> customSampleOrderCount specifies the number of custom sample
    /// orderings to use when ordering coverage samples.</summary>
    public UInt32                              customSampleOrderCount;
    /// <summary> pCustomSampleOrders is a pointer to an array of
    /// VkCoarseSampleOrderCustomNV structures, each of which specifies
    /// the coverage sample order for a single combination of fragment area and
    /// coverage sample count.</summary>
    public /* const */ VkCoarseSampleOrderCustomNV*    pCustomSampleOrders;
}
// Struct: 333
/// <summary>VkPipelineViewportExclusiveScissorStateCreateInfoNV - Structure specifying parameters controlling exclusive scissor testing
/// <para>If this structure is not present, exclusiveScissorCount is consideredto be 0 and the exclusive scissor test is disabled.</para>
/// <para>  If the multiple viewports feature is notenabled, exclusiveScissorCount must be 0 or 1 </para>
/// <para>   exclusiveScissorCount must be less than or equal toVkPhysicalDeviceLimits::maxViewports </para>
/// <para>   exclusiveScissorCount must be 0 or identical to theviewportCount member of VkPipelineViewportStateCreateInfo </para>
/// <para>  If no element of the pDynamicStates member of pDynamicStateis VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV andexclusiveScissorCount is not 0, pExclusiveScissors mustbe a valid pointer to an array of exclusiveScissorCount VkRect2D structures</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV </para>
/// <para>   If exclusiveScissorCount is not 0, and pExclusiveScissors is not NULL, pExclusiveScissors must be a valid pointer to an array of exclusiveScissorCount VkRect2D structures</para>
/// </summary>
public unsafe struct VkPipelineViewportExclusiveScissorStateCreateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> exclusiveScissorCount is the number of exclusive scissor
    /// rectangles used by the pipeline.</summary>
    public UInt32           exclusiveScissorCount;
    /// <summary> pExclusiveScissors is a pointer to an array of VkRect2D
    /// structures defining exclusive scissor rectangles.
    /// If the exclusive scissor state is dynamic, this member is ignored.</summary>
    public /* const */ VkRect2D*    pExclusiveScissors;
}
// Struct: 334
/// <summary>VkPipelineViewportShadingRateImageStateCreateInfoNV - Structure specifying parameters controlling shading rate image usage
/// <para>If this structure is not present, shadingRateImageEnable is consideredto be VK_FALSE, and the shading rate image and palettes are not used.</para>
/// <para>  If the multiple viewports feature is notenabled, viewportCount must be 0 or 1 </para>
/// <para>   viewportCount must be less than or equal toVkPhysicalDeviceLimits::maxViewports </para>
/// <para>  If shadingRateImageEnable is VK_TRUE, viewportCount must be equal to the viewportCount member ofVkPipelineViewportStateCreateInfo </para>
/// <para>  If no element of the pDynamicStates member of pDynamicStateis VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV,pShadingRatePalettes must be a valid pointer to an array ofviewportCount VkShadingRatePaletteNV structures</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV </para>
/// <para>   If viewportCount is not 0, and pShadingRatePalettes is not NULL, pShadingRatePalettes must be a valid pointer to an array of viewportCount valid VkShadingRatePaletteNV structures</para>
/// </summary>
public unsafe struct VkPipelineViewportShadingRateImageStateCreateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                  sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                      pNext;
    /// <summary> shadingRateImageEnable specifies whether shading rate image and
    /// palettes are used during rasterization.</summary>
    public VkBool32                         shadingRateImageEnable;
    /// <summary> viewportCount specifies the number of per-viewport palettes used
    /// to translate values stored in shading rate images.</summary>
    public UInt32                         viewportCount;
    /// <summary> pShadingRatePalettes is a pointer to an array of
    /// VkShadingRatePaletteNV structures defining the palette for each
    /// viewport.
    /// If the shading rate palette state is dynamic, this member is ignored.</summary>
    public /* const */ VkShadingRatePaletteNV*    pShadingRatePalettes;
}
// Struct: 335
/// <summary>VkPipelineViewportStateCreateInfo - Structure specifying parameters of a newly created pipeline viewport state
/// <para>  If the multiple viewports feature is notenabled, viewportCount must be 1 </para>
/// <para>  If the multiple viewports feature is notenabled, scissorCount must be 1 </para>
/// <para>   viewportCount must be between 1 andVkPhysicalDeviceLimits::maxViewports, inclusive</para>
/// <para>   scissorCount must be between 1 andVkPhysicalDeviceLimits::maxViewports, inclusive</para>
/// <para>   scissorCount and viewportCount must be identical</para>
/// <para>  If the viewportWScalingEnable member of aVkPipelineViewportWScalingStateCreateInfoNV structure chained tothe pNext chain is VK_TRUE, the viewportCount memberof the VkPipelineViewportWScalingStateCreateInfoNV structure mustbe equal to viewportCount </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, VkPipelineViewportExclusiveScissorStateCreateInfoNV, VkPipelineViewportShadingRateImageStateCreateInfoNV, VkPipelineViewportSwizzleStateCreateInfoNV, or VkPipelineViewportWScalingStateCreateInfoNV </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   flags must be 0 </para>
/// <para>   viewportCount must be greater than 0 </para>
/// <para>   scissorCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkPipelineViewportStateCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                           pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineViewportStateCreateFlags    flags;
    /// <summary> viewportCount is the number of viewports used by the pipeline.</summary>
    public UInt32                              viewportCount;
    /// <summary> pViewports is a pointer to an array of VkViewport
    /// structures, defining the viewport transforms.
    /// If the viewport state is dynamic, this member is ignored.</summary>
    public /* const */ VkViewport*                     pViewports;
    /// <summary> scissorCount is the number of scissors and
    /// must match the number of viewports.</summary>
    public UInt32                              scissorCount;
    /// <summary> pScissors is a pointer to an array of VkRect2D structures
    /// which define the rectangular bounds of the scissor for the corresponding
    /// viewport.
    /// If the scissor state is dynamic, this member is ignored.</summary>
    public /* const */ VkRect2D*                       pScissors;
}
// Struct: 336
/// <summary>VkPipelineViewportSwizzleStateCreateInfoNV - Structure specifying swizzle applied to primitive clip coordinates
/// <para>   viewportCount must match the viewportCount set inVkPipelineViewportStateCreateInfo </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV </para>
/// <para>   flags must be 0 </para>
/// <para>   pViewportSwizzles must be a valid pointer to an array of viewportCount valid VkViewportSwizzleNV structures</para>
/// <para>   viewportCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkPipelineViewportSwizzleStateCreateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                                sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                    pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkPipelineViewportSwizzleStateCreateFlagsNV    flags;
    /// <summary> viewportCount is the number of viewport swizzles used by the
    /// pipeline.</summary>
    public UInt32                                       viewportCount;
    /// <summary> pViewportSwizzles is a pointer to an array of
    /// VkViewportSwizzleNV structures, defining the viewport swizzles.</summary>
    public /* const */ VkViewportSwizzleNV*                     pViewportSwizzles;
}
// Struct: 337
/// <summary>VkPipelineViewportWScalingStateCreateInfoNV - Structure specifying parameters of a newly created pipeline viewport W scaling state
/// <para>   sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV </para>
/// <para>   viewportCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkPipelineViewportWScalingStateCreateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                    pNext;
    /// <summary> viewportWScalingEnable controls whether viewport W scaling is
    /// enabled.</summary>
    public VkBool32                       viewportWScalingEnable;
    /// <summary> viewportCount is the number of viewports used by W scaling, and
    /// must match the number of viewports in the pipeline if viewport W
    /// scaling is enabled.</summary>
    public UInt32                       viewportCount;
    /// <summary> pViewportWScalings is a pointer to an array of
    /// VkViewportWScalingNV structures, which define the W scaling
    /// parameters for the corresponding viewport.
    /// If the viewport W scaling state is dynamic, this member is ignored.</summary>
    public /* const */ VkViewportWScalingNV*    pViewportWScalings;
}
// Struct: 338
/// <summary>VkPresentFrameTokenGGP - The Google Games Platform frame token
/// <para>   frameToken must be a valid GgpFrameToken </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP </para>
/// </summary>
public unsafe struct VkPresentFrameTokenGGP {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> frameToken is the Google Games Platform frame token.</summary>
    public GgpFrameToken      frameToken;
}
// Struct: 339
/// <summary>VkPresentInfoKHR - Structure describing parameters of a queue presentation
/// <para>Before an application can present an image, the image’s layout must betransitioned to the VK_IMAGE_LAYOUT_PRESENT_SRC_KHRlayout, or for a shared presentable image theVK_IMAGE_LAYOUT_SHARED_PRESENT_KHRlayout.</para>
/// <para>When transitioning the image toVK_IMAGE_LAYOUT_SHARED_PRESENT_KHR orVK_IMAGE_LAYOUT_PRESENT_SRC_KHR, there is no need to delay subsequentprocessing, or perform any visibility operations (as vkQueuePresentKHRperforms automatic visibility operations).To achieve this, the dstAccessMask member of theVkImageMemoryBarrier should be set to 0, and the dstStageMaskparameter should be set to VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT.</para>
/// <para>  Each element of pImageIndices must be the index of a presentableimage acquired from the swapchain specified by the corresponding elementof the pSwapchains array, and the presented image subresourcemust be in the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR orVK_IMAGE_LAYOUT_SHARED_PRESENT_KHR layout at the time theoperation is executed on a VkDevice </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PRESENT_INFO_KHR </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupPresentInfoKHR, VkDisplayPresentInfoKHR, VkPresentFrameTokenGGP, VkPresentRegionsKHR, or VkPresentTimesInfoGOOGLE </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles</para>
/// <para>   pSwapchains must be a valid pointer to an array of swapchainCount valid VkSwapchainKHR handles</para>
/// <para>   pImageIndices must be a valid pointer to an array of swapchainCount uint32_t values</para>
/// <para>   If pResults is not NULL, pResults must be a valid pointer to an array of swapchainCount VkResult values</para>
/// <para>   swapchainCount must be greater than 0 </para>
/// <para>   Both of the elements of pSwapchains, and the elements of pWaitSemaphores that are valid handles must have been created, allocated, or retrieved from the same VkInstance </para>
/// </summary>
public unsafe struct VkPresentInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*              pNext;
    /// <summary> waitSemaphoreCount is the number of semaphores to wait for before
    /// issuing the present request.
    /// The number may be zero.</summary>
    public UInt32                 waitSemaphoreCount;
    /// <summary> pWaitSemaphores, if not NULL, is an array of VkSemaphore
    /// objects with waitSemaphoreCount entries, and specifies the
    /// semaphores to wait for before issuing the present request.</summary>
    public /* const */ VkSemaphore*       pWaitSemaphores;
    /// <summary> swapchainCount is the number of swapchains being presented to by
    /// this command.</summary>
    public UInt32                 swapchainCount;
    /// <summary> pSwapchains is an array of VkSwapchainKHR objects with
    /// swapchainCount entries.
    /// A given swapchain must not appear in this list more than once.</summary>
    public /* const */ VkSwapchainKHR*    pSwapchains;
    /// <summary> pImageIndices is an array of indices into the array of each
    /// swapchain’s presentable images, with swapchainCount entries.
    /// Each entry in this array identifies the image to present on the
    /// corresponding entry in the pSwapchains array.</summary>
    public /* const */ UInt32*          pImageIndices;
    /// <summary> pResults is an array of VkResult typed elements with
    /// swapchainCount entries.
    /// Applications that do not need per-swapchain results can use NULL for
    /// pResults.
    /// If non-NULL, each entry in pResults will be set to the
    /// VkResult for presenting the swapchain corresponding to the same
    /// index in pSwapchains.</summary>
    public VkResult*                pResults;
}
// Struct: 340
/// <summary>VkPresentRegionKHR - Structure containing rectangular region changed by vkQueuePresentKHR for a given VkImage
/// <para>   If rectangleCount is not 0, and pRectangles is not NULL, pRectangles must be a valid pointer to an array of rectangleCount valid VkRectLayerKHR structures</para>
/// </summary>
public unsafe struct VkPresentRegionKHR {
    /// <summary> rectangleCount is the number of rectangles in pRectangles,
    /// or zero if the entire image has changed and should be presented.</summary>
    public UInt32                 rectangleCount;
    /// <summary> pRectangles is either NULL or a pointer to an array of
    /// VkRectLayerKHR structures.
    /// The VkRectLayerKHR structure is the framebuffer coordinates, plus
    /// layer, of a portion of a presentable image that has changed and must be
    /// presented.
    /// If non-NULL, each entry in pRectangles is a rectangle of the
    /// given image that has changed since the last image was presented to the
    /// given swapchain.</summary>
    public /* const */ VkRectLayerKHR*    pRectangles;
}
// Struct: 341
/// <summary>VkPresentRegionsKHR - Structure hint of rectangular regions changed by vkQueuePresentKHR
/// <para>   swapchainCount must be the same value asVkPresentInfoKHR::swapchainCount, whereVkPresentInfoKHR is in the pNext chain of thisVkPresentRegionsKHR structure</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR </para>
/// <para>   If pRegions is not NULL, pRegions must be a valid pointer to an array of swapchainCount valid VkPresentRegionKHR structures</para>
/// <para>   swapchainCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkPresentRegionsKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType              sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                  pNext;
    /// <summary> swapchainCount is the number of swapchains being presented to by
    /// this command.</summary>
    public UInt32                     swapchainCount;
    /// <summary> pRegions is NULL or a pointer to an array of
    /// VkPresentRegionKHR elements with swapchainCount entries.
    /// If not NULL, each element of pRegions contains the region that
    /// has changed since the last present to the swapchain in the corresponding
    /// entry in the VkPresentInfoKHR::pSwapchains array.</summary>
    public /* const */ VkPresentRegionKHR*    pRegions;
}
// Struct: 342
/// <summary>VkPresentTimeGOOGLE - The earliest time image should be presented
/// </summary>
public unsafe struct VkPresentTimeGOOGLE {
    /// <summary> presentID is an application-provided identification value, that
    /// can be used with the results of
    /// vkGetPastPresentationTimingGOOGLE, in order to uniquely identify
    /// this present.
    /// In order to be useful to the application, it should be unique within
    /// some period of time that is meaningful to the application.</summary>
    public UInt32    presentID;
    /// <summary> desiredPresentTime specifies that the image given should not be
    /// displayed to the user any earlier than this time.
    /// desiredPresentTime is a time in nanoseconds, relative to a
    /// monotonically-increasing clock (e.g. CLOCK_MONOTONIC (see
    /// clock_gettime(2)) on Android and Linux).
    /// A value of zero specifies that the presentation engine may display the
    /// image at any time.
    /// This is useful when the application desires to provide presentID,
    /// but does not need a specific desiredPresentTime.</summary>
    public UInt64    desiredPresentTime;
}
// Struct: 343
/// <summary>VkPresentTimesInfoGOOGLE - The earliest time each image should be presented
/// <para>   swapchainCount must be the same value asVkPresentInfoKHR::swapchainCount, whereVkPresentInfoKHR is in the pNext chain of thisVkPresentTimesInfoGOOGLE structure.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE </para>
/// <para>   If pTimes is not NULL, pTimes must be a valid pointer to an array of swapchainCount VkPresentTimeGOOGLE structures</para>
/// <para>   swapchainCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkPresentTimesInfoGOOGLE {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                   pNext;
    /// <summary> swapchainCount is the number of swapchains being presented to by
    /// this command.</summary>
    public UInt32                      swapchainCount;
    /// <summary> pTimes is NULL or a pointer to an array of
    /// VkPresentTimeGOOGLE elements with swapchainCount entries.
    /// If not NULL, each element of pTimes contains the earliest time
    /// to present the image corresponding to the entry in the
    /// VkPresentInfoKHR::pImageIndices array.</summary>
    public /* const */ VkPresentTimeGOOGLE*    pTimes;
}
// Struct: 344
/// <summary>VkProtectedSubmitInfo - Structure indicating whether the submission is protected
/// <para>  If the protected memory feature is not enabled, protectedSubmit must not be VK_TRUE.</para>
/// <para>  If protectedSubmit is VK_TRUE, then each element of thepCommandBuffers array must be a protected command buffer.</para>
/// <para>  If protectedSubmit is VK_FALSE, then each element of thepCommandBuffers array must be an unprotected command buffer.</para>
/// <para>  If the VkSubmitInfo::pNext chain does not include aVkProtectedSubmitInfo structure, then each element of the commandbuffer of the pCommandBuffers array must be an unprotectedcommand buffer.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO </para>
/// </summary>
public unsafe struct VkProtectedSubmitInfo {
    public VkStructureType    sType;
    public /* const */ void*        pNext;
    /// <summary> protectedSubmit specifies whether the batch is protected.
    /// If protectedSubmit is VK_TRUE, the batch is protected.
    /// If protectedSubmit is VK_FALSE, the batch is unprotected.
    /// If the VkSubmitInfo::pNext chain does not contain this
    /// structure, the batch is unprotected.</summary>
    public VkBool32           protectedSubmit;
}
// Struct: 345
/// <summary>VkPushConstantRange - Structure specifying a push constant range
/// <para>   offset must be less thanVkPhysicalDeviceLimits::maxPushConstantsSize </para>
/// <para>   offset must be a multiple of 4 </para>
/// <para>   size must be greater than 0 </para>
/// <para>   size must be a multiple of 4 </para>
/// <para>   size must be less than or equal toVkPhysicalDeviceLimits::maxPushConstantsSize minusoffset </para>
/// <para>   stageFlags must be a valid combination of VkShaderStageFlagBits values</para>
/// <para>   stageFlags must not be 0 </para>
/// </summary>
public unsafe struct VkPushConstantRange {
    /// <summary> stageFlags is a set of stage flags describing the shader stages
    /// that will access a range of push constants.
    /// If a particular stage is not included in the range, then accessing
    /// members of that range of push constants from the corresponding shader
    /// stage will return undefined values.</summary>
    public VkShaderStageFlags    stageFlags;
    /// <summary> offset and size are the start offset and size, respectively,
    /// consumed by the range.
    /// Both offset and size are in units of bytes and must be a
    /// multiple of 4.
    /// The layout of the push constant variables is specified in the shader.</summary>
    public UInt32              offset;
    public UInt32              size;
}
// Struct: 346
/// <summary>VkQueryPoolCreateInfo - Structure specifying parameters of a newly created query pool
/// <para> pipelineStatistics is ignored if queryType is notVK_QUERY_TYPE_PIPELINE_STATISTICS.</para>
/// <para>  If the pipeline statistics queriesfeature is not enabled, queryType must not beVK_QUERY_TYPE_PIPELINE_STATISTICS </para>
/// <para>  If queryType is VK_QUERY_TYPE_PIPELINE_STATISTICS,pipelineStatistics must be a valid combination ofVkQueryPipelineStatisticFlagBits values</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   queryType must be a valid VkQueryType value</para>
/// </summary>
public unsafe struct VkQueryPoolCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                  sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                      pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkQueryPoolCreateFlags           flags;
    /// <summary> queryType is a VkQueryType value specifying the type of
    /// queries managed by the pool.</summary>
    public VkQueryType                      queryType;
    /// <summary> queryCount is the number of queries managed by the pool.</summary>
    public UInt32                         queryCount;
    /// <summary> pipelineStatistics is a bitmask of
    /// VkQueryPipelineStatisticFlagBits specifying which counters will be
    /// returned in queries on the new pool, as described below in
    /// html/vkspec.html#queries-pipestats.</summary>
    public VkQueryPipelineStatisticFlags    pipelineStatistics;
}
// Struct: 347
/// <summary>VkQueueFamilyCheckpointPropertiesNV - return structure for queue family checkpoint info query
/// <para>   sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV </para>
/// </summary>
public unsafe struct VkQueueFamilyCheckpointPropertiesNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType         sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                   pNext;
    /// <summary> checkpointExecutionStageMask is a mask indicating which pipeline
    /// stages the implementation can execute checkpoint markers in.</summary>
    public VkPipelineStageFlags    checkpointExecutionStageMask;
}
// Struct: 348
/// <summary>VkQueueFamilyProperties - Structure providing information about a queue family
/// <para>The value returned in minImageTransferGranularity has a unit ofcompressed texel blocks for images having a block-compressed format, and aunit of texels otherwise.</para>
/// <para>Possible values of minImageTransferGranularity are:</para>
/// <para> (0,0,0) which indicates that only whole mip levels must betransferred using the image transfer operations on the correspondingqueues.In this case, the following restrictions apply to all offset and extentparameters of image transfer operations:</para>
/// <para>The x, y, and z members of a VkOffset3Dparameter must always be zero.</para>
/// <para>The width, height, and depth members of aVkExtent3D parameter must always match the width, height, anddepth of the image subresource corresponding to the parameter,respectively.</para>
/// <para> (Ax, Ay, Az) where Ax , Ay , and Az are all integer powers of two.In this case the following restrictions apply to all image transferoperations:</para>
/// <para> x, y, and z of a VkOffset3D parameter must beinteger multiples of Ax , Ay , and Az ,respectively.</para>
/// <para> width of a VkExtent3D parameter must be an integermultiple of Ax , or else  x +  width  mustequal the width of the image subresource corresponding to theparameter.</para>
/// <para> height of a VkExtent3D parameter must be an integermultiple of Ay , or else  y +  height  mustequal the height of the image subresource corresponding to theparameter.</para>
/// <para> depth of a VkExtent3D parameter must be an integermultiple of Az , or else  z +  depth  mustequal the depth of the image subresource corresponding to theparameter.</para>
/// <para>If the format of the image corresponding to the parameters is one ofthe block-compressed formats then for the purposes of the abovecalculations the granularity must be scaled up by the compressed texelblock dimensions.</para>
/// <para>Queues supporting graphics and/or compute operations must report(1,1,1) in minImageTransferGranularity, meaning that there areno additional restrictions on the granularity of image transfer operationsfor these queues.Other queues supporting image transfer operations are only required tosupport whole mip level transfers, thus minImageTransferGranularityfor queues belonging to such queue families may be (0,0,0).</para>
/// <para>The Device Memory section describes memory propertiesqueried from the physical device.</para>
/// <para>For physical device feature queries see the Features chapter.</para>
/// </summary>
public unsafe struct VkQueueFamilyProperties {
    /// <summary> queueFlags is a bitmask of VkQueueFlagBits indicating
    /// capabilities of the queues in this queue family.</summary>
    public VkQueueFlags    queueFlags;
    /// <summary> queueCount is the unsigned integer count of queues in this queue
    /// family.
    /// Each queue family must support at least one queue.</summary>
    public UInt32        queueCount;
    /// <summary> timestampValidBits is the unsigned integer count of meaningful
    /// bits in the timestamps written via vkCmdWriteTimestamp.
    /// The valid range for the count is 36..64 bits, or a value of 0,
    /// indicating no support for timestamps.
    /// Bits outside the valid range are guaranteed to be zeros.</summary>
    public UInt32        timestampValidBits;
    /// <summary> minImageTransferGranularity is the minimum granularity supported
    /// for image transfer operations on the queues in this queue family.</summary>
    public VkExtent3D      minImageTransferGranularity;
}
// Struct: 349
/// <summary>VkQueueFamilyProperties2 - Structure providing information about a queue family
/// <para>   sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkQueueFamilyCheckpointPropertiesNV </para>
/// </summary>
public unsafe struct VkQueueFamilyProperties2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                      pNext;
    /// <summary> queueFamilyProperties is a structure of type
    /// VkQueueFamilyProperties which is populated with the same values as
    /// in vkGetPhysicalDeviceQueueFamilyProperties.</summary>
    public VkQueueFamilyProperties    queueFamilyProperties;
}
// Struct: 350
/// <summary>VkRayTracingPipelineCreateInfoNV - Structure specifying parameters of a newly created ray tracing pipeline
/// <para>The parameters basePipelineHandle and basePipelineIndex aredescribed in more detail in PipelineDerivatives.</para>
/// <para>  If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BITflag, and basePipelineIndex is -1, basePipelineHandle must be a valid handle to a ray tracing VkPipeline </para>
/// <para>  If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BITflag, and basePipelineHandle is VK_NULL_HANDLE,basePipelineIndex must be a valid index into the callingcommand’s pCreateInfos parameter</para>
/// <para>  If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BITflag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE </para>
/// <para>  If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BITflag, and basePipelineHandle is not VK_NULL_HANDLE,basePipelineIndex must be -1 </para>
/// <para>  The stage member of one element of pStages must beVK_SHADER_STAGE_RAYGEN_BIT_NV </para>
/// <para>  The shader code for the entry points identified by pStages, andthe rest of the state identified by this structure must adhere to thepipeline linking rules described in the Shader Interfaceschapter</para>
/// <para>   layout must beconsistent with allshaders specified in pStages </para>
/// <para>  The number of resources in layout accessible to each shader stagethat is used by the pipeline must be less than or equal toVkPhysicalDeviceLimits::maxPerStageResources </para>
/// <para>   maxRecursionDepth must be less than or equal toVkPhysicalDeviceRayTracingPropertiesNV::maxRecursionDepth </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkPipelineCreationFeedbackCreateInfoEXT </para>
/// <para>   flags must be a valid combination of VkPipelineCreateFlagBits values</para>
/// <para>   pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures</para>
/// <para>   pGroups must be a valid pointer to an array of groupCount valid VkRayTracingShaderGroupCreateInfoNV structures</para>
/// <para>   layout must be a valid VkPipelineLayout handle</para>
/// <para>   stageCount must be greater than 0 </para>
/// <para>   groupCount must be greater than 0 </para>
/// <para>   Both of basePipelineHandle, and layout that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkRayTracingPipelineCreateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                   pNext;
    /// <summary> flags is a bitmask of VkPipelineCreateFlagBits specifying
    /// how the pipeline will be generated.</summary>
    public VkPipelineCreateFlags                         flags;
    /// <summary> stageCount is the number of entries in the pStages array.</summary>
    public UInt32                                      stageCount;
    /// <summary> pStages is an array of size stageCount structures of type
    /// VkPipelineShaderStageCreateInfo describing the set of the shader
    /// stages to be included in the ray tracing pipeline.</summary>
    public /* const */ VkPipelineShaderStageCreateInfo*        pStages;
    /// <summary> groupCount is the number of entries in the pGroups array.</summary>
    public UInt32                                      groupCount;
    /// <summary> pGroups is an array of size groupCount structures of type
    /// VkRayTracingShaderGroupCreateInfoNV describing the set of the
    /// shader stages to be included in each shader group in the ray tracing
    /// pipeline.</summary>
    public /* const */ VkRayTracingShaderGroupCreateInfoNV*    pGroups;
    /// <summary> maxRecursionDepth is the maximum recursion that will be called
    /// from this pipeline.</summary>
    public UInt32                                      maxRecursionDepth;
    /// <summary> layout is the description of binding locations used by both the
    /// pipeline and descriptor sets used with the pipeline.</summary>
    public VkPipelineLayout                              layout;
    /// <summary> basePipelineHandle is a pipeline to derive from.</summary>
    public VkPipeline                                    basePipelineHandle;
    /// <summary> basePipelineIndex is an index into the pCreateInfos
    /// parameter to use as a pipeline to derive from.</summary>
    public Int32                                       basePipelineIndex;
}
// Struct: 351
/// <summary>VkRayTracingShaderGroupCreateInfoNV - Structure specifying shaders in a shader group
/// <para>  If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV thengeneralShader must be a valid index into pStages referringto a shader of VK_SHADER_STAGE_RAYGEN_BIT_NV,VK_SHADER_STAGE_MISS_BIT_NV, orVK_SHADER_STAGE_CALLABLE_BIT_NV </para>
/// <para>  If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV thenclosestHitShader, anyHitShader, and intersectionShader must be VK_SHADER_UNUSED_NV </para>
/// <para>  If type isVK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV thenintersectionShader must be a valid index into pStagesreferring to a shader of VK_SHADER_STAGE_INTERSECTION_BIT_NV </para>
/// <para>  If type isVK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV thenintersectionShader must be VK_SHADER_UNUSED_NV </para>
/// <para>   closestHitShader must be either VK_SHADER_UNUSED_NV or avalid index into pStages referring to a shader ofVK_SHADER_STAGE_CLOSEST_HIT_BIT_NV </para>
/// <para>   anyHitShader must be either VK_SHADER_UNUSED_NV or a validindex into pStages referring to a shader ofVK_SHADER_STAGE_ANY_HIT_BIT_NV </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV </para>
/// <para>   pNext must be NULL </para>
/// <para>   type must be a valid VkRayTracingShaderGroupTypeNV value</para>
/// </summary>
public unsafe struct VkRayTracingShaderGroupCreateInfoNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                  sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                      pNext;
    /// <summary> type is the type of hit group specified in this structure.</summary>
    public VkRayTracingShaderGroupTypeNV    type;
    /// <summary> generalShader is the index of the ray generation, miss, or
    /// callable shader from
    /// VkRayTracingPipelineCreateInfoNV::pStages in the group if
    /// the shader group has type of
    /// VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV and
    /// VK_SHADER_UNUSED_NV otherwise.</summary>
    public UInt32                         generalShader;
    /// <summary> closestHitShader is the optional index of the closest hit shader
    /// from VkRayTracingPipelineCreateInfoNV::pStages in the group
    /// if the shader group has type of
    /// VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV or
    /// VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV and
    /// VK_SHADER_UNUSED_NV otherwise.</summary>
    public UInt32                         closestHitShader;
    /// <summary> anyHitShader is the optional index of the any-hit shader from
    /// VkRayTracingPipelineCreateInfoNV::pStages in the group if
    /// the shader group has type of
    /// VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV or
    /// VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV and
    /// VK_SHADER_UNUSED_NV otherwise.</summary>
    public UInt32                         anyHitShader;
    /// <summary> intersectionShader is the index of the intersection shader from
    /// VkRayTracingPipelineCreateInfoNV::pStages in the group if
    /// the shader group has type of
    /// VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV and
    /// VK_SHADER_UNUSED_NV otherwise.</summary>
    public UInt32                         intersectionShader;
}
// Struct: 352
/// <summary>VkRect2D - Structure specifying a two-dimensional subregion
/// </summary>
public unsafe struct VkRect2D {
    /// <summary> offset is a VkOffset2D specifying the rectangle offset.</summary>
    public VkOffset2D    offset;
    /// <summary> extent is a VkExtent2D specifying the rectangle extent.</summary>
    public VkExtent2D    extent;
}
// Struct: 353
/// <summary>VkRectLayerKHR - Structure containing a rectangle, including layer, changed by vkQueuePresentKHR for a given VkImage
/// <para>  The sum of offset and extent must be no greater than theimageExtent member of the VkSwapchainCreateInfoKHR structuregiven to vkCreateSwapchainKHR.</para>
/// <para>   layer must be less than imageArrayLayers member of theVkSwapchainCreateInfoKHR structure given tovkCreateSwapchainKHR.</para>
/// <para>Some platforms allow the size of a surface to change, and then scale thepixels of the image to fit the surface.VkRectLayerKHR specifies pixels of the swapchain’s image(s), whichwill be constant for the life of the swapchain.</para>
/// </summary>
public unsafe struct VkRectLayerKHR {
    /// <summary> offset is the origin of the rectangle, in pixels.</summary>
    public VkOffset2D    offset;
    /// <summary> extent is the size of the rectangle, in pixels.</summary>
    public VkExtent2D    extent;
    /// <summary> layer is the layer of the image.
    /// For images with only one layer, the value of layer must be 0.</summary>
    public UInt32      layer;
}
// Struct: 354
/// <summary>VkRefreshCycleDurationGOOGLE - Structure containing the RC duration of a display
/// </summary>
public unsafe struct VkRefreshCycleDurationGOOGLE {
    /// <summary> refreshDuration is the number of nanoseconds from the start of one
    /// refresh cycle to the next.</summary>
    public UInt64    refreshDuration;
}
// Struct: 355
/// <summary>VkRenderPassBeginInfo - Structure specifying render pass begin info
/// <para> renderArea is the render area that is affected by the render passinstance.The effects of attachment load, store and multisample resolve operations arerestricted to the pixels whose x and y coordinates fall within the renderarea on all attachments.The render area extends to all layers of framebuffer.The application must ensure (using scissor if necessary) that all renderingis contained within the render area.The render area must be contained within the framebuffer dimensions.</para>
/// <para>When multiview is enabled, the resolve operation at the end of a subpassapplies to all views in the view mask.</para>
/// <para>There may be a performance cost for using a render area smaller than theframebuffer, unless it matches the render area granularity for the renderpass.</para>
/// <para>   clearValueCount must be greater than the largest attachment indexin renderPass that specifies a loadOp (orstencilLoadOp, if the attachment has a depth/stencil format) ofVK_ATTACHMENT_LOAD_OP_CLEAR </para>
/// <para>   renderPass must be compatible withthe renderPass member of the VkFramebufferCreateInfostructure specified when creating framebuffer.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupRenderPassBeginInfo or VkRenderPassSampleLocationsBeginInfoEXT </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   renderPass must be a valid VkRenderPass handle</para>
/// <para>   framebuffer must be a valid VkFramebuffer handle</para>
/// <para>   If clearValueCount is not 0, pClearValues must be a valid pointer to an array of clearValueCount VkClearValue unions</para>
/// <para>   Both of framebuffer, and renderPass must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkRenderPassBeginInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType        sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*            pNext;
    /// <summary> renderPass is the render pass to begin an instance of.</summary>
    public VkRenderPass           renderPass;
    /// <summary> framebuffer is the framebuffer containing the attachments that are
    /// used with the render pass.</summary>
    public VkFramebuffer          framebuffer;
    /// <summary> renderArea is the render area that is affected by the render pass
    /// instance, and is described in more detail below.</summary>
    public VkRect2D               renderArea;
    /// <summary> clearValueCount is the number of elements in pClearValues.</summary>
    public UInt32               clearValueCount;
    /// <summary> pClearValues is an array of VkClearValue structures that
    /// contains clear values for each attachment, if the attachment uses a
    /// loadOp value of VK_ATTACHMENT_LOAD_OP_CLEAR or if the
    /// attachment has a depth/stencil format and uses a stencilLoadOp
    /// value of VK_ATTACHMENT_LOAD_OP_CLEAR.
    /// The array is indexed by attachment number.
    /// Only elements corresponding to cleared attachments are used.
    /// Other elements of pClearValues are ignored.</summary>
    public /* const */ VkClearValue*    pClearValues;
}
// Struct: 356
/// <summary>VkRenderPassCreateInfo - Structure specifying parameters of a newly created render pass
/// <para>Care should be taken to avoid a data race here; if any subpasses accessattachments with overlapping memory locations, and one of those accesses isa write, a subpass dependency needs to be included between them.</para>
/// <para>  If the attachment member of any element ofpInputAttachments, pColorAttachments,pResolveAttachments or pDepthStencilAttachment, or anyelement of pPreserveAttachments in any element of pSubpassesis not VK_ATTACHMENT_UNUSED, it must be less thanattachmentCount </para>
/// <para>  For any member of pAttachments with a loadOp equal toVK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachmentmust not specify a layout equal toVK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL orVK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL.</para>
/// <para>  For any member of pAttachments with a stencilLoadOp equal toVK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachmentmust not specify a layout equal toVK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL orVK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL.</para>
/// <para>  For any member of pAttachments with a loadOp equal toVK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachmentmust not specify a layout equal toVK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL.</para>
/// <para>  For any member of pAttachments with a stencilLoadOp equal toVK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachmentmust not specify a layout equal toVK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL.</para>
/// <para>  If the pNext chain includes an instance ofVkRenderPassInputAttachmentAspectCreateInfo, the subpassmember of each element of its pAspectReferences member must beless than subpassCount </para>
/// <para>  If the pNext chain includes an instance ofVkRenderPassInputAttachmentAspectCreateInfo, theinputAttachmentIndex member of each element of itspAspectReferences member must be less than the value ofinputAttachmentCount in the member of pSubpasses identifiedby its subpass member</para>
/// <para>  If the pNext chain includes an instance ofVkRenderPassInputAttachmentAspectCreateInfo, for any element ofthe pInputAttachments member of any element of pSubpasseswhere the attachment member is not VK_ATTACHMENT_UNUSED, theaspectMask member of the corresponding element ofVkRenderPassInputAttachmentAspectCreateInfo::pAspectReferences must only include aspects that are present in images of the formatspecified by the element of pAttachments at attachment </para>
/// <para>  If the pNext chain includes an instance ofVkRenderPassMultiviewCreateInfo, and its subpassCount memberis not zero, that member must be equal to the value ofsubpassCount </para>
/// <para>  If the pNext chain includes an instance ofVkRenderPassMultiviewCreateInfo, if its dependencyCountmember is not zero, it must be equal to dependencyCount </para>
/// <para>  If the pNext chain includes an instance ofVkRenderPassMultiviewCreateInfo, for each non-zero element ofpViewOffsets, the srcSubpass and dstSubpass members ofpDependencies at the same index must not be equal</para>
/// <para>  If the pNext chain includes an instance ofVkRenderPassMultiviewCreateInfo, for any element ofpDependencies with a dependencyFlags member that does notinclude VK_DEPENDENCY_VIEW_LOCAL_BIT, the corresponding element ofthe pViewOffsets member of thatVkRenderPassMultiviewCreateInfo instance must be 0 </para>
/// <para>  If the pNext chain includes an instance ofVkRenderPassMultiviewCreateInfo, elements of its pViewMasksmember must either all be 0, or all not be 0 </para>
/// <para>  If the pNext chain includes an instance ofVkRenderPassMultiviewCreateInfo, and each element of itspViewMasks member is 0, the dependencyFlags member of eachelement of pDependencies must not includeVK_DEPENDENCY_VIEW_LOCAL_BIT </para>
/// <para>  If the pNext chain includes an instance ofVkRenderPassMultiviewCreateInfo, and each element of itspViewMasks member is 0, correlatedViewMaskCount must be0 </para>
/// <para>  If the pNext chain includes an instance ofVkRenderPassMultiviewCreateInfo, each element of itspViewMask member must not include a bit at a position greaterthan the value ofVkPhysicalDeviceLimits::maxFramebufferLayers </para>
/// <para>  For any element of pDependencies, if the srcSubpass is notVK_SUBPASS_EXTERNAL, all stage flags included in thesrcStageMask member of that dependency must be a pipeline stagesupported by the pipelineidentified by the pipelineBindPoint member of the source subpass</para>
/// <para>  For any element of pDependencies, if the dstSubpass is notVK_SUBPASS_EXTERNAL, all stage flags included in thedstStageMask member of that dependency must be a pipeline stagesupported by the pipelineidentified by the pipelineBindPoint member of the source subpass</para>
/// <para>  The srcSubpass member of each element of pDependencies mustbe less than subpassCount </para>
/// <para>  The dstSubpass member of each element of pDependencies mustbe less than subpassCount </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkRenderPassFragmentDensityMapCreateInfoEXT, VkRenderPassInputAttachmentAspectCreateInfo, or VkRenderPassMultiviewCreateInfo </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkAttachmentDescription structures</para>
/// <para>   pSubpasses must be a valid pointer to an array of subpassCount valid VkSubpassDescription structures</para>
/// <para>   If dependencyCount is not 0, pDependencies must be a valid pointer to an array of dependencyCount valid VkSubpassDependency structures</para>
/// <para>   subpassCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkRenderPassCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                   sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                       pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkRenderPassCreateFlags           flags;
    /// <summary> attachmentCount is the number of attachments used by this render
    /// pass.</summary>
    public UInt32                          attachmentCount;
    /// <summary> pAttachments points to an array of attachmentCount VkAttachmentDescription structures describing the attachments used
    /// by the render pass.</summary>
    public /* const */ VkAttachmentDescription*    pAttachments;
    /// <summary> subpassCount is the number of subpasses to create.</summary>
    public UInt32                          subpassCount;
    /// <summary> pSubpasses points to an array of subpassCount VkSubpassDescription structures describing each subpass.</summary>
    public /* const */ VkSubpassDescription*       pSubpasses;
    /// <summary> dependencyCount is the number of memory dependencies between pairs
    /// of subpasses.</summary>
    public UInt32                          dependencyCount;
    /// <summary> pDependencies points to an array of dependencyCount VkSubpassDependency structures describing dependencies between
    /// pairs of subpasses.</summary>
    public /* const */ VkSubpassDependency*        pDependencies;
}
// Struct: 357
/// <summary>VkRenderPassCreateInfo2KHR - Structure specifying parameters of a newly created render pass
/// <para>Parameters defined by this structure with the same name as those inVkRenderPassCreateInfo have the identical effect to those parameters;the child structures are variants of those used inVkRenderPassCreateInfo which include sType and pNextparameters, allowing them to be extended.</para>
/// <para>If the VkSubpassDescription2KHR::viewMask member of any elementof pSubpasses is not zero, multiview functionality is considered tobe enabled for this render pass.</para>
/// <para> correlatedViewMaskCount and pCorrelatedViewMasks have the sameeffect as VkRenderPassMultiviewCreateInfo::correlationMaskCountand VkRenderPassMultiviewCreateInfo::pCorrelationMasks,respectively.</para>
/// <para>  If any two subpasses operate on attachments with overlapping ranges ofthe same VkDeviceMemory object, and at least one subpass writes tothat area of VkDeviceMemory, a subpass dependency must beincluded (either directly or via some intermediate subpasses) betweenthem</para>
/// <para>  If the attachment member of any element ofpInputAttachments, pColorAttachments,pResolveAttachments or pDepthStencilAttachment, or theattachment indexed by any element of pPreserveAttachments in anygiven element of pSubpasses is bound to a range of aVkDeviceMemory object that overlaps with any other attachment inany subpass (including the same subpass), theVkAttachmentDescription2KHR structures describing them mustinclude VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT in flags </para>
/// <para>  If the attachment member of any element ofpInputAttachments, pColorAttachments,pResolveAttachments or pDepthStencilAttachment, or anyelement of pPreserveAttachments in any given element ofpSubpasses is not VK_ATTACHMENT_UNUSED, it must be lessthan attachmentCount </para>
/// <para>  For any member of pAttachments with a loadOp equal toVK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachmentmust not specify a layout equal toVK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, orVK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL </para>
/// <para>  For any member of pAttachments with a stencilLoadOp equal toVK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachmentmust not specify a layout equal toVK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, orVK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL.</para>
/// <para>  For any element of pDependencies, if the srcSubpass is notVK_SUBPASS_EXTERNAL, all stage flags included in thesrcStageMask member of that dependency must be a pipeline stagesupported by the pipelineidentified by the pipelineBindPoint member of the source subpass.</para>
/// <para>  For any element of pDependencies, if the dstSubpass is notVK_SUBPASS_EXTERNAL, all stage flags included in thedstStageMask member of that dependency must be a pipeline stagesupported by the pipelineidentified by the pipelineBindPoint member of the source subpass.</para>
/// <para>  The set of bits included in any element of pCorrelatedViewMasks must not overlap with the set of bits included in any other element ofpCorrelatedViewMasks </para>
/// <para>  If the VkSubpassDescription2KHR::viewMask member of allelements of pSubpasses is 0, correlatedViewMaskCount mustbe 0 </para>
/// <para>  The VkSubpassDescription2KHR::viewMask member of allelements of pSubpasses must either all be 0, or all not be 0 </para>
/// <para>  If the VkSubpassDescription2KHR::viewMask member of allelements of pSubpasses is 0, the dependencyFlags member ofany element of pDependencies must not includeVK_DEPENDENCY_VIEW_LOCAL_BIT </para>
/// <para>  For any element of pDependencies where its srcSubpass memberequals its dstSubpass member, if the viewMask member of thecorresponding element of pSubpasses includes more than one bit,its dependencyFlags member must includeVK_DEPENDENCY_VIEW_LOCAL_BIT </para>
/// <para>  The viewMask member must not include a bit at a position greaterthan the value ofVkPhysicalDeviceLimits::maxFramebufferLayers </para>
/// <para>  If the attachment member of any element of thepInputAttachments member of any element of pSubpasses is notVK_ATTACHMENT_UNUSED, the aspectMask member of that elementof pInputAttachments must only include aspects that are presentin images of the format specified by the element of pAttachmentsspecified by attachment </para>
/// <para>  The srcSubpass member of each element of pDependencies mustbe less than subpassCount </para>
/// <para>  The dstSubpass member of each element of pDependencies mustbe less than subpassCount </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkAttachmentDescription2KHR structures</para>
/// <para>   pSubpasses must be a valid pointer to an array of subpassCount valid VkSubpassDescription2KHR structures</para>
/// <para>   If dependencyCount is not 0, pDependencies must be a valid pointer to an array of dependencyCount valid VkSubpassDependency2KHR structures</para>
/// <para>   If correlatedViewMaskCount is not 0, pCorrelatedViewMasks must be a valid pointer to an array of correlatedViewMaskCount uint32_t values</para>
/// <para>   subpassCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkRenderPassCreateInfo2KHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                           pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkRenderPassCreateFlags               flags;
    /// <summary> attachmentCount is the number of attachments used by this render
    /// pass.</summary>
    public UInt32                              attachmentCount;
    /// <summary> pAttachments points to an array of attachmentCount VkAttachmentDescription2KHR structures describing the attachments
    /// used by the render pass.</summary>
    public /* const */ VkAttachmentDescription2KHR*    pAttachments;
    /// <summary> subpassCount is the number of subpasses to create.</summary>
    public UInt32                              subpassCount;
    /// <summary> pSubpasses points to an array of subpassCount VkSubpassDescription2KHR structures describing each subpass.</summary>
    public /* const */ VkSubpassDescription2KHR*       pSubpasses;
    /// <summary> dependencyCount is the number of dependencies between pairs of
    /// subpasses.</summary>
    public UInt32                              dependencyCount;
    /// <summary> pDependencies points to an array of dependencyCount VkSubpassDependency2KHR structures describing dependencies between
    /// pairs of subpasses.</summary>
    public /* const */ VkSubpassDependency2KHR*        pDependencies;
    /// <summary> correlatedViewMaskCount is the number of correlation masks.</summary>
    public UInt32                              correlatedViewMaskCount;
    /// <summary> pCorrelatedViewMasks is an array of view masks indicating sets of
    /// views that may be more efficient to render concurrently.</summary>
    public /* const */ UInt32*                       pCorrelatedViewMasks;
}
// Struct: 358
/// <summary>VkRenderPassFragmentDensityMapCreateInfoEXT - Structure containing fragment density map attachment for render pass
/// <para>The fragment density map attachment is read at an implementation-dependenttime either by the host during vkCmdBeginRenderPass if theattachment’s image view was not created with flags containingVK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT, or by thedevice when drawing commands in the renderpass executeVK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT.</para>
/// <para>If this structure is not present, it is as iffragmentDensityMapAttachment was given as VK_ATTACHMENT_UNUSED.</para>
/// <para>  If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED,fragmentDensityMapAttachment must be less thanVkRenderPassCreateInfo::attachmentCount </para>
/// <para>  If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED,fragmentDensityMapAttachment must not be an element ofVkSubpassDescription::pInputAttachments,VkSubpassDescription::pColorAttachments,VkSubpassDescription::pResolveAttachments,VkSubpassDescription::pDepthStencilAttachment, orVkSubpassDescription::pPreserveAttachments for any subpass</para>
/// <para>  If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED,layout must be equal toVK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT, orVK_IMAGE_LAYOUT_GENERAL </para>
/// <para>  If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED,fragmentDensityMapAttachment must reference an attachment with aloadOp equal to VK_ATTACHMENT_LOAD_OP_LOAD orVK_ATTACHMENT_LOAD_OP_DONT_CARE.</para>
/// <para>  If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED,fragmentDensityMapAttachment must reference an attachment with astoreOp equal to VK_ATTACHMENT_STORE_OP_DONT_CARE.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT </para>
/// <para>   fragmentDensityMapAttachment must be a valid VkAttachmentReference structure</para>
/// </summary>
public unsafe struct VkRenderPassFragmentDensityMapCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*              pNext;
    /// <summary> fragmentDensityMapAttachment is the fragment density map to use
    /// for the render pass.</summary>
    public VkAttachmentReference    fragmentDensityMapAttachment;
}
// Struct: 359
/// <summary>VkRenderPassInputAttachmentAspectCreateInfo - Structure specifying, for a given subpass/input attachment pair, which aspect <strong class="purple">can</strong> be read.
/// <para>   sType must be VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO </para>
/// <para>   pAspectReferences must be a valid pointer to an array of aspectReferenceCount valid VkInputAttachmentAspectReference structures</para>
/// <para>   aspectReferenceCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkRenderPassInputAttachmentAspectCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                pNext;
    /// <summary> aspectReferenceCount is the number of elements in the
    /// pAspectReferences array.</summary>
    public UInt32                                   aspectReferenceCount;
    /// <summary> pAspectReferences points to an array of aspectReferenceCount
    /// number of VkInputAttachmentAspectReference structures describing
    /// which aspect(s) can be accessed for a given input attachment within a
    /// given subpass.</summary>
    public /* const */ VkInputAttachmentAspectReference*    pAspectReferences;
}
// Struct: 360
/// <summary>VkRenderPassMultiviewCreateInfo - Structure containing multiview info for all subpasses
/// <para>When a subpass uses a non-zero view mask, multiview functionality isconsidered to be enabled.Multiview is all-or-nothing for a render pass - that is, either allsubpasses must have a non-zero view mask (though some subpasses may haveonly one view) or all must be zero.Multiview causes all drawing and clear commands in the subpass to behave asif they were broadcast to each view, where a view is represented by onelayer of the framebuffer attachments.All draws and clears are broadcast to each view index whose bit is set inthe view mask.The view index is provided in the ViewIndex shader input variable, andcolor, depth/stencil, and input attachments all read/write the layer of theframebuffer corresponding to the view index.</para>
/// <para>If the view mask is zero for all subpasses, multiview is considered to bedisabled and all drawing commands execute normally, without this additionalbroadcasting.</para>
/// <para>Some implementations may not support multiview in conjunction withgeometry shaders ortessellation shaders.</para>
/// <para>When multiview is enabled, the VK_DEPENDENCY_VIEW_LOCAL_BIT bit in adependency can be used to express a view-local dependency, meaning thateach view in the destination subpass depends on a single view in the sourcesubpass.Unlike pipeline barriers, a subpass dependency can potentially have adifferent view mask in the source subpass and the destination subpass.If the dependency is view-local, then each view (dstView) in thedestination subpass depends on the view dstView + pViewOffsets[dependency] in the source subpass.If there is not such a view in the source subpass, then this dependency doesnot affect that view in the destination subpass.If the dependency is not view-local, then all views in the destinationsubpass depend on all views in the source subpass, and the view offset isignored.A non-zero view offset is not allowed in a self-dependency.</para>
/// <para>The elements of pCorrelationMasks are a set of masks of viewsindicating that views in the same mask may exhibit spatial coherencybetween the views, making it more efficient to render them concurrently.Correlation masks must not have a functional effect on the results of themultiview rendering.</para>
/// <para>When multiview is enabled, at the beginning of each subpass all non-renderpass state is undefined.In particular, each time vkCmdBeginRenderPass orvkCmdNextSubpass is called the graphics pipeline must be bound, anyrelevant descriptor sets or vertex/index buffers must be bound, and anyrelevant dynamic state or push constants must be set before they are used.</para>
/// <para>A multiview subpass can declare that its shaders will write per-viewattributes for all views in a single invocation, by setting theVK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX bit in the subpassdescription.The only supported per-view attributes are position and viewport mask, andper-view position and viewport masks are written to output array variablesdecorated with PositionPerViewNV and ViewportMaskPerViewNV,respectively.If  html/vkspec.html#VK_NV_viewport_array2  is not supported and enabled,ViewportMaskPerViewNV must not be used.Values written to elements of PositionPerViewNV andViewportMaskPerViewNV must not depend on the ViewIndex.The shader must also write to an output variable decorated withPosition, and the value written to Position must equal the valuewritten to PositionPerViewNV[ViewIndex].Similarly, if ViewportMaskPerViewNV is written to then the shader mustalso write to an output variable decorated with ViewportMaskNV, and thevalue written to ViewportMaskNV must equal the value written toViewportMaskPerViewNV[ViewIndex].Implementations will either use values taken from Position andViewportMaskNV and invoke the shader once for each view, or will usevalues taken from PositionPerViewNV and ViewportMaskPerViewNV andinvoke the shader fewer times.The values written to Position and ViewportMaskNV must not dependon the values written to PositionPerViewNV andViewportMaskPerViewNV, or vice versa (to allow compilers to eliminatethe unused outputs).All attributes that do not have *PerViewNV counterparts must not dependon ViewIndex.</para>
/// <para>Per-view attributes are all-or-nothing for a subpass.That is, all pipelines compiled against a subpass that includes theVK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX bit must writeper-view attributes to the *PerViewNV[] shader outputs, in addition to thenon-per-view (e.g. Position) outputs.Pipelines compiled against a subpass that does not include this bit mustnot include the *PerViewNV[] outputs in their interfaces.</para>
/// <para>  Each view index must not be set in more than one element ofpCorrelationMasks </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO </para>
/// <para>   If subpassCount is not 0, pViewMasks must be a valid pointer to an array of subpassCount uint32_t values</para>
/// <para>   If dependencyCount is not 0, pViewOffsets must be a valid pointer to an array of dependencyCount int32_t values</para>
/// <para>   If correlationMaskCount is not 0, pCorrelationMasks must be a valid pointer to an array of correlationMaskCount uint32_t values</para>
/// </summary>
public unsafe struct VkRenderPassMultiviewCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> subpassCount is zero or is the number of subpasses in the render
    /// pass.</summary>
    public UInt32           subpassCount;
    /// <summary> pViewMasks points to an array of subpassCount number of view
    /// masks, where each mask is a bitfield of view indices describing which
    /// views rendering is broadcast to in each subpass, when multiview is
    /// enabled.
    /// If subpassCount is zero, each view mask is treated as zero.</summary>
    public /* const */ UInt32*    pViewMasks;
    /// <summary> dependencyCount is zero or the number of dependencies in the
    /// render pass.</summary>
    public UInt32           dependencyCount;
    /// <summary> pViewOffsets points to an array of dependencyCount view
    /// offsets, one for each dependency.
    /// If dependencyCount is zero, each dependency’s view offset is
    /// treated as zero.
    /// Each view offset controls which views in the source subpass the views in
    /// the destination subpass depend on.</summary>
    public /* const */ Int32*     pViewOffsets;
    /// <summary> correlationMaskCount is zero or a number of correlation masks.</summary>
    public UInt32           correlationMaskCount;
    /// <summary> pCorrelationMasks is an array of view masks indicating sets of
    /// views that may be more efficient to render concurrently.</summary>
    public /* const */ UInt32*    pCorrelationMasks;
}
// Struct: 361
/// <summary>VkRenderPassSampleLocationsBeginInfoEXT - Structure specifying sample locations to use for the layout transition of custom sample locations compatible depth/stencil attachments
/// <para>   sType must be VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT </para>
/// <para>   If attachmentInitialSampleLocationsCount is not 0, pAttachmentInitialSampleLocations must be a valid pointer to an array of attachmentInitialSampleLocationsCount valid VkAttachmentSampleLocationsEXT structures</para>
/// <para>   If postSubpassSampleLocationsCount is not 0, pPostSubpassSampleLocations must be a valid pointer to an array of postSubpassSampleLocationsCount valid VkSubpassSampleLocationsEXT structures</para>
/// </summary>
public unsafe struct VkRenderPassSampleLocationsBeginInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                              pNext;
    /// <summary> attachmentInitialSampleLocationsCount is the number of elements in
    /// the pAttachmentInitialSampleLocations array.</summary>
    public UInt32                                 attachmentInitialSampleLocationsCount;
    /// <summary> pAttachmentInitialSampleLocations is an array of
    /// attachmentInitialSampleLocationsCount VkAttachmentSampleLocationsEXT structures specifying the
    /// attachment indices and their corresponding sample location state.
    /// Each element of pAttachmentInitialSampleLocations can specify the
    /// sample location state to use in the automatic layout transition
    /// performed to transition a depth/stencil attachment from the initial
    /// layout of the attachment to the image layout specified for the
    /// attachment in the first subpass using it.</summary>
    public /* const */ VkAttachmentSampleLocationsEXT*    pAttachmentInitialSampleLocations;
    /// <summary> postSubpassSampleLocationsCount is the number of elements in the
    /// pPostSubpassSampleLocations array.</summary>
    public UInt32                                 postSubpassSampleLocationsCount;
    /// <summary> pPostSubpassSampleLocations is an array of
    /// postSubpassSampleLocationsCount VkSubpassSampleLocationsEXT
    /// structures specifying the subpass indices and their corresponding sample
    /// location state.
    /// Each element of pPostSubpassSampleLocations can specify the
    /// sample location state to use in the automatic layout transition
    /// performed to transition the depth/stencil attachment used by the
    /// specified subpass to the image layout specified in a dependent subpass
    /// or to the final layout of the attachment in case the specified subpass
    /// is the last subpass using that attachment.
    /// In addition, if
    /// VkPhysicalDeviceSampleLocationsPropertiesEXT::variableSampleLocations
    /// is VK_FALSE, each element of pPostSubpassSampleLocations must specify the sample location state that matches the sample
    /// locations used by all pipelines that will be bound to a command buffer
    /// during the specified subpass.
    /// If variableSampleLocations is VK_TRUE, the sample locations
    /// used for rasterization do not depend on
    /// pPostSubpassSampleLocations.</summary>
    public /* const */ VkSubpassSampleLocationsEXT*       pPostSubpassSampleLocations;
}
// Struct: 362
/// <summary>VkSampleLocationEXT - Structure specifying the coordinates of a sample location
/// <para>The domain space of the sample location coordinates has an upper-left originwithin the pixel in framebuffer space.</para>
/// <para>The values specified in a VkSampleLocationEXT structure are alwaysclamped to the implementation-dependent sample location coordinate range[sampleLocationCoordinateRange[0],sampleLocationCoordinateRange[1]]that can be queried by chaining theVkPhysicalDeviceSampleLocationsPropertiesEXT structure to thepNext chain of VkPhysicalDeviceProperties2.</para>
/// </summary>
public unsafe struct VkSampleLocationEXT {
    /// <summary> x is the horizontal coordinate of the sample’s location.</summary>
    public float    x;
    /// <summary> y is the vertical coordinate of the sample’s location.</summary>
    public float    y;
}
// Struct: 363
/// <summary>VkSampleLocationsInfoEXT - Structure specifying a set of sample locations
/// <para>This structure can be used either to specify the sample locations to beused for rendering or to specify the set of sample locations an imagesubresource has been last rendered with for the purposes of layouttransitions of depth/stencil images created withVK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT.</para>
/// <para>The sample locations in pSampleLocations specifysampleLocationsPerPixel number of sample locations for each pixel inthe grid of the size specified in sampleLocationGridSize.The sample location for sample i at the pixel grid location(x,y) is taken from  pSampleLocations[(x + y *sampleLocationGridSize.width) * sampleLocationsPerPixel + i].</para>
/// <para>If the render pass has a fragment density map, the implementation willchoose the sample locations for the fragment and the contents ofpSampleLocations may be ignored.</para>
/// <para>   sampleLocationsPerPixel must be a bit value that is set inVkPhysicalDeviceSampleLocationsPropertiesEXT::sampleLocationSampleCounts </para>
/// <para>   sampleLocationsCount must equal sampleLocationsPerPixel ×sampleLocationGridSize.width ×sampleLocationGridSize.height  </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT </para>
/// <para>   If sampleLocationsPerPixel is not 0, sampleLocationsPerPixel must be a valid VkSampleCountFlagBits value</para>
/// <para>   If sampleLocationsCount is not 0, pSampleLocations must be a valid pointer to an array of sampleLocationsCount VkSampleLocationEXT structures</para>
/// </summary>
public unsafe struct VkSampleLocationsInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                   pNext;
    /// <summary> sampleLocationsPerPixel is a VkSampleCountFlagBits
    /// specifying the number of sample locations per pixel.</summary>
    public VkSampleCountFlagBits         sampleLocationsPerPixel;
    /// <summary> sampleLocationGridSize is the size of the sample location grid to
    /// select custom sample locations for.</summary>
    public VkExtent2D                    sampleLocationGridSize;
    /// <summary> sampleLocationsCount is the number of sample locations in
    /// pSampleLocations.</summary>
    public UInt32                      sampleLocationsCount;
    /// <summary> pSampleLocations is an array of sampleLocationsCount VkSampleLocationEXT structures.</summary>
    public /* const */ VkSampleLocationEXT*    pSampleLocations;
}
// Struct: 364
/// <summary>VkSamplerCreateInfo - Structure specifying parameters of a newly created sampler
/// <para> magFilter values of VK_FILTER_NEAREST and VK_FILTER_LINEARdirectly correspond to GL_NEAREST and GL_LINEAR magnificationfilters.minFilter and mipmapMode combine to correspond to the similarlynamed OpenGL minification filter of GL_minFilter_MIPMAP_mipmapMode(e.g. minFilter of VK_FILTER_LINEAR and mipmapMode ofVK_SAMPLER_MIPMAP_MODE_NEAREST correspond toGL_LINEAR_MIPMAP_NEAREST).</para>
/// <para>There are no Vulkan filter modes that directly correspond to OpenGLminification filters of GL_LINEAR or GL_NEAREST, but they can beemulated using VK_SAMPLER_MIPMAP_MODE_NEAREST, minLod = 0, andmaxLod = 0.25, and using minFilter = VK_FILTER_LINEAR orminFilter = VK_FILTER_NEAREST, respectively.</para>
/// <para>Note that using a maxLod of zero would causemagnification to always be performed, and themagFilter to always be used.This is valid, just not an exact match for OpenGL behavior.Clamping the maximum LOD to 0.25 allows the λ value to benon-zero and minification to be performed, while still always rounding downto the base level.If the minFilter and magFilter are equal, then using amaxLod of zero also works.</para>
/// <para>The maximum number of sampler objects which can be simultaneously createdon a device is implementation-dependent and specified by themaxSamplerAllocationCount member of theVkPhysicalDeviceLimits structure.If maxSamplerAllocationCount is exceeded, vkCreateSampler willreturn VK_ERROR_TOO_MANY_OBJECTS.</para>
/// <para>Since VkSampler is a non-dispatchable handle type, implementationsmay return the same handle for sampler state vectors that are identical.In such cases, all such objects would only count once against themaxSamplerAllocationCount limit.</para>
/// <para>  The absolute value of mipLodBias must be less than or equal toVkPhysicalDeviceLimits::maxSamplerLodBias </para>
/// <para>   maxLod must be greater than or equal to minLod </para>
/// <para>  If the anisotropic sampling feature isnot enabled, anisotropyEnable must be VK_FALSE </para>
/// <para>  If anisotropyEnable is VK_TRUE, maxAnisotropy must bebetween 1.0 andVkPhysicalDeviceLimits::maxSamplerAnisotropy, inclusive</para>
/// <para>  If sampler Y’CBCR conversion isenabled andVK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BITis not set for the format, minFilter and magFilter must beequal to the sampler Y’CBCR conversion’s chromaFilter </para>
/// <para>  If unnormalizedCoordinates is VK_TRUE, minFilter andmagFilter must be equal</para>
/// <para>  If unnormalizedCoordinates is VK_TRUE, mipmapMode must be VK_SAMPLER_MIPMAP_MODE_NEAREST </para>
/// <para>  If unnormalizedCoordinates is VK_TRUE, minLod andmaxLod must be zero</para>
/// <para>  If unnormalizedCoordinates is VK_TRUE, addressModeUand addressModeV must each be eitherVK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE orVK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER </para>
/// <para>  If unnormalizedCoordinates is VK_TRUE,anisotropyEnable must be VK_FALSE </para>
/// <para>  If unnormalizedCoordinates is VK_TRUE, compareEnable must be VK_FALSE </para>
/// <para>  If any of addressModeU, addressModeV or addressModeWare VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER, borderColor must be a valid VkBorderColor value</para>
/// <para>  If sampler Y’CBCR conversion isenabled, addressModeU, addressModeV, and addressModeW must be VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,anisotropyEnable must be VK_FALSE, andunnormalizedCoordinates must be VK_FALSE </para>
/// <para>  The sampler reduction mode must be set toVK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT ifsampler Y’CBCR conversion is enabled</para>
/// <para>  If the  html/vkspec.html#VK_KHR_sampler_mirror_clamp_to_edge  extension is notenabled, addressModeU, addressModeV and addressModeW must not be VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE </para>
/// <para>  If compareEnable is VK_TRUE, compareOp must be avalid VkCompareOp value</para>
/// <para>  If either magFilter or minFilter isVK_FILTER_CUBIC_EXT, anisotropyEnable must beVK_FALSE </para>
/// <para>  If compareEnable is VK_TRUE, the reductionMode memberof VkSamplerReductionModeCreateInfoEXT must beVK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT </para>
/// <para>  If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, thenminFilter and magFilter must be equal.</para>
/// <para>  If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, thenmipmapMode must be VK_SAMPLER_MIPMAP_MODE_NEAREST.</para>
/// <para>  If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, thenminLod and maxLod must be zero.</para>
/// <para>  If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, thenaddressModeU and addressModeV must each be eitherVK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE orVK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER.</para>
/// <para>  If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, thenanisotropyEnable must be VK_FALSE.</para>
/// <para>  If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, thencompareEnable must be VK_FALSE.</para>
/// <para>  If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, thenunnormalizedCoordinates must be VK_FALSE.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkSamplerReductionModeCreateInfoEXT or VkSamplerYcbcrConversionInfo </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   flags must be a valid combination of VkSamplerCreateFlagBits values</para>
/// <para>   magFilter must be a valid VkFilter value</para>
/// <para>   minFilter must be a valid VkFilter value</para>
/// <para>   mipmapMode must be a valid VkSamplerMipmapMode value</para>
/// <para>   addressModeU must be a valid VkSamplerAddressMode value</para>
/// <para>   addressModeV must be a valid VkSamplerAddressMode value</para>
/// <para>   addressModeW must be a valid VkSamplerAddressMode value</para>
/// </summary>
public unsafe struct VkSamplerCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType         sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*             pNext;
    /// <summary> flags is a bitmask of VkSamplerCreateFlagBits describing
    /// additional parameters of the sampler.</summary>
    public VkSamplerCreateFlags    flags;
    /// <summary> magFilter is a VkFilter value specifying the magnification
    /// filter to apply to lookups.</summary>
    public VkFilter                magFilter;
    /// <summary> minFilter is a VkFilter value specifying the minification
    /// filter to apply to lookups.</summary>
    public VkFilter                minFilter;
    /// <summary> mipmapMode is a VkSamplerMipmapMode value specifying the
    /// mipmap filter to apply to lookups.</summary>
    public VkSamplerMipmapMode     mipmapMode;
    /// <summary> addressModeU is a VkSamplerAddressMode value specifying the
    /// addressing mode for outside [0..1] range for U coordinate.</summary>
    public VkSamplerAddressMode    addressModeU;
    /// <summary> addressModeV is a VkSamplerAddressMode value specifying the
    /// addressing mode for outside [0..1] range for V coordinate.</summary>
    public VkSamplerAddressMode    addressModeV;
    /// <summary> addressModeW is a VkSamplerAddressMode value specifying the
    /// addressing mode for outside [0..1] range for W coordinate.</summary>
    public VkSamplerAddressMode    addressModeW;
    /// <summary>  
    ///   mipLodBias is the bias to be added to
    /// mipmap LOD (level-of-detail) calculation and bias provided by image
    /// sampling functions in SPIR-V, as described in the
    /// Level-of-Detail Operation
    /// section.</summary>
    public float                   mipLodBias;
    /// <summary>  
    ///   anisotropyEnable is VK_TRUE to
    /// enable anisotropic filtering, as described in the
    /// Texel Anisotropic Filtering
    /// section, or VK_FALSE otherwise.</summary>
    public VkBool32                anisotropyEnable;
    /// <summary> maxAnisotropy is the anisotropy value clamp used by the sampler
    /// when anisotropyEnable is VK_TRUE.
    /// If anisotropyEnable is VK_FALSE, maxAnisotropy is
    /// ignored.</summary>
    public float                   maxAnisotropy;
    /// <summary> compareEnable is VK_TRUE to enable comparison against a
    /// reference value during lookups, or VK_FALSE otherwise.</summary>
    public VkBool32                compareEnable;
    /// <summary> compareOp is a VkCompareOp value specifying the comparison
    /// function to apply to fetched data before filtering as described in the
    /// Depth Compare Operation section.</summary>
    public VkCompareOp             compareOp;
    /// <summary> minLod and maxLod are the values used to clamp the computed
    /// LOD value, as described in the Level-of-Detail Operation section.</summary>
    public float                   minLod;
    public float                   maxLod;
    /// <summary> borderColor is a VkBorderColor value specifying the
    /// predefined border color to use.</summary>
    public VkBorderColor           borderColor;
    /// <summary>  
    ///   unnormalizedCoordinates
    /// controls whether to use unnormalized or normalized texel coordinates to
    /// address texels of the image.
    /// When set to VK_TRUE, the range of the image coordinates used to
    /// lookup the texel is in the range of zero to the image dimensions for x,
    /// y and z.
    /// When set to VK_FALSE the range of image coordinates is zero to
    /// one.</summary>
    public VkBool32                unnormalizedCoordinates;
}
// Struct: 365
/// <summary>VkSamplerReductionModeCreateInfoEXT - Structure specifying sampler reduction mode
/// <para>If this structure is not present, reductionMode is considered to beVK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT </para>
/// <para>   reductionMode must be a valid VkSamplerReductionModeEXT value</para>
/// </summary>
public unsafe struct VkSamplerReductionModeCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType              sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                  pNext;
    /// <summary> reductionMode is an enum of type VkSamplerReductionModeEXT
    /// that controls how texture filtering combines texel values.</summary>
    public VkSamplerReductionModeEXT    reductionMode;
}
// Struct: 366
/// <summary>VkSamplerYcbcrConversionCreateInfo - Structure specifying the parameters of the newly created conversion
/// <para>Setting forceExplicitReconstruction to VK_TRUE may have aperformance penalty on implementations where explicit reconstruction is notthe default mode of operation.</para>
/// <para>If the pNext chain has an instance of VkExternalFormatANDROIDwith non-zero externalFormat member, the sampler Y’CBCR conversionobject represents an external format conversion, and format must beVK_FORMAT_UNDEFINED.Such conversions must only be used to sample image views with a matchingexternalformat.When creating an external format conversion, the value of componentsis ignored.</para>
/// <para>  If an external format conversion is being created, format must beVK_FORMAT_UNDEFINED, otherwise it must not beVK_FORMAT_UNDEFINED.</para>
/// <para>   format must supportVK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT orVK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT </para>
/// <para>  If the format does not supportVK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT, xChromaOffsetand yChromaOffset must not beVK_CHROMA_LOCATION_COSITED_EVEN </para>
/// <para>  If the format does not supportVK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT, xChromaOffsetand yChromaOffset must not be VK_CHROMA_LOCATION_MIDPOINT </para>
/// <para>   format must represent unsigned normalized values (i.e. the formatmust be a UNORM format)</para>
/// <para>  If the format has a _422 or _420 suffix, thencomponents.g must be VK_COMPONENT_SWIZZLE_IDENTITY </para>
/// <para>  If the format has a _422 or _420 suffix, thencomponents.a must be VK_COMPONENT_SWIZZLE_IDENTITY,VK_COMPONENT_SWIZZLE_ONE, or VK_COMPONENT_SWIZZLE_ZERO </para>
/// <para>  If the format has a _422 or _420 suffix, thencomponents.r must be VK_COMPONENT_SWIZZLE_IDENTITY orVK_COMPONENT_SWIZZLE_B </para>
/// <para>  If the format has a _422 or _420 suffix, thencomponents.b must be VK_COMPONENT_SWIZZLE_IDENTITY orVK_COMPONENT_SWIZZLE_R </para>
/// <para>  If the format has a _422 or _420 suffix, and if eithercomponents.r or components.b isVK_COMPONENT_SWIZZLE_IDENTITY, both values must beVK_COMPONENT_SWIZZLE_IDENTITY </para>
/// <para>  If ycbcrModel is notVK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY, thencomponents.r, components.g, and components.b mustcorrespond to channels of the format; that is, components.r,components.g, and components.b must not beVK_COMPONENT_SWIZZLE_ZERO or VK_COMPONENT_SWIZZLE_ONE, andmust not correspond to a channel which contains zero or one as aconsequence of conversion to RGBA </para>
/// <para>  If the format does not supportVK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,forceExplicitReconstruction must be FALSE</para>
/// <para>  If the format does not supportVK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,chromaFilter must be VK_FILTER_NEAREST </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkExternalFormatANDROID </para>
/// <para>   format must be a valid VkFormat value</para>
/// <para>   ycbcrModel must be a valid VkSamplerYcbcrModelConversion value</para>
/// <para>   ycbcrRange must be a valid VkSamplerYcbcrRange value</para>
/// <para>   components must be a valid VkComponentMapping structure</para>
/// <para>   xChromaOffset must be a valid VkChromaLocation value</para>
/// <para>   yChromaOffset must be a valid VkChromaLocation value</para>
/// <para>   chromaFilter must be a valid VkFilter value</para>
/// <para>If chromaFilter is VK_FILTER_NEAREST, chroma samples arereconstructed to luma channel resolution using nearest-neighbour sampling.Otherwise, chroma samples are reconstructed using interpolation.More details can be found in thedescription of sampler Y’CBCR conversion in the ImageOperations chapter.</para>
/// </summary>
public unsafe struct VkSamplerYcbcrConversionCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                  sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                      pNext;
    /// <summary> format is the format of the image from which color information
    /// will be retrieved.</summary>
    public VkFormat                         format;
    /// <summary> ycbcrModel describes the color matrix for conversion between color
    /// models.</summary>
    public VkSamplerYcbcrModelConversion    ycbcrModel;
    /// <summary> ycbcrRange describes whether the encoded values have headroom and
    /// foot room, or whether the encoding uses the full numerical range.</summary>
    public VkSamplerYcbcrRange              ycbcrRange;
    /// <summary> components applies a swizzle based on VkComponentSwizzle
    /// enums prior to range expansion and color model conversion.</summary>
    public VkComponentMapping               components;
    /// <summary> xChromaOffset describes the
    /// sample location associated with
    /// downsampled chroma channels in the x dimension.
    /// xChromaOffset has no effect for formats in which chroma channels
    /// are the same resolution as the luma channel.</summary>
    public VkChromaLocation                 xChromaOffset;
    /// <summary> yChromaOffset describes the
    /// sample location associated with
    /// downsampled chroma channels in the y dimension.
    /// yChromaOffset has no effect for formats in which the chroma
    /// channels are not downsampled vertically.</summary>
    public VkChromaLocation                 yChromaOffset;
    /// <summary> chromaFilter is the filter for chroma reconstruction.</summary>
    public VkFilter                         chromaFilter;
    /// <summary> forceExplicitReconstruction
    ///   can be used to ensure that
    /// reconstruction is done explicitly, if supported.</summary>
    public VkBool32                         forceExplicitReconstruction;
}
// Struct: 367
/// <summary>VkSamplerYcbcrConversionImageFormatProperties - Structure specifying combined image sampler descriptor count for multi-planar images
/// <para>   sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES </para>
/// </summary>
public unsafe struct VkSamplerYcbcrConversionImageFormatProperties {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    /// <summary> combinedImageSamplerDescriptorCount is the number of combined
    /// image sampler descriptors that the implementation uses to access the
    /// format.</summary>
    public UInt32           combinedImageSamplerDescriptorCount;
}
// Struct: 368
/// <summary>VkSamplerYcbcrConversionInfo - Structure specifying Y’CbCr conversion to a sampler or image view
/// <para>   sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO </para>
/// <para>   conversion must be a valid VkSamplerYcbcrConversion handle</para>
/// </summary>
public unsafe struct VkSamplerYcbcrConversionInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                 pNext;
    /// <summary> conversion is a VkSamplerYcbcrConversion handle created with
    /// vkCreateSamplerYcbcrConversion.</summary>
    public VkSamplerYcbcrConversion    conversion;
}
// Struct: 369
/// <summary>VkSemaphoreCreateInfo - Structure specifying parameters of a newly created semaphore
/// <para>   sType must be VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkExportSemaphoreCreateInfo or VkExportSemaphoreWin32HandleInfoKHR </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkSemaphoreCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType           sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*               pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkSemaphoreCreateFlags    flags;
}
// Struct: 370
/// <summary>VkSemaphoreGetFdInfoKHR - Structure describing a POSIX FD semaphore export operation
/// <para>The properties of the file descriptor returned depend on the value ofhandleType.See VkExternalSemaphoreHandleTypeFlagBits for a description of theproperties of the defined external semaphore handle types.</para>
/// <para>   handleType must have been included inVkExportSemaphoreCreateInfo::handleTypes whensemaphore’s current payload was created.</para>
/// <para>   semaphore must not currently have its payload replaced by animported payload as described below inImporting Semaphore Payloadsunless that imported payload’s handle type was included inVkExternalSemaphoreProperties::exportFromImportedHandleTypesfor handleType.</para>
/// <para>  If handleType refers to a handle type with copy payloadtransference semantics, as defined below inImporting Semaphore Payloads,there must be no queue waiting on semaphore.</para>
/// <para>  If handleType refers to a handle type with copy payloadtransference semantics, semaphore must be signaled, or have anassociated semaphore signaloperation pending execution.</para>
/// <para>   handleType must be defined as a POSIX file descriptor handle.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   semaphore must be a valid VkSemaphore handle</para>
/// <para>   handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value</para>
/// </summary>
public unsafe struct VkSemaphoreGetFdInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                              pNext;
    /// <summary> semaphore is the semaphore from which state will be exported.</summary>
    public VkSemaphore                              semaphore;
    /// <summary> handleType is the type of handle requested.</summary>
    public VkExternalSemaphoreHandleTypeFlagBits    handleType;
}
// Struct: 371
/// <summary>VkSemaphoreGetWin32HandleInfoKHR - Structure describing a Win32 handle semaphore export operation
/// <para>The properties of the handle returned depend on the value ofhandleType.See VkExternalSemaphoreHandleTypeFlagBits for a description of theproperties of the defined external semaphore handle types.</para>
/// <para>   handleType must have been included inVkExportSemaphoreCreateInfo::handleTypes when thesemaphore’s current payload was created.</para>
/// <para>  If handleType is defined as an NT handle,vkGetSemaphoreWin32HandleKHR must be called no more than once foreach valid unique combination of semaphore and handleType.</para>
/// <para>   semaphore must not currently have its payload replaced by animported payload as described below inImporting Semaphore Payloadsunless that imported payload’s handle type was included inVkExternalSemaphoreProperties::exportFromImportedHandleTypesfor handleType.</para>
/// <para>  If handleType refers to a handle type with copy payloadtransference semantics, as defined below inImporting Semaphore Payloads,there must be no queue waiting on semaphore.</para>
/// <para>  If handleType refers to a handle type with copy payloadtransference semantics, semaphore must be signaled, or have anassociated semaphore signaloperation pending execution.</para>
/// <para>   handleType must be defined as an NT handle or a global sharehandle.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   semaphore must be a valid VkSemaphore handle</para>
/// <para>   handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value</para>
/// </summary>
public unsafe struct VkSemaphoreGetWin32HandleInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                          sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                              pNext;
    /// <summary> semaphore is the semaphore from which state will be exported.</summary>
    public VkSemaphore                              semaphore;
    /// <summary> handleType is the type of handle requested.</summary>
    public VkExternalSemaphoreHandleTypeFlagBits    handleType;
}
// Struct: 372
/// <summary>VkShaderModuleCreateInfo - Structure specifying parameters of a newly created shader module
/// <para>   codeSize must be greater than 0</para>
/// <para>  If pCode points to SPIR-V code, codeSize must be a multipleof 4</para>
/// <para>   pCode must point to either valid SPIR-V code, formatted andpacked as described by the Khronos SPIR-V Specificationor valid GLSL code which must be written to the GL_KHR_vulkan_glslextension specification</para>
/// <para>  If pCode points to SPIR-V code, that code must adhere to thevalidation rules described by the Validation Rules within a Module section of theSPIR-V Environment appendix</para>
/// <para>  If pCode points to GLSL code, it must be valid GLSL code writtento the GL_KHR_vulkan_glsl GLSL extension specification</para>
/// <para>   pCode must declare the Shader capability for SPIR-V code</para>
/// <para>   pCode must not declare any capability that is not supported bythe API, as described by the Capabilities section of the SPIR-VEnvironment appendix</para>
/// <para>  If pCode declares any of the capabilities listed as optional inthe SPIR-V Environment appendix, thecorresponding feature(s) must be enabled.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO </para>
/// <para>   pNext must be NULL or a pointer to a valid instance of VkShaderModuleValidationCacheCreateInfoEXT </para>
/// <para>   flags must be 0 </para>
/// <para>   pCode must be a valid pointer to an array of \(\textrm{codeSize} \over 4\) uint32_t values</para>
/// </summary>
public unsafe struct VkShaderModuleCreateInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType              sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                  pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkShaderModuleCreateFlags    flags;
    /// <summary> codeSize is the size, in bytes, of the code pointed to by
    /// pCode.</summary>
    public size_t                       codeSize;
    /// <summary> pCode points to code that is used to create the shader module.
    /// The type and format of the code is determined from the content of the
    /// memory addressed by pCode.</summary>
    public /* const */ UInt32*              pCode;
}
// Struct: 373
/// <summary>VkShaderModuleValidationCacheCreateInfoEXT - Specify validation cache to use during shader module creation
/// <para>   sType must be VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT </para>
/// <para>   validationCache must be a valid VkValidationCacheEXT handle</para>
/// </summary>
public unsafe struct VkShaderModuleValidationCacheCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType         sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*             pNext;
    /// <summary> validationCache is the validation cache object from which the
    /// results of prior validation attempts will be written, and to which new
    /// validation results for this VkShaderModule will be written (if not
    /// already present).</summary>
    public VkValidationCacheEXT    validationCache;
}
// Struct: 374
/// <summary>VkShaderResourceUsageAMD - Resource usage information about a particular shader within a pipeline
/// </summary>
public unsafe struct VkShaderResourceUsageAMD {
    /// <summary> numUsedVgprs is the number of vector instruction general-purpose
    /// registers used by this shader.</summary>
    public UInt32    numUsedVgprs;
    /// <summary> numUsedSgprs is the number of scalar instruction general-purpose
    /// registers used by this shader.</summary>
    public UInt32    numUsedSgprs;
    /// <summary> ldsSizePerLocalWorkGroup is the maximum local data store size per
    /// work group in bytes.</summary>
    public UInt32    ldsSizePerLocalWorkGroup;
    /// <summary> ldsUsageSizeInBytes is the LDS usage size in bytes per work group
    /// by this shader.</summary>
    public size_t      ldsUsageSizeInBytes;
    /// <summary> scratchMemUsageInBytes is the scratch memory usage in bytes by
    /// this shader.</summary>
    public size_t      scratchMemUsageInBytes;
}
// Struct: 375
/// <summary>VkShaderStatisticsInfoAMD - Statistical information about a particular shader within a pipeline
/// <para>Some implementations may merge multiple logical shader stages together in asingle shader.In such cases, shaderStageMask will contain a bitmask of all of thestages that are active within that shader.Consequently, if specifying those stages as input tovkGetShaderInfoAMD, the same output information may be returned forall such shader stage queries.</para>
/// <para>The number of available VGPRs and SGPRs (numAvailableVgprs andnumAvailableSgprs respectively) are the shader-addressable subset ofphysical registers that is given as a limit to the compiler for registerassignment.These values may further be limited by implementations due to performanceoptimizations where register pressure is a bottleneck.</para>
/// </summary>
public unsafe struct VkShaderStatisticsInfoAMD {
    /// <summary> shaderStageMask are the combination of logical shader stages
    /// contained within this shader.</summary>
    public VkShaderStageFlags          shaderStageMask;
    /// <summary> resourceUsage is an instance of VkShaderResourceUsageAMD
    /// describing internal physical device resources used by this shader.</summary>
    public VkShaderResourceUsageAMD    resourceUsage;
    /// <summary> numPhysicalVgprs is the maximum number of vector instruction
    /// general-purpose registers (VGPRs) available to the physical device.</summary>
    public UInt32                    numPhysicalVgprs;
    /// <summary> numPhysicalSgprs is the maximum number of scalar instruction
    /// general-purpose registers (SGPRs) available to the physical device.</summary>
    public UInt32                    numPhysicalSgprs;
    /// <summary> numAvailableVgprs is the maximum limit of VGPRs made available to
    /// the shader compiler.</summary>
    public UInt32                    numAvailableVgprs;
    /// <summary> numAvailableSgprs is the maximum limit of SGPRs made available to
    /// the shader compiler.</summary>
    public UInt32                    numAvailableSgprs;
    public fixed UInt32                    computeWorkGroupSize[3];
}
// Struct: 376
/// <summary>VkShadingRatePaletteNV - Structure specifying a single shading rate palette
/// <para>   shadingRatePaletteEntryCount must be between 1 andVkPhysicalDeviceShadingRateImagePropertiesNV::shadingRatePaletteSize,inclusive</para>
/// <para>   pShadingRatePaletteEntries must be a valid pointer to an array of shadingRatePaletteEntryCount valid VkShadingRatePaletteEntryNV values</para>
/// <para>   shadingRatePaletteEntryCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkShadingRatePaletteNV {
    /// <summary> shadingRatePaletteEntryCount specifies the number of entries in
    /// the shading rate image palette.</summary>
    public UInt32                              shadingRatePaletteEntryCount;
    /// <summary> pShadingRatePaletteEntries is a pointer to an array of
    /// VkShadingRatePaletteEntryNV enums defining the shading rate for
    /// each palette entry.</summary>
    public /* const */ VkShadingRatePaletteEntryNV*    pShadingRatePaletteEntries;
}
// Struct: 377
/// <summary>VkSharedPresentSurfaceCapabilitiesKHR - structure describing capabilities of a surface for shared presentation
/// <para>   sType must be VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR </para>
/// </summary>
public unsafe struct VkSharedPresentSurfaceCapabilitiesKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                pNext;
    /// <summary> sharedPresentSupportedUsageFlags is a bitmask of
    /// VkImageUsageFlagBits representing the ways the application can
    /// use the shared presentable image from a swapchain created with
    /// VkPresentModeKHR set to
    /// VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or
    /// VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR for the surface on
    /// the specified device.
    /// VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT must be included in the set
    /// but implementations may support additional usages.</summary>
    public VkImageUsageFlags    sharedPresentSupportedUsageFlags;
}
// Struct: 378
/// <summary>VkSparseBufferMemoryBindInfo - Structure specifying a sparse buffer memory bind operation
/// <para>   buffer must be a valid VkBuffer handle</para>
/// <para>   pBinds must be a valid pointer to an array of bindCount valid VkSparseMemoryBind structures</para>
/// <para>   bindCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkSparseBufferMemoryBindInfo {
    /// <summary> buffer is the VkBuffer object to be bound.</summary>
    public VkBuffer                     buffer;
    /// <summary> bindCount is the number of VkSparseMemoryBind structures in
    /// the pBinds array.</summary>
    public UInt32                     bindCount;
    /// <summary> pBinds is a pointer to array of VkSparseMemoryBind
    /// structures.</summary>
    public /* const */ VkSparseMemoryBind*    pBinds;
}
// Struct: 379
/// <summary>VkSparseImageFormatProperties - Structure specifying sparse image format properties
/// </summary>
public unsafe struct VkSparseImageFormatProperties {
    /// <summary> aspectMask is a bitmask VkImageAspectFlagBits specifying
    /// which aspects of the image the properties apply to.</summary>
    public VkImageAspectFlags          aspectMask;
    /// <summary> imageGranularity is the width, height, and depth of the sparse
    /// image block in texels or compressed texel blocks.</summary>
    public VkExtent3D                  imageGranularity;
    /// <summary> flags is a bitmask of VkSparseImageFormatFlagBits specifying
    /// additional information about the sparse resource.</summary>
    public VkSparseImageFormatFlags    flags;
}
// Struct: 380
/// <summary>VkSparseImageFormatProperties2 - Structure specifying sparse image format properties
/// <para>   sType must be VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkSparseImageFormatProperties2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                  sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                            pNext;
    /// <summary> properties is a structure of type
    /// VkSparseImageFormatProperties which is populated with the same
    /// values as in vkGetPhysicalDeviceSparseImageFormatProperties.</summary>
    public VkSparseImageFormatProperties    properties;
}
// Struct: 381
/// <summary>VkSparseImageMemoryBind - Structure specifying sparse image memory bind
/// <para>  If the sparse aliased residencyfeature is not enabled, and if any other resources are bound to rangesof memory, the range of memory being bound must not overlapwith those bound ranges</para>
/// <para>   memory and memoryOffset must match the memory requirementsof the calling command’s image, as described in sectionhtml/vkspec.html#resources-association </para>
/// <para>   subresource must be a valid image subresource for image(see html/vkspec.html#resources-image-views)</para>
/// <para>   offset.x must be a multiple of the sparse image block width(VkSparseImageFormatProperties::imageGranularity.width) ofthe image</para>
/// <para>   extent.width must either be a multiple of the sparse image blockwidth of the image, or else (extent.width + offset.x) must equal the width of the image subresource</para>
/// <para>   offset.y must be a multiple of the sparse image block height(VkSparseImageFormatProperties::imageGranularity.height) ofthe image</para>
/// <para>   extent.height must either be a multiple of the sparse image blockheight of the image, or else (extent.height + offset.y) must equal the height of the image subresource</para>
/// <para>   offset.z must be a multiple of the sparse image block depth(VkSparseImageFormatProperties::imageGranularity.depth) ofthe image</para>
/// <para>   extent.depth must either be a multiple of the sparse image blockdepth of the image, or else (extent.depth + offset.z) must equal the depth of the image subresource</para>
/// <para>   subresource must be a valid VkImageSubresource structure</para>
/// <para>   If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle</para>
/// <para>   flags must be a valid combination of VkSparseMemoryBindFlagBits values</para>
/// </summary>
public unsafe struct VkSparseImageMemoryBind {
    /// <summary> subresource is the image aspect and region of interest in the
    /// image.</summary>
    public VkImageSubresource         subresource;
    /// <summary> offset are the coordinates of the first texel within the image
    /// subresource to bind.</summary>
    public VkOffset3D                 offset;
    /// <summary> extent is the size in texels of the region within the image
    /// subresource to bind.
    /// The extent must be a multiple of the sparse image block dimensions,
    /// except when binding sparse image blocks along the edge of an image
    /// subresource it can instead be such that any coordinate of
    ///  offset +  extent  equals the corresponding
    /// dimensions of the image subresource.</summary>
    public VkExtent3D                 extent;
    /// <summary> memory is the VkDeviceMemory object that the sparse image
    /// blocks of the image are bound to.
    /// If memory is VK_NULL_HANDLE, the sparse image blocks are
    /// unbound.</summary>
    public VkDeviceMemory             memory;
    /// <summary> memoryOffset is an offset into VkDeviceMemory object.
    /// If memory is VK_NULL_HANDLE, this value is ignored.</summary>
    public VkDeviceSize               memoryOffset;
    /// <summary> flags are sparse memory binding flags.</summary>
    public VkSparseMemoryBindFlags    flags;
}
// Struct: 382
/// <summary>VkSparseImageMemoryBindInfo - Structure specifying sparse image memory bind info
/// <para>  The subresource.mipLevel member of each element of pBinds must be less than the mipLevels specified inVkImageCreateInfo when image was created</para>
/// <para>  The subresource.arrayLayer member of each element of pBinds must be less than the arrayLayers specified inVkImageCreateInfo when image was created</para>
/// <para>   image must be a valid VkImage handle</para>
/// <para>   pBinds must be a valid pointer to an array of bindCount valid VkSparseImageMemoryBind structures</para>
/// <para>   bindCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkSparseImageMemoryBindInfo {
    /// <summary> image is the VkImage object to be bound</summary>
    public VkImage                           image;
    /// <summary> bindCount is the number of VkSparseImageMemoryBind
    /// structures in pBinds array</summary>
    public UInt32                          bindCount;
    /// <summary> pBinds is a pointer to array of VkSparseImageMemoryBind
    /// structures</summary>
    public /* const */ VkSparseImageMemoryBind*    pBinds;
}
// Struct: 383
/// <summary>VkSparseImageMemoryRequirements - Structure specifying sparse image memory requirements
/// </summary>
public unsafe struct VkSparseImageMemoryRequirements {
    public VkSparseImageFormatProperties    formatProperties;
    /// <summary> imageMipTailFirstLod is the first mip level at which image
    /// subresources are included in the mip tail region.</summary>
    public UInt32                         imageMipTailFirstLod;
    /// <summary> imageMipTailSize is the memory size (in bytes) of the mip tail
    /// region.
    /// If formatProperties.flags contains
    /// VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT, this is the size of the
    /// whole mip tail, otherwise this is the size of the mip tail of a single
    /// array layer.
    /// This value is guaranteed to be a multiple of the sparse block size in
    /// bytes.</summary>
    public VkDeviceSize                     imageMipTailSize;
    /// <summary> imageMipTailOffset is the opaque memory offset used with
    /// VkSparseImageOpaqueMemoryBindInfo to bind the mip tail region(s).</summary>
    public VkDeviceSize                     imageMipTailOffset;
    /// <summary> imageMipTailStride is the offset stride between each array-layer’s
    /// mip tail, if formatProperties.flags does not contain
    /// VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT (otherwise the value is
    /// undefined).</summary>
    public VkDeviceSize                     imageMipTailStride;
}
// Struct: 384
/// <summary>VkSparseImageMemoryRequirements2 - (None)
/// <para>   sType must be VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkSparseImageMemoryRequirements2 {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                              pNext;
    /// <summary> memoryRequirements is a structure of type
    /// VkSparseImageMemoryRequirements describing the memory requirements
    /// of the sparse image.</summary>
    public VkSparseImageMemoryRequirements    memoryRequirements;
}
// Struct: 385
/// <summary>VkSparseImageOpaqueMemoryBindInfo - Structure specifying sparse image opaque memory bind info
/// <para>  If the flags member of any element of pBinds containsVK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range definedmust be within the mip tail region of the metadata aspect ofimage </para>
/// <para>   image must be a valid VkImage handle</para>
/// <para>   pBinds must be a valid pointer to an array of bindCount valid VkSparseMemoryBind structures</para>
/// <para>   bindCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkSparseImageOpaqueMemoryBindInfo {
    /// <summary> image is the VkImage object to be bound.</summary>
    public VkImage                      image;
    /// <summary> bindCount is the number of VkSparseMemoryBind structures in
    /// the pBinds array.</summary>
    public UInt32                     bindCount;
    /// <summary> pBinds is a pointer to array of VkSparseMemoryBind
    /// structures.</summary>
    public /* const */ VkSparseMemoryBind*    pBinds;
}
// Struct: 386
/// <summary>VkSparseMemoryBind - Structure specifying a sparse memory bind operation
/// <para>The binding range [resourceOffset, resourceOffset + size) has different constraints based on flags.If flags contains VK_SPARSE_MEMORY_BIND_METADATA_BIT, thebinding range must be within the mip tail region of the metadata aspect.This metadata region is defined by:</para>
/// <para>and imageMipTailOffset, imageMipTailSize, andimageMipTailStride values are from theVkSparseImageMemoryRequirements corresponding to the metadata aspectof the image, and n is a valid array layer index for the image,</para>
/// <para> imageMipTailStride is considered to be zero for aspects whereVkSparseImageMemoryRequirements::formatProperties.flags containsVK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT.</para>
/// <para>If flags does not contain VK_SPARSE_MEMORY_BIND_METADATA_BIT,the binding range must be within the range[0,VkMemoryRequirements::size).</para>
/// <para>  If memory is not VK_NULL_HANDLE, memory andmemoryOffset must match the memory requirements of the resource,as described in section html/vkspec.html#resources-association </para>
/// <para>  If memory is not VK_NULL_HANDLE, memory must not havebeen created with a memory type that reportsVK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set</para>
/// <para>   size must be greater than 0 </para>
/// <para>   resourceOffset must be less than the size of the resource</para>
/// <para>   size must be less than or equal to the size of the resource minusresourceOffset </para>
/// <para>   memoryOffset must be less than the size of memory </para>
/// <para>   size must be less than or equal to the size of memory minusmemoryOffset </para>
/// <para>   If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle</para>
/// <para>   flags must be a valid combination of VkSparseMemoryBindFlagBits values</para>
/// </summary>
public unsafe struct VkSparseMemoryBind {
    /// <summary> resourceOffset is the offset into the resource.</summary>
    public VkDeviceSize               resourceOffset;
    /// <summary> size is the size of the memory region to be bound.</summary>
    public VkDeviceSize               size;
    /// <summary> memory is the VkDeviceMemory object that the range of the
    /// resource is bound to.
    /// If memory is VK_NULL_HANDLE, the range is unbound.</summary>
    public VkDeviceMemory             memory;
    /// <summary> memoryOffset is the offset into the VkDeviceMemory object to
    /// bind the resource range to.
    /// If memory is VK_NULL_HANDLE, this value is ignored.</summary>
    public VkDeviceSize               memoryOffset;
    /// <summary> flags is a bitmask of VkSparseMemoryBindFlagBits specifying
    /// usage of the binding operation.</summary>
    public VkSparseMemoryBindFlags    flags;
}
// Struct: 387
/// <summary>VkSpecializationInfo - Structure specifying specialization info
/// <para> pMapEntries points to a structure of typeVkSpecializationMapEntry.</para>
/// <para>  The offset member of each element of pMapEntries must beless than dataSize </para>
/// <para>  The size member of each element of pMapEntries must be lessthan or equal to dataSize minus offset </para>
/// <para>   If mapEntryCount is not 0, pMapEntries must be a valid pointer to an array of mapEntryCount valid VkSpecializationMapEntry structures</para>
/// <para>   If dataSize is not 0, pData must be a valid pointer to an array of dataSize bytes</para>
/// </summary>
public unsafe struct VkSpecializationInfo {
    /// <summary> mapEntryCount is the number of entries in the pMapEntries
    /// array.</summary>
    public UInt32                           mapEntryCount;
    /// <summary> pMapEntries is a pointer to an array of
    /// VkSpecializationMapEntry which maps constant IDs to offsets in
    /// pData.</summary>
    public /* const */ VkSpecializationMapEntry*    pMapEntries;
    /// <summary> dataSize is the byte size of the pData buffer.</summary>
    public size_t                             dataSize;
    /// <summary> pData contains the actual constant values to specialize with.</summary>
    public /* const */ void*                        pData;
}
// Struct: 388
/// <summary>VkSpecializationMapEntry - Structure specifying a specialization map entry
/// <para>If a constantID value is not a specialization constant ID used in theshader, that map entry does not affect the behavior of the pipeline.</para>
/// <para>  For a constantID specialization constant declared in a shader,size must match the byte size of the constantID.If the specialization constant is of type boolean, size mustbe the byte size of VkBool32 </para>
/// </summary>
public unsafe struct VkSpecializationMapEntry {
    /// <summary> constantID is the ID of the specialization constant in SPIR-V.</summary>
    public UInt32    constantID;
    /// <summary> offset is the byte offset of the specialization constant value
    /// within the supplied data buffer.</summary>
    public UInt32    offset;
    /// <summary> size is the byte size of the specialization constant value within
    /// the supplied data buffer.</summary>
    public size_t      size;
}
// Struct: 389
/// <summary>VkStencilOpState - Structure specifying stencil operation state
/// <para>   failOp must be a valid VkStencilOp value</para>
/// <para>   passOp must be a valid VkStencilOp value</para>
/// <para>   depthFailOp must be a valid VkStencilOp value</para>
/// <para>   compareOp must be a valid VkCompareOp value</para>
/// </summary>
public unsafe struct VkStencilOpState {
    /// <summary> failOp is a VkStencilOp value specifying the action
    /// performed on samples that fail the stencil test.</summary>
    public VkStencilOp    failOp;
    /// <summary> passOp is a VkStencilOp value specifying the action
    /// performed on samples that pass both the depth and stencil tests.</summary>
    public VkStencilOp    passOp;
    /// <summary> depthFailOp is a VkStencilOp value specifying the action
    /// performed on samples that pass the stencil test and fail the depth test.</summary>
    public VkStencilOp    depthFailOp;
    /// <summary> compareOp is a VkCompareOp value specifying the comparison
    /// operator used in the stencil test.</summary>
    public VkCompareOp    compareOp;
    /// <summary> compareMask selects the bits of the unsigned integer stencil
    /// values participating in the stencil test.</summary>
    public UInt32       compareMask;
    /// <summary> writeMask selects the bits of the unsigned integer stencil values
    /// updated by the stencil test in the stencil framebuffer attachment.</summary>
    public UInt32       writeMask;
    /// <summary> reference is an integer reference value that is used in the
    /// unsigned stencil comparison.</summary>
    public UInt32       reference;
}
// Struct: 390
/// <summary>VkStreamDescriptorSurfaceCreateInfoGGP - Structure specifying parameters of a newly created Google Games Platform stream surface object
/// <para>   streamDescriptor must be a valid GgpStreamDescriptor </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkStreamDescriptorSurfaceCreateInfoGGP {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                            sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                                pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkStreamDescriptorSurfaceCreateFlagsGGP    flags;
    /// <summary> streamDescriptor is a GgpStreamDescriptor referring to the
    /// GGP stream descriptor to associate with the surface.</summary>
    public GgpStreamDescriptor                        streamDescriptor;
}
// Struct: 391
/// <summary>VkSubmitInfo - Structure specifying a queue submit operation
/// <para>The order that command buffers appear in pCommandBuffers is used todetermine submission order, and thusall the implicit ordering guarantees thatrespect it.Other than these implicit ordering guarantees and any explicit synchronization primitives, these command buffers may overlap orotherwise execute out of order.</para>
/// <para>  Each element of pCommandBuffers must not have been allocated withVK_COMMAND_BUFFER_LEVEL_SECONDARY </para>
/// <para>  If the geometry shaders feature is notenabled, each element of pWaitDstStageMask must not containVK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT </para>
/// <para>  If the tessellation shaders feature isnot enabled, each element of pWaitDstStageMask must not containVK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT orVK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT </para>
/// <para>  Each element of pWaitDstStageMask must not includeVK_PIPELINE_STAGE_HOST_BIT.</para>
/// <para>  If the mesh shaders feature is not enabled, eachelement of pWaitDstStageMask must not containVK_PIPELINE_STAGE_MESH_SHADER_BIT_NV </para>
/// <para>  If the task shaders feature is not enabled, eachelement of pWaitDstStageMask must not containVK_PIPELINE_STAGE_TASK_SHADER_BIT_NV </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SUBMIT_INFO </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkD3D12FenceSubmitInfoKHR, VkDeviceGroupSubmitInfo, VkProtectedSubmitInfo, VkWin32KeyedMutexAcquireReleaseInfoKHR, or VkWin32KeyedMutexAcquireReleaseInfoNV </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles</para>
/// <para>   If waitSemaphoreCount is not 0, pWaitDstStageMask must be a valid pointer to an array of waitSemaphoreCount valid combinations of VkPipelineStageFlagBits values</para>
/// <para>   Each element of pWaitDstStageMask must not be 0 </para>
/// <para>   If commandBufferCount is not 0, pCommandBuffers must be a valid pointer to an array of commandBufferCount valid VkCommandBuffer handles</para>
/// <para>   If signalSemaphoreCount is not 0, pSignalSemaphores must be a valid pointer to an array of signalSemaphoreCount valid VkSemaphore handles</para>
/// <para>   Each of the elements of pCommandBuffers, the elements of pSignalSemaphores, and the elements of pWaitSemaphores that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkSubmitInfo {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                    pNext;
    /// <summary> waitSemaphoreCount is the number of semaphores upon which to wait
    /// before executing the command buffers for the batch.</summary>
    public UInt32                       waitSemaphoreCount;
    /// <summary> pWaitSemaphores is a pointer to an array of semaphores upon which
    /// to wait before the command buffers for this batch begin execution.
    /// If semaphores to wait on are provided, they define a
    /// semaphore wait operation.</summary>
    public /* const */ VkSemaphore*             pWaitSemaphores;
    /// <summary> pWaitDstStageMask is a pointer to an array of pipeline stages at
    /// which each corresponding semaphore wait will occur.</summary>
    public /* const */ VkPipelineStageFlags*    pWaitDstStageMask;
    /// <summary> commandBufferCount is the number of command buffers to execute in
    /// the batch.</summary>
    public UInt32                       commandBufferCount;
    /// <summary> pCommandBuffers is a pointer to an array of command buffers to
    /// execute in the batch.</summary>
    public /* const */ VkCommandBuffer*         pCommandBuffers;
    /// <summary> signalSemaphoreCount is the number of semaphores to be signaled
    /// once the commands specified in pCommandBuffers have completed
    /// execution.</summary>
    public UInt32                       signalSemaphoreCount;
    /// <summary> pSignalSemaphores is a pointer to an array of semaphores which
    /// will be signaled when the command buffers for this batch have completed
    /// execution.
    /// If semaphores to be signaled are provided, they define a
    /// semaphore signal operation.</summary>
    public /* const */ VkSemaphore*             pSignalSemaphores;
}
// Struct: 392
/// <summary>VkSubpassBeginInfoKHR - Structure specifying subpass begin info
/// <para>   sType must be VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   contents must be a valid VkSubpassContents value</para>
/// </summary>
public unsafe struct VkSubpassBeginInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType      sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*          pNext;
    /// <summary> contents is a VkSubpassContents value specifying how the
    /// commands in the next subpass will be provided.</summary>
    public VkSubpassContents    contents;
}
// Struct: 393
/// <summary>VkSubpassDependency - Structure specifying a subpass dependency
/// <para>If srcSubpass is equal to dstSubpass then theVkSubpassDependency describes asubpassself-dependency, and only constrains the pipeline barriers allowed withina subpass instance.Otherwise, when a render pass instance which includes a subpass dependencyis submitted to a queue, it defines a memory dependency between thesubpasses identified by srcSubpass and dstSubpass.</para>
/// <para>If srcSubpass is equal to VK_SUBPASS_EXTERNAL, the firstsynchronization scope includescommands that occur earlier in submissionorder than the vkCmdBeginRenderPass used to begin the render passinstance.Otherwise, the first set of commands includes all commands submitted as partof the subpass instance identified by srcSubpass and any load, storeor multisample resolve operations on attachments used in srcSubpass.In either case, the first synchronization scope is limited to operations onthe pipeline stages determined by thesource stage mask specified bysrcStageMask.</para>
/// <para>If dstSubpass is equal to VK_SUBPASS_EXTERNAL, the secondsynchronization scope includescommands that occur later in submissionorder than the vkCmdEndRenderPass used to end the render passinstance.Otherwise, the second set of commands includes all commands submitted aspart of the subpass instance identified by dstSubpass and any load,store or multisample resolve operations on attachments used indstSubpass.In either case, the second synchronization scope is limited to operations onthe pipeline stages determined by thedestination stage mask specifiedby dstStageMask.</para>
/// <para>The first access scope islimited to access in the pipeline stages determined by thesource stage mask specified bysrcStageMask.It is also limited to access types in the source access mask specified by srcAccessMask.</para>
/// <para>The second access scope islimited to access in the pipeline stages determined by thedestination stage mask specifiedby dstStageMask.It is also limited to access types in the destination access mask specified by dstAccessMask.</para>
/// <para>The availability andvisibility operations defined by a subpass dependency affect the executionof image layout transitions within therender pass.</para>
/// <para>For non-attachment resources, the memory dependency expressed by subpassdependency is nearly identical to that of a VkMemoryBarrier (withmatching srcAccessMask/dstAccessMask parameters) submitted as apart of a vkCmdPipelineBarrier (with matchingsrcStageMask/dstStageMask parameters).The only difference being that its scopes are limited to the identifiedsubpasses rather than potentially affecting everything before and after.</para>
/// <para>For attachments however, subpass dependencies work more like aVkImageMemoryBarrier defined similarly to the VkMemoryBarrierabove, the queue family indices set to VK_QUEUE_FAMILY_IGNORED, andlayouts as follows:</para>
/// <para>The equivalent to oldLayout is the attachment’s layout accordingto the subpass description for srcSubpass.</para>
/// <para>The equivalent to newLayout is the attachment’s layout accordingto the subpass description for dstSubpass.</para>
/// <para>  If srcSubpass is not VK_SUBPASS_EXTERNAL, srcStageMask must not include VK_PIPELINE_STAGE_HOST_BIT </para>
/// <para>  If dstSubpass is not VK_SUBPASS_EXTERNAL, dstStageMask must not include VK_PIPELINE_STAGE_HOST_BIT </para>
/// <para>  If the geometry shaders feature is notenabled, srcStageMask must not containVK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT </para>
/// <para>  If the geometry shaders feature is notenabled, dstStageMask must not containVK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT </para>
/// <para>  If the tessellation shaders feature isnot enabled, srcStageMask must not containVK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT orVK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT </para>
/// <para>  If the tessellation shaders feature isnot enabled, dstStageMask must not containVK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT orVK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT </para>
/// <para>   srcSubpass must be less than or equal to dstSubpass, unlessone of them is VK_SUBPASS_EXTERNAL, to avoid cyclic dependenciesand ensure a valid execution order</para>
/// <para>   srcSubpass and dstSubpass must not both be equal toVK_SUBPASS_EXTERNAL </para>
/// <para>  If srcSubpass is equal to dstSubpass, srcStageMask anddstStageMask must not set any bits that are neitherVK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, nor one of thegraphics pipeline stages </para>
/// <para>  If srcSubpass is equal to dstSubpass and not all of thestages in srcStageMask and dstStageMask areframebuffer-space stages, thelogically latest pipelinestage in srcStageMask must belogically earlier than orequal to the logicallyearliest pipeline stage in dstStageMask </para>
/// <para>  Any access flag included in srcAccessMask must be supported byone of the pipeline stages in srcStageMask, as specified in thetable of supported accesstypes </para>
/// <para>  Any access flag included in dstAccessMask must be supported byone of the pipeline stages in dstStageMask, as specified in thetable of supported accesstypes </para>
/// <para>  If srcSubpass equals dstSubpass, and srcStageMask anddstStageMask both include aframebuffer-space stage, thendependencyFlags must include VK_DEPENDENCY_BY_REGION_BIT </para>
/// <para>  If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT,srcSubpass must not be equal to VK_SUBPASS_EXTERNAL </para>
/// <para>  If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT,dstSubpass must not be equal to VK_SUBPASS_EXTERNAL </para>
/// <para>  If srcSubpass equals dstSubpass and that subpass has morethan one bit set in the view mask, then dependencyFlags mustinclude VK_DEPENDENCY_VIEW_LOCAL_BIT </para>
/// <para>  If the mesh shaders feature is not enabled,srcStageMask must not containVK_PIPELINE_STAGE_MESH_SHADER_BIT_NV </para>
/// <para>  If the task shaders feature is not enabled,srcStageMask must not containVK_PIPELINE_STAGE_TASK_SHADER_BIT_NV </para>
/// <para>  If the mesh shaders feature is not enabled,dstStageMask must not containVK_PIPELINE_STAGE_MESH_SHADER_BIT_NV </para>
/// <para>  If the task shaders feature is not enabled,dstStageMask must not containVK_PIPELINE_STAGE_TASK_SHADER_BIT_NV </para>
/// <para>   srcStageMask must be a valid combination of VkPipelineStageFlagBits values</para>
/// <para>   srcStageMask must not be 0 </para>
/// <para>   dstStageMask must be a valid combination of VkPipelineStageFlagBits values</para>
/// <para>   dstStageMask must not be 0 </para>
/// <para>   srcAccessMask must be a valid combination of VkAccessFlagBits values</para>
/// <para>   dstAccessMask must be a valid combination of VkAccessFlagBits values</para>
/// <para>   dependencyFlags must be a valid combination of VkDependencyFlagBits values</para>
/// </summary>
public unsafe struct VkSubpassDependency {
    /// <summary> srcSubpass is the subpass index of the first subpass in the
    /// dependency, or VK_SUBPASS_EXTERNAL.</summary>
    public UInt32                srcSubpass;
    /// <summary> dstSubpass is the subpass index of the second subpass in the
    /// dependency, or VK_SUBPASS_EXTERNAL.</summary>
    public UInt32                dstSubpass;
    /// <summary> srcStageMask is a bitmask of VkPipelineStageFlagBits
    /// specifying the source stage
    /// mask.</summary>
    public VkPipelineStageFlags    srcStageMask;
    /// <summary> dstStageMask is a bitmask of VkPipelineStageFlagBits
    /// specifying the destination
    /// stage mask </summary>
    public VkPipelineStageFlags    dstStageMask;
    /// <summary> srcAccessMask is a bitmask of VkAccessFlagBits specifying a
    /// source access mask.</summary>
    public VkAccessFlags           srcAccessMask;
    /// <summary> dstAccessMask is a bitmask of VkAccessFlagBits specifying a
    /// destination access mask.</summary>
    public VkAccessFlags           dstAccessMask;
    /// <summary> dependencyFlags is a bitmask of VkDependencyFlagBits.</summary>
    public VkDependencyFlags       dependencyFlags;
}
// Struct: 394
/// <summary>VkSubpassDependency2KHR - Structure specifying a subpass dependency
/// <para>Parameters defined by this structure with the same name as those inVkSubpassDependency have the identical effect to those parameters.</para>
/// <para> viewOffset has the same effect for the described subpass dependency asVkRenderPassMultiviewCreateInfo::pViewOffsets has on eachcorresponding subpass dependency.</para>
/// <para>  If srcSubpass is not VK_SUBPASS_EXTERNAL, srcStageMask must not include VK_PIPELINE_STAGE_HOST_BIT </para>
/// <para>  If dstSubpass is not VK_SUBPASS_EXTERNAL, dstStageMask must not include VK_PIPELINE_STAGE_HOST_BIT </para>
/// <para>  If the geometry shaders feature is notenabled, srcStageMask must not containVK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT </para>
/// <para>  If the geometry shaders feature is notenabled, dstStageMask must not containVK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT </para>
/// <para>  If the tessellation shaders feature isnot enabled, srcStageMask must not containVK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT orVK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT </para>
/// <para>  If the tessellation shaders feature isnot enabled, dstStageMask must not containVK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT orVK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT </para>
/// <para>   srcSubpass must be less than or equal to dstSubpass, unlessone of them is VK_SUBPASS_EXTERNAL, to avoid cyclic dependenciesand ensure a valid execution order</para>
/// <para>   srcSubpass and dstSubpass must not both be equal toVK_SUBPASS_EXTERNAL </para>
/// <para>  If srcSubpass is equal to dstSubpass, srcStageMask anddstStageMask must not set any bits that are neitherVK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, nor one of thegraphics pipeline stages </para>
/// <para>  If srcSubpass is equal to dstSubpass and not all of thestages in srcStageMask and dstStageMask areframebuffer-space stages, thelogically latest pipelinestage in srcStageMask must belogically earlier than orequal to the logicallyearliest pipeline stage in dstStageMask </para>
/// <para>  Any access flag included in srcAccessMask must be supported byone of the pipeline stages in srcStageMask, as specified in thetable of supported accesstypes </para>
/// <para>  Any access flag included in dstAccessMask must be supported byone of the pipeline stages in dstStageMask, as specified in thetable of supported accesstypes </para>
/// <para>  If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT,srcSubpass must not be equal to VK_SUBPASS_EXTERNAL </para>
/// <para>  If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT,dstSubpass must not be equal to VK_SUBPASS_EXTERNAL </para>
/// <para>  If srcSubpass equals dstSubpass, and srcStageMask anddstStageMask both include aframebuffer-space stage, thendependencyFlags must include VK_DEPENDENCY_BY_REGION_BIT </para>
/// <para>  If viewOffset is not equal to 0, srcSubpass must not beequal to dstSubpass </para>
/// <para>  If dependencyFlags does not includeVK_DEPENDENCY_VIEW_LOCAL_BIT, viewOffset must be 0 </para>
/// <para>  If viewOffset is not 0, srcSubpass must not be equal todstSubpass.</para>
/// <para>  If the mesh shaders feature is not enabled,srcStageMask must not containVK_PIPELINE_STAGE_MESH_SHADER_BIT_NV </para>
/// <para>  If the task shaders feature is not enabled,srcStageMask must not containVK_PIPELINE_STAGE_TASK_SHADER_BIT_NV </para>
/// <para>  If the mesh shaders feature is not enabled,dstStageMask must not containVK_PIPELINE_STAGE_MESH_SHADER_BIT_NV </para>
/// <para>  If the task shaders feature is not enabled,dstStageMask must not containVK_PIPELINE_STAGE_TASK_SHADER_BIT_NV </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR </para>
/// <para>   srcStageMask must be a valid combination of VkPipelineStageFlagBits values</para>
/// <para>   srcStageMask must not be 0 </para>
/// <para>   dstStageMask must be a valid combination of VkPipelineStageFlagBits values</para>
/// <para>   dstStageMask must not be 0 </para>
/// <para>   srcAccessMask must be a valid combination of VkAccessFlagBits values</para>
/// <para>   dstAccessMask must be a valid combination of VkAccessFlagBits values</para>
/// <para>   dependencyFlags must be a valid combination of VkDependencyFlagBits values</para>
/// </summary>
public unsafe struct VkSubpassDependency2KHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType         sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*             pNext;
    /// <summary> srcSubpass is the subpass index of the first subpass in the
    /// dependency, or VK_SUBPASS_EXTERNAL.</summary>
    public UInt32                srcSubpass;
    /// <summary> dstSubpass is the subpass index of the second subpass in the
    /// dependency, or VK_SUBPASS_EXTERNAL.</summary>
    public UInt32                dstSubpass;
    /// <summary> srcStageMask is a bitmask of VkPipelineStageFlagBits
    /// specifying the source stage
    /// mask.</summary>
    public VkPipelineStageFlags    srcStageMask;
    /// <summary> dstStageMask is a bitmask of VkPipelineStageFlagBits
    /// specifying the destination
    /// stage mask </summary>
    public VkPipelineStageFlags    dstStageMask;
    /// <summary> srcAccessMask is a bitmask of VkAccessFlagBits specifying a
    /// source access mask.</summary>
    public VkAccessFlags           srcAccessMask;
    /// <summary> dstAccessMask is a bitmask of VkAccessFlagBits specifying a
    /// destination access mask.</summary>
    public VkAccessFlags           dstAccessMask;
    /// <summary> dependencyFlags is a bitmask of VkDependencyFlagBits.</summary>
    public VkDependencyFlags       dependencyFlags;
    /// <summary> viewOffset controls which views in the source subpass the views in
    /// the destination subpass depend on.</summary>
    public Int32                 viewOffset;
}
// Struct: 395
/// <summary>VkSubpassDescription - Structure specifying a subpass description
/// <para>Each element of the pInputAttachments array corresponds to an inputattachment index in a fragment shader, i.e. if a shader declares an imagevariable decorated with a InputAttachmentIndex value of X, then ituses the attachment provided in pInputAttachments[X].Input attachments must also be bound to the pipeline in a descriptor set.If the attachment member of any element of pInputAttachments isVK_ATTACHMENT_UNUSED, the application must not read from thecorresponding input attachment index.Fragment shaders can use subpass input variables to access the contents ofan input attachment at the fragment’s (x, y, layer) framebuffer coordinates.</para>
/// <para>Each element of the pColorAttachments array corresponds to an outputlocation in the shader, i.e. if the shader declares an output variabledecorated with a Location value of X, then it uses the attachmentprovided in pColorAttachments[X].If the attachment member of any element of pColorAttachments isVK_ATTACHMENT_UNUSED, writes to the corresponding location by afragment are discarded.</para>
/// <para>If pResolveAttachments is not NULL, each of its elements correspondsto a color attachment (the element in pColorAttachments at the sameindex), and a multisample resolve operation is defined for each attachment.At the end of each subpass, multisample resolve operations read thesubpass’s color attachments, and resolve the samples for each pixel to thesame pixel location in the corresponding resolve attachments, unless theresolve attachment index is VK_ATTACHMENT_UNUSED.</para>
/// <para>Similarly, ifVkSubpassDescriptionDepthStencilResolveKHR::pDepthStencilResolveAttachmentis not NULL and does not have the value VK_ATTACHMENT_UNUSED, itcorresponds to the depth/stencil attachment inpDepthStencilAttachment, and multisample resolve operations for depthand stencil are defined byVkSubpassDescriptionDepthStencilResolveKHR::depthResolveMode andVkSubpassDescriptionDepthStencilResolveKHR::stencilResolveMode,respectively.At the end of each subpass, multisample resolve operations read thesubpass’s depth/stencil attachment, and resolve the samples for each pixelto the same pixel location in the corresponding resolve attachment.If VkSubpassDescriptionDepthStencilResolveKHR::depthResolveModeis VK_RESOLVE_MODE_NONE_KHR, then the depth component of the resolveattachment is not written to and its contents are preserved.Similarly, ifVkSubpassDescriptionDepthStencilResolveKHR::stencilResolveModeis VK_RESOLVE_MODE_NONE_KHR, then the stencil component of the resolveattachment is not written to and its contents are preserved.VkSubpassDescriptionDepthStencilResolveKHR::depthResolveMode isignored if the VkFormat of the pDepthStencilResolveAttachmentdoes not have a depth component.Similarly,VkSubpassDescriptionDepthStencilResolveKHR::stencilResolveModeis ignored if the VkFormat of the pDepthStencilResolveAttachmentdoes not have a stencil component.</para>
/// <para>If the image subresource range referenced by the depth/stencil attachment iscreated withVK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT, then themultisample resolve operation uses the sample locations state specified inthe sampleLocationsInfo member of the element of theVkRenderPassSampleLocationsBeginInfoEXT::pPostSubpassSampleLocationsfor the subpass.</para>
/// <para>If pDepthStencilAttachment is NULL, or if its attachment index isVK_ATTACHMENT_UNUSED, it indicates that no depth/stencil attachmentwill be used in the subpass.</para>
/// <para>The contents of an attachment within the render area become undefined atthe start of a subpass S if all of the following conditions are true:</para>
/// <para>The attachment is used as a color, depth/stencil, or resolve attachmentin any subpass in the render pass.</para>
/// <para>There is a subpass S1  that uses or preserves the attachment, and asubpass dependency from S1  to S.</para>
/// <para>The attachment is not used or preserved in subpass S.</para>
/// <para>Once the contents of an attachment become undefined in subpass S, theyremain undefined for subpasses in subpass dependency chains starting withsubpass S until they are written again.However, they remain valid for subpasses in other subpass dependency chainsstarting with subpass S1  if those subpasses use or preserve theattachment.</para>
/// <para>   pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS </para>
/// <para>   colorAttachmentCount must be less than or equal toVkPhysicalDeviceLimits::maxColorAttachments </para>
/// <para>  If the first use of an attachment in this render pass is as an inputattachment, and the attachment is not also used as a color ordepth/stencil attachment in the same subpass, then loadOp mustnot be VK_ATTACHMENT_LOAD_OP_CLEAR </para>
/// <para>  If pResolveAttachments is not NULL, for each resolve attachmentthat is not VK_ATTACHMENT_UNUSED, the corresponding colorattachment must not be VK_ATTACHMENT_UNUSED </para>
/// <para>  If pResolveAttachments is not NULL, for each resolve attachmentthat is not VK_ATTACHMENT_UNUSED, the corresponding colorattachment must not have a sample count of VK_SAMPLE_COUNT_1_BIT </para>
/// <para>  If pResolveAttachments is not NULL, each resolve attachment thatis not VK_ATTACHMENT_UNUSED must have a sample count ofVK_SAMPLE_COUNT_1_BIT </para>
/// <para>  If pResolveAttachments is not NULL, each resolve attachment thatis not VK_ATTACHMENT_UNUSED must have the same VkFormat asits corresponding color attachment</para>
/// <para>  All attachments in pColorAttachments that are notVK_ATTACHMENT_UNUSED must have the same sample count</para>
/// <para>  All attachments in pInputAttachments that are notVK_ATTACHMENT_UNUSED must have formats whose features contain atleast one of VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT orVK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT.</para>
/// <para>  All attachments in pColorAttachments that are notVK_ATTACHMENT_UNUSED must have formats whose features containVK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT </para>
/// <para>  All attachments in pResolveAttachments that are notVK_ATTACHMENT_UNUSED must have formats whose features containVK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT </para>
/// <para>  If pDepthStencilAttachment is not NULL and the attachment is notVK_ATTACHMENT_UNUSED then it must have a format whose featurescontain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT </para>
/// <para>  If the VK_AMD_mixed_attachment_samples extension is enabled, and allattachments in pColorAttachments that are notVK_ATTACHMENT_UNUSED must have a sample count that is smallerthan or equal to the sample count of pDepthStencilAttachment if itis not VK_ATTACHMENT_UNUSED </para>
/// <para>  If neither the VK_AMD_mixed_attachment_samples nor theVK_NV_framebuffer_mixed_samples extensions are enabled, and ifpDepthStencilAttachment is not VK_ATTACHMENT_UNUSED and anyattachments in pColorAttachments are notVK_ATTACHMENT_UNUSED, they must have the same sample count</para>
/// <para>  The attachment member of each element ofpPreserveAttachments must not be VK_ATTACHMENT_UNUSED </para>
/// <para>  Each element of pPreserveAttachments must not also be an elementof any other member of the subpass description</para>
/// <para>  If any attachment is used by more than one VkAttachmentReferencemember, then each use must use the same layout </para>
/// <para>  If flags includesVK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX, it mustalso include VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX.</para>
/// <para>   flags must be a valid combination of VkSubpassDescriptionFlagBits values</para>
/// <para>   pipelineBindPoint must be a valid VkPipelineBindPoint value</para>
/// <para>   If inputAttachmentCount is not 0, pInputAttachments must be a valid pointer to an array of inputAttachmentCount valid VkAttachmentReference structures</para>
/// <para>   If colorAttachmentCount is not 0, pColorAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference structures</para>
/// <para>   If colorAttachmentCount is not 0, and pResolveAttachments is not NULL, pResolveAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference structures</para>
/// <para>   If pDepthStencilAttachment is not NULL, pDepthStencilAttachment must be a valid pointer to a valid VkAttachmentReference structure</para>
/// <para>   If preserveAttachmentCount is not 0, pPreserveAttachments must be a valid pointer to an array of preserveAttachmentCount uint32_t values</para>
/// </summary>
public unsafe struct VkSubpassDescription {
    /// <summary> flags is a bitmask of VkSubpassDescriptionFlagBits
    /// specifying usage of the subpass.</summary>
    public VkSubpassDescriptionFlags       flags;
    /// <summary> pipelineBindPoint is a VkPipelineBindPoint value specifying
    /// the pipeline type supported for this subpass.</summary>
    public VkPipelineBindPoint             pipelineBindPoint;
    /// <summary> inputAttachmentCount is the number of input attachments.</summary>
    public UInt32                        inputAttachmentCount;
    /// <summary> pInputAttachments is an array of VkAttachmentReference
    /// structures defining the input attachments for this subpass and their
    /// layouts.</summary>
    public /* const */ VkAttachmentReference*    pInputAttachments;
    /// <summary> colorAttachmentCount is the number of color attachments.</summary>
    public UInt32                        colorAttachmentCount;
    /// <summary> pColorAttachments is an array of VkAttachmentReference
    /// structures defining the color attachments for this subpass and their
    /// layouts.</summary>
    public /* const */ VkAttachmentReference*    pColorAttachments;
    /// <summary> pResolveAttachments is an optional array of
    /// colorAttachmentCount VkAttachmentReference structures
    /// defining the resolve attachments for this subpass and their layouts.</summary>
    public /* const */ VkAttachmentReference*    pResolveAttachments;
    /// <summary> pDepthStencilAttachment is a pointer to a
    /// VkAttachmentReference specifying the depth/stencil attachment for
    /// this subpass and its layout.</summary>
    public /* const */ VkAttachmentReference*    pDepthStencilAttachment;
    /// <summary> preserveAttachmentCount is the number of preserved attachments.</summary>
    public UInt32                        preserveAttachmentCount;
    /// <summary> pPreserveAttachments is an array of preserveAttachmentCount
    /// render pass attachment indices identifying attachments that are not used
    /// by this subpass, but whose contents must be preserved throughout the
    /// subpass.</summary>
    public /* const */ UInt32*                 pPreserveAttachments;
}
// Struct: 396
/// <summary>VkSubpassDescription2KHR - Structure specifying a subpass description
/// <para>Parameters defined by this structure with the same name as those inVkSubpassDescription have the identical effect to those parameters.</para>
/// <para> viewMask has the same effect for the described subpass asVkRenderPassMultiviewCreateInfo::pViewMasks has on eachcorresponding subpass.</para>
/// <para>   pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS </para>
/// <para>   colorAttachmentCount must be less than or equal toVkPhysicalDeviceLimits::maxColorAttachments </para>
/// <para>  If the first use of an attachment in this render pass is as an inputattachment, and the attachment is not also used as a color ordepth/stencil attachment in the same subpass, then loadOp mustnot be VK_ATTACHMENT_LOAD_OP_CLEAR </para>
/// <para>  If pResolveAttachments is not NULL, for each resolve attachmentthat does not have the value VK_ATTACHMENT_UNUSED, thecorresponding color attachment must not have the valueVK_ATTACHMENT_UNUSED </para>
/// <para>  If pResolveAttachments is not NULL, for each resolve attachmentthat is not VK_ATTACHMENT_UNUSED, the corresponding colorattachment must not have a sample count of VK_SAMPLE_COUNT_1_BIT </para>
/// <para>  If pResolveAttachments is not NULL, each resolve attachment thatis not VK_ATTACHMENT_UNUSED must have a sample count ofVK_SAMPLE_COUNT_1_BIT </para>
/// <para>  Any given element of pResolveAttachments must have the sameVkFormat as its corresponding color attachment</para>
/// <para>  All attachments in pColorAttachments that are notVK_ATTACHMENT_UNUSED must have the same sample count</para>
/// <para>  If the VK_AMD_mixed_attachment_samples extension is enabled, allattachments in pColorAttachments that are notVK_ATTACHMENT_UNUSED must have a sample count that is smallerthan or equal to the sample count of pDepthStencilAttachment if itis not VK_ATTACHMENT_UNUSED </para>
/// <para>  If neither the VK_AMD_mixed_attachment_samples nor theVK_NV_framebuffer_mixed_samples extensions are enabled, and ifpDepthStencilAttachment is not VK_ATTACHMENT_UNUSED and anyattachments in pColorAttachments are notVK_ATTACHMENT_UNUSED, they must have the same sample count</para>
/// <para>  The attachment member of any element of pPreserveAttachments must not be VK_ATTACHMENT_UNUSED </para>
/// <para>  Any given element of pPreserveAttachments must not also be anelement of any other member of the subpass description</para>
/// <para>  If any attachment is used by more than one VkAttachmentReferencemember, then each use must use the same layout </para>
/// <para>  If flags includesVK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX, it mustalso include VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX.</para>
/// <para>  The aspectMask member of any element of pInputAttachments must be a valid combination of VkImageAspectFlagBits </para>
/// <para>  The aspectMask member of any element of pInputAttachments must not be 0 </para>
/// <para>  The aspectMask member of each element of pInputAttachments must not include VK_IMAGE_ASPECT_METADATA_BIT </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR </para>
/// <para>   flags must be a valid combination of VkSubpassDescriptionFlagBits values</para>
/// <para>   pipelineBindPoint must be a valid VkPipelineBindPoint value</para>
/// <para>   If inputAttachmentCount is not 0, pInputAttachments must be a valid pointer to an array of inputAttachmentCount valid VkAttachmentReference2KHR structures</para>
/// <para>   If colorAttachmentCount is not 0, pColorAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference2KHR structures</para>
/// <para>   If colorAttachmentCount is not 0, and pResolveAttachments is not NULL, pResolveAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference2KHR structures</para>
/// <para>   If pDepthStencilAttachment is not NULL, pDepthStencilAttachment must be a valid pointer to a valid VkAttachmentReference2KHR structure</para>
/// <para>   If preserveAttachmentCount is not 0, pPreserveAttachments must be a valid pointer to an array of preserveAttachmentCount uint32_t values</para>
/// </summary>
public unsafe struct VkSubpassDescription2KHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                     sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                         pNext;
    /// <summary> flags is a bitmask of VkSubpassDescriptionFlagBits
    /// specifying usage of the subpass.</summary>
    public VkSubpassDescriptionFlags           flags;
    /// <summary> pipelineBindPoint is a VkPipelineBindPoint value specifying
    /// the pipeline type supported for this subpass.</summary>
    public VkPipelineBindPoint                 pipelineBindPoint;
    /// <summary> viewMask is a bitfield of view indices describing which views
    /// rendering is broadcast to in this subpass, when multiview is enabled.</summary>
    public UInt32                            viewMask;
    /// <summary> inputAttachmentCount is the number of input attachments.</summary>
    public UInt32                            inputAttachmentCount;
    /// <summary> pInputAttachments is an array of VkAttachmentReference2KHR
    /// structures defining the input attachments for this subpass and their
    /// layouts.</summary>
    public /* const */ VkAttachmentReference2KHR*    pInputAttachments;
    /// <summary> colorAttachmentCount is the number of color attachments.</summary>
    public UInt32                            colorAttachmentCount;
    /// <summary> pColorAttachments is an array of VkAttachmentReference2KHR
    /// structures defining the color attachments for this subpass and their
    /// layouts.</summary>
    public /* const */ VkAttachmentReference2KHR*    pColorAttachments;
    /// <summary> pResolveAttachments is an optional array of
    /// colorAttachmentCount VkAttachmentReference2KHR structures
    /// defining the resolve attachments for this subpass and their layouts.</summary>
    public /* const */ VkAttachmentReference2KHR*    pResolveAttachments;
    /// <summary> pDepthStencilAttachment is a pointer to a
    /// VkAttachmentReference2KHR specifying the depth/stencil attachment
    /// for this subpass and its layout.</summary>
    public /* const */ VkAttachmentReference2KHR*    pDepthStencilAttachment;
    /// <summary> preserveAttachmentCount is the number of preserved attachments.</summary>
    public UInt32                            preserveAttachmentCount;
    /// <summary> pPreserveAttachments is an array of preserveAttachmentCount
    /// render pass attachment indices identifying attachments that are not used
    /// by this subpass, but whose contents must be preserved throughout the
    /// subpass.</summary>
    public /* const */ UInt32*                     pPreserveAttachments;
}
// Struct: 397
/// <summary>VkSubpassDescriptionDepthStencilResolveKHR - Structure specifying depth/stencil resolve operations for a subpass
/// <para>  If pDepthStencilResolveAttachment is not NULL and does not havethe value VK_ATTACHMENT_UNUSED, pDepthStencilAttachment must not have the value VK_ATTACHMENT_UNUSED </para>
/// <para>  If pDepthStencilResolveAttachment is not NULL and does not havethe value VK_ATTACHMENT_UNUSED, depthResolveMode andstencilResolveMode must not both beVK_RESOLVE_MODE_NONE_KHR </para>
/// <para>  If pDepthStencilResolveAttachment is not NULL and does not havethe value VK_ATTACHMENT_UNUSED, pDepthStencilAttachment must not have a sample count of VK_SAMPLE_COUNT_1_BIT </para>
/// <para>  If pDepthStencilResolveAttachment is not NULL and does not havethe value VK_ATTACHMENT_UNUSED,pDepthStencilResolveAttachment must have a sample count ofVK_SAMPLE_COUNT_1_BIT </para>
/// <para>  If pDepthStencilResolveAttachment is not NULL and does not havethe value VK_ATTACHMENT_UNUSED then it must have a format whosefeatures contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT </para>
/// <para>  If the VkFormat of pDepthStencilResolveAttachment has adepth component, then the VkFormat ofpDepthStencilAttachment must have a depth component with the samenumber of bits and numerical type</para>
/// <para>  If the VkFormat of pDepthStencilResolveAttachment has astencil component, then the VkFormat ofpDepthStencilAttachment must have a stencil component with thesame number of bits and numerical type</para>
/// <para>  The value of depthResolveMode must be one of the bits set inVkPhysicalDeviceDepthStencilResolvePropertiesKHR::supportedDepthResolveModesor VK_RESOLVE_MODE_NONE_KHR </para>
/// <para>  The value of stencilResolveMode must be one of the bits set inVkPhysicalDeviceDepthStencilResolvePropertiesKHR::supportedStencilResolveModesor VK_RESOLVE_MODE_NONE_KHR </para>
/// <para>  If the VkFormat of pDepthStencilResolveAttachment has bothdepth and stencil components,VkPhysicalDeviceDepthStencilResolvePropertiesKHR::independentResolveis VK_FALSE, andVkPhysicalDeviceDepthStencilResolvePropertiesKHR::independentResolveNoneis VK_FALSE, then the values of depthResolveMode andstencilResolveMode must be identical</para>
/// <para>  If the VkFormat of pDepthStencilResolveAttachment has bothdepth and stencil components,VkPhysicalDeviceDepthStencilResolvePropertiesKHR::independentResolveis VK_FALSE andVkPhysicalDeviceDepthStencilResolvePropertiesKHR::independentResolveNoneis VK_TRUE, then the values of depthResolveMode andstencilResolveMode must be identical or one of them must beVK_RESOLVE_MODE_NONE_KHR </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR </para>
/// <para>   depthResolveMode must be a valid VkResolveModeFlagBitsKHR value</para>
/// <para>   stencilResolveMode must be a valid VkResolveModeFlagBitsKHR value</para>
/// <para>   If pDepthStencilResolveAttachment is not NULL, pDepthStencilResolveAttachment must be a valid pointer to a valid VkAttachmentReference2KHR structure</para>
/// </summary>
public unsafe struct VkSubpassDescriptionDepthStencilResolveKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                     sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                         pNext;
    /// <summary> depthResolveMode is a bitmask of VkResolveModeFlagBitsKHR
    /// describing the depth resolve mode.</summary>
    public VkResolveModeFlagBitsKHR            depthResolveMode;
    /// <summary> stencilResolveMode is a bitmask of VkResolveModeFlagBitsKHR
    /// describing the stencil resolve mode.</summary>
    public VkResolveModeFlagBitsKHR            stencilResolveMode;
    /// <summary> pDepthStencilResolveAttachment is an optional
    /// VkAttachmentReference structure defining the depth/stencil resolve
    /// attachment for this subpass and its layout.</summary>
    public /* const */ VkAttachmentReference2KHR*    pDepthStencilResolveAttachment;
}
// Struct: 398
/// <summary>VkSubpassEndInfoKHR - Structure specifying subpass end info
/// <para>   sType must be VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkSubpassEndInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
}
// Struct: 399
/// <summary>VkSubpassSampleLocationsEXT - Structure specifying the sample locations state to use for layout transitions of attachments performed after a given subpass
/// <para>If the image referenced by the depth/stencil attachment used in the subpassidentified by subpassIndex was not created withVK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT or if thesubpass does not use a depth/stencil attachment, andVkPhysicalDeviceSampleLocationsPropertiesEXT::variableSampleLocationsis VK_TRUE then the values specified in sampleLocationsInfo areignored.</para>
/// <para>   subpassIndex must be less than the subpassCount specifiedin VkRenderPassCreateInfo the render pass specified byVkRenderPassBeginInfo::renderPass was created with</para>
/// <para>   sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure</para>
/// </summary>
public unsafe struct VkSubpassSampleLocationsEXT {
    /// <summary> subpassIndex is the index of the subpass for which the sample
    /// locations state is provided.</summary>
    public UInt32                    subpassIndex;
    /// <summary> sampleLocationsInfo is the sample locations state to use for the
    /// layout transition of the depth/stencil attachment away from the image
    /// layout the attachment is used with in the subpass specified in
    /// subpassIndex.</summary>
    public VkSampleLocationsInfoEXT    sampleLocationsInfo;
}
// Struct: 400
/// <summary>VkSubresourceLayout - Structure specifying subresource layout
/// <para>If the image is linear, then rowPitch,arrayPitch and depthPitch describe the layout of the imagesubresource in linear memory.For uncompressed formats, rowPitch is the number of bytes betweentexels with the same x coordinate in adjacent rows (y coordinates differ byone).arrayPitch is the number of bytes between texels with the same x and ycoordinate in adjacent array layers of the image (array layer values differby one).depthPitch is the number of bytes between texels with the same x and ycoordinate in adjacent slices of a 3D image (z coordinates differ by one).Expressed as an addressing formula, the starting byte of a texel in theimage subresource has address:</para>
/// <para>For compressed formats, the rowPitch is the number of bytes betweencompressed texel blocks in adjacent rows.arrayPitch is the number of bytes between compressed texel blocks inadjacent array layers.depthPitch is the number of bytes between compressed texel blocks inadjacent slices of a 3D image.</para>
/// <para>The value of arrayPitch is undefined for images that were not createdas arrays.depthPitch is defined only for 3D images.</para>
/// <para>If the image has asingle-planecolor formatand its tiling is VK_IMAGE_TILING_LINEAR, then the aspectMask member of VkImageSubresource must beVK_IMAGE_ASPECT_COLOR_BIT.</para>
/// <para>If the image has a depth/stencil formatand its tiling is VK_IMAGE_TILING_LINEAR, then aspectMask must be either VK_IMAGE_ASPECT_DEPTH_BIT orVK_IMAGE_ASPECT_STENCIL_BIT.On implementations that store depth and stencil aspects separately, queryingeach of these image subresource layouts will return a different offsetand size representing the region of memory used for that aspect.On implementations that store depth and stencil aspects interleaved, thesame offset and size are returned and represent the interleavedmemory allocation.</para>
/// <para>If the image has a multi-planarformatand its tiling is VK_IMAGE_TILING_LINEAR, then the aspectMask member of VkImageSubresource must beVK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or(for 3-plane formats only) VK_IMAGE_ASPECT_PLANE_2_BIT.Querying each of these image subresource layouts will return a differentoffset and size representing the region of memory used for thatplane.If the image is disjoint, then the offset is relative to the baseaddress of the plane.If the image is non-disjoint, then the offset is relative to thebase address of the image.</para>
/// <para>If the image’s tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, thenthe aspectMask member of VkImageSubresource must be one ofVK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT, where the maximum allowedplane index i is defined by the drmFormatModifierPlaneCount associated with the image’s  format  andmodifier.The memory range used by the subresource is described by offset andsize.If the image is disjoint, then the offset is relative to the baseaddress of the memory plane.If the image is non-disjoint, then the offset is relative to thebase address of the image.If the image is non-linear, thenrowPitch, arrayPitch, and depthPitch have animplementation-dependent meaning.</para>
/// </summary>
public unsafe struct VkSubresourceLayout {
    /// <summary> offset is the byte offset from the start of the image
    /// or the plane
    /// where the image subresource begins.</summary>
    public VkDeviceSize    offset;
    /// <summary> size is the size in bytes of the image subresource.
    /// size includes any extra memory that is required based on
    /// rowPitch.</summary>
    public VkDeviceSize    size;
    /// <summary> rowPitch describes the number of bytes between each row of texels
    /// in an image.</summary>
    public VkDeviceSize    rowPitch;
    /// <summary> arrayPitch describes the number of bytes between each array layer
    /// of an image.</summary>
    public VkDeviceSize    arrayPitch;
    /// <summary> depthPitch describes the number of bytes between each slice of 3D
    /// image.</summary>
    public VkDeviceSize    depthPitch;
}
// Struct: 401
/// <summary>VkSurfaceCapabilities2EXT - Structure describing capabilities of a surface
/// <para> sType is the type of this structure.</para>
/// <para> pNext is NULL or a pointer to an extension-specific structure.</para>
/// <para> supportedSurfaceCounters is a bitmask ofVkSurfaceCounterFlagBitsEXT indicating the supported surfacecounter types.</para>
/// <para>   supportedSurfaceCounters must not includeVK_SURFACE_COUNTER_VBLANK_EXT unless the surface queried is adisplay surface.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkSurfaceCapabilities2EXT {
    public VkStructureType                  sType;
    public void*                            pNext;
    public UInt32                         minImageCount;
    public UInt32                         maxImageCount;
    public VkExtent2D                       currentExtent;
    public VkExtent2D                       minImageExtent;
    public VkExtent2D                       maxImageExtent;
    public UInt32                         maxImageArrayLayers;
    public VkSurfaceTransformFlagsKHR       supportedTransforms;
    public VkSurfaceTransformFlagBitsKHR    currentTransform;
    public VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    public VkImageUsageFlags                supportedUsageFlags;
    public VkSurfaceCounterFlagsEXT         supportedSurfaceCounters;
}
// Struct: 402
/// <summary>VkSurfaceCapabilities2KHR - Structure describing capabilities of a surface
/// <para>   sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDisplayNativeHdrSurfaceCapabilitiesAMD, VkSharedPresentSurfaceCapabilitiesKHR, VkSurfaceCapabilitiesFullScreenExclusiveEXT, or VkSurfaceProtectedCapabilitiesKHR </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// </summary>
public unsafe struct VkSurfaceCapabilities2KHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                       pNext;
    /// <summary> surfaceCapabilities is a structure of type
    /// VkSurfaceCapabilitiesKHR describing the capabilities of the
    /// specified surface.</summary>
    public VkSurfaceCapabilitiesKHR    surfaceCapabilities;
}
// Struct: 403
/// <summary>VkSurfaceCapabilitiesFullScreenExclusiveEXT - Structure describing full screen exclusive capabilities of a surface
/// <para>This structure can be included in the pNext chain ofVkSurfaceCapabilities2KHR to determine support for exclusivefull-screen access.If fullScreenExclusiveSupported is VK_FALSE, it indicates thatexclusive full-screen access is not obtainable for this surface.</para>
/// <para>Applications must not attempt to create swapchains withVK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT set iffullScreenExclusiveSupported is VK_FALSE.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT </para>
/// </summary>
public unsafe struct VkSurfaceCapabilitiesFullScreenExclusiveEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*              pNext;
    public VkBool32           fullScreenExclusiveSupported;
}
// Struct: 404
/// <summary>VkSurfaceCapabilitiesKHR - Structure describing capabilities of a surface
/// <para>Supported usage flags of a presentable image when usingVK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR orVK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR presentation mode areprovided byVkSharedPresentSurfaceCapabilitiesKHR::sharedPresentSupportedUsageFlags.</para>
/// <para>Formulas such as min(N, maxImageCount) are not correct, sincemaxImageCount may be zero.</para>
/// </summary>
public unsafe struct VkSurfaceCapabilitiesKHR {
    /// <summary> minImageCount is the minimum number of images the specified device
    /// supports for a swapchain created for the surface, and will be at least
    /// one.</summary>
    public UInt32                         minImageCount;
    /// <summary> maxImageCount is the maximum number of images the specified device
    /// supports for a swapchain created for the surface, and will be either 0,
    /// or greater than or equal to minImageCount.
    /// A value of 0 means that there is no limit on the number of images,
    /// though there may be limits related to the total amount of memory used
    /// by presentable images.</summary>
    public UInt32                         maxImageCount;
    /// <summary> currentExtent is the current width and height of the surface, or
    /// the special value (0xFFFFFFFF, 0xFFFFFFFF) indicating that the
    /// surface size will be determined by the extent of a swapchain targeting
    /// the surface.</summary>
    public VkExtent2D                       currentExtent;
    /// <summary> minImageExtent contains the smallest valid swapchain extent for
    /// the surface on the specified device.
    /// The width and height of the extent will each be less than or
    /// equal to the corresponding width and height of
    /// currentExtent, unless currentExtent has the special value
    /// described above.</summary>
    public VkExtent2D                       minImageExtent;
    /// <summary> maxImageExtent contains the largest valid swapchain extent for the
    /// surface on the specified device.
    /// The width and height of the extent will each be greater than
    /// or equal to the corresponding width and height of
    /// minImageExtent.
    /// The width and height of the extent will each be greater than
    /// or equal to the corresponding width and height of
    /// currentExtent, unless currentExtent has the special value
    /// described above.</summary>
    public VkExtent2D                       maxImageExtent;
    /// <summary> maxImageArrayLayers is the maximum number of layers presentable
    /// images can have for a swapchain created for this device and surface,
    /// and will be at least one.</summary>
    public UInt32                         maxImageArrayLayers;
    /// <summary> supportedTransforms is a bitmask of
    /// VkSurfaceTransformFlagBitsKHR indicating the presentation
    /// transforms supported for the surface on the specified device.
    /// At least one bit will be set.</summary>
    public VkSurfaceTransformFlagsKHR       supportedTransforms;
    /// <summary> currentTransform is VkSurfaceTransformFlagBitsKHR value
    /// indicating the surface’s current transform relative to the presentation
    /// engine’s natural orientation.</summary>
    public VkSurfaceTransformFlagBitsKHR    currentTransform;
    /// <summary> supportedCompositeAlpha is a bitmask of
    /// VkCompositeAlphaFlagBitsKHR, representing the alpha compositing
    /// modes supported by the presentation engine for the surface on the
    /// specified device, and at least one bit will be set.
    /// Opaque composition can be achieved in any alpha compositing mode by
    /// either using an image format that has no alpha component, or by ensuring
    /// that all pixels in the presentable images have an alpha value of 1.0.</summary>
    public VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    /// <summary> supportedUsageFlags is a bitmask of VkImageUsageFlagBits
    /// representing the ways the application can use the presentable images of
    /// a swapchain created
    /// with VkPresentModeKHR set to VK_PRESENT_MODE_IMMEDIATE_KHR,
    /// VK_PRESENT_MODE_MAILBOX_KHR, VK_PRESENT_MODE_FIFO_KHR or
    /// VK_PRESENT_MODE_FIFO_RELAXED_KHR
    /// for the surface on the specified device.
    /// VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT must be included in the set
    /// but implementations may support additional usages.</summary>
    public VkImageUsageFlags                supportedUsageFlags;
}
// Struct: 405
/// <summary>VkSurfaceFormat2KHR - Structure describing a supported swapchain format tuple
/// <para>   sType must be VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR </para>
/// <para>   pNext must be NULL </para>
/// </summary>
public unsafe struct VkSurfaceFormat2KHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType       sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                 pNext;
    /// <summary> surfaceFormat is an instance of VkSurfaceFormatKHR
    /// describing a format-color space pair that is compatible with the
    /// specified surface.</summary>
    public VkSurfaceFormatKHR    surfaceFormat;
}
// Struct: 406
/// <summary>VkSurfaceFormatKHR - Structure describing a supported swapchain format-color space pair
/// </summary>
public unsafe struct VkSurfaceFormatKHR {
    /// <summary> format is a VkFormat that is compatible with the specified
    /// surface.</summary>
    public VkFormat           format;
    /// <summary> colorSpace is a presentation VkColorSpaceKHR that is
    /// compatible with the surface.</summary>
    public VkColorSpaceKHR    colorSpace;
}
// Struct: 407
/// <summary>VkSurfaceFullScreenExclusiveInfoEXT - Structure specifying the preferred full-screen transition behavior
/// <para>If this structure is not present, fullScreenExclusive is considered tobe VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT </para>
/// <para>   fullScreenExclusive must be a valid VkFullScreenExclusiveEXT value</para>
/// </summary>
public unsafe struct VkSurfaceFullScreenExclusiveInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public void*                       pNext;
    /// <summary> fullScreenExclusive is a VkFullScreenExclusiveEXT value
    /// specifying the preferred full-screen transition behavior.</summary>
    public VkFullScreenExclusiveEXT    fullScreenExclusive;
}
// Struct: 408
/// <summary>VkSurfaceFullScreenExclusiveWin32InfoEXT - Structure specifying additional creation parameters specific to Win32 fullscreen exclusive mode
/// <para>If hmonitor is invalidated (e.g. the monitor is unplugged) during thelifetime of a swapchain created with this structure, operations on thatswapchain will return VK_ERROR_OUT_OF_DATE_KHR.</para>
/// <para>It’s the responsibility of the application to change the display settings ofthe targeted Win32 display using the appropriate platform APIs.Such changes may alter the surface capabilities reported for the createdsurface.</para>
/// <para>   hmonitor must be a valid HMONITOR </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT </para>
/// </summary>
public unsafe struct VkSurfaceFullScreenExclusiveWin32InfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> hmonitor is the Win32 HMONITOR handle identifying the display
    /// to create the surface with.</summary>
    public HMONITOR           hmonitor;
}
// Struct: 409
/// <summary>VkSurfaceProtectedCapabilitiesKHR - Structure describing capability of a surface to be protected
/// <para>   sType must be VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR </para>
/// </summary>
public unsafe struct VkSurfaceProtectedCapabilitiesKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> supportsProtected specifies whether a protected swapchain created
    /// from VkPhysicalDeviceSurfaceInfo2KHR::surface for a
    /// particular windowing system can be displayed on screen or not.
    /// If supportsProtected is VK_TRUE, then creation of swapchains
    /// with the VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR flag set must be
    /// supported for surface.</summary>
    public VkBool32           supportsProtected;
}
// Struct: 410
/// <summary>VkSwapchainCounterCreateInfoEXT - Specify the surface counters desired
/// <para>  The bits in surfaceCounters must be supported byVkSwapchainCreateInfoKHR::surface, as reported byvkGetPhysicalDeviceSurfaceCapabilities2EXT.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT </para>
/// <para>   surfaceCounters must be a valid combination of VkSurfaceCounterFlagBitsEXT values</para>
/// </summary>
public unsafe struct VkSwapchainCounterCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                 pNext;
    /// <summary> surfaceCounters is a bitmask of VkSurfaceCounterFlagBitsEXT
    /// specifying surface counters to enable for the swapchain.</summary>
    public VkSurfaceCounterFlagsEXT    surfaceCounters;
}
// Struct: 411
/// <summary>VkSwapchainCreateInfoKHR - Structure specifying parameters of a newly created swapchain object
/// <para>On some platforms, it is normal that maxImageExtent may become (0,0), for example when the window is minimized.In such a case, it is not possible to create a swapchain due to the ValidUsage requirements.</para>
/// <para> imageArrayLayers is the number of views in a multiview/stereosurface.For non-stereoscopic-3D applications, this value is 1.</para>
/// <para> imageUsage is a bitmask of VkImageUsageFlagBits describingthe intended usage of the (acquired) swapchain images.</para>
/// <para> imageSharingMode is the sharing mode used for the image(s) of theswapchain.</para>
/// <para> queueFamilyIndexCount is the number of queue families havingaccess to the image(s) of the swapchain when imageSharingMode isVK_SHARING_MODE_CONCURRENT.</para>
/// <para> pQueueFamilyIndices is an array of queue family indices havingaccess to the images(s) of the swapchain when imageSharingMode isVK_SHARING_MODE_CONCURRENT.</para>
/// <para> preTransform is a VkSurfaceTransformFlagBitsKHR valuedescribing the transform, relative to the presentation engine’s naturalorientation, applied to the image content prior to presentation.If it does not match the currentTransform value returned byvkGetPhysicalDeviceSurfaceCapabilitiesKHR, the presentation enginewill transform the image content as part of the presentation operation.</para>
/// <para> compositeAlpha is a VkCompositeAlphaFlagBitsKHR valueindicating the alpha compositing mode to use when this surface iscomposited together with other surfaces on certain window systems.</para>
/// <para> presentMode is the presentation mode the swapchain will use.A swapchain’s present mode determines how incoming present requests willbe processed and queued internally.</para>
/// <para> clipped specifies whether the Vulkan implementation is allowed todiscard rendering operations that affect regions of the surface that arenot visible.</para>
/// <para>If set to VK_TRUE, the presentable images associated with theswapchain may not own all of their pixels.Pixels in the presentable images that correspond to regions of thetarget surface obscured by another window on the desktop, or subject tosome other clipping mechanism will have undefined content when readback.Pixel shaders may not execute for these pixels, and thus any sideeffects they would have had will not occur.VK_TRUE value does not guarantee any clipping will occur, butallows more optimal presentation methods to be used on some platforms.</para>
/// <para>If set to VK_FALSE, presentable images associated with theswapchain will own all of the pixels they contain.</para>
/// <para>Applications should set this value to VK_TRUE if they do not expectto read back the content of presentable images before presenting them orafter reacquiring them, and if their pixel shaders do not have any sideeffects that require them to run for all pixels in the presentable image.</para>
/// <para> oldSwapchain is VK_NULL_HANDLE, or the existing non-retiredswapchain currently associated with surface.Providing a valid oldSwapchain may aid in the resource reuse, andalso allows the application to still present any images that are alreadyacquired from it.</para>
/// <para>Upon calling vkCreateSwapchainKHR with an oldSwapchain that isnot VK_NULL_HANDLE, oldSwapchain is retired — even if creationof the new swapchain fails.The new swapchain is created in the non-retired state whether or notoldSwapchain is VK_NULL_HANDLE.</para>
/// <para>Upon calling vkCreateSwapchainKHR with an oldSwapchain that isnot VK_NULL_HANDLE, any images from oldSwapchain that are notacquired by the application may be freed by the implementation, which mayoccur even if creation of the new swapchain fails.The application can destroy oldSwapchain to free all memoryassociated with oldSwapchain.</para>
/// <para>Multiple retired swapchains can be associated with the sameVkSurfaceKHR through multiple uses of oldSwapchain thatoutnumber calls to vkDestroySwapchainKHR.</para>
/// <para>After oldSwapchain is retired, the application can pass tovkQueuePresentKHR any images it had already acquired fromoldSwapchain.E.g., an application may present an image from the old swapchain before animage from the new swapchain is ready to be presented.As usual, vkQueuePresentKHR may fail if oldSwapchain hasentered a state that causes VK_ERROR_OUT_OF_DATE_KHR to be returned.</para>
/// <para>The application can continue to use a shared presentable image obtainedfrom oldSwapchain until a presentable image is acquired from the newswapchain, as long as it has not entered a state that causes it to returnVK_ERROR_OUT_OF_DATE_KHR.</para>
/// <para>   surface must be a surface that is supported by the device asdetermined using vkGetPhysicalDeviceSurfaceSupportKHR </para>
/// <para>   minImageCount must be greater than or equal to the value returnedin the minImageCount member of the VkSurfaceCapabilitiesKHRstructure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHRfor the surface</para>
/// <para>   minImageCount must be less than or equal to the value returned inthe maxImageCount member of the VkSurfaceCapabilitiesKHRstructure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHRfor the surface if the returned maxImageCount is not zero</para>
/// <para>   minImageCount must be 1 if presentMode is eitherVK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR orVK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR </para>
/// <para>   imageFormat and imageColorSpace must match the formatand colorSpace members, respectively, of one of theVkSurfaceFormatKHR structures returned byvkGetPhysicalDeviceSurfaceFormatsKHR for the surface</para>
/// <para>   imageExtent must be between minImageExtent andmaxImageExtent, inclusive, where minImageExtent andmaxImageExtent are members of the VkSurfaceCapabilitiesKHRstructure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHRfor the surface</para>
/// <para>   imageExtent members width and height must both benon-zero</para>
/// <para>   imageArrayLayers must be greater than 0 and less than or equalto the maxImageArrayLayers member of theVkSurfaceCapabilitiesKHR structure returned byvkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</para>
/// <para>  If presentMode is VK_PRESENT_MODE_IMMEDIATE_KHR,VK_PRESENT_MODE_MAILBOX_KHR, VK_PRESENT_MODE_FIFO_KHR orVK_PRESENT_MODE_FIFO_RELAXED_KHR, imageUsage must be asubset of the supported usage flags present in thesupportedUsageFlags member of the VkSurfaceCapabilitiesKHRstructure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHRfor surface </para>
/// <para>  If presentMode is VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHRor VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, imageUsage must be a subset of the supported usage flags present in thesharedPresentSupportedUsageFlags member of theVkSharedPresentSurfaceCapabilitiesKHR structure returned byvkGetPhysicalDeviceSurfaceCapabilities2KHR for surface </para>
/// <para>  If imageSharingMode is VK_SHARING_MODE_CONCURRENT,pQueueFamilyIndices must be a valid pointer to an array ofqueueFamilyIndexCount uint32_t values</para>
/// <para>  If imageSharingMode is VK_SHARING_MODE_CONCURRENT,queueFamilyIndexCount must be greater than 1 </para>
/// <para>  If imageSharingMode is VK_SHARING_MODE_CONCURRENT, eachelement of pQueueFamilyIndices must be unique and must be lessthan pQueueFamilyPropertyCount returned by eithervkGetPhysicalDeviceQueueFamilyProperties orvkGetPhysicalDeviceQueueFamilyProperties2 for thephysicalDevice that was used to create device </para>
/// <para>   preTransform must be one of the bits present in thesupportedTransforms member of the VkSurfaceCapabilitiesKHRstructure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHRfor the surface</para>
/// <para>   compositeAlpha must be one of the bits present in thesupportedCompositeAlpha member of theVkSurfaceCapabilitiesKHR structure returned byvkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface</para>
/// <para>   presentMode must be one of the VkPresentModeKHR valuesreturned by vkGetPhysicalDeviceSurfacePresentModesKHR for thesurface</para>
/// <para>  If the logical device was created withVkDeviceGroupDeviceCreateInfo::physicalDeviceCount equal to1, flags must not containVK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR </para>
/// <para>  If oldSwapchain is not VK_NULL_HANDLE, oldSwapchain must be a non-retired swapchain associated with native window referredto by surface </para>
/// <para>  The implied image creationparameters of the swapchain must be supported as reported byvkGetPhysicalDeviceImageFormatProperties </para>
/// <para>  If flags contains VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHRthen the pNext chain must contain an instance ofVkImageFormatListCreateInfoKHR with a viewFormatCountgreater than zero and pViewFormats must have an element equal toimageFormat </para>
/// <para>  If flags contains VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR,then VkSurfaceProtectedCapabilitiesKHR::supportsProtected must be VK_TRUE in the VkSurfaceProtectedCapabilitiesKHRstructure returned by vkGetPhysicalDeviceSurfaceCapabilities2KHRfor surface </para>
/// <para>  If the pNext chain includes an instance ofVkSurfaceFullScreenExclusiveInfoEXT with itsfullScreenExclusive member set toVK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, andsurface was created using vkCreateWin32SurfaceKHR, aninstance of VkSurfaceFullScreenExclusiveWin32InfoEXT must bepresent in the pNext chain</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupSwapchainCreateInfoKHR, VkImageFormatListCreateInfoKHR, VkSurfaceFullScreenExclusiveInfoEXT, VkSurfaceFullScreenExclusiveWin32InfoEXT, VkSwapchainCounterCreateInfoEXT, or VkSwapchainDisplayNativeHdrCreateInfoAMD </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   flags must be a valid combination of VkSwapchainCreateFlagBitsKHR values</para>
/// <para>   surface must be a valid VkSurfaceKHR handle</para>
/// <para>   imageFormat must be a valid VkFormat value</para>
/// <para>   imageColorSpace must be a valid VkColorSpaceKHR value</para>
/// <para>   imageUsage must be a valid combination of VkImageUsageFlagBits values</para>
/// <para>   imageUsage must not be 0 </para>
/// <para>   imageSharingMode must be a valid VkSharingMode value</para>
/// <para>   preTransform must be a valid VkSurfaceTransformFlagBitsKHR value</para>
/// <para>   compositeAlpha must be a valid VkCompositeAlphaFlagBitsKHR value</para>
/// <para>   presentMode must be a valid VkPresentModeKHR value</para>
/// <para>   If oldSwapchain is not VK_NULL_HANDLE, oldSwapchain must be a valid VkSwapchainKHR handle</para>
/// <para>   If oldSwapchain is a valid handle, it must have been created, allocated, or retrieved from surface </para>
/// <para>   Both of oldSwapchain, and surface that are valid handles must have been created, allocated, or retrieved from the same VkInstance </para>
/// </summary>
public unsafe struct VkSwapchainCreateInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                  sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                      pNext;
    /// <summary> flags is a bitmask of VkSwapchainCreateFlagBitsKHR
    /// indicating parameters of the swapchain creation.</summary>
    public VkSwapchainCreateFlagsKHR        flags;
    /// <summary> surface is the surface onto which the swapchain will present
    /// images.
    /// If the creation succeeds, the swapchain becomes associated with
    /// surface.</summary>
    public VkSurfaceKHR                     surface;
    /// <summary> minImageCount is the minimum number of presentable images that the
    /// application needs.
    /// The implementation will either create the swapchain with at least that
    /// many images, or it will fail to create the swapchain.</summary>
    public UInt32                         minImageCount;
    /// <summary> imageFormat is a VkFormat value specifying the format the
    /// swapchain image(s) will be created with.</summary>
    public VkFormat                         imageFormat;
    /// <summary> imageColorSpace is a VkColorSpaceKHR value specifying the
    /// way the swapchain interprets image data.</summary>
    public VkColorSpaceKHR                  imageColorSpace;
    /// <summary> imageExtent is the size (in pixels) of the swapchain image(s).
    /// The behavior is platform-dependent if the image extent does not match
    /// the surface’s currentExtent as returned by
    /// vkGetPhysicalDeviceSurfaceCapabilitiesKHR.</summary>
    public VkExtent2D                       imageExtent;
    public UInt32                         imageArrayLayers;
    public VkImageUsageFlags                imageUsage;
    public VkSharingMode                    imageSharingMode;
    public UInt32                         queueFamilyIndexCount;
    public /* const */ UInt32*                  pQueueFamilyIndices;
    public VkSurfaceTransformFlagBitsKHR    preTransform;
    public VkCompositeAlphaFlagBitsKHR      compositeAlpha;
    public VkPresentModeKHR                 presentMode;
    public VkBool32                         clipped;
    public VkSwapchainKHR                   oldSwapchain;
}
// Struct: 412
/// <summary>VkSwapchainDisplayNativeHdrCreateInfoAMD - Structure specifying display native HDR parameters of a newly created swapchain object
/// <para>If the pNext chain of VkSwapchainCreateInfoKHR does not containthis structure, the default value for localDimmingEnable isVK_TRUE, meaning local dimming is initially enabled for the swapchain.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD </para>
/// <para>  It is only valid to set localDimmingEnable to VK_TRUE ifVkDisplayNativeHdrSurfaceCapabilitiesAMD::localDimmingSupportis supported.</para>
/// </summary>
public unsafe struct VkSwapchainDisplayNativeHdrCreateInfoAMD {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> localDimmingEnable specifies whether local dimming is enabled for
    /// the swapchain.</summary>
    public VkBool32           localDimmingEnable;
}
// Struct: 413
/// <summary>VkTextureLODGatherFormatPropertiesAMD - Structure informing whether or not texture gather bias/LOD functionality is supported for a given image format and a given physical device.
/// <para>   sType must be VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD </para>
/// </summary>
public unsafe struct VkTextureLODGatherFormatPropertiesAMD {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL.</summary>
    public void*              pNext;
    /// <summary> supportsTextureGatherLODBiasAMD tells if the image format can be
    /// used with texture gather bias/LOD functions, as introduced by the
    ///  html/vkspec.html#VK_AMD_texture_gather_bias_lod  extension.
    /// This field is set by the implementation.
    /// User-specified value is ignored.</summary>
    public VkBool32           supportsTextureGatherLODBiasAMD;
}
// Struct: 414
/// <summary>VkValidationCacheCreateInfoEXT - Structure specifying parameters of a newly created validation cache
/// <para>  If initialDataSize is not 0, it must be equal to the size ofpInitialData, as returned by vkGetValidationCacheDataEXTwhen pInitialData was originally retrieved</para>
/// <para>  If initialDataSize is not 0, pInitialData must have beenretrieved from a previous call to vkGetValidationCacheDataEXT </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// <para>   If initialDataSize is not 0, pInitialData must be a valid pointer to an array of initialDataSize bytes</para>
/// </summary>
public unsafe struct VkValidationCacheCreateInfoEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                        pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkValidationCacheCreateFlagsEXT    flags;
    /// <summary> initialDataSize is the number of bytes in pInitialData.
    /// If initialDataSize is zero, the validation cache will initially be
    /// empty.</summary>
    public size_t                             initialDataSize;
    /// <summary> pInitialData is a pointer to previously retrieved validation cache
    /// data.
    /// If the validation cache data is incompatible (as defined below) with the
    /// device, the validation cache will be initially empty.
    /// If initialDataSize is zero, pInitialData is ignored.</summary>
    public /* const */ void*                        pInitialData;
}
// Struct: 415
/// <summary>VkValidationFeaturesEXT - Specify validation features to enable or disable for a Vulkan instance
/// <para>   sType must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT </para>
/// <para>   If enabledValidationFeatureCount is not 0, pEnabledValidationFeatures must be a valid pointer to an array of enabledValidationFeatureCount valid VkValidationFeatureEnableEXT values</para>
/// <para>   If disabledValidationFeatureCount is not 0, pDisabledValidationFeatures must be a valid pointer to an array of disabledValidationFeatureCount valid VkValidationFeatureDisableEXT values</para>
/// </summary>
public unsafe struct VkValidationFeaturesEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                         sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                             pNext;
    /// <summary> enabledValidationFeatureCount is the number of features to enable.</summary>
    public UInt32                                enabledValidationFeatureCount;
    /// <summary> pEnabledValidationFeatures is a pointer to an array of
    /// VkValidationFeatureEnableEXT values specifying the validation
    /// features to be enabled.</summary>
    public /* const */ VkValidationFeatureEnableEXT*     pEnabledValidationFeatures;
    /// <summary> disabledValidationFeatureCount is the number of features to
    /// disable.</summary>
    public UInt32                                disabledValidationFeatureCount;
    /// <summary> pDisabledValidationFeatures is a pointer to an array of
    /// VkValidationFeatureDisableEXT values specifying the validation
    /// features to be disabled.</summary>
    public /* const */ VkValidationFeatureDisableEXT*    pDisabledValidationFeatures;
}
// Struct: 416
/// <summary>VkValidationFlagsEXT - Specify validation checks to disable for a Vulkan instance
/// <para>   sType must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT </para>
/// <para>   pDisabledValidationChecks must be a valid pointer to an array of disabledValidationCheckCount valid VkValidationCheckEXT values</para>
/// <para>   disabledValidationCheckCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkValidationFlagsEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                    pNext;
    /// <summary> disabledValidationCheckCount is the number of checks to disable.</summary>
    public UInt32                       disabledValidationCheckCount;
    /// <summary> pDisabledValidationChecks is a pointer to an array of
    /// VkValidationCheckEXT values specifying the validation checks to be
    /// disabled.</summary>
    public /* const */ VkValidationCheckEXT*    pDisabledValidationChecks;
}
// Struct: 417
/// <summary>VkVertexInputAttributeDescription - Structure specifying vertex input attribute description
/// <para>   location must be less thanVkPhysicalDeviceLimits::maxVertexInputAttributes </para>
/// <para>   binding must be less thanVkPhysicalDeviceLimits::maxVertexInputBindings </para>
/// <para>   offset must be less than or equal toVkPhysicalDeviceLimits::maxVertexInputAttributeOffset </para>
/// <para>   format must be allowed as a vertex buffer format, as specified bythe VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT flag inVkFormatProperties::bufferFeatures returned byvkGetPhysicalDeviceFormatProperties </para>
/// <para>   format must be a valid VkFormat value</para>
/// </summary>
public unsafe struct VkVertexInputAttributeDescription {
    /// <summary> location is the shader binding location number for this attribute.</summary>
    public UInt32    location;
    /// <summary> binding is the binding number which this attribute takes its data
    /// from.</summary>
    public UInt32    binding;
    /// <summary> format is the size and type of the vertex attribute data.</summary>
    public VkFormat    format;
    /// <summary> offset is a byte offset of this attribute relative to the start of
    /// an element in the vertex input binding.</summary>
    public UInt32    offset;
}
// Struct: 418
/// <summary>VkVertexInputBindingDescription - Structure specifying vertex input binding description
/// <para>   binding must be less thanVkPhysicalDeviceLimits::maxVertexInputBindings </para>
/// <para>   stride must be less than or equal toVkPhysicalDeviceLimits::maxVertexInputBindingStride </para>
/// <para>   inputRate must be a valid VkVertexInputRate value</para>
/// </summary>
public unsafe struct VkVertexInputBindingDescription {
    /// <summary> binding is the binding number that this structure describes.</summary>
    public UInt32             binding;
    /// <summary> stride is the distance in bytes between two consecutive elements
    /// within the buffer.</summary>
    public UInt32             stride;
    /// <summary> inputRate is a VkVertexInputRate value specifying whether
    /// vertex attribute addressing is a function of the vertex index or of the
    /// instance index.</summary>
    public VkVertexInputRate    inputRate;
}
// Struct: 419
/// <summary>VkVertexInputBindingDivisorDescriptionEXT - Structure specifying a divisor used in instanced rendering
/// <para>If this structure is not used to define a divisor value for an attributethen the divisor has a logical default value of 1.</para>
/// <para>   binding must be less thanVkPhysicalDeviceLimits::maxVertexInputBindings </para>
/// <para>  If the vertexAttributeInstanceRateZeroDivisor feature is notenabled, divisor must not be 0 </para>
/// <para>  If the vertexAttributeInstanceRateDivisor feature is not enabled,divisor must be 1 </para>
/// <para>   divisor must be a value between 0 andVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::maxVertexAttribDivisor,inclusive.</para>
/// <para>   VkVertexInputBindingDescription::inputRate must be of typeVK_VERTEX_INPUT_RATE_INSTANCE for this binding.</para>
/// </summary>
public unsafe struct VkVertexInputBindingDivisorDescriptionEXT {
    /// <summary> binding is the binding number for which the divisor is specified.</summary>
    public UInt32    binding;
    /// <summary> divisor is the number of successive instances that will use the
    /// same value of the vertex attribute when instanced rendering is enabled.
    /// For example, if the divisor is N, the same vertex attribute will applied
    /// to N successive instances before moving on to the next vertex attribute.
    /// The maximum value of divisor is implementation dependent and can be
    /// queried using
    /// VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::maxVertexAttribDivisor.
    /// A value of 0 can be used for the divisor if the
    ///  vertexAttributeInstanceRateZeroDivisor 
    /// feature is enabled.
    /// In this case, the same vertex attribute will be applied to all
    /// instances.</summary>
    public UInt32    divisor;
}
// Struct: 420
/// <summary>VkViSurfaceCreateInfoNN - Structure specifying parameters of a newly created VI surface object
/// <para>   window must be a valid nn::vi::NativeWindowHandle </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkViSurfaceCreateInfoNN {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType             sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                 pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkViSurfaceCreateFlagsNN    flags;
    /// <summary> window is the nn::vi::NativeWindowHandle for the
    /// nn::vi::Layer with which to associate the surface.</summary>
    public void*                       window;
}
// Struct: 421
/// <summary>VkViewport - Structure specifying a viewport
/// <para>The framebuffer depth coordinate  z f  may be represented usingeither a fixed-point or floating-point representation.However, a floating-point representation must be used if the depth/stencilattachment has a floating-point depth component.If an m-bit fixed-point representation is used, we assume that itrepresents each value \(\frac{k}{2^m - 1}\), where k ∈ {0, 1, …​, 2m-1 }, as k (e.g. 1.0 is represented in binary as astring of all ones).</para>
/// <para>The viewport parameters shown in the above equations are found from thesevalues as</para>
/// <para>The application can specify a negative term for height, which has theeffect of negating the y coordinate in clip space before performing thetransform.When using a negative height, the application should also adjust they value to point to the lower left corner of the viewport instead ofthe upper left corner.Using the negative height allows the application to avoid having tonegate the y component of the Position output from the last vertexprocessing stage in shaders that also target other graphics APIs.</para>
/// <para>The width and height of the implementation-dependent maximum viewport dimensions must be greater thanor equal to the width and height of the largest image which can be createdand attached to a framebuffer.</para>
/// <para>The floating-point viewport bounds are represented with animplementation-dependent precision.</para>
/// <para>   width must be greater than 0.0 </para>
/// <para>   width must be less than or equal toVkPhysicalDeviceLimits::maxViewportDimensions[0]</para>
/// <para>  The absolute value of height must be less than or equal toVkPhysicalDeviceLimits::maxViewportDimensions[1]</para>
/// <para>   x must be greater than or equal to viewportBoundsRange[0]</para>
/// <para>   (x +  width) must be less than or equal toviewportBoundsRange[1]</para>
/// <para>   y must be greater than or equal to viewportBoundsRange[0]</para>
/// <para>   y must be less than or equal to viewportBoundsRange[1]</para>
/// <para>   (y +  height) must be greater than or equal toviewportBoundsRange[0]</para>
/// <para>   (y +  height) must be less than or equal toviewportBoundsRange[1]</para>
/// <para>  Unless  html/vkspec.html#VK_EXT_depth_range_unrestricted  extension is enabledminDepth must be between 0.0 and 1.0, inclusive</para>
/// <para>  Unless  html/vkspec.html#VK_EXT_depth_range_unrestricted  extension is enabledmaxDepth must be between 0.0 and 1.0, inclusive</para>
/// </summary>
public unsafe struct VkViewport {
    /// <summary> x and y are the viewport’s upper left corner (x,y).</summary>
    public float    x;
    public float    y;
    /// <summary> width and height are the viewport’s width and height,
    /// respectively.</summary>
    public float    width;
    public float    height;
    /// <summary> minDepth and maxDepth are the depth range for the viewport.
    /// It is valid for minDepth to be greater than or equal to
    /// maxDepth.</summary>
    public float    minDepth;
    public float    maxDepth;
}
// Struct: 422
/// <summary>VkViewportSwizzleNV - Structure specifying a viewport swizzle
/// <para>   x must be a valid VkViewportCoordinateSwizzleNV value</para>
/// <para>   y must be a valid VkViewportCoordinateSwizzleNV value</para>
/// <para>   z must be a valid VkViewportCoordinateSwizzleNV value</para>
/// <para>   w must be a valid VkViewportCoordinateSwizzleNV value</para>
/// </summary>
public unsafe struct VkViewportSwizzleNV {
    /// <summary> x is a VkViewportCoordinateSwizzleNV value specifying the
    /// swizzle operation to apply to the x component of the primitive</summary>
    public VkViewportCoordinateSwizzleNV    x;
    /// <summary> y is a VkViewportCoordinateSwizzleNV value specifying the
    /// swizzle operation to apply to the y component of the primitive</summary>
    public VkViewportCoordinateSwizzleNV    y;
    /// <summary> z is a VkViewportCoordinateSwizzleNV value specifying the
    /// swizzle operation to apply to the z component of the primitive</summary>
    public VkViewportCoordinateSwizzleNV    z;
    /// <summary> w is a VkViewportCoordinateSwizzleNV value specifying the
    /// swizzle operation to apply to the w component of the primitive</summary>
    public VkViewportCoordinateSwizzleNV    w;
}
// Struct: 423
/// <summary>VkViewportWScalingNV - Structure specifying a viewport
/// </summary>
public unsafe struct VkViewportWScalingNV {
    /// <summary> xcoeff and ycoeff are the viewport’s W scaling factor for x
    /// and y respectively.</summary>
    public float    xcoeff;
    public float    ycoeff;
}
// Struct: 424
/// <summary>VkWaylandSurfaceCreateInfoKHR - Structure specifying parameters of a newly created Wayland surface object
/// <para>   display must point to a valid Wayland wl_display.</para>
/// <para>   surface must point to a valid Wayland wl_surface.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkWaylandSurfaceCreateInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                   sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                       pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkWaylandSurfaceCreateFlagsKHR    flags;
    /// <summary> display and surface are pointers to the Wayland
    /// wl_display and wl_surface to associate the surface with.</summary>
    public /* struct */ wl_display*                display;
    public /* struct */ wl_surface*                surface;
}
// Struct: 425
/// <summary>VkWin32KeyedMutexAcquireReleaseInfoKHR - Use the Windows keyed mutex mechanism to synchronize work
/// <para>  Each member of pAcquireSyncs and pReleaseSyncs must be adevice memory object imported by settingVkImportMemoryWin32HandleInfoKHR::handleType toVK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT orVK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR </para>
/// <para>   If acquireCount is not 0, pAcquireSyncs must be a valid pointer to an array of acquireCount valid VkDeviceMemory handles</para>
/// <para>   If acquireCount is not 0, pAcquireKeys must be a valid pointer to an array of acquireCount uint64_t values</para>
/// <para>   If acquireCount is not 0, pAcquireTimeouts must be a valid pointer to an array of acquireCount uint32_t values</para>
/// <para>   If releaseCount is not 0, pReleaseSyncs must be a valid pointer to an array of releaseCount valid VkDeviceMemory handles</para>
/// <para>   If releaseCount is not 0, pReleaseKeys must be a valid pointer to an array of releaseCount uint64_t values</para>
/// <para>   Both of the elements of pAcquireSyncs, and the elements of pReleaseSyncs that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkWin32KeyedMutexAcquireReleaseInfoKHR {
    public VkStructureType          sType;
    public /* const */ void*              pNext;
    /// <summary> acquireCount is the number of entries in the pAcquireSyncs,
    /// pAcquireKeys, and pAcquireTimeoutMilliseconds arrays.</summary>
    public UInt32                 acquireCount;
    /// <summary> pAcquireSyncs is a pointer to an array of VkDeviceMemory
    /// objects which were imported from Direct3D 11 resources.</summary>
    public /* const */ VkDeviceMemory*    pAcquireSyncs;
    /// <summary> pAcquireKeys is a pointer to an array of mutex key values to wait
    /// for prior to beginning the submitted work.
    /// Entries refer to the keyed mutex associated with the corresponding
    /// entries in pAcquireSyncs.</summary>
    public /* const */ UInt64*          pAcquireKeys;
    public /* const */ UInt32*          pAcquireTimeouts;
    /// <summary> releaseCount is the number of entries in the pReleaseSyncs
    /// and pReleaseKeys arrays.</summary>
    public UInt32                 releaseCount;
    /// <summary> pReleaseSyncs is a pointer to an array of VkDeviceMemory
    /// objects which were imported from Direct3D 11 resources.</summary>
    public /* const */ VkDeviceMemory*    pReleaseSyncs;
    /// <summary> pReleaseKeys is a pointer to an array of mutex key values to set
    /// when the submitted work has completed.
    /// Entries refer to the keyed mutex associated with the corresponding
    /// entries in pReleaseSyncs.</summary>
    public /* const */ UInt64*          pReleaseKeys;
}
// Struct: 426
/// <summary>VkWin32KeyedMutexAcquireReleaseInfoNV - use Windows keyex mutex mechanism to synchronize work
/// <para>   sType must be VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV </para>
/// <para>   If acquireCount is not 0, pAcquireSyncs must be a valid pointer to an array of acquireCount valid VkDeviceMemory handles</para>
/// <para>   If acquireCount is not 0, pAcquireKeys must be a valid pointer to an array of acquireCount uint64_t values</para>
/// <para>   If acquireCount is not 0, pAcquireTimeoutMilliseconds must be a valid pointer to an array of acquireCount uint32_t values</para>
/// <para>   If releaseCount is not 0, pReleaseSyncs must be a valid pointer to an array of releaseCount valid VkDeviceMemory handles</para>
/// <para>   If releaseCount is not 0, pReleaseKeys must be a valid pointer to an array of releaseCount uint64_t values</para>
/// <para>   Both of the elements of pAcquireSyncs, and the elements of pReleaseSyncs that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkWin32KeyedMutexAcquireReleaseInfoNV {
    public VkStructureType          sType;
    public /* const */ void*              pNext;
    /// <summary> acquireCount is the number of entries in the pAcquireSyncs,
    /// pAcquireKeys, and pAcquireTimeoutMilliseconds arrays.</summary>
    public UInt32                 acquireCount;
    /// <summary> pAcquireSyncs is a pointer to an array of VkDeviceMemory
    /// objects which were imported from Direct3D 11 resources.</summary>
    public /* const */ VkDeviceMemory*    pAcquireSyncs;
    /// <summary> pAcquireKeys is a pointer to an array of mutex key values to wait
    /// for prior to beginning the submitted work.
    /// Entries refer to the keyed mutex associated with the corresponding
    /// entries in pAcquireSyncs.</summary>
    public /* const */ UInt64*          pAcquireKeys;
    /// <summary> pAcquireTimeoutMilliseconds is an array of timeout values, in
    /// millisecond units, for each acquire specified in pAcquireKeys.</summary>
    public /* const */ UInt32*          pAcquireTimeoutMilliseconds;
    /// <summary> releaseCount is the number of entries in the pReleaseSyncs
    /// and pReleaseKeys arrays.</summary>
    public UInt32                 releaseCount;
    /// <summary> pReleaseSyncs is a pointer to an array of VkDeviceMemory
    /// objects which were imported from Direct3D 11 resources.</summary>
    public /* const */ VkDeviceMemory*    pReleaseSyncs;
    /// <summary> pReleaseKeys is a pointer to an array of mutex key values to set
    /// when the submitted work has completed.
    /// Entries refer to the keyed mutex associated with the corresponding
    /// entries in pReleaseSyncs.</summary>
    public /* const */ UInt64*          pReleaseKeys;
}
// Struct: 427
/// <summary>VkWin32SurfaceCreateInfoKHR - Structure specifying parameters of a newly created Win32 surface object
/// <para>   hinstance must be a valid Win32 HINSTANCE.</para>
/// <para>   hwnd must be a valid Win32 HWND.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkWin32SurfaceCreateInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                 sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                     pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkWin32SurfaceCreateFlagsKHR    flags;
    /// <summary> hinstance and hwnd are the Win32 HINSTANCE and
    /// HWND for the window to associate the surface with.</summary>
    public HINSTANCE                       hinstance;
    public HWND                            hwnd;
}
// Struct: 428
/// <summary>VkWriteDescriptorSet - Structure specifying the parameters of a descriptor set write operation
/// <para>Only one of pImageInfo, pBufferInfo, or pTexelBufferViewmembers is used according to the descriptor type specified in thedescriptorType member of the containing VkWriteDescriptorSetstructure,or none of them in case descriptorType isVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, in which case the sourcedata for the descriptor writes is taken from the instance ofVkWriteDescriptorSetInlineUniformBlockEXT in the pNext chain ofVkWriteDescriptorSet,or if descriptorType isVK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, in which case the sourcedata for the descriptor writes is taken from the instance ofVkWriteDescriptorSetAccelerationStructureNV in the pNext chainof VkWriteDescriptorSet,as specified below.</para>
/// <para>If the dstBinding has fewer than descriptorCount array elementsremaining starting from dstArrayElement, then the remainder will beused to update the subsequent binding -  dstBinding+1 starting atarray element zero.If a binding has a descriptorCount of zero, it is skipped.This behavior applies recursively, with the update affecting consecutivebindings as needed to update all descriptorCount descriptors.</para>
/// <para>The same behavior applies to bindings with a descriptor type ofVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT wheredescriptorCount specifies the number of bytes to update whiledstArrayElement specifies the starting byte offset, thus in this caseif the dstBinding has a smaller byte size than the sum ofdstArrayElement and descriptorCount, then the remainder will beused to update the subsequent binding -  dstBinding+1 starting atoffset zero.This falls out as a special case of the above rule.</para>
/// <para>   dstBinding must be less than or equal to the maximum value ofbinding of all VkDescriptorSetLayoutBinding structuresspecified when dstSet’s descriptor set layout was created</para>
/// <para>   dstBinding must be a binding with a non-zerodescriptorCount </para>
/// <para>  All consecutive bindings updated via a single VkWriteDescriptorSetstructure, except those with a descriptorCount of zero, must haveidentical descriptorType and stageFlags.</para>
/// <para>  All consecutive bindings updated via a single VkWriteDescriptorSetstructure, except those with a descriptorCount of zero, must alleither use immutable samplers or must all not use immutable samplers.</para>
/// <para>   descriptorType must match the type of dstBinding withindstSet </para>
/// <para>   dstSet must be a valid VkDescriptorSet handle</para>
/// <para>  The sum of dstArrayElement and descriptorCount must be lessthan or equal to the number of array elements in the descriptor setbinding specified by dstBinding, and all applicable consecutivebindings, as described by html/vkspec.html#descriptorsets-updates-consecutive </para>
/// <para>  If descriptorType isVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, dstArrayElement must be an integer multiple of 4 </para>
/// <para>  If descriptorType isVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, descriptorCount must be an integer multiple of 4 </para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER,VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, orVK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, pImageInfo must be avalid pointer to an array of descriptorCount validVkDescriptorImageInfo structures</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFERor VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, pTexelBufferView must be a valid pointer to an array of descriptorCount validVkBufferView handles</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, orVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, pBufferInfo mustbe a valid pointer to an array of descriptorCount validVkDescriptorBufferInfo structures</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER orVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet wasnot allocated with a layout that included immutable samplers fordstBinding with descriptorType, the sampler member ofeach element of pImageInfo must be a valid VkSampler object</para>
/// <para>  If descriptorType isVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, orVK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView andimageLayout members of each element of pImageInfo must be avalid VkImageView and VkImageLayout, respectively</para>
/// <para>  If descriptorType isVK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, the pNext chainmust include a VkWriteDescriptorSetInlineUniformBlockEXTstructure whose dataSize member equals descriptorCount </para>
/// <para>  If descriptorType isVK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, the pNextchain must include a VkWriteDescriptorSetAccelerationStructureNVstructure whose accelerationStructureCount member equalsdescriptorCount </para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, thenthe imageView member of each pImageInfo element must havebeen created without a VkSamplerYcbcrConversionInfo structure inits pNext chain</para>
/// <para>  If descriptorType isVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and if any element ofpImageInfo has a imageView member that was created with aVkSamplerYcbcrConversionInfo structure in its pNext chain,then dstSet must have been allocated with a layout that includedimmutable samplers for dstBinding </para>
/// <para>  If descriptorType isVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet wasallocated with a layout that included immutable samplers fordstBinding, then the imageView member of each element ofpImageInfo which corresponds to an immutable sampler that enablessampler Y’CBCR conversion must havebeen created with a VkSamplerYcbcrConversionInfo structure in itspNext chain with an identically defined VkSamplerYcbcrConversionInfo to the corresponding immutablesampler</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, foreach descriptor that will be accessed via load or store operations theimageLayout member for corresponding elements of pImageInfo must be VK_IMAGE_LAYOUT_GENERAL </para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER orVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the offset memberof each element of pBufferInfo must be a multiple ofVkPhysicalDeviceLimits::minUniformBufferOffsetAlignment </para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER orVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the offset memberof each element of pBufferInfo must be a multiple ofVkPhysicalDeviceLimits::minStorageBufferOffsetAlignment </para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, orVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, and the buffermember of any element of pBufferInfo is the handle of a non-sparsebuffer, then that buffer must be bound completely and contiguously to asingle VkDeviceMemory object</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER orVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the buffer memberof each element of pBufferInfo must have been created withVK_BUFFER_USAGE_UNIFORM_BUFFER_BIT set</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER orVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the buffer memberof each element of pBufferInfo must have been created withVK_BUFFER_USAGE_STORAGE_BUFFER_BIT set</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER orVK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the range memberof each element of pBufferInfo, or the effective range ifrange is VK_WHOLE_SIZE, must be less than or equal toVkPhysicalDeviceLimits::maxUniformBufferRange </para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER orVK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the range memberof each element of pBufferInfo, or the effective range ifrange is VK_WHOLE_SIZE, must be less than or equal toVkPhysicalDeviceLimits::maxStorageBufferRange </para>
/// <para>  If descriptorType isVK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, the VkBuffer thateach element of pTexelBufferView was created from must have beencreated with VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT set</para>
/// <para>  If descriptorType isVK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, the VkBuffer thateach element of pTexelBufferView was created from must have beencreated with VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE orVK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView member ofeach element of pImageInfo must have been created with theidentity swizzle</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE orVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the imageViewmember of each element of pImageInfo must have been created withVK_IMAGE_USAGE_SAMPLED_BIT set</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE orVK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the imageLayoutmember of each element of pImageInfo must be a member of the listgiven in Sampled Image orCombined Image Sampler,corresponding to its type</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,the imageView member of each element of pImageInfo musthave been created with VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set</para>
/// <para>  If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, theimageView member of each element of pImageInfo must havebeen created with VK_IMAGE_USAGE_STORAGE_BIT set</para>
/// <para>  All consecutive bindings updated via a single VkWriteDescriptorSetstructure, except those with a descriptorCount of zero, must haveidentical VkDescriptorBindingFlagBitsEXT.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET </para>
/// <para>   Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkWriteDescriptorSetAccelerationStructureNV or VkWriteDescriptorSetInlineUniformBlockEXT </para>
/// <para>   Each sType member in the pNext chain must be unique</para>
/// <para>   descriptorType must be a valid VkDescriptorType value</para>
/// <para>   descriptorCount must be greater than 0 </para>
/// <para>   Both of dstSet, and the elements of pTexelBufferView that are valid handles must have been created, allocated, or retrieved from the same VkDevice </para>
/// </summary>
public unsafe struct VkWriteDescriptorSet {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                  sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                      pNext;
    /// <summary> dstSet is the destination descriptor set to update.</summary>
    public VkDescriptorSet                  dstSet;
    /// <summary> dstBinding is the descriptor binding within that set.</summary>
    public UInt32                         dstBinding;
    /// <summary> dstArrayElement is the starting element in that array.
    /// If the descriptor binding identified by dstSet and
    /// dstBinding has a descriptor type of
    /// VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then
    /// dstArrayElement specifies the starting byte offset within the
    /// binding.</summary>
    public UInt32                         dstArrayElement;
    /// <summary> descriptorCount is the number of descriptors to update (the number
    /// of elements in pImageInfo, pBufferInfo, or
    /// pTexelBufferView
    /// , or a value matching the dataSize member of an instance of
    /// VkWriteDescriptorSetInlineUniformBlockEXT in the pNext chain
    /// , or a value matching the accelerationStructureCount of an
    /// instance of VkWriteDescriptorSetAccelerationStructureNV in the
    /// pNext chain
    /// ).
    /// If the descriptor binding identified by dstSet and
    /// dstBinding has a descriptor type of
    /// VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then
    /// descriptorCount specifies the number of bytes to update.</summary>
    public UInt32                         descriptorCount;
    /// <summary> descriptorType is a VkDescriptorType specifying the type of
    /// each descriptor in pImageInfo, pBufferInfo, or
    /// pTexelBufferView, as described below.
    /// It must be the same type as that specified in
    /// VkDescriptorSetLayoutBinding for dstSet at dstBinding.
    /// The type of the descriptor also controls which array the descriptors are
    /// taken from.</summary>
    public VkDescriptorType                 descriptorType;
    /// <summary> pImageInfo points to an array of VkDescriptorImageInfo
    /// structures or is ignored, as described below.</summary>
    public /* const */ VkDescriptorImageInfo*     pImageInfo;
    /// <summary> pBufferInfo points to an array of VkDescriptorBufferInfo
    /// structures or is ignored, as described below.</summary>
    public /* const */ VkDescriptorBufferInfo*    pBufferInfo;
    /// <summary> pTexelBufferView points to an array of VkBufferView handles
    /// as described in the Buffer Views section or
    /// is ignored, as described below.</summary>
    public /* const */ VkBufferView*              pTexelBufferView;
}
// Struct: 429
/// <summary>VkWriteDescriptorSetAccelerationStructureNV - Structure specifying acceleration to query for memory requirements
/// <para>   accelerationStructureCount must be equal to descriptorCountin the extended structure</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV </para>
/// <para>   pAccelerationStructures must be a valid pointer to an array of accelerationStructureCount valid VkAccelerationStructureNV handles</para>
/// <para>   accelerationStructureCount must be greater than 0 </para>
/// </summary>
public unsafe struct VkWriteDescriptorSetAccelerationStructureNV {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                     sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                         pNext;
    /// <summary> accelerationStructureCount is the number of elements in
    /// pAccelerationStructures.</summary>
    public UInt32                            accelerationStructureCount;
    /// <summary> pAccelerationStructures are the acceleration structures to update.</summary>
    public /* const */ VkAccelerationStructureNV*    pAccelerationStructures;
}
// Struct: 430
/// <summary>VkWriteDescriptorSetInlineUniformBlockEXT - Structure specifying inline uniform block data
/// <para>   dataSize must be an integer multiple of 4 </para>
/// <para>   sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT </para>
/// <para>   pData must be a valid pointer to an array of dataSize bytes</para>
/// <para>   dataSize must be greater than 0 </para>
/// </summary>
public unsafe struct VkWriteDescriptorSetInlineUniformBlockEXT {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType    sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*        pNext;
    /// <summary> dataSize is the number of bytes of inline uniform block data
    /// pointed to by pData.</summary>
    public UInt32           dataSize;
    /// <summary> pData is a pointer to dataSize number of bytes of data to
    /// write to the inline uniform block.</summary>
    public /* const */ void*        pData;
}
// Struct: 431
/// <summary>VkXYColorEXT - structure to specify X,Y chromaticity coordinates
/// </summary>
public unsafe struct VkXYColorEXT {
    public float    x;
    public float    y;
}
// Struct: 432
/// <summary>VkXcbSurfaceCreateInfoKHR - Structure specifying parameters of a newly created Xcb surface object
/// <para>   connection must point to a valid X11 xcb_connection_t.</para>
/// <para>   window must be a valid X11 xcb_window_t.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkXcbSurfaceCreateInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType               sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                   pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkXcbSurfaceCreateFlagsKHR    flags;
    /// <summary> connection is a pointer to an xcb_connection_t to the X
    /// server.</summary>
    public xcb_connection_t*             connection;
    /// <summary> window is the xcb_window_t for the X11 window to associate
    /// the surface with.</summary>
    public xcb_window_t                  window;
}
// Struct: 433
/// <summary>VkXlibSurfaceCreateInfoKHR - Structure specifying parameters of a newly created Xlib surface object
/// <para>   dpy must point to a valid Xlib Display.</para>
/// <para>   window must be a valid Xlib Window.</para>
/// <para>   sType must be VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR </para>
/// <para>   pNext must be NULL </para>
/// <para>   flags must be 0 </para>
/// </summary>
public unsafe struct VkXlibSurfaceCreateInfoKHR {
    /// <summary> sType is the type of this structure.</summary>
    public VkStructureType                sType;
    /// <summary> pNext is NULL or a pointer to an extension-specific structure.</summary>
    public /* const */ void*                    pNext;
    /// <summary> flags is reserved for future use.</summary>
    public VkXlibSurfaceCreateFlagsKHR    flags;
    /// <summary> dpy is a pointer to an Xlib Display connection to the X
    /// server.</summary>
    public Display*                       dpy;
    /// <summary> window is an Xlib Window to associate the surface with.</summary>
    public Window                         window;
}
