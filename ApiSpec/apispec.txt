Copyright
Copyright (c) 2014-2019 Khronos Group. This work is licensed under a Creative Commons Attribution 4.0 International License.

Vulkan Commands
vkAcquireFullScreenExclusiveModeEXT(3)
Name
vkAcquireFullScreenExclusiveModeEXT - Acquire full-screen exclusive mode for a swapchain

C Specification
To acquire exclusive full-screen access for a swapchain, call:

VkResult vkAcquireFullScreenExclusiveModeEXT(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain);
Parameters
device is the device associated with swapchain.
swapchain is the swapchain to acquire exclusive full-screen access for.
Description
Valid Usage
swapchain must not be in the retired state
swapchain must be a swapchain created with an instance of VkSurfaceFullScreenExclusiveInfoEXT, with fullScreenExclusive set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT
swapchain must not currently have exclusive full-screen access
A return value of VK_SUCCESS indicates that the swapchain successfully acquired exclusive full-screen access. The swapchain will retain this exclusivity until either the application releases exclusive full-screen access with vkReleaseFullScreenExclusiveModeEXT, destroys the swapchain, or if any of the swapchain commands return VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT indicating that the mode was lost because of platform-specific changes.

If the swapchain was unable to acquire exclusive full-screen access to the display then VK_ERROR_INITIALIZATION_FAILED is returned. An application can attempt to acquire exclusive full-screen access again for the same swapchain even if this command fails, or if VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT has been returned by a swapchain command.

Valid Usage (Implicit)
device must be a valid VkDevice handle
swapchain must be a valid VkSwapchainKHR handle
Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_INITIALIZATION_FAILED
VK_ERROR_SURFACE_LOST_KHR
See Also
VkDevice, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkAcquireFullScreenExclusiveModeEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkAcquireNextImage2KHR(3)
Name
vkAcquireNextImage2KHR - Retrieve the index of the next available presentable image

C Specification
To acquire an available presentable image to use, and retrieve the index of that image, call:

VkResult vkAcquireNextImage2KHR(
    VkDevice                                    device,
    const VkAcquireNextImageInfoKHR*            pAcquireInfo,
    uint32_t*                                   pImageIndex);
Parameters
device is the device associated with swapchain.
pAcquireInfo is a pointer to a structure of type VkAcquireNextImageInfoKHR containing parameters of the acquire.
pImageIndex is a pointer to a uint32_t that is set to the index of the next image to use.
Description
Valid Usage
If the number of currently acquired images is greater than the difference between the number of images in the swapchain member of pAcquireInfo and the value of VkSurfaceCapabilitiesKHR::minImageCount as returned by a call to vkGetPhysicalDeviceSurfaceCapabilities2KHR with the surface used to create swapchain, the timeout member of pAcquireInfo must not be UINT64_MAX
Valid Usage (Implicit)
device must be a valid VkDevice handle
pAcquireInfo must be a valid pointer to a valid VkAcquireNextImageInfoKHR structure
pImageIndex must be a valid pointer to a uint32_t value
Return Codes
Success
VK_SUCCESS
VK_TIMEOUT
VK_NOT_READY
VK_SUBOPTIMAL_KHR
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
VK_ERROR_OUT_OF_DATE_KHR
VK_ERROR_SURFACE_LOST_KHR
VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
See Also
VkAcquireNextImageInfoKHR, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkAcquireNextImage2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkAcquireNextImageKHR(3)
Name
vkAcquireNextImageKHR - Retrieve the index of the next available presentable image

C Specification
To acquire an available presentable image to use, and retrieve the index of that image, call:

VkResult vkAcquireNextImageKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint64_t                                    timeout,
    VkSemaphore                                 semaphore,
    VkFence                                     fence,
    uint32_t*                                   pImageIndex);
Parameters
device is the device associated with swapchain.
swapchain is the non-retired swapchain from which an image is being acquired.
timeout specifies how long the function waits, in nanoseconds, if no image is available.
semaphore is VK_NULL_HANDLE or a semaphore to signal.
fence is VK_NULL_HANDLE or a fence to signal.
pImageIndex is a pointer to a uint32_t that is set to the index of the next image to use (i.e. an index into the array of images returned by vkGetSwapchainImagesKHR).
Description
Valid Usage
swapchain must not be in the retired state
If semaphore is not VK_NULL_HANDLE it must be unsignaled
If semaphore is not VK_NULL_HANDLE it must not have any uncompleted signal or wait operations pending
If fence is not VK_NULL_HANDLE it must be unsignaled and must not be associated with any other queue command that has not yet completed execution on that queue
semaphore and fence must not both be equal to VK_NULL_HANDLE
If the number of currently acquired images is greater than the difference between the number of images in swapchain and the value of VkSurfaceCapabilitiesKHR::minImageCount as returned by a call to vkGetPhysicalDeviceSurfaceCapabilities2KHR with the surface used to create swapchain, timeout must not be UINT64_MAX
Valid Usage (Implicit)
device must be a valid VkDevice handle
swapchain must be a valid VkSwapchainKHR handle
If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle
If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle
pImageIndex must be a valid pointer to a uint32_t value
If semaphore is a valid handle, it must have been created, allocated, or retrieved from device
If fence is a valid handle, it must have been created, allocated, or retrieved from device
Both of device, and swapchain that are valid handles must have been created, allocated, or retrieved from the same VkInstance
Host Synchronization
Host access to swapchain must be externally synchronized
Host access to semaphore must be externally synchronized
Host access to fence must be externally synchronized
Return Codes
Success
VK_SUCCESS
VK_TIMEOUT
VK_NOT_READY
VK_SUBOPTIMAL_KHR
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
VK_ERROR_OUT_OF_DATE_KHR
VK_ERROR_SURFACE_LOST_KHR
VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
See Also
VkDevice, VkFence, VkSemaphore, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkAcquireNextImageKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkAcquireXlibDisplayEXT(3)
Name
vkAcquireXlibDisplayEXT - Acquire access to a VkDisplayKHR using Xlib

C Specification
To acquire permission to directly access a display in Vulkan from an X11 server, call:

VkResult vkAcquireXlibDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    Display*                                    dpy,
    VkDisplayKHR                                display);
Parameters
physicalDevice The physical device the display is on.
dpy A connection to the X11 server that currently owns display.
display The display the caller wishes to control in Vulkan.
Description
All permissions necessary to control the display are granted to the Vulkan instance associated with physicalDevice until the display is released or the X11 connection specified by dpy is terminated. Permission to access the display may be temporarily revoked during periods when the X11 server from which control was acquired itself looses access to display. During such periods, operations which require access to the display must fail with an approriate error code. If the X11 server associated with dpy does not own display, or if permission to access it has already been acquired by another entity, the call must return the error code VK_ERROR_INITIALIZATION_FAILED.

Note
One example of when an X11 server loses access to a display is when it loses ownership of its virtual terminal.
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
dpy must be a valid pointer to a Display value
display must be a valid VkDisplayKHR handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_INITIALIZATION_FAILED
See Also
VkDisplayKHR, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkAcquireXlibDisplayEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkAllocateCommandBuffers(3)
Name
vkAllocateCommandBuffers - Allocate command buffers from an existing command pool

C Specification
To allocate command buffers, call:

VkResult vkAllocateCommandBuffers(
    VkDevice                                    device,
    const VkCommandBufferAllocateInfo*          pAllocateInfo,
    VkCommandBuffer*                            pCommandBuffers);
Parameters
device is the logical device that owns the command pool.
pAllocateInfo is a pointer to an instance of the VkCommandBufferAllocateInfo structure describing parameters of the allocation.
pCommandBuffers is a pointer to an array of VkCommandBuffer handles in which the resulting command buffer objects are returned. The array must be at least the length specified by the commandBufferCount member of pAllocateInfo. Each allocated command buffer begins in the initial state.
Description
vkAllocateCommandBuffers can be used to create multiple command buffers. If the creation of any of those command buffers fails, the implementation must destroy all successfully created command buffer objects from this command, set all entries of the pCommandBuffers array to NULL and return the error.

When command buffers are first allocated, they are in the initial state.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pAllocateInfo must be a valid pointer to a valid VkCommandBufferAllocateInfo structure
pCommandBuffers must be a valid pointer to an array of pAllocateInfo::commandBufferCount VkCommandBuffer handles
Host Synchronization
Host access to pAllocateInfo::commandPool must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkCommandBuffer, VkCommandBufferAllocateInfo, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkAllocateCommandBuffers

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkAllocateDescriptorSets(3)
Name
vkAllocateDescriptorSets - Allocate one or more descriptor sets

C Specification
To allocate descriptor sets from a descriptor pool, call:

VkResult vkAllocateDescriptorSets(
    VkDevice                                    device,
    const VkDescriptorSetAllocateInfo*          pAllocateInfo,
    VkDescriptorSet*                            pDescriptorSets);
Parameters
device is the logical device that owns the descriptor pool.
pAllocateInfo is a pointer to an instance of the VkDescriptorSetAllocateInfo structure describing parameters of the allocation.
pDescriptorSets is a pointer to an array of VkDescriptorSet handles in which the resulting descriptor set objects are returned.
Description
The allocated descriptor sets are returned in pDescriptorSets.

When a descriptor set is allocated, the initial state is largely uninitialized and all descriptors are undefined. Descriptors also become undefined if the underlying resource is destroyed. Descriptor sets containing undefined descriptors can still be bound and used, subject to the following conditions:

For descriptor set bindings created with the VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT bit set, all descriptors in that binding that are dynamically used must have been populated before the descriptor set is consumed.
For descriptor set bindings created without the VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT bit set, all descriptors in that binding that are statically used must have been populated before the descriptor set is consumed.
Descriptor bindings with descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT can be undefined when the descriptor set is consumed; though values in that block will be undefined.
Entries that are not used by a pipeline can have undefined descriptors.
If a call to vkAllocateDescriptorSets would cause the total number of descriptor sets allocated from the pool to exceed the value of VkDescriptorPoolCreateInfo::maxSets used to create pAllocateInfo->descriptorPool, then the allocation may fail due to lack of space in the descriptor pool. Similarly, the allocation may fail due to lack of space if the call to vkAllocateDescriptorSets would cause the number of any given descriptor type to exceed the sum of all the descriptorCount members of each element of VkDescriptorPoolCreateInfo::pPoolSizes with a member equal to that type.

Additionally, the allocation may also fail if a call to vkAllocateDescriptorSets would cause the total number of inline uniform block bindings allocated from the pool to exceed the value of VkDescriptorPoolInlineUniformBlockCreateInfoEXT::maxInlineUniformBlockBindings used to create the descriptor pool.

If the allocation fails due to no more space in the descriptor pool, and not because of system or device memory exhaustion, then VK_ERROR_OUT_OF_POOL_MEMORY must be returned.

vkAllocateDescriptorSets can be used to create multiple descriptor sets. If the creation of any of those descriptor sets fails, then the implementation must destroy all successfully created descriptor set objects from this command, set all entries of the pDescriptorSets array to VK_NULL_HANDLE and return the error.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pAllocateInfo must be a valid pointer to a valid VkDescriptorSetAllocateInfo structure
pDescriptorSets must be a valid pointer to an array of pAllocateInfo::descriptorSetCount VkDescriptorSet handles
Host Synchronization
Host access to pAllocateInfo::descriptorPool must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_FRAGMENTED_POOL
VK_ERROR_OUT_OF_POOL_MEMORY
See Also
VkDescriptorSet, VkDescriptorSetAllocateInfo, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkAllocateDescriptorSets

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkAllocateMemory(3)
Name
vkAllocateMemory - Allocate device memory

C Specification
To allocate memory objects, call:

VkResult vkAllocateMemory(
    VkDevice                                    device,
    const VkMemoryAllocateInfo*                 pAllocateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDeviceMemory*                             pMemory);
Parameters
device is the logical device that owns the memory.
pAllocateInfo is a pointer to an instance of the VkMemoryAllocateInfo structure describing parameters of the allocation. A successful returned allocation must use the requested parameters — no substitution is permitted by the implementation.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pMemory is a pointer to a VkDeviceMemory handle in which information about the allocated memory is returned.
Description
Allocations returned by vkAllocateMemory are guaranteed to meet any alignment requirement of the implementation. For example, if an implementation requires 128 byte alignment for images and 64 byte alignment for buffers, the device memory returned through this mechanism would be 128-byte aligned. This ensures that applications can correctly suballocate objects of different types (with potentially different alignment requirements) in the same memory object.

When memory is allocated, its contents are undefined with the following constraint:

The contents of unprotected memory must not be a function of data protected memory objects, even if those memory objects were previously freed.
Note
The contents of memory allocated by one application should not be a function of data from protected memory objects of another application, even if those memory objects were previously freed.
The maximum number of valid memory allocations that can exist simultaneously within a VkDevice may be restricted by implementation- or platform-dependent limits. If a call to vkAllocateMemory would cause the total number of allocations to exceed these limits, such a call will fail and must return VK_ERROR_TOO_MANY_OBJECTS. The maxMemoryAllocationCount feature describes the number of allocations that can exist simultaneously before encountering these internal limits.

Some platforms may have a limit on the maximum size of a single allocation. For example, certain systems may fail to create allocations with a size greater than or equal to 4GB. Such a limit is implementation-dependent, and if such a failure occurs then the error VK_ERROR_OUT_OF_DEVICE_MEMORY must be returned. This limit is advertised in VkPhysicalDeviceMaintenance3Properties::maxMemoryAllocationSize.

The cumulative memory size allocated to a heap can be limited by the size of the specified heap. In such cases, allocated memory is tracked on a per-device and per-heap basis. Some platforms allow overallocation into other heaps. The overallocation behavior can be specified through the html/vkspec.html#VK_AMD_memory_overallocation_behavior extension.

Valid Usage
pAllocateInfo->allocationSize must be less than or equal to VkPhysicalDeviceMemoryProperties::memoryHeaps[pAllocateInfo->memoryTypeIndex].size as returned by vkGetPhysicalDeviceMemoryProperties for the VkPhysicalDevice that device was created from.
pAllocateInfo->memoryTypeIndex must be less than VkPhysicalDeviceMemoryProperties::memoryTypeCount as returned by vkGetPhysicalDeviceMemoryProperties for the VkPhysicalDevice that device was created from.
Valid Usage (Implicit)
device must be a valid VkDevice handle
pAllocateInfo must be a valid pointer to a valid VkMemoryAllocateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pMemory must be a valid pointer to a VkDeviceMemory handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_TOO_MANY_OBJECTS
VK_ERROR_INVALID_EXTERNAL_HANDLE
See Also
VkAllocationCallbacks, VkDevice, VkDeviceMemory, VkMemoryAllocateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkAllocateMemory

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkBeginCommandBuffer(3)
Name
vkBeginCommandBuffer - Start recording a command buffer

C Specification
To begin recording a command buffer, call:

VkResult vkBeginCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    const VkCommandBufferBeginInfo*             pBeginInfo);
Parameters
commandBuffer is the handle of the command buffer which is to be put in the recording state.
pBeginInfo is an instance of the VkCommandBufferBeginInfo structure, which defines additional information about how the command buffer begins recording.
Description
Valid Usage
commandBuffer must not be in the recording or pending state.
If commandBuffer was allocated from a VkCommandPool which did not have the VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT flag set, commandBuffer must be in the initial state.
If commandBuffer is a secondary command buffer, the pInheritanceInfo member of pBeginInfo must be a valid VkCommandBufferInheritanceInfo structure
If commandBuffer is a secondary command buffer and either the occlusionQueryEnable member of the pInheritanceInfo member of pBeginInfo is VK_FALSE, or the precise occlusion queries feature is not enabled, the queryFlags member of the pInheritanceInfo member pBeginInfo must not contain VK_QUERY_CONTROL_PRECISE_BIT
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pBeginInfo must be a valid pointer to a valid VkCommandBufferBeginInfo structure
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkCommandBuffer, VkCommandBufferBeginInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkBeginCommandBuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkBindAccelerationStructureMemoryNV(3)
Name
vkBindAccelerationStructureMemoryNV - Bind acceleration structure memory

C Specification
To attach memory to one or more acceleration structures at a time, call:

VkResult vkBindAccelerationStructureMemoryNV(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindAccelerationStructureMemoryInfoNV* pBindInfos);
Parameters
device is the logical device that owns the acceleration structures and memory.
bindInfoCount is the number of elements in pBindInfos.
pBindInfos is a pointer to an array of structures of type VkBindAccelerationStructureMemoryInfoNV, describing images and memory to bind.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pBindInfos must be a valid pointer to an array of bindInfoCount valid VkBindAccelerationStructureMemoryInfoNV structures
bindInfoCount must be greater than 0
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkBindAccelerationStructureMemoryInfoNV, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkBindAccelerationStructureMemoryNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkBindBufferMemory(3)
Name
vkBindBufferMemory - Bind device memory to a buffer object

C Specification
To attach memory to a buffer object, call:

VkResult vkBindBufferMemory(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);
Parameters
device is the logical device that owns the buffer and memory.
buffer is the buffer to be attached to memory.
memory is a VkDeviceMemory object describing the device memory to attach.
memoryOffset is the start offset of the region of memory which is to be bound to the buffer. The number of bytes returned in the VkMemoryRequirements::size member in memory, starting from memoryOffset bytes, will be bound to the specified buffer.
Description
vkBindBufferMemory is equivalent to passing the same parameters through VkBindBufferMemoryInfo to vkBindBufferMemory2.

Valid Usage
buffer must not already be backed by a memory object
buffer must not have been created with any sparse memory binding flags
memoryOffset must be less than the size of memory
memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer
memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer
The size member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer must be less than or equal to the size of memory minus memoryOffset
If buffer requires a dedicated allocation(as reported by vkGetBufferMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for buffer), memory must have been created with VkMemoryDedicatedAllocateInfo::buffer equal to buffer
If the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::buffer was not VK_NULL_HANDLE, then buffer must equal VkMemoryDedicatedAllocateInfo::buffer, and memoryOffset must be zero.
If buffer was created with the VK_BUFFER_CREATE_PROTECTED_BIT bit set, the buffer must be bound to a memory object allocated with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT
If buffer was created with the VK_BUFFER_CREATE_PROTECTED_BIT bit not set, the buffer must not be bound to a memory object created with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT
If buffer was created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::buffer equal to a buffer handle created with identical creation parameters to buffer and memoryOffset must be zero
Valid Usage (Implicit)
device must be a valid VkDevice handle
buffer must be a valid VkBuffer handle
memory must be a valid VkDeviceMemory handle
buffer must have been created, allocated, or retrieved from device
memory must have been created, allocated, or retrieved from device
Host Synchronization
Host access to buffer must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkBuffer, VkDevice, VkDeviceMemory, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkBindBufferMemory

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkBindBufferMemory2(3)
Name
vkBindBufferMemory2 - Bind device memory to buffer objects

C Specification
To attach memory to buffer objects for one or more buffers at a time, call:

VkResult vkBindBufferMemory2(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindBufferMemoryInfo*               pBindInfos);
or the equivalent command

VkResult vkBindBufferMemory2KHR(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindBufferMemoryInfo*               pBindInfos);
Parameters
device is the logical device that owns the buffers and memory.
bindInfoCount is the number of elements in pBindInfos.
pBindInfos is a pointer to an array of structures of type VkBindBufferMemoryInfo, describing buffers and memory to bind.
Description
On some implementations, it may be more efficient to batch memory bindings into a single command.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pBindInfos must be a valid pointer to an array of bindInfoCount valid VkBindBufferMemoryInfo structures
bindInfoCount must be greater than 0
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkBindBufferMemoryInfo, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkBindBufferMemory2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkBindImageMemory(3)
Name
vkBindImageMemory - Bind device memory to an image object

C Specification
To attach memory to a VkImage object created without the VK_IMAGE_CREATE_DISJOINT_BIT set, call:

VkResult vkBindImageMemory(
    VkDevice                                    device,
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset);
Parameters
device is the logical device that owns the image and memory.
image is the image.
memory is the VkDeviceMemory object describing the device memory to attach.
memoryOffset is the start offset of the region of memory which is to be bound to the image. The number of bytes returned in the VkMemoryRequirements::size member in memory, starting from memoryOffset bytes, will be bound to the specified image.
Description
vkBindImageMemory is equivalent to passing the same parameters through VkBindImageMemoryInfo to vkBindImageMemory2.

Valid Usage
image must not have been created with the VK_IMAGE_CREATE_DISJOINT_BIT set.
image must not already be backed by a memory object
image must not have been created with any sparse memory binding flags
memoryOffset must be less than the size of memory
memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image
memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image
The size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image must be less than or equal to the size of memory minus memoryOffset
If image requires a dedicated allocation (as reported by vkGetImageMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for image), memory must have been created with VkMemoryDedicatedAllocateInfo::image equal to image
If the dedicated allocation image aliasing feature is not enabled, and the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then image must equal VkMemoryDedicatedAllocateInfo::image and memoryOffset must be zero.
If the dedicated allocation image aliasing feature is enabled, and the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then memoryOffset must be zero, and image must be either equal to VkMemoryDedicatedAllocateInfo::image or an image that was created using the same parameters in VkImageCreateInfo, with the exception that extent and arrayLayers may differ subject to the following restrictions: every dimension in the extent parameter of the image being bound must be equal to or smaller than the original image for which the allocation was created; and the arrayLayers parameter of the image being bound must be equal to or smaller than the original image for which the allocation was created.
If image was created with the VK_IMAGE_CREATE_PROTECTED_BIT bit set, the image must be bound to a memory object allocated with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT
If image was created with the VK_IMAGE_CREATE_PROTECTED_BIT bit not set, the image must not be bound to a memory object created with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT
If image was created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::image equal to an image handle created with identical creation parameters to image and memoryOffset must be zero
Valid Usage (Implicit)
device must be a valid VkDevice handle
image must be a valid VkImage handle
memory must be a valid VkDeviceMemory handle
image must have been created, allocated, or retrieved from device
memory must have been created, allocated, or retrieved from device
Host Synchronization
Host access to image must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkDeviceMemory, VkDeviceSize, VkImage

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkBindImageMemory

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkBindImageMemory2(3)
Name
vkBindImageMemory2 - Bind device memory to image objects

C Specification
To attach memory to image objects for one or more images at a time, call:

VkResult vkBindImageMemory2(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindImageMemoryInfo*                pBindInfos);
or the equivalent command

VkResult vkBindImageMemory2KHR(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindImageMemoryInfo*                pBindInfos);
Parameters
device is the logical device that owns the images and memory.
bindInfoCount is the number of elements in pBindInfos.
pBindInfos is a pointer to an array of structures of type VkBindImageMemoryInfo, describing images and memory to bind.
Description
On some implementations, it may be more efficient to batch memory bindings into a single command.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pBindInfos must be a valid pointer to an array of bindInfoCount valid VkBindImageMemoryInfo structures
bindInfoCount must be greater than 0
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkBindImageMemoryInfo, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkBindImageMemory2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBeginConditionalRenderingEXT(3)
Name
vkCmdBeginConditionalRenderingEXT - Define the beginning of a conditional rendering block

C Specification
To begin conditional rendering, call:

void vkCmdBeginConditionalRenderingEXT(
    VkCommandBuffer                             commandBuffer,
    const VkConditionalRenderingBeginInfoEXT*   pConditionalRenderingBegin);
Parameters
commandBuffer is the command buffer into which this command will be recorded.
pConditionalRenderingBegin is a pointer to an instance of the VkConditionalRenderingBeginInfoEXT structure specifying the parameters of conditional rendering.
Description
Valid Usage
Conditional rendering must not already be active
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pConditionalRenderingBegin must be a valid pointer to a valid VkConditionalRenderingBeginInfoEXT structure
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer, VkConditionalRenderingBeginInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBeginConditionalRenderingEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBeginDebugUtilsLabelEXT(3)
Name
vkCmdBeginDebugUtilsLabelEXT - Open a command buffer debug label region

C Specification
A command buffer debug label region can be opened by calling:

void vkCmdBeginDebugUtilsLabelEXT(
    VkCommandBuffer                             commandBuffer,
    const VkDebugUtilsLabelEXT*                 pLabelInfo);
Parameters
commandBuffer is the command buffer into which the command is recorded.
pLabelInfo is a pointer to an instance of the VkDebugUtilsLabelEXT structure specifying the parameters of the label region to open.
Description
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Host Synchronization
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer, VkDebugUtilsLabelEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBeginDebugUtilsLabelEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBeginQuery(3)
Name
vkCmdBeginQuery - Begin a query

C Specification
To begin a query, call:

void vkCmdBeginQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags);
Parameters
commandBuffer is the command buffer into which this command will be recorded.
queryPool is the query pool that will manage the results of the query.
query is the query index within the query pool that will contain the results.
flags is a bitmask of VkQueryControlFlagBits specifying constraints on the types of queries that can be performed.
Description
If the queryType of the pool is VK_QUERY_TYPE_OCCLUSION and flags contains VK_QUERY_CONTROL_PRECISE_BIT, an implementation must return a result that matches the actual number of samples passed. This is described in more detail in Occlusion Queries.

After beginning a query, that query is considered active within the command buffer it was called in until that same query is ended. Queries active in a primary command buffer when secondary command buffers are executed are considered active for those secondary command buffers.

Valid Usage
queryPool must have been created with a queryType that differs from that of any queries that are active within commandBuffer
All queries used by the command must be unavailable
If the precise occlusion queries feature is not enabled, or the queryType used to create queryPool was not VK_QUERY_TYPE_OCCLUSION, flags must not contain VK_QUERY_CONTROL_PRECISE_BIT
query must be less than the number of queries in queryPool
If the queryType used to create queryPool was VK_QUERY_TYPE_OCCLUSION, the VkCommandPool that commandBuffer was allocated from must support graphics operations
If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate graphics operations, the VkCommandPool that commandBuffer was allocated from must support graphics operations
If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate compute operations, the VkCommandPool that commandBuffer was allocated from must support compute operations
commandBuffer must not be a protected command buffer
If vkCmdBeginQuery is called within a render pass instance, the sum of query and the number of bits set in the current subpass’s view mask must be less than or equal to the number of queries in queryPool
If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the VkCommandPool that commandBuffer was allocated from must support graphics operations
If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT then VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackQueries must be supported
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
queryPool must be a valid VkQueryPool handle
flags must be a valid combination of VkQueryControlFlagBits values
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer, VkQueryControlFlags, VkQueryPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBeginQuery

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBeginQueryIndexedEXT(3)
Name
vkCmdBeginQueryIndexedEXT - Begin an indexed query

C Specification
To begin an indexed query, call:

void vkCmdBeginQueryIndexedEXT(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags,
    uint32_t                                    index);
Parameters
commandBuffer is the command buffer into which this command will be recorded.
queryPool is the query pool that will manage the results of the query.
query is the query index within the query pool that will contain the results.
flags is a bitmask of VkQueryControlFlagBits specifying constraints on the types of queries that can be performed.
index is the query type specific index. When the query type is VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the index represents the vertex stream.
Description
The vkCmdBeginQueryIndexedEXT command operates the same as the vkCmdBeginQuery command, except that it also accepts a query type specific index parameter.

Valid Usage
queryPool must have been created with a queryType that differs from that of any queries that are active within commandBuffer
All queries used by the command must be unavailable
If the precise occlusion queries feature is not enabled, or the queryType used to create queryPool was not VK_QUERY_TYPE_OCCLUSION, flags must not contain VK_QUERY_CONTROL_PRECISE_BIT
query must be less than the number of queries in queryPool
If the queryType used to create queryPool was VK_QUERY_TYPE_OCCLUSION, the VkCommandPool that commandBuffer was allocated from must support graphics operations
If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate graphics operations, the VkCommandPool that commandBuffer was allocated from must support graphics operations
If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate compute operations, the VkCommandPool that commandBuffer was allocated from must support compute operations
commandBuffer must not be a protected command buffer
If vkCmdBeginQuery is called within a render pass instance, the sum of query and the number of bits set in the current subpass’s view mask must be less than or equal to the number of queries in queryPool
If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the VkCommandPool that commandBuffer was allocated from must support graphics operations
If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the index parameter must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams
If the queryType used to create queryPool was not VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the index must be zero
If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT then VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackQueries must be supported
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
queryPool must be a valid VkQueryPool handle
flags must be a valid combination of VkQueryControlFlagBits values
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer, VkQueryControlFlags, VkQueryPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBeginQueryIndexedEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBeginRenderPass(3)
Name
vkCmdBeginRenderPass - Begin a new render pass

C Specification
To begin a render pass instance, call:

void vkCmdBeginRenderPass(
    VkCommandBuffer                             commandBuffer,
    const VkRenderPassBeginInfo*                pRenderPassBegin,
    VkSubpassContents                           contents);
Parameters
commandBuffer is the command buffer in which to record the command.
pRenderPassBegin is a pointer to a VkRenderPassBeginInfo structure (defined below) which specifies the render pass to begin an instance of, and the framebuffer the instance uses.
contents is a VkSubpassContents value specifying how the commands in the first subpass will be provided.
Description
After beginning a render pass instance, the command buffer is ready to record the commands for the first subpass of that render pass.

Valid Usage
If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_TRANSFER_SRC_BIT
If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_TRANSFER_DST_BIT
If any of the initialLayout members of the VkAttachmentDescription structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is not VK_IMAGE_LAYOUT_UNDEFINED, then each such initialLayout must be equal to the current layout of the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin
The srcStageMask and dstStageMask members of any element of the pDependencies member of VkRenderPassCreateInfo used to create renderPass must be supported by the capabilities of the queue family identified by the queueFamilyIndex member of the VkCommandPoolCreateInfo used to create the command pool which commandBuffer was allocated from
For any attachment in framebuffer that is used by renderPass and is bound to memory locations that are also bound to another attachment used by renderPass, and if at least one of those uses causes either attachment to be written to, both attachments must have had the VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT set
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pRenderPassBegin must be a valid pointer to a valid VkRenderPassBeginInfo structure
contents must be a valid VkSubpassContents value
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called outside of a render pass instance
commandBuffer must be a primary VkCommandBuffer
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Outside
Graphics
Graphics
See Also
VkCommandBuffer, VkRenderPassBeginInfo, VkSubpassContents

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBeginRenderPass

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBeginRenderPass2KHR(3)
Name
vkCmdBeginRenderPass2KHR - Begin a new render pass

C Specification
Alternatively to begin a render pass, call:

void vkCmdBeginRenderPass2KHR(
    VkCommandBuffer                             commandBuffer,
    const VkRenderPassBeginInfo*                pRenderPassBegin,
    const VkSubpassBeginInfoKHR*                pSubpassBeginInfo);
Parameters
commandBuffer is the command buffer in which to record the command.
pRenderPassBegin is a pointer to a VkRenderPassBeginInfo structure (defined below) which indicates the render pass to begin an instance of, and the framebuffer the instance uses.
pSubpassBeginInfo is a pointer to a VkSubpassBeginInfoKHR structure which contains information about the subpass which is about to begin rendering.
Description
After beginning a render pass instance, the command buffer is ready to record the commands for the first subpass of that render pass.

Valid Usage
If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_TRANSFER_SRC_BIT
If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_TRANSFER_DST_BIT
If any of the initialLayout members of the VkAttachmentDescription structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is not VK_IMAGE_LAYOUT_UNDEFINED, then each such initialLayout must be equal to the current layout of the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin
The srcStageMask and dstStageMask members of any element of the pDependencies member of VkRenderPassCreateInfo used to create renderPass must be supported by the capabilities of the queue family identified by the queueFamilyIndex member of the VkCommandPoolCreateInfo used to create the command pool which commandBuffer was allocated from
For any attachment in framebuffer that is used by renderPass and is bound to memory locations that are also bound to another attachment used by renderPass, and if at least one of those uses causes either attachment to be written to, both attachments must have had the VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT set
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pRenderPassBegin must be a valid pointer to a valid VkRenderPassBeginInfo structure
pSubpassBeginInfo must be a valid pointer to a valid VkSubpassBeginInfoKHR structure
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called outside of a render pass instance
commandBuffer must be a primary VkCommandBuffer
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Outside
Graphics
Graphics
See Also
VkCommandBuffer, VkRenderPassBeginInfo, VkSubpassBeginInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBeginRenderPass2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBeginTransformFeedbackEXT(3)
Name
vkCmdBeginTransformFeedbackEXT - Make transform feedback active in the command buffer

C Specification
Transform feedback for specific transform feedback buffers is made active by calling:

void vkCmdBeginTransformFeedbackEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstCounterBuffer,
    uint32_t                                    counterBufferCount,
    const VkBuffer*                             pCounterBuffers,
    const VkDeviceSize*                         pCounterBufferOffsets);
Parameters
commandBuffer is the command buffer into which the command is recorded.
firstCounterBuffer is the index of the first transform feedback buffer corresponding to pCounterBuffers[0] and pCounterBufferOffsets[0].
counterBufferCount is the size of the pCounterBuffers and pCounterBufferOffsets arrays.
pCounterBuffers is an optional array of buffer handles to the counter buffers which contain a 4 byte integer value representing the byte offset from the start of the corresponding transform feedback buffer from where to start capturing vertex data. If the byte offset stored to the counter buffer location was done using vkCmdEndTransformFeedbackEXT it can be used to resume transform feedback from the previous location. If pCounterBuffers is NULL, then transform feedback will start capturing vertex data to byte offset zero in all bound transform feedback buffers. For each element of pCounterBuffers that is VK_NULL_HANDLE, transform feedback will start capturing vertex data to byte zero in the corresponding bound transform feedback buffer.
pCounterBufferOffsets is an optional array of offsets within each of the pCounterBuffers where the counter values were previously written. The location in each counter buffer at these offsets must be large enough to contain 4 bytes of data. This data is the number of bytes captured by the previous transform feedback to this buffer. If pCounterBufferOffsets is NULL, then it is assumed the offsets are zero.
Description
The active transform feedback buffers will capture primitives emitted from the corresponding XfbBuffer in the bound graphics pipeline. Any XfbBuffer emitted that does not output to an active transform feedback buffer will not be captured.

Valid Usage
VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled
Transform feedback must not be active
firstCounterBuffer must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers
The sum of firstCounterBuffer and counterBufferCount must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers
If counterBufferCount is not 0, and pCounterBuffers is not NULL, pCounterBuffers must be a valid pointer to an array of counterBufferCount VkBuffer handles that are either valid or VK_NULL_HANDLE
For each buffer handle in the array, if it is not VK_NULL_HANDLE it must reference a buffer large enough to hold 4 bytes at the corresponding offset from the pCounterBufferOffsets array
If pCounterBuffer is NULL, then pCounterBufferOffsets must also be NULL
For each buffer handle in the pCounterBuffers array that is not VK_NULL_HANDLE it must have been created with a usage value containing VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT
Transform feedback must not be made active in a render pass instance with multiview enabled
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
If counterBufferCount is not 0, and pCounterBufferOffsets is not NULL, pCounterBufferOffsets must be a valid pointer to an array of counterBufferCount VkDeviceSize values
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Both of commandBuffer, and the elements of pCounterBuffers that are valid handles must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBeginTransformFeedbackEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBindDescriptorSets(3)
Name
vkCmdBindDescriptorSets - Binds descriptor sets to a command buffer

C Specification
To bind one or more descriptor sets to a command buffer, call:

void vkCmdBindDescriptorSets(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    const VkDescriptorSet*                      pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    const uint32_t*                             pDynamicOffsets);
Parameters
commandBuffer is the command buffer that the descriptor sets will be bound to.
pipelineBindPoint is a VkPipelineBindPoint indicating whether the descriptors will be used by graphics pipelines or compute pipelines. There is a separate set of bind points for each of graphics and compute, so binding one does not disturb the other.
layout is a VkPipelineLayout object used to program the bindings.
firstSet is the set number of the first descriptor set to be bound.
descriptorSetCount is the number of elements in the pDescriptorSets array.
pDescriptorSets is an array of handles to VkDescriptorSet objects describing the descriptor sets to write to.
dynamicOffsetCount is the number of dynamic offsets in the pDynamicOffsets array.
pDynamicOffsets is a pointer to an array of uint32_t values specifying dynamic offsets.
Description
vkCmdBindDescriptorSets causes the sets numbered [firstSet.. firstSet+descriptorSetCount-1] to use the bindings stored in pDescriptorSets[0..descriptorSetCount-1] for subsequent rendering commands (either compute or graphics, according to the pipelineBindPoint). Any bindings that were previously applied via these sets are no longer valid.

Once bound, a descriptor set affects rendering of subsequent graphics or compute commands in the command buffer until a different set is bound to the same set number, or else until the set is disturbed as described in Pipeline Layout Compatibility.

A compatible descriptor set must be bound for all set numbers that any shaders in a pipeline access, at the time that a draw or dispatch command is recorded to execute using that pipeline. However, if none of the shaders in a pipeline statically use any bindings with a particular set number, then no descriptor set need be bound for that set number, even if the pipeline layout includes a non-trivial descriptor set layout for that set number.

If any of the sets being bound include dynamic uniform or storage buffers, then pDynamicOffsets includes one element for each array element in each dynamic descriptor type binding in each set. Values are taken from pDynamicOffsets in an order such that all entries for set N come before set N+1; within a set, entries are ordered by the binding numbers in the descriptor set layouts; and within a binding array, elements are in order. dynamicOffsetCount must equal the total number of dynamic descriptors in the sets being bound.

The effective offset used for dynamic uniform and storage buffer bindings is the sum of the relative offset taken from pDynamicOffsets, and the base address of the buffer plus base offset in the descriptor set. The range of the dynamic uniform and storage buffer bindings is the buffer range as specified in the descriptor set.

Each of the pDescriptorSets must be compatible with the pipeline layout specified by layout. The layout used to program the bindings must also be compatible with the pipeline used in subsequent graphics or compute commands, as defined in the Pipeline Layout Compatibility section.

The descriptor set contents bound by a call to vkCmdBindDescriptorSets may be consumed at the following times:

For descriptor bindings created with the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT bit set, the contents may be consumed when the command buffer is submitted to a queue, or during shader execution of the resulting draws and dispatches, or any time in between. Otherwise,
during host execution of the command, or during shader execution of the resulting draws and dispatches, or any time in between.
Thus, the contents of a descriptor set binding must not be altered (overwritten by an update command, or freed) between the first point in time that it may be consumed, and when the command completes executing on the queue.

The contents of pDynamicOffsets are consumed immediately during execution of vkCmdBindDescriptorSets. Once all pending uses have completed, it is legal to update and reuse a descriptor set.

Valid Usage
Each element of pDescriptorSets must have been allocated with a VkDescriptorSetLayout that matches (is the same as, or identically defined as) the VkDescriptorSetLayout at set n in layout, where n is the sum of firstSet and the index into pDescriptorSets
dynamicOffsetCount must be equal to the total number of dynamic descriptors in pDescriptorSets
The sum of firstSet and descriptorSetCount must be less than or equal to VkPipelineLayoutCreateInfo::setLayoutCount provided when layout was created
pipelineBindPoint must be supported by the commandBuffer’s parent VkCommandPool’s queue family
Each element of pDynamicOffsets which corresponds to a descriptor binding with type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must be a multiple of VkPhysicalDeviceLimits::minUniformBufferOffsetAlignment
Each element of pDynamicOffsets which corresponds to a descriptor binding with type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must be a multiple of VkPhysicalDeviceLimits::minStorageBufferOffsetAlignment
For each dynamic uniform or storage buffer binding in pDescriptorSets, the sum of the effective offset, as defined above, and the range of the binding must be less than or equal to the size of the buffer
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pipelineBindPoint must be a valid VkPipelineBindPoint value
layout must be a valid VkPipelineLayout handle
pDescriptorSets must be a valid pointer to an array of descriptorSetCount valid VkDescriptorSet handles
If dynamicOffsetCount is not 0, pDynamicOffsets must be a valid pointer to an array of dynamicOffsetCount uint32_t values
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
descriptorSetCount must be greater than 0
Each of commandBuffer, layout, and the elements of pDescriptorSets must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer, VkDescriptorSet, VkPipelineBindPoint, VkPipelineLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBindDescriptorSets

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBindIndexBuffer(3)
Name
vkCmdBindIndexBuffer - Bind an index buffer to a command buffer

C Specification
To bind an index buffer to a command buffer, call:

void vkCmdBindIndexBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType);
Parameters
commandBuffer is the command buffer into which the command is recorded.
buffer is the buffer being bound.
offset is the starting offset in bytes within buffer used in index buffer address calculations.
indexType is a VkIndexType value specifying whether indices are treated as 16 bits or 32 bits.
Description
Valid Usage
offset must be less than the size of buffer
The sum of offset and the address of the range of VkDeviceMemory object that is backing buffer, must be a multiple of the type indicated by indexType
buffer must have been created with the VK_BUFFER_USAGE_INDEX_BUFFER_BIT flag
If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
indexType must not be VK_INDEX_TYPE_NONE_NV.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
buffer must be a valid VkBuffer handle
indexType must be a valid VkIndexType value
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize, VkIndexType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBindIndexBuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBindPipeline(3)
Name
vkCmdBindPipeline - Bind a pipeline object to a command buffer

C Specification
Once a pipeline has been created, it can be bound to the command buffer using the command:

void vkCmdBindPipeline(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipeline                                  pipeline);
Parameters
commandBuffer is the command buffer that the pipeline will be bound to.
pipelineBindPoint is a VkPipelineBindPoint value specifying whether to bind to the compute or graphics bind point. Binding one does not disturb the other.
pipeline is the pipeline to be bound.
Description
Once bound, a pipeline binding affects subsequent graphics or compute commands in the command buffer until a different pipeline is bound to the bind point. The pipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE controls the behavior of vkCmdDispatch and vkCmdDispatchIndirect. The pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS controls the behavior of all drawing commands. The pipeline bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV controls the behavior of vkCmdTraceRaysNV. No other commands are affected by the pipeline state.

Valid Usage
If pipelineBindPoint is VK_PIPELINE_BIND_POINT_COMPUTE, the VkCommandPool that commandBuffer was allocated from must support compute operations
If pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS, the VkCommandPool that commandBuffer was allocated from must support graphics operations
If pipelineBindPoint is VK_PIPELINE_BIND_POINT_COMPUTE, pipeline must be a compute pipeline
If pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline must be a graphics pipeline
If the variable multisample rate feature is not supported, pipeline is a graphics pipeline, the current subpass has no attachments, and this is not the first call to this function with a graphics pipeline after transitioning to the current subpass, then the sample count specified by this pipeline must match that set in the previous pipeline
If VkPhysicalDeviceSampleLocationsPropertiesEXT::variableSampleLocations is VK_FALSE, and pipeline is a graphics pipeline created with a VkPipelineSampleLocationsStateCreateInfoEXT structure having its sampleLocationsEnable member set to VK_TRUE but without VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT enabled then the current render pass instance must have been begun by specifying a VkRenderPassSampleLocationsBeginInfoEXT structure whose pPostSubpassSampleLocations member contains an element with a subpassIndex matching the current subpass index and the sampleLocationsInfo member of that element must match the sampleLocationsInfo specified in VkPipelineSampleLocationsStateCreateInfoEXT when the pipeline was created
This command must not be recorded when transform feedback is active
If pipelineBindPoint is VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, the VkCommandPool that commandBuffer was allocated from must support compute operations
If pipelineBindPoint is VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, the pipeline must be a ray tracing pipeline
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pipelineBindPoint must be a valid VkPipelineBindPoint value
pipeline must be a valid VkPipeline handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Both of commandBuffer, and pipeline must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer, VkPipeline, VkPipelineBindPoint

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBindPipeline

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBindShadingRateImageNV(3)
Name
vkCmdBindShadingRateImageNV - Bind a shading rate image on a command buffer

C Specification
When shading rate image usage is enabled in the bound pipeline, the pipeline uses a shading rate image specified by the command:

void vkCmdBindShadingRateImageNV(
    VkCommandBuffer                             commandBuffer,
    VkImageView                                 imageView,
    VkImageLayout                               imageLayout);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
imageView is an image view handle that specifies the shading rate image. imageView may be set to VK_NULL_HANDLE, which is equivalent to specifying a view of an image filled with zero values.
imageLayout is the layout that the image subresources accessible from imageView will be in when the shading rate image is accessed.
Description
Valid Usage
The shading rate image feature must be enabled.
If imageView is not VK_NULL_HANDLE, it must be a valid VkImageView handle of type VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY.
If imageView is not VK_NULL_HANDLE, it must have a format of VK_FORMAT_R8_UINT.
If imageView is not VK_NULL_HANDLE, it must have been created with a usage value including VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV
If imageView is not VK_NULL_HANDLE, imageLayout must match the actual VkImageLayout of each subresource accessible from imageView at the time the subresource is accessed.
If imageView is not VK_NULL_HANDLE, imageLayout must be VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV or VK_IMAGE_LAYOUT_GENERAL.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
imageView must be a valid VkImageView handle
imageLayout must be a valid VkImageLayout value
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
Both of commandBuffer, and imageView must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer, VkImageLayout, VkImageView

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBindShadingRateImageNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBindTransformFeedbackBuffersEXT(3)
Name
vkCmdBindTransformFeedbackBuffersEXT - Bind transform feedback buffers to a command buffer

C Specification
To bind transform feedback buffers to a command buffer for use in subsequent draw commands, call:

void vkCmdBindTransformFeedbackBuffersEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const VkBuffer*                             pBuffers,
    const VkDeviceSize*                         pOffsets,
    const VkDeviceSize*                         pSizes);
Parameters
commandBuffer is the command buffer into which the command is recorded.
firstBinding is the index of the first transform feedback binding whose state is updated by the command.
bindingCount is the number of transform feedback bindings whose state is updated by the command.
pBuffers is a pointer to an array of buffer handles.
pOffsets is a pointer to an array of buffer offsets.
pSizes is an optional array of buffer sizes, which specifies the maximum number of bytes to capture to the corresponding transform feedback buffer. If pSizes is NULL, or the value of the pSizes array element is VK_WHOLE_SIZE, then the maximum bytes captured will be the size of the corresponding buffer minus the buffer offset.
Description
The values taken from elements i of pBuffers, pOffsets and pSizes replace the current state for the transform feedback binding firstBinding + i, for i in [0, bindingCount). The transform feedback binding is updated to start at the offset indicated by pOffsets[i] from the start of the buffer pBuffers[i].

Valid Usage
VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled
firstBinding must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers
The sum of firstBinding and bindingCount must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers
All elements of pOffsets must be less than the size of the corresponding element in pBuffers
All elements of pOffsets must be a multiple of 4
All elements of pBuffers must have been created with the VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT flag
If the optional pSize array is specified, each element of pSizes must either be VK_WHOLE_SIZE, or be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBufferSize
All elements of pSizes must be less than or equal to the size of the corresponding buffer in pBuffers
All elements of pOffsets plus pSizes, where the pSizes, element is not VK_WHOLE_SIZE, must be less than or equal to the size of the corresponding element in pBuffers
Each element of pBuffers that is non-sparse must be bound completely and contiguously to a single VkDeviceMemory object
Transform feedback must not be active when the vkCmdBindTransformFeedbackBuffersEXT command is recorded
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pBuffers must be a valid pointer to an array of bindingCount valid VkBuffer handles
pOffsets must be a valid pointer to an array of bindingCount VkDeviceSize values
If pSizes is not NULL, pSizes must be a valid pointer to an array of bindingCount VkDeviceSize values
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
If pSizes is not NULL, bindingCount must be greater than 0
Both of commandBuffer, and the elements of pBuffers must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBindTransformFeedbackBuffersEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBindVertexBuffers(3)
Name
vkCmdBindVertexBuffers - Bind vertex buffers to a command buffer

C Specification
To bind vertex buffers to a command buffer for use in subsequent draw commands, call:

void vkCmdBindVertexBuffers(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const VkBuffer*                             pBuffers,
    const VkDeviceSize*                         pOffsets);
Parameters
commandBuffer is the command buffer into which the command is recorded.
firstBinding is the index of the first vertex input binding whose state is updated by the command.
bindingCount is the number of vertex input bindings whose state is updated by the command.
pBuffers is a pointer to an array of buffer handles.
pOffsets is a pointer to an array of buffer offsets.
Description
The values taken from elements i of pBuffers and pOffsets replace the current state for the vertex input binding firstBinding + i, for i in [0, bindingCount). The vertex input binding is updated to start at the offset indicated by pOffsets[i] from the start of the buffer pBuffers[i]. All vertex input attributes that use each of these bindings will use these updated addresses in their address calculations for subsequent draw commands.

Valid Usage
firstBinding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings
The sum of firstBinding and bindingCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings
All elements of pOffsets must be less than the size of the corresponding element in pBuffers
All elements of pBuffers must have been created with the VK_BUFFER_USAGE_VERTEX_BUFFER_BIT flag
Each element of pBuffers that is non-sparse must be bound completely and contiguously to a single VkDeviceMemory object
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pBuffers must be a valid pointer to an array of bindingCount valid VkBuffer handles
pOffsets must be a valid pointer to an array of bindingCount VkDeviceSize values
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
bindingCount must be greater than 0
Both of commandBuffer, and the elements of pBuffers must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBindVertexBuffers

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBlitImage(3)
Name
vkCmdBlitImage - Copy regions of an image, potentially performing format conversion,

C Specification
To copy regions of a source image into a destination image, potentially performing format conversion, arbitrary scaling, and filtering, call:

void vkCmdBlitImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageBlit*                          pRegions,
    VkFilter                                    filter);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
srcImage is the source image.
srcImageLayout is the layout of the source image subresources for the blit.
dstImage is the destination image.
dstImageLayout is the layout of the destination image subresources for the blit.
regionCount is the number of regions to blit.
pRegions is a pointer to an array of VkImageBlit structures specifying the regions to blit.
filter is a VkFilter specifying the filter to apply if the blits require scaling.
Description
vkCmdBlitImage must not be used for multisampled source or destination images. Use vkCmdResolveImage for this purpose.

As the sizes of the source and destination extents can differ in any dimension, texels in the source extent are scaled and filtered to the destination extent. Scaling occurs via the following operations:

For each destination texel, the integer coordinate of that texel is converted to an unnormalized texture coordinate, using the effective inverse of the equations described in unnormalized to integer conversion: :: ubase = i + ½ :: vbase = j + ½ :: wbase = k + ½
These base coordinates are then offset by the first destination offset: :: uoffset = ubase - xdst0 :: voffset = vbase - ydst0 :: woffset = wbase - zdst0 :: aoffset = a - baseArrayCountdst
The scale is determined from the source and destination regions, and applied to the offset coordinates: :: scale_u = (xsrc1 - xsrc0) / (xdst1 - xdst0) :: scale_v = (ysrc1 - ysrc0) / (ydst1 - ydst0) :: scale_w = (zsrc1 - zsrc0) / (zdst1 - zdst0) :: uscaled = uoffset * scaleu :: vscaled = voffset * scalev :: wscaled = woffset * scalew
Finally the source offset is added to the scaled coordinates, to determine the final unnormalized coordinates used to sample from srcImage: :: u = uscaled + xsrc0 :: v = vscaled + ysrc0 :: w = wscaled + zsrc0 :: q = mipLevel :: a = aoffset + baseArrayCountsrc
These coordinates are used to sample from the source image, as described in Image Operations chapter, with the filter mode equal to that of filter, a mipmap mode of VK_SAMPLER_MIPMAP_MODE_NEAREST and an address mode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE. Implementations must clamp at the edge of the source image, and may additionally clamp to the edge of the source region.

Note
Due to allowable rounding errors in the generation of the source texture coordinates, it is not always possible to guarantee exactly which source texels will be sampled for a given blit. As rounding errors are implementation dependent, the exact results of a blitting operation are also implementation dependent.
Blits are done layer by layer starting with the baseArrayLayer member of srcSubresource for the source and dstSubresource for the destination. layerCount layers are blitted to the destination image.

3D textures are blitted slice by slice. Slices in the source region bounded by srcOffsets[0].z and srcOffsets[1].z are copied to slices in the destination region bounded by dstOffsets[0].z and dstOffsets[1].z. For each destination slice, a source z coordinate is linearly interpolated between srcOffsets[0].z and srcOffsets[1].z. If the filter parameter is VK_FILTER_LINEAR then the value sampled from the source image is taken by doing linear filtering using the interpolated z coordinate. If filter parameter is VK_FILTER_NEAREST then the value sampled from the source image is taken from the single nearest slice, with an implementation-dependent arithmetic rounding mode.

The following filtering and conversion rules apply:

Integer formats can only be converted to other integer formats with the same signedness.
No format conversion is supported between depth/stencil images. The formats must match.
Format conversions on unorm, snorm, unscaled and packed float formats of the copied aspect of the image are performed by first converting the pixels to float values.
For sRGB source formats, nonlinear RGB values are converted to linear representation prior to filtering.
After filtering, the float values are first clamped and then cast to the destination image format. In case of sRGB destination format, linear RGB values are converted to nonlinear representation before writing the pixel to the image.
Signed and unsigned integers are converted by first clamping to the representable range of the destination format, then casting the value.

Valid Usage
The source region specified by each element of pRegions must be a region that is contained within srcImage
The destination region specified by each element of pRegions must be a region that is contained within dstImage
The union of all destination regions, specified by the elements of pRegions, must not overlap in memory with any texel that may be sampled during the blit operation
The format features of srcImage must contain VK_FORMAT_FEATURE_BLIT_SRC_BIT.
srcImage must not use a format listed in html/vkspec.html#formats-requiring-sampler-ycbcr-conversion
srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag
If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice
srcImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
The format features of dstImage must contain VK_FORMAT_FEATURE_BLIT_DST_BIT.
dstImage must not use a format listed in html/vkspec.html#formats-requiring-sampler-ycbcr-conversion
dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag
If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice
dstImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
The sample count of srcImage and dstImage must both be equal to VK_SAMPLE_COUNT_1_BIT
If either of srcImage or dstImage was created with a signed integer VkFormat, the other must also have been created with a signed integer VkFormat
If either of srcImage or dstImage was created with an unsigned integer VkFormat, the other must also have been created with an unsigned integer VkFormat
If either of srcImage or dstImage was created with a depth/stencil format, the other must have exactly the same format
If srcImage was created with a depth/stencil format, filter must be VK_FILTER_NEAREST
srcImage must have been created with a samples value of VK_SAMPLE_COUNT_1_BIT
dstImage must have been created with a samples value of VK_SAMPLE_COUNT_1_BIT
If filter is VK_FILTER_LINEAR, then the format features of srcImage must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
If filter is VK_FILTER_CUBIC_EXT, then the format features of srcImage must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT.
If filter is VK_FILTER_CUBIC_EXT, srcImage must have a VkImageType of VK_IMAGE_TYPE_2D
If commandBuffer is an unprotected command buffer, then srcImage must not be a protected image
If commandBuffer is an unprotected command buffer, then dstImage must not be a protected image
If commandBuffer is a protected command buffer, then dstImage must not be an unprotected image
The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created
The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created
The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created
The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created
dstImage and srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
srcImage must be a valid VkImage handle
srcImageLayout must be a valid VkImageLayout value
dstImage must be a valid VkImage handle
dstImageLayout must be a valid VkImageLayout value
pRegions must be a valid pointer to an array of regionCount valid VkImageBlit structures
filter must be a valid VkFilter value
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called outside of a render pass instance
regionCount must be greater than 0
Each of commandBuffer, dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Graphics
Transfer
See Also
VkCommandBuffer, VkFilter, VkImage, VkImageBlit, VkImageLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBlitImage

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdBuildAccelerationStructureNV(3)
Name
vkCmdBuildAccelerationStructureNV - Build an acceleration structure

C Specification
To build an acceleration structure call:

void vkCmdBuildAccelerationStructureNV(
    VkCommandBuffer                             commandBuffer,
    const VkAccelerationStructureInfoNV*        pInfo,
    VkBuffer                                    instanceData,
    VkDeviceSize                                instanceOffset,
    VkBool32                                    update,
    VkAccelerationStructureNV                   dst,
    VkAccelerationStructureNV                   src,
    VkBuffer                                    scratch,
    VkDeviceSize                                scratchOffset);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
pInfo contains the shared information for the acceleration structure’s structure.
instanceData is the buffer containing instance data that will be used to build the acceleration structure as described in Accelerator structure instances. This parameter must be NULL for bottom level acceleration structures.
instanceOffset is the offset in bytes (relative to the start of instanceData) at which the instance data is located.
update specifies whether to update the dst acceleration structure with the data in src.
dst points to the target acceleration structure for the build.
src points to an existing acceleration structure that is to be used to update the dst acceleration structure.
scratch is the VkBuffer that will be used as scratch memory for the build.
scratchOffset is the offset in bytes relative to the start of scratch that will be used as a scratch memory.
Description
Valid Usage
geometryCount must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxGeometryCount
dst must have been created with compatible VkAccelerationStructureInfoNV where VkAccelerationStructureInfoNV::type and VkAccelerationStructureInfoNV::flags are identical, VkAccelerationStructureInfoNV::instanceCount and VkAccelerationStructureInfoNV::geometryCount for dst are greater than or equal to the build size and each geometry in VkAccelerationStructureInfoNV::pGeometries for dst has greater than or equal to the number of vertices, indices, and AABBs.
If update is VK_TRUE, src must not be VK_NULL_HANDLE
If update is VK_TRUE, src must have been built before with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV set in VkAccelerationStructureInfoNV::flags
If update is VK_FALSE, The size member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with VkAccelerationStructureMemoryRequirementsInfoNV::accelerationStructure set to dst and VkAccelerationStructureMemoryRequirementsInfoNV::type set to VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV must be less than or equal to the size of scratch minus scratchOffset
If update is VK_TRUE, The size member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with VkAccelerationStructureMemoryRequirementsInfoNV::accelerationStructure set to dst and VkAccelerationStructureMemoryRequirementsInfoNV::type set to VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV must be less than or equal to the size of scratch minus scratchOffset
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pInfo must be a valid pointer to a valid VkAccelerationStructureInfoNV structure
If instanceData is not VK_NULL_HANDLE, instanceData must be a valid VkBuffer handle
dst must be a valid VkAccelerationStructureNV handle
If src is not VK_NULL_HANDLE, src must be a valid VkAccelerationStructureNV handle
scratch must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support compute operations
Each of commandBuffer, dst, instanceData, scratch, and src that are valid handles must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Compute
See Also
VkAccelerationStructureInfoNV, VkAccelerationStructureNV, VkBool32, VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdBuildAccelerationStructureNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdClearAttachments(3)
Name
vkCmdClearAttachments - Clear regions within bound framebuffer attachments

C Specification
To clear one or more regions of color and depth/stencil attachments inside a render pass instance, call:

void vkCmdClearAttachments(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    attachmentCount,
    const VkClearAttachment*                    pAttachments,
    uint32_t                                    rectCount,
    const VkClearRect*                          pRects);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
attachmentCount is the number of entries in the pAttachments array.
pAttachments is a pointer to an array of VkClearAttachment structures defining the attachments to clear and the clear values to use. If any attachment to be cleared in the current subpass is VK_ATTACHMENT_UNUSED, then the clear has no effect on that attachment.
rectCount is the number of entries in the pRects array.
pRects points to an array of VkClearRect structures defining regions within each selected attachment to clear.
Description
vkCmdClearAttachments can clear multiple regions of each attachment used in the current subpass of a render pass instance. This command must be called only inside a render pass instance, and implicitly selects the images to clear based on the current framebuffer attachments and the command parameters.

If the render pass has a fragment density map attachment, clears follow the operations of fragment density maps as if each clear region was a primitive which generates fragments. The clear color is applied to all pixels inside each fragment’s area regardless if the pixels lie outside of the clear region. Clears may have a different set of supported fragment areas than draws.

Unlike other clear commands, vkCmdClearAttachments executes as a drawing command, rather than a transfer command, with writes performed by it executing in rasterization order. Clears to color attachments are executed as color attachment writes, by the VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT stage. Clears to depth/stencil attachments are executed as depth writes and writes by the VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT and VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT stages.

Valid Usage
If the aspectMask member of any element of pAttachments contains VK_IMAGE_ASPECT_COLOR_BIT, then the colorAttachment member of that element must either refer to a color attachment which is VK_ATTACHMENT_UNUSED, or must be a valid color attachment.
If the aspectMask member of any element of pAttachments contains VK_IMAGE_ASPECT_DEPTH_BIT, then the current subpass' depth/stencil attachment must either be VK_ATTACHMENT_UNUSED, or must have a depth component
If the aspectMask member of any element of pAttachments contains VK_IMAGE_ASPECT_STENCIL_BIT, then the current subpass' depth/stencil attachment must either be VK_ATTACHMENT_UNUSED, or must have a stencil component
The rect member of each element of pRects must have an extent.width greater than 0
The rect member of each element of pRects must have an extent.height greater than 0
The rectangular region specified by each element of pRects must be contained within the render area of the current render pass instance
The layers specified by each element of pRects must be contained within every attachment that pAttachments refers to
The layerCount member of each element of pRects must not be 0
If commandBuffer is an unprotected command buffer, then each attachment to be cleared must not be a protected image.
If commandBuffer is a protected command buffer, then each attachment to be cleared must not be an unprotected image.
If the render pass instance this is recorded in uses multiview, then baseArrayLayer must be zero and layerCount must be one.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pAttachments must be a valid pointer to an array of attachmentCount valid VkClearAttachment structures
pRects must be a valid pointer to an array of rectCount VkClearRect structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
attachmentCount must be greater than 0
rectCount must be greater than 0
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Graphics
See Also
VkClearAttachment, VkClearRect, VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdClearAttachments

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdClearColorImage(3)
Name
vkCmdClearColorImage - Clear regions of a color image

C Specification
To clear one or more subranges of a color image, call:

void vkCmdClearColorImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    const VkClearColorValue*                    pColor,
    uint32_t                                    rangeCount,
    const VkImageSubresourceRange*              pRanges);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
image is the image to be cleared.
imageLayout specifies the current layout of the image subresource ranges to be cleared, and must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_GENERAL or VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL.
pColor is a pointer to a VkClearColorValue structure that contains the values the image subresource ranges will be cleared to (see html/vkspec.html#clears-values below).
rangeCount is the number of image subresource range structures in pRanges.
pRanges points to an array of VkImageSubresourceRange structures that describe a range of mipmap levels, array layers, and aspects to be cleared, as described in Image Views.
Description
Each specified range in pRanges is cleared to the value specified by pColor.

Valid Usage
The format features of image must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT.
image must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag
image must not use a format listed in html/vkspec.html#formats-requiring-sampler-ycbcr-conversion
If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
imageLayout must specify the layout of the image subresource ranges of image specified in pRanges at the time this command is executed on a VkDevice
imageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR
The VkImageSubresourceRange::aspectMask members of the elements of the pRanges array must each only include VK_IMAGE_ASPECT_COLOR_BIT
The VkImageSubresourceRange::baseMipLevel members of the elements of the pRanges array must each be less than the mipLevels specified in VkImageCreateInfo when image was created
For each VkImageSubresourceRange element of pRanges, if the levelCount member is not VK_REMAINING_MIP_LEVELS, then baseMipLevel + levelCount must be less than the mipLevels specified in VkImageCreateInfo when image was created
The VkImageSubresourceRange::baseArrayLayer members of the elements of the pRanges array must each be less than the arrayLayers specified in VkImageCreateInfo when image was created
For each VkImageSubresourceRange element of pRanges, if the layerCount member is not VK_REMAINING_ARRAY_LAYERS, then baseArrayLayer + layerCount must be less than the arrayLayers specified in VkImageCreateInfo when image was created
image must not have a compressed or depth/stencil format
If commandBuffer is an unprotected command buffer, then image must not be a protected image
If commandBuffer is a protected command buffer, then image must not be an unprotected image
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
image must be a valid VkImage handle
imageLayout must be a valid VkImageLayout value
pColor must be a valid pointer to a valid VkClearColorValue union
pRanges must be a valid pointer to an array of rangeCount valid VkImageSubresourceRange structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
This command must only be called outside of a render pass instance
rangeCount must be greater than 0
Both of commandBuffer, and image must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Graphics
Compute
Transfer
See Also
VkClearColorValue, VkCommandBuffer, VkImage, VkImageLayout, VkImageSubresourceRange

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdClearColorImage

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdClearDepthStencilImage(3)
Name
vkCmdClearDepthStencilImage - Fill regions of a combined depth/stencil image

C Specification
To clear one or more subranges of a depth/stencil image, call:

void vkCmdClearDepthStencilImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    const VkClearDepthStencilValue*             pDepthStencil,
    uint32_t                                    rangeCount,
    const VkImageSubresourceRange*              pRanges);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
image is the image to be cleared.
imageLayout specifies the current layout of the image subresource ranges to be cleared, and must be VK_IMAGE_LAYOUT_GENERAL or VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL.
pDepthStencil is a pointer to a VkClearDepthStencilValue structure that contains the values the depth and stencil image subresource ranges will be cleared to (see html/vkspec.html#clears-values below).
rangeCount is the number of image subresource range structures in pRanges.
pRanges points to an array of VkImageSubresourceRange structures that describe a range of mipmap levels, array layers, and aspects to be cleared, as described in Image Views.
Description
Valid Usage
The format features of image must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT.
If any element of pRanges.aspect includes VK_IMAGE_ASPECT_STENCIL_BIT, and image was created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageStencilUsageCreateInfoEXT::stencilUsage used to create image
If any element of pRanges.aspect includes VK_IMAGE_ASPECT_STENCIL_BIT, and image was not created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageCreateInfo::usage used to create image
If any element of pRanges.aspect includes VK_IMAGE_ASPECT_DEPTH_BIT, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageCreateInfo::usage used to create image
If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
imageLayout must specify the layout of the image subresource ranges of image specified in pRanges at the time this command is executed on a VkDevice
imageLayout must be either of VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
The VkImageSubresourceRange::aspectMask members of the elements of the pRanges array must each only include VK_IMAGE_ASPECT_DEPTH_BIT if the image format has a depth component
The VkImageSubresourceRange::aspectMask members of the elements of the pRanges array must each only include VK_IMAGE_ASPECT_STENCIL_BIT if the image format has a stencil component
The VkImageSubresourceRange::baseMipLevel members of the elements of the pRanges array must each be less than the mipLevels specified in VkImageCreateInfo when image was created
For each VkImageSubresourceRange element of pRanges, if the levelCount member is not VK_REMAINING_MIP_LEVELS, then baseMipLevel + levelCount must be less than the mipLevels specified in VkImageCreateInfo when image was created
The VkImageSubresourceRange::baseArrayLayer members of the elements of the pRanges array must each be less than the arrayLayers specified in VkImageCreateInfo when image was created
For each VkImageSubresourceRange element of pRanges, if the layerCount member is not VK_REMAINING_ARRAY_LAYERS, then baseArrayLayer + layerCount must be less than the arrayLayers specified in VkImageCreateInfo when image was created
image must have a depth/stencil format
If commandBuffer is an unprotected command buffer, then image must not be a protected image
If commandBuffer is a protected command buffer, then image must not be an unprotected image
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
image must be a valid VkImage handle
imageLayout must be a valid VkImageLayout value
pDepthStencil must be a valid pointer to a valid VkClearDepthStencilValue structure
pRanges must be a valid pointer to an array of rangeCount valid VkImageSubresourceRange structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called outside of a render pass instance
rangeCount must be greater than 0
Both of commandBuffer, and image must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Graphics
Transfer
See Also
VkClearDepthStencilValue, VkCommandBuffer, VkImage, VkImageLayout, VkImageSubresourceRange

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdClearDepthStencilImage

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdCopyAccelerationStructureNV(3)
Name
vkCmdCopyAccelerationStructureNV - Copy an acceleration structure

C Specification
To copy an acceleration structure call:

void vkCmdCopyAccelerationStructureNV(
    VkCommandBuffer                             commandBuffer,
    VkAccelerationStructureNV                   dst,
    VkAccelerationStructureNV                   src,
    VkCopyAccelerationStructureModeNV           mode);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
dst points to the target acceleration structure for the copy.
src points to the source acceleration structure for the copy.
mode is a VkCopyAccelerationStructureModeNV value that specifies additional operations to perform during the copy.
Description
Valid Usage
mode must be VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV or VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV
src must have been built with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV if mode is VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
dst must be a valid VkAccelerationStructureNV handle
src must be a valid VkAccelerationStructureNV handle
mode must be a valid VkCopyAccelerationStructureModeNV value
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support compute operations
Each of commandBuffer, dst, and src must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Compute
See Also
VkAccelerationStructureNV, VkCommandBuffer, VkCopyAccelerationStructureModeNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdCopyAccelerationStructureNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdCopyBuffer(3)
Name
vkCmdCopyBuffer - Copy data between buffer regions

C Specification
To copy data between buffer objects, call:

void vkCmdCopyBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    const VkBufferCopy*                         pRegions);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
srcBuffer is the source buffer.
dstBuffer is the destination buffer.
regionCount is the number of regions to copy.
pRegions is a pointer to an array of VkBufferCopy structures specifying the regions to copy.
Description
Each region in pRegions is copied from the source buffer to the same region of the destination buffer. srcBuffer and dstBuffer can be the same buffer or alias the same memory, but the resulting values are undefined if the copy regions overlap in memory.

Valid Usage
The srcOffset member of each element of pRegions must be less than the size of srcBuffer
The dstOffset member of each element of pRegions must be less than the size of dstBuffer
The size member of each element of pRegions must be less than or equal to the size of srcBuffer minus srcOffset
The size member of each element of pRegions must be less than or equal to the size of dstBuffer minus dstOffset
The union of the source regions, and the union of the destination regions, specified by the elements of pRegions, must not overlap in memory
srcBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_SRC_BIT usage flag
If srcBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag
If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
If commandBuffer is an unprotected command buffer, then srcBuffer must not be a protected buffer
If commandBuffer is an unprotected command buffer, then dstBuffer must not be a protected buffer
If commandBuffer is a protected command buffer, then dstBuffer must not be an unprotected buffer
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
srcBuffer must be a valid VkBuffer handle
dstBuffer must be a valid VkBuffer handle
pRegions must be a valid pointer to an array of regionCount valid VkBufferCopy structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations
This command must only be called outside of a render pass instance
regionCount must be greater than 0
Each of commandBuffer, dstBuffer, and srcBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Transfer
Graphics
Compute
Transfer
See Also
VkBuffer, VkBufferCopy, VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdCopyBuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdCopyBufferToImage(3)
Name
vkCmdCopyBufferToImage - Copy data from a buffer into an image

C Specification
To copy data from a buffer object to an image object, call:

void vkCmdCopyBufferToImage(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkBufferImageCopy*                    pRegions);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
srcBuffer is the source buffer.
dstImage is the destination image.
dstImageLayout is the layout of the destination image subresources for the copy.
regionCount is the number of regions to copy.
pRegions is a pointer to an array of VkBufferImageCopy structures specifying the regions to copy.
Description
Each region in pRegions is copied from the specified region of the source buffer to the specified region of the destination image.

If the format of dstImage is a multi-planar image format), regions of each plane to be a target of a copy must be specified separately using the pRegions member of the VkBufferImageCopy structure. In this case, the aspectMask of imageSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT. For the purposes of vkCmdCopyBufferToImage, each plane of a multi-planar image is treated as having the format listed in html/vkspec.html#formats-compatible-planes for the plane identified by the aspectMask of the corresponding subresource. This applies both to VkFormat and to coordinates used in the copy, which correspond to texels in the plane rather than how these texels map to coordinates in the image as a whole.

Valid Usage
srcBuffer must be large enough to contain all buffer locations that are accessed according to Buffer and Image Addressing, for each element of pRegions
The image region specified by each element of pRegions must be a region that is contained within dstImage if the dstImage’s VkFormat is not a multi-planar format, and must be a region that is contained within the plane being copied to if the dstImage’s VkFormat is a multi-planar format
The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory
srcBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_SRC_BIT usage flag
The format features of dstImage must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT.
If srcBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag
If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
dstImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT
dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice
dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR
If commandBuffer is an unprotected command buffer, then srcBuffer must not be a protected buffer
If commandBuffer is an unprotected command buffer, then dstImage must not be a protected image
If commandBuffer is a protected command buffer, then dstImage must not be an unprotected image
The imageSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created
The imageSubresource.baseArrayLayer + imageSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created
The imageOffset and imageExtent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer’s command pool’s queue family, as described in VkQueueFamilyProperties
dstImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
srcBuffer must be a valid VkBuffer handle
dstImage must be a valid VkImage handle
dstImageLayout must be a valid VkImageLayout value
pRegions must be a valid pointer to an array of regionCount valid VkBufferImageCopy structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations
This command must only be called outside of a render pass instance
regionCount must be greater than 0
Each of commandBuffer, dstImage, and srcBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Transfer
Graphics
Compute
Transfer
See Also
VkBuffer, VkBufferImageCopy, VkCommandBuffer, VkImage, VkImageLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdCopyBufferToImage

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdCopyImage(3)
Name
vkCmdCopyImage - Copy data between images

C Specification
To copy data between image objects, call:

void vkCmdCopyImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageCopy*                          pRegions);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
srcImage is the source image.
srcImageLayout is the current layout of the source image subresource.
dstImage is the destination image.
dstImageLayout is the current layout of the destination image subresource.
regionCount is the number of regions to copy.
pRegions is a pointer to an array of VkImageCopy structures specifying the regions to copy.
Description
Each region in pRegions is copied from the source image to the same region of the destination image. srcImage and dstImage can be the same image or alias the same memory.

The formats of srcImage and dstImage must be compatible. Formats are compatible if they share the same class, as shown in the Compatible Formats table. Depth/stencil formats must match exactly.

If the format of srcImage or dstImage is a multi-planar image format, regions of each plane to be copied must be specified separately using the srcSubresource and dstSubresource members of the VkImageCopy structure. In this case, the aspectMask of the srcSubresource or dstSubresource that refers to the multi-planar image must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT. For the purposes of vkCmdCopyImage, each plane of a multi-planar image is treated as having the format listed in html/vkspec.html#formats-compatible-planes for the plane identified by the aspectMask of the corresponding subresource. This applies both to VkFormat and to coordinates used in the copy, which correspond to texels in the plane rather than how these texels map to coordinates in the image as a whole.

Note
For example, the VK_IMAGE_ASPECT_PLANE_1_BIT plane of a VK_FORMAT_G8_B8R8_2PLANE_420_UNORM image is compatible with an image of format VK_FORMAT_R8G8_UNORM and (less usefully) with the VK_IMAGE_ASPECT_PLANE_0_BIT plane of an image of format VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16, as each texel is 2 bytes in size.
vkCmdCopyImage allows copying between size-compatible compressed and uncompressed internal formats. Formats are size-compatible if the texel block size of the uncompressed format is equal to the texel block size of the compressed format. Such a copy does not perform on-the-fly compression or decompression. When copying from an uncompressed format to a compressed format, each texel of uncompressed data of the source image is copied as a raw value to the corresponding compressed texel block of the destination image. When copying from a compressed format to an uncompressed format, each compressed texel block of the source image is copied as a raw value to the corresponding texel of uncompressed data in the destination image. Thus, for example, it is legal to copy between a 128-bit uncompressed format and a compressed format which has a 128-bit sized compressed texel block representing 4×4 texels (using 8 bits per texel), or between a 64-bit uncompressed format and a compressed format which has a 64-bit sized compressed texel block representing 4×4 texels (using 4 bits per texel).

When copying between compressed and uncompressed formats the extent members represent the texel dimensions of the source image and not the destination. When copying from a compressed image to an uncompressed image the image texel dimensions written to the uncompressed image will be source extent divided by the compressed texel block dimensions. When copying from an uncompressed image to a compressed image the image texel dimensions written to the compressed image will be the source extent multiplied by the compressed texel block dimensions. In both cases the number of bytes read and the number of bytes written will be identical.

Copying to or from block-compressed images is typically done in multiples of the compressed texel block size. For this reason the extent must be a multiple of the compressed texel block dimension. There is one exception to this rule which is required to handle compressed images created with dimensions that are not a multiple of the compressed texel block dimensions: if the srcImage is compressed, then:

If extent.width is not a multiple of the compressed texel block width, then (extent.width + srcOffset.x) must equal the image subresource width.
If extent.height is not a multiple of the compressed texel block height, then (extent.height + srcOffset.y) must equal the image subresource height.
If extent.depth is not a multiple of the compressed texel block depth, then (extent.depth + srcOffset.z) must equal the image subresource depth.
Similarly, if the dstImage is compressed, then:

If extent.width is not a multiple of the compressed texel block width, then (extent.width + dstOffset.x) must equal the image subresource width.
If extent.height is not a multiple of the compressed texel block height, then (extent.height + dstOffset.y) must equal the image subresource height.
If extent.depth is not a multiple of the compressed texel block depth, then (extent.depth + dstOffset.z) must equal the image subresource depth.
This allows the last compressed texel block of the image in each non-multiple dimension to be included as a source or destination of the copy.

“_422” image formats that are not multi-planar are treated as having a 2×1 compressed texel block for the purposes of these rules.

vkCmdCopyImage can be used to copy image data between multisample images, but both images must have the same number of samples.

Valid Usage
The source region specified by each element of pRegions must be a region that is contained within srcImage if the srcImage’s VkFormat is not a multi-planar format, and must be a region that is contained within the plane being copied if the srcImage’s VkFormat is a multi-planar format
The destination region specified by each element of pRegions must be a region that is contained within dstImage if the dstImage’s VkFormat is not a multi-planar format, and must be a region that is contained within the plane being copied to if the dstImage’s VkFormat is a multi-planar format
The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory
The format features of srcImage must contain VK_FORMAT_FEATURE_TRANSFER_SRC_BIT.
srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag
If srcImage is non-sparse then the image or disjoint plane to be copied must be bound completely and contiguously to a single VkDeviceMemory object
srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice
srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR
The format features of dstImage must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT.
dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag
If dstImage is non-sparse then the image or disjoint plane that is the destination of the copy must be bound completely and contiguously to a single VkDeviceMemory object
dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice
dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR
If the VkFormat of each of srcImage and dstImage is not a multi-planar format, the VkFormat of each of srcImage and dstImage must be compatible, as defined above
In a copy to or from a plane of a multi-planar image, the VkFormat of the image and plane must be compatible according to the description of compatible planes for the plane being copied
When a copy is performed to or from an image with a multi-planar format, the aspectMask of the srcSubresource and/or dstSubresource that refers to the multi-planar image must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT (with VK_IMAGE_ASPECT_PLANE_2_BIT valid only for a VkFormat with three planes)
The sample count of srcImage and dstImage must match
If commandBuffer is an unprotected command buffer, then srcImage must not be a protected image
If commandBuffer is an unprotected command buffer, then dstImage must not be a protected image
If commandBuffer is a protected command buffer, then dstImage must not be an unprotected image
The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created
The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created
The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created
The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created
The srcOffset and extent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer’s command pool’s queue family, as described in VkQueueFamilyProperties
The dstOffset and extent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer’s command pool’s queue family, as described in VkQueueFamilyProperties
dstImage and srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
srcImage must be a valid VkImage handle
srcImageLayout must be a valid VkImageLayout value
dstImage must be a valid VkImage handle
dstImageLayout must be a valid VkImageLayout value
pRegions must be a valid pointer to an array of regionCount valid VkImageCopy structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations
This command must only be called outside of a render pass instance
regionCount must be greater than 0
Each of commandBuffer, dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Transfer
Graphics
Compute
Transfer
See Also
VkCommandBuffer, VkImage, VkImageCopy, VkImageLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdCopyImage

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdCopyImageToBuffer(3)
Name
vkCmdCopyImageToBuffer - Copy image data into a buffer

C Specification
To copy data from an image object to a buffer object, call:

void vkCmdCopyImageToBuffer(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    const VkBufferImageCopy*                    pRegions);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
srcImage is the source image.
srcImageLayout is the layout of the source image subresources for the copy.
dstBuffer is the destination buffer.
regionCount is the number of regions to copy.
pRegions is a pointer to an array of VkBufferImageCopy structures specifying the regions to copy.
Description
Each region in pRegions is copied from the specified region of the source image to the specified region of the destination buffer.

If the VkFormat of srcImage is a multi-planar image format, regions of each plane to be a source of a copy must be specified separately using the pRegions member of the VkBufferImageCopy structure. In this case, the aspectMask of imageSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT. For the purposes of vkCmdCopyBufferToImage, each plane of a multi-planar image is treated as having the format listed in html/vkspec.html#formats-compatible-planes for the plane identified by the aspectMask of the corresponding subresource. This applies both to VkFormat and to coordinates used in the copy, which correspond to texels in the plane rather than how these texels map to coordinates in the image as a whole.

Valid Usage
The image region specified by each element of pRegions must be a region that is contained within srcImage if the srcImage’s VkFormat is not a multi-planar format, and must be a region that is contained within the plane being copied if the srcImage’s VkFormat is a multi-planar format
dstBuffer must be large enough to contain all buffer locations that are accessed according to Buffer and Image Addressing, for each element of pRegions
The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory
The format features of srcImage must contain VK_FORMAT_FEATURE_TRANSFER_SRC_BIT.
srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag
If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
srcImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT
srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice
srcImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag
If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
If commandBuffer is an unprotected command buffer, then srcImage must not be a protected image
If commandBuffer is an unprotected command buffer, then dstBuffer must not be a protected buffer
If commandBuffer is a protected command buffer, then dstBuffer must not be an unprotected buffer
The imageSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created
The imageSubresource.baseArrayLayer + imageSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created
The imageOffset and imageExtent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer’s command pool’s queue family, as described in VkQueueFamilyProperties
srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
srcImage must be a valid VkImage handle
srcImageLayout must be a valid VkImageLayout value
dstBuffer must be a valid VkBuffer handle
pRegions must be a valid pointer to an array of regionCount valid VkBufferImageCopy structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations
This command must only be called outside of a render pass instance
regionCount must be greater than 0
Each of commandBuffer, dstBuffer, and srcImage must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Transfer
Graphics
Compute
Transfer
See Also
VkBuffer, VkBufferImageCopy, VkCommandBuffer, VkImage, VkImageLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdCopyImageToBuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdCopyQueryPoolResults(3)
Name
vkCmdCopyQueryPoolResults - Copy the results of queries in a query pool to a buffer object

C Specification
To copy query statuses and numerical results directly to buffer memory, call:

void vkCmdCopyQueryPoolResults(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags);
Parameters
commandBuffer is the command buffer into which this command will be recorded.
queryPool is the query pool managing the queries containing the desired results.
firstQuery is the initial query index.
queryCount is the number of queries. firstQuery and queryCount together define a range of queries.
dstBuffer is a VkBuffer object that will receive the results of the copy command.
dstOffset is an offset into dstBuffer.
stride is the stride in bytes between results for individual queries within dstBuffer. The required size of the backing memory for dstBuffer is determined as described above for vkGetQueryPoolResults.
flags is a bitmask of VkQueryResultFlagBits specifying how and when results are returned.
Description
vkCmdCopyQueryPoolResults is guaranteed to see the effect of previous uses of vkCmdResetQueryPool in the same queue, without any additional synchronization. Thus, the results will always reflect the most recent use of the query.

flags has the same possible values described above for the flags parameter of vkGetQueryPoolResults, but the different style of execution causes some subtle behavioral differences. Because vkCmdCopyQueryPoolResults executes in order with respect to other query commands, there is less ambiguity about which use of a query is being requested.

If no bits are set in flags, results for all requested queries in the available state are written as 32-bit unsigned integer values, and nothing is written for queries in the unavailable state.

If VK_QUERY_RESULT_64_BIT is set, the results are written as an array of 64-bit unsigned integer values as described for vkGetQueryPoolResults.

If VK_QUERY_RESULT_WAIT_BIT is set, the implementation will wait for each query’s status to be in the available state before retrieving the numerical results for that query. This is guaranteed to reflect the most recent use of the query on the same queue, assuming that the query is not being simultaneously used by other queues. If the query does not become available in a finite amount of time (e.g. due to not issuing a query since the last reset), a VK_ERROR_DEVICE_LOST error may occur.

Similarly, if VK_QUERY_RESULT_WITH_AVAILABILITY_BIT is set and VK_QUERY_RESULT_WAIT_BIT is not set, the availability is guaranteed to reflect the most recent use of the query on the same queue, assuming that the query is not being simultaneously used by other queues. As with vkGetQueryPoolResults, implementations must guarantee that if they return a non-zero availability value, then the numerical results are valid.

If VK_QUERY_RESULT_PARTIAL_BIT is set, VK_QUERY_RESULT_WAIT_BIT is not set, and the query’s status is unavailable, an intermediate result value between zero and the final result value is written for that query.

VK_QUERY_RESULT_PARTIAL_BIT must not be used if the pool’s queryType is VK_QUERY_TYPE_TIMESTAMP.

vkCmdCopyQueryPoolResults is considered to be a transfer operation, and its writes to buffer memory must be synchronized using VK_PIPELINE_STAGE_TRANSFER_BIT and VK_ACCESS_TRANSFER_WRITE_BIT before using the results.

Valid Usage
dstOffset must be less than the size of dstBuffer
firstQuery must be less than the number of queries in queryPool
The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool
If VK_QUERY_RESULT_64_BIT is not set in flags then dstOffset and stride must be multiples of 4
If VK_QUERY_RESULT_64_BIT is set in flags then dstOffset and stride must be multiples of 8
dstBuffer must have enough storage, from dstOffset, to contain the result of each query, as described here
dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag
If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
If the queryType used to create queryPool was VK_QUERY_TYPE_TIMESTAMP, flags must not contain VK_QUERY_RESULT_PARTIAL_BIT
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
queryPool must be a valid VkQueryPool handle
dstBuffer must be a valid VkBuffer handle
flags must be a valid combination of VkQueryResultFlagBits values
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
This command must only be called outside of a render pass instance
Each of commandBuffer, dstBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Graphics
Compute
Transfer
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize, VkQueryPool, VkQueryResultFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdCopyQueryPoolResults

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDebugMarkerBeginEXT(3)
Name
vkCmdDebugMarkerBeginEXT - Open a command buffer marker region

C Specification
A marker region can be opened by calling:

void vkCmdDebugMarkerBeginEXT(
    VkCommandBuffer                             commandBuffer,
    const VkDebugMarkerMarkerInfoEXT*           pMarkerInfo);
Parameters
commandBuffer is the command buffer into which the command is recorded.
pMarkerInfo is a pointer to an instance of the VkDebugMarkerMarkerInfoEXT structure specifying the parameters of the marker region to open.
Description
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pMarkerInfo must be a valid pointer to a valid VkDebugMarkerMarkerInfoEXT structure
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Host Synchronization
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer, VkDebugMarkerMarkerInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDebugMarkerBeginEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDebugMarkerEndEXT(3)
Name
vkCmdDebugMarkerEndEXT - Close a command buffer marker region

C Specification
A marker region can be closed by calling:

void vkCmdDebugMarkerEndEXT(
    VkCommandBuffer                             commandBuffer);
Parameters
commandBuffer is the command buffer into which the command is recorded.
Description
An application may open a marker region in one command buffer and close it in another, or otherwise split marker regions across multiple command buffers or multiple queue submissions. When viewed from the linear series of submissions to a single queue, the calls to vkCmdDebugMarkerBeginEXT and vkCmdDebugMarkerEndEXT must be matched and balanced.

Valid Usage
There must be an outstanding vkCmdDebugMarkerBeginEXT command prior to the vkCmdDebugMarkerEndEXT on the queue that commandBuffer is submitted to
If commandBuffer is a secondary command buffer, there must be an outstanding vkCmdDebugMarkerBeginEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdDebugMarkerEndEXT.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Host Synchronization
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDebugMarkerEndEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDebugMarkerInsertEXT(3)
Name
vkCmdDebugMarkerInsertEXT - Insert a marker label into a command buffer

C Specification
A single marker label can be inserted into a command buffer by calling:

void vkCmdDebugMarkerInsertEXT(
    VkCommandBuffer                             commandBuffer,
    const VkDebugMarkerMarkerInfoEXT*           pMarkerInfo);
Parameters
commandBuffer is the command buffer into which the command is recorded.
pMarkerInfo is a pointer to an instance of the VkDebugMarkerMarkerInfoEXT structure specifying the parameters of the marker to insert.
Description
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pMarkerInfo must be a valid pointer to a valid VkDebugMarkerMarkerInfoEXT structure
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Host Synchronization
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer, VkDebugMarkerMarkerInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDebugMarkerInsertEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDispatch(3)
Name
vkCmdDispatch - Dispatch compute work items

C Specification
To record a dispatch, call:

void vkCmdDispatch(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
groupCountX is the number of local workgroups to dispatch in the X dimension.
groupCountY is the number of local workgroups to dispatch in the Y dimension.
groupCountZ is the number of local workgroups to dispatch in the Z dimension.
Description
When the command is executed, a global workgroup consisting of groupCountX × groupCountY × groupCountZ local workgroups is assembled.

Valid Usage
groupCountX must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]
groupCountY must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]
groupCountZ must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]
For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_COMPUTE, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline
A valid compute pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_COMPUTE
For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE, a push constant value must have been set for VK_PIPELINE_BIND_POINT_COMPUTE, with a VkPipelineLayout that is compatible for push constants with the one used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT.
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.
If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer.
If commandBuffer is a protected command buffer, and any pipeline stage other than the compute pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE reads from any image or buffer, the image or buffer must not be a protected image or protected buffer.
Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support compute operations
This command must only be called outside of a render pass instance
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Compute
Compute
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDispatch

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDispatchBase(3)
Name
vkCmdDispatchBase - Dispatch compute work items

C Specification
To record a dispatch using non-zero base values for the components of WorkgroupId, call:

void vkCmdDispatchBase(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ);
or the equivalent command

void vkCmdDispatchBaseKHR(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
baseGroupX is the start value for the X component of WorkgroupId.
baseGroupY is the start value for the Y component of WorkgroupId.
baseGroupZ is the start value for the Z component of WorkgroupId.
groupCountX is the number of local workgroups to dispatch in the X dimension.
groupCountY is the number of local workgroups to dispatch in the Y dimension.
groupCountZ is the number of local workgroups to dispatch in the Z dimension.
Description
When the command is executed, a global workgroup consisting of groupCountX × groupCountY × groupCountZ local workgroups is assembled, with WorkgroupId values ranging from [baseGroup*, baseGroup* + groupCount*) in each component. vkCmdDispatch is equivalent to vkCmdDispatchBase(0,0,0,groupCountX,groupCountY,groupCountZ).

Valid Usage
All valid usage rules from vkCmdDispatch apply
baseGroupX must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]
baseGroupX must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]
baseGroupZ must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]
groupCountX must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] minus baseGroupX
groupCountY must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] minus baseGroupY
groupCountZ must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] minus baseGroupZ
If any of baseGroupX, baseGroupY, or baseGroupZ are not zero, then the bound compute pipeline must have been created with the VK_PIPELINE_CREATE_DISPATCH_BASE flag.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support compute operations
This command must only be called outside of a render pass instance
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Compute
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDispatchBase

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDispatchIndirect(3)
Name
vkCmdDispatchIndirect - Dispatch compute work items using indirect parameters

C Specification
To record an indirect command dispatch, call:

void vkCmdDispatchIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
buffer is the buffer containing dispatch parameters.
offset is the byte offset into buffer where parameters begin.
Description
vkCmdDispatchIndirect behaves similarly to vkCmdDispatch except that the parameters are read by the device from a buffer during execution. The parameters of the dispatch are encoded in a VkDispatchIndirectCommand structure taken from buffer starting at offset.

Valid Usage
If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_COMPUTE, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline
A valid compute pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_COMPUTE
buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
offset must be a multiple of 4
The sum of offset and the size of VkDispatchIndirectCommand must be less than or equal to the size of buffer
For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE, a push constant value must have been set for VK_PIPELINE_BIND_POINT_COMPUTE, with a VkPipelineLayout that is compatible for push constants with the one used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_COMPUTE uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT.
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2
commandBuffer must not be a protected command buffer
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_COMPUTE reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.
Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
buffer must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support compute operations
This command must only be called outside of a render pass instance
Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Compute
Compute
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDispatchIndirect

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDraw(3)
Name
vkCmdDraw - Draw primitives

C Specification
To record a non-indexed draw, call:

void vkCmdDraw(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance);
Parameters
commandBuffer is the command buffer into which the command is recorded.
vertexCount is the number of vertices to draw.
instanceCount is the number of instances to draw.
firstVertex is the index of the first vertex to draw.
firstInstance is the instance ID of the first instance to draw.
Description
When the command is executed, primitives are assembled using the current primitive topology and vertexCount consecutive vertex indices with the first vertexIndex value equal to firstVertex. The primitives are drawn instanceCount times with instanceIndex starting with firstInstance and increasing sequentially for each instance. The assembled primitives execute the bound graphics pipeline.

Valid Usage
The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline
All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface must have valid buffers bound
For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in html/vkspec.html#fxvertex-input
A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer
Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2
If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.
If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer.
If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer.
If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Graphics
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDraw

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDrawIndexed(3)
Name
vkCmdDrawIndexed - Issue an indexed draw into a command buffer

C Specification
To record an indexed draw, call:

void vkCmdDrawIndexed(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance);
Parameters
commandBuffer is the command buffer into which the command is recorded.
indexCount is the number of vertices to draw.
instanceCount is the number of instances to draw.
firstIndex is the base index within the index buffer.
vertexOffset is the value added to the vertex index before indexing into the vertex buffer.
firstInstance is the instance ID of the first instance to draw.
Description
When the command is executed, primitives are assembled using the current primitive topology and indexCount vertices whose indices are retrieved from the index buffer. The index buffer is treated as an array of tightly packed unsigned integers of size defined by the vkCmdBindIndexBuffer::indexType parameter with which the buffer was bound.

The first vertex index is at an offset of firstIndex * indexSize + offset within the bound index buffer, where offset is the offset specified by vkCmdBindIndexBuffer and indexSize is the byte size of the type specified by indexType. Subsequent index values are retrieved from consecutive locations in the index buffer. Indices are first compared to the primitive restart value, then zero extended to 32 bits (if the indexType is VK_INDEX_TYPE_UINT16) and have vertexOffset added to them, before being supplied as the vertexIndex value.

The primitives are drawn instanceCount times with instanceIndex starting with firstInstance and increasing sequentially for each instance. The assembled primitives execute the bound graphics pipeline.

Valid Usage
The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline
All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface must have valid buffers bound
For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in html/vkspec.html#fxvertex-input
A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer
(indexSize * (firstIndex + indexCount) + offset) must be less than or equal to the size of the bound index buffer, with indexSize being based on the type specified by indexType, where the index buffer, indexType, and offset are specified via vkCmdBindIndexBuffer
Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2
If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.
If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer.
If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer.
If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Graphics
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDrawIndexed

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDrawIndexedIndirect(3)
Name
vkCmdDrawIndexedIndirect - Perform an indexed indirect draw

C Specification
To record an indexed indirect draw, call:

void vkCmdDrawIndexedIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);
Parameters
commandBuffer is the command buffer into which the command is recorded.
buffer is the buffer containing draw parameters.
offset is the byte offset into buffer where parameters begin.
drawCount is the number of draws to execute, and can be zero.
stride is the byte stride between successive sets of draw parameters.
Description
vkCmdDrawIndexedIndirect behaves similarly to vkCmdDrawIndexed except that the parameters are read by the device from a buffer during execution. drawCount draws are executed by the command, with parameters taken from buffer starting at offset and increasing by stride bytes for each successive draw. The parameters of each draw are encoded in an array of VkDrawIndexedIndirectCommand structures. If drawCount is less than or equal to one, stride is ignored.

Valid Usage
If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
offset must be a multiple of 4
If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndexedIndirectCommand)
If the multi-draw indirect feature is not enabled, drawCount must be 0 or 1
If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndexedIndirectCommand structures accessed by this command must be 0
The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline
All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface must have valid buffers bound
A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer
If drawCount is equal to 1, (offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer
If drawCount is greater than 1, (stride × (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer
drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2
If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.
commandBuffer must not be a protected command buffer
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.
If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
buffer must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDrawIndexedIndirect

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDrawIndexedIndirectCountAMD(3)
Name
vkCmdDrawIndexedIndirectCountAMD - Perform an indexed indirect draw with the draw count sourced from a buffer

C Specification
To record an indexed draw call with a draw call count sourced from a buffer, call:

void vkCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride);
Parameters
commandBuffer is the command buffer into which the command is recorded.
buffer is the buffer containing draw parameters.
offset is the byte offset into buffer where parameters begin.
countBuffer is the buffer containing the draw count.
countBufferOffset is the byte offset into countBuffer where the draw count begins.
maxDrawCount specifies the maximum number of draws that will be executed. The actual number of executed draw calls is the minimum of the count specified in countBuffer and maxDrawCount.
stride is the byte stride between successive sets of draw parameters.
Description
vkCmdDrawIndexedIndirectCountAMD behaves similarly to vkCmdDrawIndexedIndirect except that the draw count is read by the device from a buffer during execution. The command will read an unsigned 32-bit integer from countBuffer located at countBufferOffset and use this as the draw count.

Valid Usage
If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
offset must be a multiple of 4
countBufferOffset must be a multiple of 4
stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndexedIndirectCommand)
If maxDrawCount is greater than or equal to 1, (stride × (maxDrawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer
If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndexedIndirectCommand structures accessed by this command must be 0
The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline
All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface must have valid buffers bound
A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer
If count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer
If count stored in countBuffer is greater than 1, (stride × (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer
drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.
commandBuffer must not be a protected command buffer
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.
If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
buffer must be a valid VkBuffer handle
countBuffer must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDrawIndexedIndirectCountAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDrawIndexedIndirectCountKHR(3)
Name
vkCmdDrawIndexedIndirectCountKHR - Perform an indexed indirect draw with the draw count sourced from a buffer

C Specification
To record an indexed draw call with a draw call count sourced from a buffer, call:

void vkCmdDrawIndexedIndirectCountKHR(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride);
Parameters
commandBuffer is the command buffer into which the command is recorded.
buffer is the buffer containing draw parameters.
offset is the byte offset into buffer where parameters begin.
countBuffer is the buffer containing the draw count.
countBufferOffset is the byte offset into countBuffer where the draw count begins.
maxDrawCount specifies the maximum number of draws that will be executed. The actual number of executed draw calls is the minimum of the count specified in countBuffer and maxDrawCount.
stride is the byte stride between successive sets of draw parameters.
Description
vkCmdDrawIndexedIndirectCountKHR behaves similarly to vkCmdDrawIndexedIndirect except that the draw count is read by the device from a buffer during execution. The command will read an unsigned 32-bit integer from countBuffer located at countBufferOffset and use this as the draw count.

Valid Usage
If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
offset must be a multiple of 4
countBufferOffset must be a multiple of 4
stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndexedIndirectCommand)
If maxDrawCount is greater than or equal to 1, (stride × (maxDrawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer
If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndexedIndirectCommand structures accessed by this command must be 0
The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline
All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface must have valid buffers bound
A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer
If count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer
If count stored in countBuffer is greater than 1, (stride × (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer
drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2
If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.
commandBuffer must not be a protected command buffer
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.
If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
buffer must be a valid VkBuffer handle
countBuffer must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDrawIndexedIndirectCountKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDrawIndirect(3)
Name
vkCmdDrawIndirect - Issue an indirect draw into a command buffer

C Specification
To record a non-indexed indirect draw, call:

void vkCmdDrawIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);
Parameters
commandBuffer is the command buffer into which the command is recorded.
buffer is the buffer containing draw parameters.
offset is the byte offset into buffer where parameters begin.
drawCount is the number of draws to execute, and can be zero.
stride is the byte stride between successive sets of draw parameters.
Description
vkCmdDrawIndirect behaves similarly to vkCmdDraw except that the parameters are read by the device from a buffer during execution. drawCount draws are executed by the command, with parameters taken from buffer starting at offset and increasing by stride bytes for each successive draw. The parameters of each draw are encoded in an array of VkDrawIndirectCommand structures. If drawCount is less than or equal to one, stride is ignored.

Valid Usage
If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
offset must be a multiple of 4
If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndirectCommand)
If the multi-draw indirect feature is not enabled, drawCount must be 0 or 1
If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndirectCommand structures accessed by this command must be 0
The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline
All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface must have valid buffers bound
A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer
If drawCount is equal to 1, (offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer
If drawCount is greater than 1, (stride × (drawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer
drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2
If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.
commandBuffer must not be a protected command buffer
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.
If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
buffer must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDrawIndirect

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDrawIndirectByteCountEXT(3)
Name
vkCmdDrawIndirectByteCountEXT - Draw primitives where the vertex count is derived from the counter byte value in the counter buffer

C Specification
To record a non-indexed draw call, where the vertex count is based on a byte count read from a buffer and the passed in vertex stride parameter, call:

void vkCmdDrawIndirectByteCountEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    instanceCount,
    uint32_t                                    firstInstance,
    VkBuffer                                    counterBuffer,
    VkDeviceSize                                counterBufferOffset,
    uint32_t                                    counterOffset,
    uint32_t                                    vertexStride);
Parameters
commandBuffer is the command buffer into which the command is recorded.
instanceCount is the number of instances to draw.
firstInstance is the instance ID of the first instance to draw.
counterBuffer is the buffer handle from where the byte count is read.
counterBufferOffset is the offset into the buffer used to read the byte count, which is used to calculate the vertex count for this draw call.
counterOffset is subtracted from the byte count read from the counterBuffer at the counterBufferOffset
vertexStride is the stride in bytes between each element of the vertex data that is used to calculate the vertex count from the counter value. This value is typically the same value that was used in the graphics pipeline state when the transform feedback was captured as the XfbStride.
Description
When the command is executed, primitives are assembled in the same way as done with vkCmdDraw except the vertexCount is calculated based on the byte count read from counterBuffer at offset counterBufferOffset. The assembled primitives execute the bound graphics pipeline.

The effective vertexCount is calculated as follows:

const uint32_t * counterBufferPtr = (const uint8_t *)counterBuffer.address + counterBufferOffset;
vertexCount = floor(max(0, (*counterBufferPtr - counterOffset)) / vertexStride);
The effective firstVertex is zero.

Valid Usage
VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled
The implementation must support VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackDraw
vertexStride must be greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxTransformFeedbackBufferDataStride
counterBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS
The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS
For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline
All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface must have valid buffers bound
For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in html/vkspec.html#fxvertex-input
A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer
Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command
If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2
If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex
commandBuffer must not be a protected command buffer
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer
If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
counterBuffer must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Both of commandBuffer, and counterBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDrawIndirectByteCountEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDrawIndirectCountAMD(3)
Name
vkCmdDrawIndirectCountAMD - Perform an indirect draw with the draw count sourced from a buffer

C Specification
To record a non-indexed draw call with a draw call count sourced from a buffer, call:

void vkCmdDrawIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride);
Parameters
commandBuffer is the command buffer into which the command is recorded.
buffer is the buffer containing draw parameters.
offset is the byte offset into buffer where parameters begin.
countBuffer is the buffer containing the draw count.
countBufferOffset is the byte offset into countBuffer where the draw count begins.
maxDrawCount specifies the maximum number of draws that will be executed. The actual number of executed draw calls is the minimum of the count specified in countBuffer and maxDrawCount.
stride is the byte stride between successive sets of draw parameters.
Description
vkCmdDrawIndirectCountAMD behaves similarly to vkCmdDrawIndirect except that the draw count is read by the device from a buffer during execution. The command will read an unsigned 32-bit integer from countBuffer located at countBufferOffset and use this as the draw count.

Valid Usage
If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
offset must be a multiple of 4
countBufferOffset must be a multiple of 4
stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndirectCommand)
If maxDrawCount is greater than or equal to 1, (stride × (maxDrawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer
If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndirectCommand structures accessed by this command must be 0
The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline
All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface must have valid buffers bound
A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer
If the count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer
If the count stored in countBuffer is greater than 1, (stride × (drawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer
The count stored in countBuffer must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.
commandBuffer must not be a protected command buffer
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.
If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
buffer must be a valid VkBuffer handle
countBuffer must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDrawIndirectCountAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDrawIndirectCountKHR(3)
Name
vkCmdDrawIndirectCountKHR - Perform an indirect draw with the draw count sourced from a buffer

C Specification
To record a non-indexed draw call with a draw call count sourced from a buffer, call:

void vkCmdDrawIndirectCountKHR(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride);
Parameters
commandBuffer is the command buffer into which the command is recorded.
buffer is the buffer containing draw parameters.
offset is the byte offset into buffer where parameters begin.
countBuffer is the buffer containing the draw count.
countBufferOffset is the byte offset into countBuffer where the draw count begins.
maxDrawCount specifies the maximum number of draws that will be executed. The actual number of executed draw calls is the minimum of the count specified in countBuffer and maxDrawCount.
stride is the byte stride between successive sets of draw parameters.
Description
vkCmdDrawIndirectCountKHR behaves similarly to vkCmdDrawIndirect except that the draw count is read by the device from a buffer during execution. The command will read an unsigned 32-bit integer from countBuffer located at countBufferOffset and use this as the draw count.

Valid Usage
If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
offset must be a multiple of 4
countBufferOffset must be a multiple of 4
stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndirectCommand)
If maxDrawCount is greater than or equal to 1, (stride × (maxDrawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer
If the drawIndirectFirstInstance feature is not enabled, all the firstInstance members of the VkDrawIndirectCommand structures accessed by this command must be 0
The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline
All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface must have valid buffers bound
A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
If the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer
If the count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer
If the count stored in countBuffer is greater than 1, (stride × (drawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer
The count stored in countBuffer must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT.
Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2
Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN_EXT or VK_SAMPLER_REDUCTION_MODE_MAX_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2
If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.
commandBuffer must not be a protected command buffer
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.
If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
buffer must be a valid VkBuffer handle
countBuffer must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDrawIndirectCountKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDrawMeshTasksIndirectCountNV(3)
Name
vkCmdDrawMeshTasksIndirectCountNV - Perform an indirect mesh tasks draw with the draw count sourced from a buffer

C Specification
To record an indirect mesh tasks draw with the draw count sourced from a buffer, call:

void vkCmdDrawMeshTasksIndirectCountNV(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride);
Parameters
commandBuffer is the command buffer into which the command is recorded.
buffer is the buffer containing draw parameters.
offset is the byte offset into buffer where parameters begin.
countBuffer is the buffer containing the draw count.
countBufferOffset is the byte offset into countBuffer where the draw count begins.
maxDrawCount specifies the maximum number of draws that will be executed. The actual number of executed draw calls is the minimum of the count specified in countBuffer and maxDrawCount.
stride is the byte stride between successive sets of draw parameters.
Description
vkCmdDrawMeshTasksIndirectCountNV behaves similarly to vkCmdDrawMeshTasksIndirectNV except that the draw count is read by the device from a buffer during execution. The command will read an unsigned 32-bit integer from countBuffer located at countBufferOffset and use this as the draw count.

Valid Usage
If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
offset must be a multiple of 4
countBufferOffset must be a multiple of 4
stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawMeshTasksIndirectCommandNV)
If maxDrawCount is greater than or equal to 1, (stride × (maxDrawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer
The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
For each set n that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
For each push constant that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the currently bound VkPipeline object, specified via vkCmdBindPipeline
A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
If the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer
If the count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer
If the count stored in countBuffer is greater than 1, (stride × (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer
The count stored in countBuffer must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set
Any VkImageView being sampled with VK_FILTER_LINEAR as a result of this command must be of a format which supports linear filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties
Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.
If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer.
If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer.
If the currently bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
buffer must be a valid VkBuffer handle
countBuffer must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDrawMeshTasksIndirectCountNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDrawMeshTasksIndirectNV(3)
Name
vkCmdDrawMeshTasksIndirectNV - Issue an indirect mesh tasks draw into a command buffer

C Specification
To record an indirect mesh tasks draw, call:

void vkCmdDrawMeshTasksIndirectNV(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);
Parameters
commandBuffer is the command buffer into which the command is recorded.
buffer is the buffer containing draw parameters.
offset is the byte offset into buffer where parameters begin.
drawCount is the number of draws to execute, and can be zero.
stride is the byte stride between successive sets of draw parameters.
Description
vkCmdDrawMeshTasksIndirectNV behaves similarly to vkCmdDrawMeshTasksNV except that the parameters are read by the device from a buffer during execution. drawCount draws are executed by the command, with parameters taken from buffer starting at offset and increasing by stride bytes for each successive draw. The parameters of each draw are encoded in an array of VkDrawMeshTasksIndirectCommandNV structures. If drawCount is less than or equal to one, stride is ignored.

Valid Usage
If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
offset must be a multiple of 4
If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawMeshTasksIndirectCommandNV)
If the multi-draw indirect feature is not enabled, drawCount must be 0 or 1
The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
For each set n that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
For each push constant that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the currently bound VkPipeline object, specified via vkCmdBindPipeline
All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface must have valid buffers bound
A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
If the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer
If drawCount is equal to 1, (offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer
If drawCount is greater than 1, (stride × (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer
drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount
Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set
Any VkImageView being sampled with VK_FILTER_LINEAR as a result of this command must be of a format which supports linear filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties
Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must be of a format which supports cubic filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties
Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.
If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer.
If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer.
If the currently bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
buffer must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDrawMeshTasksIndirectNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdDrawMeshTasksNV(3)
Name
vkCmdDrawMeshTasksNV - Draw mesh task work items

C Specification
To record a draw that uses the mesh pipeline, call:

void vkCmdDrawMeshTasksNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    taskCount,
    uint32_t                                    firstTask);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
taskCount is the number of local workgroups to dispatch in the X dimension. Y and Z dimension are implicitly set to one.
firstTask is the X component of the first workgroup ID.
Description
When the command is executed, a global workgroup consisting of taskCount local workgroups is assembled.

Valid Usage
taskCount must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxDrawMeshTasksCount
The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS.
For each set n that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
For each push constant that is statically used by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS, a push constant value must have been set for VK_PIPELINE_BIND_POINT_GRAPHICS, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the currently bound VkPipeline object, specified via vkCmdBindPipeline
A valid graphics pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_GRAPHICS
If the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS requires any dynamic state, that state must have been set on the current command buffer
Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set
If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS accesses a storage buffer, it must not access values outside of the range of that buffer specified in the currently bound descriptor set
Any VkImageView being sampled with VK_FILTER_LINEAR as a result of this command must be of a format which supports linear filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties
Image subresources used as attachments in the current render pass must not be accessed in any way other than as an attachment by this command.
Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must be of a format which supports cubic filtering, as specified by the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG flag in VkFormatProperties::linearTilingFeatures (for a linear image) or VkFormatProperties::optimalTilingFeatures(for an optimally tiled image) returned by vkGetPhysicalDeviceFormatProperties
Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex.
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer.
If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer.
If commandBuffer is a protected command buffer, and any pipeline stage other than the framebuffer-space pipeline stages in the VkPipeline object currently bound to VK_PIPELINE_BIND_POINT_GRAPHICS reads from or writes to any image or buffer, the image or buffer must not be a protected image or protected buffer.
If the currently bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set
Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Graphics
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdDrawMeshTasksNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdEndConditionalRenderingEXT(3)
Name
vkCmdEndConditionalRenderingEXT - Define the end of a conditional rendering block

C Specification
To end conditional rendering, call:

void vkCmdEndConditionalRenderingEXT(
    VkCommandBuffer                             commandBuffer);
Parameters
commandBuffer is the command buffer into which this command will be recorded.
Description
Once ended, conditional rendering becomes inactive.

Valid Usage
Conditional rendering must be active
If conditional rendering was made active outside of a render pass instance, it must not be ended inside a render pass instance
If conditional rendering was made active within a subpass it must be ended in the same subpass
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdEndConditionalRenderingEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdEndDebugUtilsLabelEXT(3)
Name
vkCmdEndDebugUtilsLabelEXT - Close a command buffer label region

C Specification
A command buffer label region can be closed by calling:

void vkCmdEndDebugUtilsLabelEXT(
    VkCommandBuffer                             commandBuffer);
Parameters
commandBuffer is the command buffer into which the command is recorded.
Description
An application may open a debug label region in one command buffer and close it in another, or otherwise split debug label regions across multiple command buffers or multiple queue submissions. When viewed from the linear series of submissions to a single queue, the calls to vkCmdBeginDebugUtilsLabelEXT and vkCmdEndDebugUtilsLabelEXT must be matched and balanced.

Valid Usage
There must be an outstanding vkCmdBeginDebugUtilsLabelEXT command prior to the vkCmdEndDebugUtilsLabelEXT on the queue that commandBuffer is submitted to
If commandBuffer is a secondary command buffer, there must be an outstanding vkCmdBeginDebugUtilsLabelEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdEndDebugUtilsLabelEXT.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Host Synchronization
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdEndDebugUtilsLabelEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdEndQuery(3)
Name
vkCmdEndQuery - Ends a query

C Specification
To end a query after the set of desired draw or dispatch commands is executed, call:

void vkCmdEndQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query);
Parameters
commandBuffer is the command buffer into which this command will be recorded.
queryPool is the query pool that is managing the results of the query.
query is the query index within the query pool where the result is stored.
Description
As queries operate asynchronously, ending a query does not immediately set the query’s status to available. A query is considered finished when the final results of the query are ready to be retrieved by vkGetQueryPoolResults and vkCmdCopyQueryPoolResults, and this is when the query’s status is set to available.

Once a query is ended the query must finish in finite time, unless the state of the query is changed using other commands, e.g. by issuing a reset of the query.

Valid Usage
All queries used by the command must be active
query must be less than the number of queries in queryPool
commandBuffer must not be a protected command buffer
If vkCmdEndQuery is called within a render pass instance, the sum of query and the number of bits set in the current subpass’s view mask must be less than or equal to the number of queries in queryPool
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
queryPool must be a valid VkQueryPool handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer, VkQueryPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdEndQuery

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdEndQueryIndexedEXT(3)
Name
vkCmdEndQueryIndexedEXT - Ends a query

C Specification
To end an indexed query after the set of desired draw or dispatch commands is recorded, call:

void vkCmdEndQueryIndexedEXT(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    uint32_t                                    index);
Parameters
commandBuffer is the command buffer into which this command will be recorded.
queryPool is the query pool that is managing the results of the query.
query is the query index within the query pool where the result is stored.
index is the query type specific index.
Description
The vkCmdEndQueryIndexedEXT command operates the same as the vkCmdEndQuery command, except that it also accepts a query type specific index parameter.

Valid Usage
All queries used by the command must be active
query must be less than the number of queries in queryPool
commandBuffer must not be a protected command buffer
If vkCmdEndQuery is called within a render pass instance, the sum of query and the number of bits set in the current subpass’s view mask must be less than or equal to the number of queries in queryPool
If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the index parameter must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams
If the queryType used to create queryPool was not VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the index must be zero
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
queryPool must be a valid VkQueryPool handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer, VkQueryPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdEndQueryIndexedEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdEndRenderPass(3)
Name
vkCmdEndRenderPass - End the current render pass

C Specification
To record a command to end a render pass instance after recording the commands for the last subpass, call:

void vkCmdEndRenderPass(
    VkCommandBuffer                             commandBuffer);
Parameters
commandBuffer is the command buffer in which to end the current render pass instance.
Description
Ending a render pass instance performs any multisample resolve operations on the final subpass.

Valid Usage
The current subpass index must be equal to the number of subpasses in the render pass minus one
This command must not be recorded when transform feedback is active
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
commandBuffer must be a primary VkCommandBuffer
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Inside
Graphics
Graphics
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdEndRenderPass

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdEndRenderPass2KHR(3)
Name
vkCmdEndRenderPass2KHR - End the current render pass

C Specification
To record a command to end a render pass instance after recording the commands for the last subpass, call:

void vkCmdEndRenderPass2KHR(
    VkCommandBuffer                             commandBuffer,
    const VkSubpassEndInfoKHR*                  pSubpassEndInfo);
Parameters
commandBuffer is the command buffer in which to end the current render pass instance.
pSubpassEndInfo is a pointer to a VkSubpassEndInfoKHR structure which contains information about how the previous subpass will be ended.
Description
vkCmdEndRenderPass2KHR is semantically identical to vkCmdEndRenderPass, except that it is extensible.

Valid Usage
The current subpass index must be equal to the number of subpasses in the render pass minus one
This command must not be recorded when transform feedback is active
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pSubpassEndInfo must be a valid pointer to a valid VkSubpassEndInfoKHR structure
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
commandBuffer must be a primary VkCommandBuffer
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Inside
Graphics
Graphics
See Also
VkCommandBuffer, VkSubpassEndInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdEndRenderPass2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdEndTransformFeedbackEXT(3)
Name
vkCmdEndTransformFeedbackEXT - Make transform feedback inactive in the command buffer

C Specification
Transform feedback for specific transform feedback buffers is made inactive by calling:

void vkCmdEndTransformFeedbackEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstCounterBuffer,
    uint32_t                                    counterBufferCount,
    const VkBuffer*                             pCounterBuffers,
    const VkDeviceSize*                         pCounterBufferOffsets);
Parameters
commandBuffer is the command buffer into which the command is recorded.
firstCounterBuffer is the index of the first transform feedback buffer corresponding to pCounterBuffers[0] and pCounterBufferOffsets[0].
counterBufferCount is the size of the pCounterBuffers and pCounterBufferOffsets arrays.
pCounterBuffers is an optional array of buffer handles to the counter buffers used to record the current byte positions of each transform feedback buffer where the next vertex output data would be captured. This can be used by a subsequent vkCmdBeginTransformFeedbackEXT call to resume transform feedback capture from this position. It can also be used by vkCmdDrawIndirectByteCountEXT to determine the vertex count of the draw call.
pCounterBufferOffsets is an optional array of offsets within each of the pCounterBuffers where the counter values can be written. The location in each counter buffer at these offsets must be large enough to contain 4 bytes of data. The data stored at this location is the byte offset from the start of the transform feedback buffer binding where the next vertex data would be written. If pCounterBufferOffsets is NULL, then it is assumed the offsets are zero.
Description
Valid Usage
VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled
Transform feedback must be active
firstCounterBuffer must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers
The sum of firstCounterBuffer and counterBufferCount must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers
If counterBufferCount is not 0, and pCounterBuffers is not NULL, pCounterBuffers must be a valid pointer to an array of counterBufferCount VkBuffer handles that are either valid or VK_NULL_HANDLE
For each buffer handle in the array, if it is not VK_NULL_HANDLE it must reference a buffer large enough to hold 4 bytes at the corresponding offset from the pCounterBufferOffsets array
If pCounterBuffer is NULL, then pCounterBufferOffsets must also be NULL
For each buffer handle in the pCounterBuffers array that is not VK_NULL_HANDLE it must have been created with a usage value containing VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
If counterBufferCount is not 0, and pCounterBufferOffsets is not NULL, pCounterBufferOffsets must be a valid pointer to an array of counterBufferCount VkDeviceSize values
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
Both of commandBuffer, and the elements of pCounterBuffers that are valid handles must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdEndTransformFeedbackEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdExecuteCommands(3)
Name
vkCmdExecuteCommands - Execute a secondary command buffer from a primary command buffer

C Specification
A secondary command buffer must not be directly submitted to a queue. Instead, secondary command buffers are recorded to execute as part of a primary command buffer with the command:

void vkCmdExecuteCommands(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    commandBufferCount,
    const VkCommandBuffer*                      pCommandBuffers);
Parameters
commandBuffer is a handle to a primary command buffer that the secondary command buffers are executed in.
commandBufferCount is the length of the pCommandBuffers array.
pCommandBuffers is an array of secondary command buffer handles, which are recorded to execute in the primary command buffer in the order they are listed in the array.
Description
If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, and it was recorded into any other primary command buffer which is currently in the executable or recording state, that primary command buffer becomes invalid.

Valid Usage
commandBuffer must have been allocated with a level of VK_COMMAND_BUFFER_LEVEL_PRIMARY
Each element of pCommandBuffers must have been allocated with a level of VK_COMMAND_BUFFER_LEVEL_SECONDARY
Each element of pCommandBuffers must be in the pending or executable state.
If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, and it was recorded into any other primary command buffer, that primary command buffer must not be in the pending state
If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not be in the pending state.
If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not have already been recorded to commandBuffer.
If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not appear more than once in pCommandBuffers.
Each element of pCommandBuffers must have been allocated from a VkCommandPool that was created for the same queue family as the VkCommandPool from which commandBuffer was allocated
If vkCmdExecuteCommands is being called within a render pass instance, that render pass instance must have been begun with the contents parameter of vkCmdBeginRenderPass set to VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS
If vkCmdExecuteCommands is being called within a render pass instance, each element of pCommandBuffers must have been recorded with the VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT
If vkCmdExecuteCommands is being called within a render pass instance, each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::subpass set to the index of the subpass which the given command buffer will be executed in
If vkCmdExecuteCommands is being called within a render pass instance, the render passes specified in the pBeginInfo::pInheritanceInfo::renderPass members of the vkBeginCommandBuffer commands used to begin recording each element of pCommandBuffers must be compatible with the current render pass.
If vkCmdExecuteCommands is being called within a render pass instance, and any element of pCommandBuffers was recorded with VkCommandBufferInheritanceInfo::framebuffer not equal to VK_NULL_HANDLE, that VkFramebuffer must match the VkFramebuffer used in the current render pass instance
If vkCmdExecuteCommands is not being called within a render pass instance, each element of pCommandBuffers must not have been recorded with the VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT
If the inherited queries feature is not enabled, commandBuffer must not have any queries active
If commandBuffer has a VK_QUERY_TYPE_OCCLUSION query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::occlusionQueryEnable set to VK_TRUE
If commandBuffer has a VK_QUERY_TYPE_OCCLUSION query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::queryFlags having all bits set that are set for the query
If commandBuffer has a VK_QUERY_TYPE_PIPELINE_STATISTICS query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::pipelineStatistics having all bits set that are set in the VkQueryPool the query uses
Each element of pCommandBuffers must not begin any query types that are active in commandBuffer
If commandBuffer is a protected command buffer, then each element of pCommandBuffers must be a protected command buffer.
If commandBuffer is an unprotected command buffer, then each element of pCommandBuffers must be an unprotected command buffer.
This command must not be recorded when transform feedback is active
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pCommandBuffers must be a valid pointer to an array of commandBufferCount valid VkCommandBuffer handles
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations
commandBuffer must be a primary VkCommandBuffer
commandBufferCount must be greater than 0
Both of commandBuffer, and the elements of pCommandBuffers must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Both
Transfer
Graphics
Compute
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdExecuteCommands

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdFillBuffer(3)
Name
vkCmdFillBuffer - Fill a region of a buffer with a fixed value

C Specification
To clear buffer data, call:

void vkCmdFillBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size,
    uint32_t                                    data);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
dstBuffer is the buffer to be filled.
dstOffset is the byte offset into the buffer at which to start filling, and must be a multiple of 4.
size is the number of bytes to fill, and must be either a multiple of 4, or VK_WHOLE_SIZE to fill the range from offset to the end of the buffer. If VK_WHOLE_SIZE is used and the remaining size of the buffer is not a multiple of 4, then the nearest smaller multiple is used.
data is the 4-byte word written repeatedly to the buffer to fill size bytes of data. The data word is written to memory according to the host endianness.
Description
vkCmdFillBuffer is treated as “transfer” operation for the purposes of synchronization barriers. The VK_BUFFER_USAGE_TRANSFER_DST_BIT must be specified in usage of VkBufferCreateInfo in order for the buffer to be compatible with vkCmdFillBuffer.

Valid Usage
dstOffset must be less than the size of dstBuffer
dstOffset must be a multiple of 4
If size is not equal to VK_WHOLE_SIZE, size must be greater than 0
If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to the size of dstBuffer minus dstOffset
If size is not equal to VK_WHOLE_SIZE, size must be a multiple of 4
dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag
If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
If commandBuffer is an unprotected command buffer, then dstBuffer must not be a protected buffer
If commandBuffer is a protected command buffer, then dstBuffer must not be an unprotected buffer
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
dstBuffer must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support transfer, graphics or compute operations
This command must only be called outside of a render pass instance
Both of commandBuffer, and dstBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Transfer
Graphics
Compute
Transfer
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdFillBuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdInsertDebugUtilsLabelEXT(3)
Name
vkCmdInsertDebugUtilsLabelEXT - Insert a label into a command buffer

C Specification
A single debug label can be inserted into a command buffer by calling:

void vkCmdInsertDebugUtilsLabelEXT(
    VkCommandBuffer                             commandBuffer,
    const VkDebugUtilsLabelEXT*                 pLabelInfo);
Parameters
commandBuffer is the command buffer into which the command is recorded.
pInfo is a pointer to an instance of the VkDebugUtilsLabelEXT structure specifying the parameters of the label to insert.
Description
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Host Synchronization
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer, VkDebugUtilsLabelEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdInsertDebugUtilsLabelEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdNextSubpass(3)
Name
vkCmdNextSubpass - Transition to the next subpass of a render pass

C Specification
To transition to the next subpass in the render pass instance after recording the commands for a subpass, call:

void vkCmdNextSubpass(
    VkCommandBuffer                             commandBuffer,
    VkSubpassContents                           contents);
Parameters
commandBuffer is the command buffer in which to record the command.
contents specifies how the commands in the next subpass will be provided, in the same fashion as the corresponding parameter of vkCmdBeginRenderPass.
Description
The subpass index for a render pass begins at zero when vkCmdBeginRenderPass is recorded, and increments each time vkCmdNextSubpass is recorded.

Moving to the next subpass automatically performs any multisample resolve operations in the subpass being ended. End-of-subpass multisample resolves are treated as color attachment writes for the purposes of synchronization. This applies to resolve operations for both color and depth/stencil attachments. That is, they are considered to execute in the VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT pipeline stage and their writes are synchronized with VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT. Synchronization between rendering within a subpass and any resolve operations at the end of the subpass occurs automatically, without need for explicit dependencies or pipeline barriers. However, if the resolve attachment is also used in a different subpass, an explicit dependency is needed.

After transitioning to the next subpass, the application can record the commands for that subpass.

Valid Usage
The current subpass index must be less than the number of subpasses in the render pass minus one
This command must not be recorded when transform feedback is active
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
contents must be a valid VkSubpassContents value
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
commandBuffer must be a primary VkCommandBuffer
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Inside
Graphics
Graphics
See Also
VkCommandBuffer, VkSubpassContents

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdNextSubpass

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdNextSubpass2KHR(3)
Name
vkCmdNextSubpass2KHR - Transition to the next subpass of a render pass

C Specification
To transition to the next subpass in the render pass instance after recording the commands for a subpass, call:

void vkCmdNextSubpass2KHR(
    VkCommandBuffer                             commandBuffer,
    const VkSubpassBeginInfoKHR*                pSubpassBeginInfo,
    const VkSubpassEndInfoKHR*                  pSubpassEndInfo);
Parameters
commandBuffer is the command buffer in which to record the command.
pSubpassBeginInfo is a pointer to a VkSubpassBeginInfoKHR structure which contains information about the subpass which is about to begin rendering.
pSubpassEndInfo is a pointer to a VkSubpassEndInfoKHR structure which contains information about how the previous subpass will be ended.
Description
vkCmdNextSubpass2KHR is semantically identical to vkCmdNextSubpass, except that it is extensible, and that contents is provided as part of an extensible structure instead of as a flat parameter.

Valid Usage
The current subpass index must be less than the number of subpasses in the render pass minus one
This command must not be recorded when transform feedback is active
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pSubpassBeginInfo must be a valid pointer to a valid VkSubpassBeginInfoKHR structure
pSubpassEndInfo must be a valid pointer to a valid VkSubpassEndInfoKHR structure
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called inside of a render pass instance
commandBuffer must be a primary VkCommandBuffer
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Inside
Graphics
Graphics
See Also
VkCommandBuffer, VkSubpassBeginInfoKHR, VkSubpassEndInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdNextSubpass2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdPipelineBarrier(3)
Name
vkCmdPipelineBarrier - Insert a memory dependency

C Specification
To record a pipeline barrier, call:

void vkCmdPipelineBarrier(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkDependencyFlags                           dependencyFlags,
    uint32_t                                    memoryBarrierCount,
    const VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const VkImageMemoryBarrier*                 pImageMemoryBarriers);
Parameters
commandBuffer is the command buffer into which the command is recorded.
srcStageMask is a bitmask of VkPipelineStageFlagBits specifying the source stage mask.
dstStageMask is a bitmask of VkPipelineStageFlagBits specifying the destination stage mask.
dependencyFlags is a bitmask of VkDependencyFlagBits specifying how execution and memory dependencies are formed.
memoryBarrierCount is the length of the pMemoryBarriers array.
pMemoryBarriers is a pointer to an array of VkMemoryBarrier structures.
bufferMemoryBarrierCount is the length of the pBufferMemoryBarriers array.
pBufferMemoryBarriers is a pointer to an array of VkBufferMemoryBarrier structures.
imageMemoryBarrierCount is the length of the pImageMemoryBarriers array.
pImageMemoryBarriers is a pointer to an array of VkImageMemoryBarrier structures.
Description
When vkCmdPipelineBarrier is submitted to a queue, it defines a memory dependency between commands that were submitted before it, and those submitted after it.

If vkCmdPipelineBarrier was recorded outside a render pass instance, the first synchronization scope includes all commands that occur earlier in submission order. If vkCmdPipelineBarrier was recorded inside a render pass instance, the first synchronization scope includes only commands that occur earlier in submission order within the same subpass. In either case, the first synchronization scope is limited to operations on the pipeline stages determined by the source stage mask specified by srcStageMask.

If vkCmdPipelineBarrier was recorded outside a render pass instance, the second synchronization scope includes all commands that occur later in submission order. If vkCmdPipelineBarrier was recorded inside a render pass instance, the second synchronization scope includes only commands that occur later in submission order within the same subpass. In either case, the second synchronization scope is limited to operations on the pipeline stages determined by the destination stage mask specified by dstStageMask.

The first access scope is limited to access in the pipeline stages determined by the source stage mask specified by srcStageMask. Within that, the first access scope only includes the first access scopes defined by elements of the pMemoryBarriers, pBufferMemoryBarriers and pImageMemoryBarriers arrays, which each define a set of memory barriers. If no memory barriers are specified, then the first access scope includes no accesses.

The second access scope is limited to access in the pipeline stages determined by the destination stage mask specified by dstStageMask. Within that, the second access scope only includes the second access scopes defined by elements of the pMemoryBarriers, pBufferMemoryBarriers and pImageMemoryBarriers arrays, which each define a set of memory barriers. If no memory barriers are specified, then the second access scope includes no accesses.

If dependencyFlags includes VK_DEPENDENCY_BY_REGION_BIT, then any dependency between framebuffer-space pipeline stages is framebuffer-local - otherwise it is framebuffer-global.

Valid Usage
If the geometry shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
If the geometry shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
If the tessellation shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
If the tessellation shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
If vkCmdPipelineBarrier is called within a render pass instance, the render pass must have been created with at least one VkSubpassDependency instance in VkRenderPassCreateInfo::pDependencies that expresses a dependency from the current subpass to itself, and for which srcStageMask contains a subset of the bit values in VkSubpassDependency::srcStageMask, dstStageMask contains a subset of the bit values in VkSubpassDependency::dstStageMask, dependencyFlags is equal to VkSubpassDependency::dependencyFlags, srcAccessMask member of each element of pMemoryBarriers and pImageMemoryBarriers contains a subset of the bit values in VkSubpassDependency::srcAccessMask, and dstAccessMask member of each element of pMemoryBarriers and pImageMemoryBarriers contains a subset of the bit values in VkSubpassDependency::dstAccessMask
If vkCmdPipelineBarrier is called within a render pass instance, bufferMemoryBarrierCount must be 0
If vkCmdPipelineBarrier is called within a render pass instance, the image member of any element of pImageMemoryBarriers must be equal to one of the elements of pAttachments that the current framebuffer was created with, that is also referred to by one of the elements of the pColorAttachments, pResolveAttachments or pDepthStencilAttachment members of the VkSubpassDescription instance or by the pDepthStencilResolveAttachment member of the VkSubpassDescriptionDepthStencilResolveKHR structure that the current subpass was created with
If vkCmdPipelineBarrier is called within a render pass instance, the oldLayout and newLayout members of any element of pImageMemoryBarriers must be equal to the layout member of an element of the pColorAttachments, pResolveAttachments or pDepthStencilAttachment members of the VkSubpassDescription instance or by the pDepthStencilResolveAttachment member of the VkSubpassDescriptionDepthStencilResolveKHR structure that the current subpass was created with, that refers to the same image
If vkCmdPipelineBarrier is called within a render pass instance, the oldLayout and newLayout members of an element of pImageMemoryBarriers must be equal
If vkCmdPipelineBarrier is called within a render pass instance, the srcQueueFamilyIndex and dstQueueFamilyIndex members of any element of pImageMemoryBarriers must be VK_QUEUE_FAMILY_IGNORED
Any pipeline stage included in srcStageMask or dstStageMask must be supported by the capabilities of the queue family specified by the queueFamilyIndex member of the VkCommandPoolCreateInfo structure that was used to create the VkCommandPool that commandBuffer was allocated from, as specified in the table of supported pipeline stages.
Each element of pMemoryBarriers, pBufferMemoryBarriers and pImageMemoryBarriers must not have any access flag included in its srcAccessMask member if that bit is not supported by any of the pipeline stages in srcStageMask, as specified in the table of supported access types.
Each element of pMemoryBarriers, pBufferMemoryBarriers and pImageMemoryBarriers must not have any access flag included in its dstAccessMask member if that bit is not supported by any of the pipeline stages in dstStageMask, as specified in the table of supported access types.
If vkCmdPipelineBarrier is called outside of a render pass instance, dependencyFlags must not include VK_DEPENDENCY_VIEW_LOCAL_BIT
If the mesh shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
If the task shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
If the mesh shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
If the task shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
srcStageMask must be a valid combination of VkPipelineStageFlagBits values
srcStageMask must not be 0
dstStageMask must be a valid combination of VkPipelineStageFlagBits values
dstStageMask must not be 0
dependencyFlags must be a valid combination of VkDependencyFlagBits values
If memoryBarrierCount is not 0, pMemoryBarriers must be a valid pointer to an array of memoryBarrierCount valid VkMemoryBarrier structures
If bufferMemoryBarrierCount is not 0, pBufferMemoryBarriers must be a valid pointer to an array of bufferMemoryBarrierCount valid VkBufferMemoryBarrier structures
If imageMemoryBarrierCount is not 0, pImageMemoryBarriers must be a valid pointer to an array of imageMemoryBarrierCount valid VkImageMemoryBarrier structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Transfer
Graphics
Compute
See Also
VkBufferMemoryBarrier, VkCommandBuffer, VkDependencyFlags, VkImageMemoryBarrier, VkMemoryBarrier, VkPipelineStageFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdPipelineBarrier

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdProcessCommandsNVX(3)
Name
vkCmdProcessCommandsNVX - Performs the generation of commands on the device

C Specification
The actual generation on the device is handled with:

void vkCmdProcessCommandsNVX(
    VkCommandBuffer                             commandBuffer,
    const VkCmdProcessCommandsInfoNVX*          pProcessCommandsInfo);
Parameters
commandBuffer is the primary command buffer in which the generation process takes space.
pProcessCommandsInfo is a pointer to an instance of the VkCmdProcessCommandsInfoNVX structure containing parameters affecting the processing of commands.
Description
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pProcessCommandsInfo must be a valid pointer to a valid VkCmdProcessCommandsInfoNVX structure
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
This command must only be called inside of a render pass instance
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Inside
Graphics
Compute
See Also
VkCmdProcessCommandsInfoNVX, VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdProcessCommandsNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdPushConstants(3)
Name
vkCmdPushConstants - Update the values of push constants

C Specification
To update push constants, call:

void vkCmdPushConstants(
    VkCommandBuffer                             commandBuffer,
    VkPipelineLayout                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    const void*                                 pValues);
Parameters
commandBuffer is the command buffer in which the push constant update will be recorded.
layout is the pipeline layout used to program the push constant updates.
stageFlags is a bitmask of VkShaderStageFlagBits specifying the shader stages that will use the push constants in the updated range.
offset is the start offset of the push constant range to update, in units of bytes.
size is the size of the push constant range to update, in units of bytes.
pValues is an array of size bytes containing the new push constant values.
Description
Note
As stageFlags needs to include all flags the relevant push constant ranges were created with, any flags that are not supported by the queue family that the VkCommandPool used to allocate commandBuffer was created on are ignored.
Valid Usage
For each byte in the range specified by offset and size and for each shader stage in stageFlags, there must be a push constant range in layout that includes that byte and that stage
For each byte in the range specified by offset and size and for each push constant range that overlaps that byte, stageFlags must include all stages in that push constant range’s VkPushConstantRange::stageFlags
offset must be a multiple of 4
size must be a multiple of 4
offset must be less than VkPhysicalDeviceLimits::maxPushConstantsSize
size must be less than or equal to VkPhysicalDeviceLimits::maxPushConstantsSize minus offset
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
layout must be a valid VkPipelineLayout handle
stageFlags must be a valid combination of VkShaderStageFlagBits values
stageFlags must not be 0
pValues must be a valid pointer to an array of size bytes
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
size must be greater than 0
Both of commandBuffer, and layout must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer, VkPipelineLayout, VkShaderStageFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdPushConstants

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdPushDescriptorSetKHR(3)
Name
vkCmdPushDescriptorSetKHR - Pushes descriptor updates into a command buffer

C Specification
In addition to allocating descriptor sets and binding them to a command buffer, an application can record descriptor updates into the command buffer.

To push descriptor updates into a command buffer, call:

void vkCmdPushDescriptorSetKHR(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    uint32_t                                    descriptorWriteCount,
    const VkWriteDescriptorSet*                 pDescriptorWrites);
Parameters
commandBuffer is the command buffer that the descriptors will be recorded in.
pipelineBindPoint is a VkPipelineBindPoint indicating whether the descriptors will be used by graphics pipelines or compute pipelines. There is a separate set of push descriptor bindings for each of graphics and compute, so binding one does not disturb the other.
layout is a VkPipelineLayout object used to program the bindings.
set is the set number of the descriptor set in the pipeline layout that will be updated.
descriptorWriteCount is the number of elements in the pDescriptorWrites array.
pDescriptorWrites is a pointer to an array of VkWriteDescriptorSet structures describing the descriptors to be updated.
Description
Push descriptors are a small bank of descriptors whose storage is internally managed by the command buffer rather than being written into a descriptor set and later bound to a command buffer. Push descriptors allow for incremental updates of descriptors without managing the lifetime of descriptor sets.

When a command buffer begins recording, all push descriptors are undefined. Push descriptors can be updated incrementally and cause shaders to use the updated descriptors for subsequent rendering commands (either compute or graphics, according to the pipelineBindPoint) until the descriptor is overwritten, or else until the set is disturbed as described in Pipeline Layout Compatibility. When the set is disturbed or push descriptors with a different descriptor set layout are set, all push descriptors are undefined.

Push descriptors that are statically used by a pipeline must not be undefined at the time that a draw or dispatch command is recorded to execute using that pipeline. This includes immutable sampler descriptors, which must be pushed before they are accessed by a pipeline. Push descriptors that are not statically used can remain undefined.

Push descriptors do not use dynamic offsets. Instead, the corresponding non-dynamic descriptor types can be used and the offset member of VkDescriptorBufferInfo can be changed each time the descriptor is written.

Each element of pDescriptorWrites is interpreted as in VkWriteDescriptorSet, except the dstSet member is ignored.

To push an immutable sampler, use a VkWriteDescriptorSet with dstBinding and dstArrayElement selecting the immutable sampler’s binding. If the descriptor type is VK_DESCRIPTOR_TYPE_SAMPLER, the pImageInfo parameter is ignored and the immutable sampler is taken from the push descriptor set layout in the pipeline layout. If the descriptor type is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the sampler member of the pImageInfo parameter is ignored and the immutable sampler is taken from the push descriptor set layout in the pipeline layout.

Valid Usage
pipelineBindPoint must be supported by the commandBuffer’s parent VkCommandPool’s queue family
set must be less than VkPipelineLayoutCreateInfo::setLayoutCount provided when layout was created
set must be the unique set number in the pipeline layout that uses a descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pipelineBindPoint must be a valid VkPipelineBindPoint value
layout must be a valid VkPipelineLayout handle
pDescriptorWrites must be a valid pointer to an array of descriptorWriteCount valid VkWriteDescriptorSet structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
descriptorWriteCount must be greater than 0
Both of commandBuffer, and layout must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkCommandBuffer, VkPipelineBindPoint, VkPipelineLayout, VkWriteDescriptorSet

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdPushDescriptorSetKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdPushDescriptorSetWithTemplateKHR(3)
Name
vkCmdPushDescriptorSetWithTemplateKHR - Pushes descriptor updates into a command buffer using a descriptor update template

C Specification
It is also possible to use a descriptor update template to specify the push descriptors to update. To do so, call:

void vkCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer                             commandBuffer,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    const void*                                 pData);
Parameters
commandBuffer is the command buffer that the descriptors will be recorded in.
descriptorUpdateTemplate is a descriptor update template that defines how to interpret the descriptor information in pData.
layout is a VkPipelineLayout object used to program the bindings. It must be compatible with the layout used to create the descriptorUpdateTemplate handle.
set is the set number of the descriptor set in the pipeline layout that will be updated. This must be the same number used to create the descriptorUpdateTemplate handle.
pData points to memory which contains the descriptors for the templated update.
Description
Valid Usage
The pipelineBindPoint specified during the creation of the descriptor update template must be supported by the commandBuffer’s parent VkCommandPool’s queue family
pData must be a valid pointer to a memory that contains one or more valid instances of VkDescriptorImageInfo, VkDescriptorBufferInfo, or VkBufferView in a layout defined by descriptorUpdateTemplate when it was created with vkCreateDescriptorUpdateTemplateKHR
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
descriptorUpdateTemplate must be a valid VkDescriptorUpdateTemplate handle
layout must be a valid VkPipelineLayout handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
Each of commandBuffer, descriptorUpdateTemplate, and layout must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
API example
struct AppDataStructure
{
    VkDescriptorImageInfo  imageInfo;          // a single image info
    // ... some more application related data
};

const VkDescriptorUpdateTemplateEntry descriptorUpdateTemplateEntries[] =
{
    // binding to a single image descriptor
    {
        0,                                           // binding
        0,                                           // dstArrayElement
        1,                                           // descriptorCount
        VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,   // descriptorType
        offsetof(AppDataStructure, imageInfo),       // offset
        0                                            // stride is not required if descriptorCount is 1
    }
};

// create a descriptor update template for descriptor set updates
const VkDescriptorUpdateTemplateCreateInfo createInfo =
{
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,  // sType
    NULL,                                                      // pNext
    0,                                                         // flags
    1,                                                         // descriptorUpdateEntryCount
    descriptorUpdateTemplateEntries,                           // pDescriptorUpdateEntries
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR,   // templateType
    0,                                                         // descriptorSetLayout, ignored by given templateType
    VK_PIPELINE_BIND_POINT_GRAPHICS,                           // pipelineBindPoint
    myPipelineLayout,                                          // pipelineLayout
    0,                                                         // set
};

VkDescriptorUpdateTemplate myDescriptorUpdateTemplate;
myResult = vkCreateDescriptorUpdateTemplate(
    myDevice,
    &createInfo,
    NULL,
    &myDescriptorUpdateTemplate);
}

AppDataStructure appData;
// fill appData here or cache it in your engine
vkCmdPushDescriptorSetWithTemplateKHR(myCmdBuffer, myDescriptorUpdateTemplate, myPipelineLayout, 0,&appData);
See Also
VkCommandBuffer, VkDescriptorUpdateTemplate, VkPipelineLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdPushDescriptorSetWithTemplateKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdReserveSpaceForCommandsNVX(3)
Name
vkCmdReserveSpaceForCommandsNVX - Perform a reservation of command buffer space

C Specification
Command space for generated commands recorded into a secondary command buffer must be reserved by calling:

void vkCmdReserveSpaceForCommandsNVX(
    VkCommandBuffer                             commandBuffer,
    const VkCmdReserveSpaceForCommandsInfoNVX*  pReserveSpaceInfo);
Parameters
commandBuffer is the secondary command buffer in which the space for device-generated commands is reserved.
pProcessCommandsInfo is a pointer to an instance of the VkCmdReserveSpaceForCommandsInfoNVX structure containing parameters affecting the reservation of command buffer space.
Description
Valid Usage
The provided commandBuffer must not have had a prior space reservation since its creation or the last reset.
The state of the commandBuffer must be legal to execute all commands within the sequence provided by the indirectCommandsLayout member of pProcessCommandsInfo.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pReserveSpaceInfo must be a valid pointer to a valid VkCmdReserveSpaceForCommandsInfoNVX structure
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
This command must only be called inside of a render pass instance
commandBuffer must be a secondary VkCommandBuffer
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Secondary
Inside
Graphics
Compute
See Also
VkCmdReserveSpaceForCommandsInfoNVX, VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdReserveSpaceForCommandsNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdResetEvent(3)
Name
vkCmdResetEvent - Reset an event object to non-signaled state

C Specification
To set the state of an event to unsignaled from a device, call:

void vkCmdResetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask);
Parameters
commandBuffer is the command buffer into which the command is recorded.
event is the event that will be unsignaled.
stageMask is a bitmask of VkPipelineStageFlagBits specifying the source stage mask used to determine when the event is unsignaled.
Description
When vkCmdResetEvent is submitted to a queue, it defines an execution dependency on commands that were submitted before it, and defines an event unsignal operation which resets the event to the unsignaled state.

The first synchronization scope includes all commands that occur earlier in submission order. The synchronization scope is limited to operations on the pipeline stages determined by the source stage mask specified by stageMask.

The second synchronization scope includes only the event unsignal operation.

If event is already in the unsignaled state when vkCmdResetEvent is executed on the device, then vkCmdResetEvent has no effect, no event unsignal operation occurs, and no execution dependency is generated.

Valid Usage
stageMask must not include VK_PIPELINE_STAGE_HOST_BIT
If the geometry shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
If the tessellation shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
When this command executes, event must not be waited on by a vkCmdWaitEvents command that is currently executing
commandBuffer’s current device mask must include exactly one physical device.
If the mesh shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
If the task shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
event must be a valid VkEvent handle
stageMask must be a valid combination of VkPipelineStageFlagBits values
stageMask must not be 0
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
This command must only be called outside of a render pass instance
Both of commandBuffer, and event must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Graphics
Compute
See Also
VkCommandBuffer, VkEvent, VkPipelineStageFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdResetEvent

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdResetQueryPool(3)
Name
vkCmdResetQueryPool - Reset queries in a query pool

C Specification
To reset a range of queries in a query pool on a queue, call:

void vkCmdResetQueryPool(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount);
Parameters
commandBuffer is the command buffer into which this command will be recorded.
queryPool is the handle of the query pool managing the queries being reset.
firstQuery is the initial query index to reset.
queryCount is the number of queries to reset.
Description
When executed on a queue, this command sets the status of query indices [firstQuery, firstQuery + queryCount - 1] to unavailable.

Valid Usage
firstQuery must be less than the number of queries in queryPool
The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
queryPool must be a valid VkQueryPool handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
This command must only be called outside of a render pass instance
Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Graphics
Compute
See Also
VkCommandBuffer, VkQueryPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdResetQueryPool

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdResolveImage(3)
Name
vkCmdResolveImage - Resolve regions of an image

C Specification
To resolve a multisample image to a non-multisample image, call:

void vkCmdResolveImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageResolve*                       pRegions);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
srcImage is the source image.
srcImageLayout is the layout of the source image subresources for the resolve.
dstImage is the destination image.
dstImageLayout is the layout of the destination image subresources for the resolve.
regionCount is the number of regions to resolve.
pRegions is a pointer to an array of VkImageResolve structures specifying the regions to resolve.
Description
During the resolve the samples corresponding to each pixel location in the source are converted to a single sample before being written to the destination. If the source formats are floating-point or normalized types, the sample values for each pixel are resolved in an implementation-dependent manner. If the source formats are integer types, a single sample’s value is selected for each pixel.

srcOffset and dstOffset select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data. extent is the size in texels of the source image to resolve in width, height and depth.

Resolves are done layer by layer starting with baseArrayLayer member of srcSubresource for the source and dstSubresource for the destination. layerCount layers are resolved to the destination image.

Valid Usage
The source region specified by each element of pRegions must be a region that is contained within srcImage
The destination region specified by each element of pRegions must be a region that is contained within dstImage
The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory
If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
srcImage must have a sample count equal to any valid sample count value other than VK_SAMPLE_COUNT_1_BIT
If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
dstImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT
srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice
srcImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice
dstImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL
The format features of dstImage must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT.
srcImage and dstImage must have been created with the same image format
If commandBuffer is an unprotected command buffer, then srcImage must not be a protected image
If commandBuffer is an unprotected command buffer, then dstImage must not be a protected image
If commandBuffer is a protected command buffer, then dstImage must not be an unprotected image
The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created
The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created
The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created
The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created
dstImage and srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
srcImage must be a valid VkImage handle
srcImageLayout must be a valid VkImageLayout value
dstImage must be a valid VkImage handle
dstImageLayout must be a valid VkImageLayout value
pRegions must be a valid pointer to an array of regionCount valid VkImageResolve structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
This command must only be called outside of a render pass instance
regionCount must be greater than 0
Each of commandBuffer, dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Graphics
Transfer
See Also
VkCommandBuffer, VkImage, VkImageLayout, VkImageResolve

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdResolveImage

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetBlendConstants(3)
Name
vkCmdSetBlendConstants - Set the values of blend constants

C Specification
Otherwise, to dynamically set and change the blend constant, call:

void vkCmdSetBlendConstants(
    VkCommandBuffer                             commandBuffer,
    const float                                 blendConstants[4]);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
blendConstants is an array of four values specifying the R, G, B, and A components of the blend constant color used in blending, depending on the blend factor.
Description
Valid Usage
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_BLEND_CONSTANTS dynamic state enabled
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetBlendConstants

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetCheckpointNV(3)
Name
vkCmdSetCheckpointNV - insert diagnostic checkpoint in command stream

C Specification
Device diagnostic checkpoints are inserted into the command stream by calling vkCmdSetCheckpointNV.

void vkCmdSetCheckpointNV(
    VkCommandBuffer                             commandBuffer,
    const void*                                 pCheckpointMarker);
Parameters
commandBuffer is the command buffer that will receive the marker
pCheckpointMarker is an opaque application-provided value that will be associated with the checkpoint.
Description
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, compute, or transfer operations
Host Synchronization
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
Transfer
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetCheckpointNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetCoarseSampleOrderNV(3)
Name
vkCmdSetCoarseSampleOrderNV - Set sample order for coarse fragments on a command buffer

C Specification
If a pipeline state object is created with VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV enabled, the order of coverage samples in fragments larger than one pixel is set by the command:

void vkCmdSetCoarseSampleOrderNV(
    VkCommandBuffer                             commandBuffer,
    VkCoarseSampleOrderTypeNV                   sampleOrderType,
    uint32_t                                    customSampleOrderCount,
    const VkCoarseSampleOrderCustomNV*          pCustomSampleOrders);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
sampleOrderType specifies the mechanism used to order coverage samples in fragments larger than one pixel.
customSampleOrderCount specifies the number of custom sample orderings to use when ordering coverage samples.
pCustomSampleOrders is a pointer to an array of VkCoarseSampleOrderCustomNV structures, each of which specifies the coverage sample order for a single combination of fragment area and coverage sample count.
Description
If sampleOrderType is VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, the coverage sample order used for any combination of fragment area and coverage sample count not enumerated in pCustomSampleOrders will be identical to that used for VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV.

Valid Usage
If sampleOrderType is not VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, customSamplerOrderCount must be 0
The array pCustomSampleOrders must not contain two structures with matching values for both the shadingRate and sampleCount members.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
sampleOrderType must be a valid VkCoarseSampleOrderTypeNV value
If customSampleOrderCount is not 0, pCustomSampleOrders must be a valid pointer to an array of customSampleOrderCount valid VkCoarseSampleOrderCustomNV structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCoarseSampleOrderCustomNV, VkCoarseSampleOrderTypeNV, VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetCoarseSampleOrderNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetDepthBias(3)
Name
vkCmdSetDepthBias - Set the depth bias dynamic state

C Specification
The depth values of all fragments generated by the rasterization of a polygon can be offset by a single value that is computed for that polygon. This behavior is controlled by the depthBiasEnable, depthBiasConstantFactor, depthBiasClamp, and depthBiasSlopeFactor members of VkPipelineRasterizationStateCreateInfo, or by the corresponding parameters to the vkCmdSetDepthBias command if depth bias state is dynamic.

void vkCmdSetDepthBias(
    VkCommandBuffer                             commandBuffer,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
depthBiasConstantFactor is a scalar factor controlling the constant depth value added to each fragment.
depthBiasClamp is the maximum (or minimum) depth bias of a fragment.
depthBiasSlopeFactor is a scalar factor applied to a fragment’s slope in depth bias calculations.
Description
If depthBiasEnable is VK_FALSE, no depth bias is applied and the fragment’s depth values are unchanged.

depthBiasSlopeFactor scales the maximum depth slope of the polygon, and depthBiasConstantFactor scales an implementation-dependent constant that relates to the usable resolution of the depth buffer. The resulting values are summed to produce the depth bias value which is then clamped to a minimum or maximum value specified by depthBiasClamp. depthBiasSlopeFactor, depthBiasConstantFactor, and depthBiasClamp can each be positive, negative, or zero.

The maximum depth slope m of a triangle is

\[m = \sqrt{ \left({{\partial z_f} \over {\partial x_f}}\right)^2 + \left({{\partial z_f} \over {\partial y_f}}\right)^2}\]
where (xf, yf, zf) is a point on the triangle. m may be approximated as

\[m = \max\left( \left| { {\partial z_f} \over {\partial x_f} } \right|, \left| { {\partial z_f} \over {\partial y_f} } \right| \right).\]
The minimum resolvable difference r is an implementation-dependent parameter that depends on the depth buffer representation. It is the smallest difference in framebuffer coordinate z values that is guaranteed to remain distinct throughout polygon rasterization and in the depth buffer. All pairs of fragments generated by the rasterization of two polygons with otherwise identical vertices, but zf values that differ by r, will have distinct depth values.

For fixed-point depth buffer representations, r is constant throughout the range of the entire depth buffer. For floating-point depth buffers, there is no single minimum resolvable difference. In this case, the minimum resolvable difference for a given polygon is dependent on the maximum exponent, e, in the range of z values spanned by the primitive. If n is the number of bits in the floating-point mantissa, the minimum resolvable difference, r, for the given primitive is defined as

:: [eq]#r = 2^e-n^#
If a triangle is rasterized using the VK_POLYGON_MODE_FILL_RECTANGLE_NV polygon mode, then this minimum resolvable difference may not be resolvable for samples outside of the triangle, where the depth is extrapolated.

If no depth buffer is present, r is undefined.

The bias value o for a polygon is

\[\begin{aligned} o &= \mathrm{dbclamp}( m \times \mathtt{depthBiasSlopeFactor} + r \times \mathtt{depthBiasConstantFactor} ) \\ \text{where} &\quad \mathrm{dbclamp}(x) = \begin{cases} x & \mathtt{depthBiasClamp} = 0 \ \text{or}\ \texttt{NaN} \\ \min(x, \mathtt{depthBiasClamp}) & \mathtt{depthBiasClamp} > 0 \\ \max(x, \mathtt{depthBiasClamp}) & \mathtt{depthBiasClamp} < 0 \\ \end{cases} \end{aligned}\]
m is computed as described above. If the depth buffer uses a fixed-point representation, m is a function of depth values in the range [0,1], and o is applied to depth values in the same range.

For fixed-point depth buffers, fragment depth values are always limited to the range [0,1] by clamping after depth bias addition is performed. Unless the html/vkspec.html#VK_EXT_depth_range_unrestricted extension is enabled, fragment depth values are clamped even when the depth buffer uses a floating-point representation.

Valid Usage
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state enabled
If the depth bias clamping feature is not enabled, depthBiasClamp must be 0.0
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetDepthBias

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetDepthBounds(3)
Name
vkCmdSetDepthBounds - Set the depth bounds test values for a command buffer

C Specification
The depth bounds test conditionally disables coverage of a sample based on the outcome of a comparison between the value za in the depth attachment at location (xf,yf) (for the appropriate sample) and a range of values. The test is enabled or disabled by the depthBoundsTestEnable member of VkPipelineDepthStencilStateCreateInfo: If the pipeline state object is created without the VK_DYNAMIC_STATE_DEPTH_BOUNDS dynamic state enabled then the range of values used in the depth bounds test are defined by the minDepthBounds and maxDepthBounds members of the VkPipelineDepthStencilStateCreateInfo structure. Otherwise, to dynamically set the depth bounds range values call:

void vkCmdSetDepthBounds(
    VkCommandBuffer                             commandBuffer,
    float                                       minDepthBounds,
    float                                       maxDepthBounds);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
minDepthBounds is the lower bound of the range of depth values used in the depth bounds test.
maxDepthBounds is the upper bound of the range.
Description
Valid Usage
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_DEPTH_BOUNDS dynamic state enabled
Unless the html/vkspec.html#VK_EXT_depth_range_unrestricted extension is enabled minDepthBounds must be between 0.0 and 1.0, inclusive
Unless the html/vkspec.html#VK_EXT_depth_range_unrestricted extension is enabled maxDepthBounds must be between 0.0 and 1.0, inclusive
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetDepthBounds

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetDeviceMask(3)
Name
vkCmdSetDeviceMask - Modify device mask of a command buffer

C Specification
To update the current device mask of a command buffer, call:

void vkCmdSetDeviceMask(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    deviceMask);
or the equivalent command

void vkCmdSetDeviceMaskKHR(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    deviceMask);
Parameters
commandBuffer is command buffer whose current device mask is modified.
deviceMask is the new value of the current device mask.
Description
deviceMask is used to filter out subsequent commands from executing on all physical devices whose bit indices are not set in the mask, except commands beginning a render pass instance, commands transitioning to the next subpass in the render pass instance, and commands ending a render pass instance, which always execute on the set of physical devices whose bit indices are included in the deviceMask member of the instance of the VkDeviceGroupRenderPassBeginInfoKHR structure passed to the command beginning the corresponding render pass instance.

Valid Usage
deviceMask must be a valid device mask value
deviceMask must not be zero
deviceMask must not include any set bits that were not in the VkDeviceGroupCommandBufferBeginInfo::deviceMask value when the command buffer began recording.
If vkCmdSetDeviceMask is called inside a render pass instance, deviceMask must not include any set bits that were not in the VkDeviceGroupRenderPassBeginInfo::deviceMask value when the render pass instance began recording.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, compute, or transfer operations
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
Transfer
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetDeviceMask

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetDiscardRectangleEXT(3)
Name
vkCmdSetDiscardRectangleEXT - Set discard rectangles dynamically

C Specification
If the pipeline state object was created with the VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT dynamic state enabled, the discard rectangles are dynamically set and changed with the command:

void vkCmdSetDiscardRectangleEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstDiscardRectangle,
    uint32_t                                    discardRectangleCount,
    const VkRect2D*                             pDiscardRectangles);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
firstDiscardRectangle is the index of the first discard rectangle whose state is updated by the command.
discardRectangleCount is the number of discard rectangles whose state are updated by the command.
pDiscardRectangles is a pointer to an array of VkRect2D structures specifying discard rectangles.
Description
The discard rectangle taken from element i of pDiscardRectangles replace the current state for the discard rectangle index firstDiscardRectangle + i, for i in [0, discardRectangleCount).

Valid Usage
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT dynamic state enabled
The sum of firstDiscardRectangle and discardRectangleCount must be less than or equal to VkPhysicalDeviceDiscardRectanglePropertiesEXT::maxDiscardRectangles
The x and y member of offset in each VkRect2D element of pDiscardRectangles must be greater than or equal to 0
Evaluation of (offset.x + extent.width) in each VkRect2D element of pDiscardRectangles must not cause a signed integer addition overflow
Evaluation of (offset.y + extent.height) in each VkRect2D element of pDiscardRectangles must not cause a signed integer addition overflow
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pDiscardRectangles must be a valid pointer to an array of discardRectangleCount VkRect2D structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
discardRectangleCount must be greater than 0
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer, VkRect2D

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetDiscardRectangleEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetEvent(3)
Name
vkCmdSetEvent - Set an event object to signaled state

C Specification
To set the state of an event to signaled from a device, call:

void vkCmdSetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask);
Parameters
commandBuffer is the command buffer into which the command is recorded.
event is the event that will be signaled.
stageMask specifies the source stage mask used to determine when the event is signaled.
Description
When vkCmdSetEvent is submitted to a queue, it defines an execution dependency on commands that were submitted before it, and defines an event signal operation which sets the event to the signaled state.

The first synchronization scope includes all commands that occur earlier in submission order. The synchronization scope is limited to operations on the pipeline stages determined by the source stage mask specified by stageMask.

The second synchronization scope includes only the event signal operation.

If event is already in the signaled state when vkCmdSetEvent is executed on the device, then vkCmdSetEvent has no effect, no event signal operation occurs, and no execution dependency is generated.

Valid Usage
stageMask must not include VK_PIPELINE_STAGE_HOST_BIT
If the geometry shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
If the tessellation shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
commandBuffer’s current device mask must include exactly one physical device.
If the mesh shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
If the task shaders feature is not enabled, stageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
event must be a valid VkEvent handle
stageMask must be a valid combination of VkPipelineStageFlagBits values
stageMask must not be 0
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
This command must only be called outside of a render pass instance
Both of commandBuffer, and event must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Graphics
Compute
See Also
VkCommandBuffer, VkEvent, VkPipelineStageFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetEvent

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetExclusiveScissorNV(3)
Name
vkCmdSetExclusiveScissorNV - Set the dynamic exclusive scissor rectangles on a command buffer

C Specification
If the pipeline state object is created with VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV enabled, then the exclusive scissor rectangles are set by:

void vkCmdSetExclusiveScissorNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstExclusiveScissor,
    uint32_t                                    exclusiveScissorCount,
    const VkRect2D*                             pExclusiveScissors);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
firstExclusiveScissor is the index of the first exclusive scissor rectangle whose state is updated by the command.
exclusiveScissorCount is the number of exclusive scissor rectangles updated by the command.
pExclusiveScissors is a pointer to an array of VkRect2D structures defining exclusive scissor rectangles.
Description
The scissor rectangles taken from element i of pExclusiveScissors replace the current state for the scissor index firstExclusiveScissor + i, for i in [0, exclusiveScissorCount).

Each scissor rectangle is described by a VkRect2D structure, with the offset.x and offset.y values determining the upper left corner of the scissor rectangle, and the extent.width and extent.height values determining the size in pixels.

Valid Usage
The exclusive scissor feature must be enabled.
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV dynamic state enabled
firstExclusiveScissor must be less than VkPhysicalDeviceLimits::maxViewports
The sum of firstExclusiveScissor and exclusiveScissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive
If the multiple viewports feature is not enabled, firstExclusiveScissor must be 0
If the multiple viewports feature is not enabled, exclusiveScissorCount must be 1
The x and y members of offset in each member of pExclusiveScissors must be greater than or equal to 0
Evaluation of (offset.x + extent.width) for each member of pExclusiveScissors must not cause a signed integer addition overflow
Evaluation of (offset.y + extent.height) for each member of pExclusiveScissors must not cause a signed integer addition overflow
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pExclusiveScissors must be a valid pointer to an array of exclusiveScissorCount VkRect2D structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
exclusiveScissorCount must be greater than 0
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer, VkRect2D

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetExclusiveScissorNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetLineWidth(3)
Name
vkCmdSetLineWidth - Set the dynamic line width state

C Specification
The line width is specified by the VkPipelineRasterizationStateCreateInfo::lineWidth property of the currently active pipeline, if the pipeline was not created with VK_DYNAMIC_STATE_LINE_WIDTH enabled.

Otherwise, the line width is set by calling vkCmdSetLineWidth:

void vkCmdSetLineWidth(
    VkCommandBuffer                             commandBuffer,
    float                                       lineWidth);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
lineWidth is the width of rasterized line segments.
Description
Valid Usage
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_LINE_WIDTH dynamic state enabled
If the wide lines feature is not enabled, lineWidth must be 1.0
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetLineWidth

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetSampleLocationsEXT(3)
Name
vkCmdSetSampleLocationsEXT - Set the dynamic sample locations state

C Specification
The custom sample locations used for rasterization when VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable is VK_TRUE are specified by the VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsInfo property of the bound graphics pipeline, if the pipeline was not created with VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT enabled.

Otherwise, the sample locations used for rasterization are set by calling vkCmdSetSampleLocationsEXT:

void vkCmdSetSampleLocationsEXT(
    VkCommandBuffer                             commandBuffer,
    const VkSampleLocationsInfoEXT*             pSampleLocationsInfo);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
pSampleLocationsInfo is the sample locations state to set.
Description
Valid Usage
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled
The sampleLocationsPerPixel member of pSampleLocationsInfo must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with
If VkPhysicalDeviceSampleLocationsPropertiesEXT::variableSampleLocations is VK_FALSE then the current render pass must have been begun by specifying a VkRenderPassSampleLocationsBeginInfoEXT structure whose pPostSubpassSampleLocations member contains an element with a subpassIndex matching the current subpass index and the sampleLocationsInfo member of that element must match the sample locations state pointed to by pSampleLocationsInfo
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pSampleLocationsInfo must be a valid pointer to a valid VkSampleLocationsInfoEXT structure
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer, VkSampleLocationsInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetSampleLocationsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetScissor(3)
Name
vkCmdSetScissor - Set the dynamic scissor rectangles on a command buffer

C Specification
The scissor test determines if a fragment’s framebuffer coordinates (xf,yf) lie within the scissor rectangle corresponding to the viewport index (see Controlling the Viewport) used by the primitive that generated the fragment. If the pipeline state object is created without VK_DYNAMIC_STATE_SCISSOR enabled then the scissor rectangles are set by the VkPipelineViewportStateCreateInfo state of the pipeline state object. Otherwise, to dynamically set the scissor rectangles call:

void vkCmdSetScissor(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstScissor,
    uint32_t                                    scissorCount,
    const VkRect2D*                             pScissors);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
firstScissor is the index of the first scissor whose state is updated by the command.
scissorCount is the number of scissors whose rectangles are updated by the command.
pScissors is a pointer to an array of VkRect2D structures defining scissor rectangles.
Description
The scissor rectangles taken from element i of pScissors replace the current state for the scissor index firstScissor + i, for i in [0, scissorCount).

Each scissor rectangle is described by a VkRect2D structure, with the offset.x and offset.y values determining the upper left corner of the scissor rectangle, and the extent.width and extent.height values determining the size in pixels.

Valid Usage
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_SCISSOR dynamic state enabled
firstScissor must be less than VkPhysicalDeviceLimits::maxViewports
The sum of firstScissor and scissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive
If the multiple viewports feature is not enabled, firstScissor must be 0
If the multiple viewports feature is not enabled, scissorCount must be 1
The x and y members of offset must be greater than or equal to 0
Evaluation of (offset.x + extent.width) must not cause a signed integer addition overflow
Evaluation of (offset.y + extent.height) must not cause a signed integer addition overflow
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pScissors must be a valid pointer to an array of scissorCount VkRect2D structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
scissorCount must be greater than 0
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer, VkRect2D

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetScissor

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetStencilCompareMask(3)
Name
vkCmdSetStencilCompareMask - Set the stencil compare mask dynamic state

C Specification
If the pipeline state object is created with the VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK dynamic state enabled, then to dynamically set the stencil compare mask call:

void vkCmdSetStencilCompareMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    compareMask);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
faceMask is a bitmask of VkStencilFaceFlagBits specifying the set of stencil state for which to update the compare mask.
compareMask is the new value to use as the stencil compare mask.
Description
Valid Usage
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK dynamic state enabled
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
faceMask must be a valid combination of VkStencilFaceFlagBits values
faceMask must not be 0
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer, VkStencilFaceFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetStencilCompareMask

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetStencilReference(3)
Name
vkCmdSetStencilReference - Set the stencil reference dynamic state

C Specification
If the pipeline state object is created with the VK_DYNAMIC_STATE_STENCIL_REFERENCE dynamic state enabled, then to dynamically set the stencil reference value call:

void vkCmdSetStencilReference(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    reference);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
faceMask is a bitmask of VkStencilFaceFlagBits specifying the set of stencil state for which to update the reference value, as described above for vkCmdSetStencilCompareMask.
reference is the new value to use as the stencil reference value.
Description
Valid Usage
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_STENCIL_REFERENCE dynamic state enabled
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
faceMask must be a valid combination of VkStencilFaceFlagBits values
faceMask must not be 0
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer, VkStencilFaceFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetStencilReference

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetStencilWriteMask(3)
Name
vkCmdSetStencilWriteMask - Set the stencil write mask dynamic state

C Specification
If the pipeline state object is created with the VK_DYNAMIC_STATE_STENCIL_WRITE_MASK dynamic state enabled, then to dynamically set the stencil write mask call:

void vkCmdSetStencilWriteMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    writeMask);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
faceMask is a bitmask of VkStencilFaceFlagBits specifying the set of stencil state for which to update the write mask, as described above for vkCmdSetStencilCompareMask.
writeMask is the new value to use as the stencil write mask.
Description
Valid Usage
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_STENCIL_WRITE_MASK dynamic state enabled
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
faceMask must be a valid combination of VkStencilFaceFlagBits values
faceMask must not be 0
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer, VkStencilFaceFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetStencilWriteMask

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetViewport(3)
Name
vkCmdSetViewport - Set the viewport on a command buffer

C Specification
If the bound pipeline state object was not created with the VK_DYNAMIC_STATE_VIEWPORT dynamic state enabled, viewport transformation parameters are specified using the pViewports member of VkPipelineViewportStateCreateInfo in the pipeline state object. If the pipeline state object was created with the VK_DYNAMIC_STATE_VIEWPORT dynamic state enabled, the viewport transformation parameters are dynamically set and changed with the command:

void vkCmdSetViewport(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const VkViewport*                           pViewports);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
firstViewport is the index of the first viewport whose parameters are updated by the command.
viewportCount is the number of viewports whose parameters are updated by the command.
pViewports is a pointer to an array of VkViewport structures specifying viewport parameters.
Description
The viewport parameters taken from element i of pViewports replace the current state for the viewport index firstViewport + i, for i in [0, viewportCount).

Valid Usage
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_VIEWPORT dynamic state enabled
firstViewport must be less than VkPhysicalDeviceLimits::maxViewports
The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive
If the multiple viewports feature is not enabled, firstViewport must be 0
If the multiple viewports feature is not enabled, viewportCount must be 1
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pViewports must be a valid pointer to an array of viewportCount valid VkViewport structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
viewportCount must be greater than 0
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer, VkViewport

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetViewport

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetViewportShadingRatePaletteNV(3)
Name
vkCmdSetViewportShadingRatePaletteNV - Set shading rate image palettes on a command buffer

C Specification
If a pipeline state object is created with VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV enabled, the per-viewport shading rate image palettes are set by the command:

void vkCmdSetViewportShadingRatePaletteNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const VkShadingRatePaletteNV*               pShadingRatePalettes);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
firstViewport is the index of the first viewport whose shading rate palette is updated by the command.
viewportCount is the number of viewports whose shading rate palettes are updated by the command.
pShadingRatePalettes is a pointer to an array of VkShadingRatePaletteNV structures defining the palette for each viewport.
Description
Valid Usage
The shading rate image feature must be enabled.
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled
firstViewport must be less than VkPhysicalDeviceLimits::maxViewports
The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive
If the multiple viewports feature is not enabled, firstViewport must be 0
If the multiple viewports feature is not enabled, viewportCount must be 1
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pShadingRatePalettes must be a valid pointer to an array of viewportCount valid VkShadingRatePaletteNV structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
viewportCount must be greater than 0
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer, VkShadingRatePaletteNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetViewportShadingRatePaletteNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdSetViewportWScalingNV(3)
Name
vkCmdSetViewportWScalingNV - Set the viewport W scaling on a command buffer

C Specification
If the bound pipeline state object was not created with the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, viewport W scaling parameters are specified using the pViewportWScalings member of VkPipelineViewportWScalingStateCreateInfoNV in the pipeline state object. If the pipeline state object was created with the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, the viewport transformation parameters are dynamically set and changed with the command:

void vkCmdSetViewportWScalingNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const VkViewportWScalingNV*                 pViewportWScalings);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
firstViewport is the index of the first viewport whose parameters are updated by the command.
viewportCount is the number of viewports whose parameters are updated by the command.
pViewportWScalings is a pointer to an array of VkViewportWScalingNV structures specifying viewport parameters.
Description
The viewport parameters taken from element i of pViewportWScalings replace the current state for the viewport index firstViewport + i, for i in [0, viewportCount).

Valid Usage
The bound graphics pipeline must have been created with the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled
firstViewport must be less than VkPhysicalDeviceLimits::maxViewports
The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pViewportWScalings must be a valid pointer to an array of viewportCount VkViewportWScalingNV structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics operations
viewportCount must be greater than 0
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
See Also
VkCommandBuffer, VkViewportWScalingNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdSetViewportWScalingNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdTraceRaysNV(3)
Name
vkCmdTraceRaysNV - Initialize a ray tracing dispatch

C Specification
To dispatch a ray tracing call use:

void vkCmdTraceRaysNV(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    raygenShaderBindingTableBuffer,
    VkDeviceSize                                raygenShaderBindingOffset,
    VkBuffer                                    missShaderBindingTableBuffer,
    VkDeviceSize                                missShaderBindingOffset,
    VkDeviceSize                                missShaderBindingStride,
    VkBuffer                                    hitShaderBindingTableBuffer,
    VkDeviceSize                                hitShaderBindingOffset,
    VkDeviceSize                                hitShaderBindingStride,
    VkBuffer                                    callableShaderBindingTableBuffer,
    VkDeviceSize                                callableShaderBindingOffset,
    VkDeviceSize                                callableShaderBindingStride,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
raygenShaderBindingTableBuffer is the buffer object that holds the shader binding table data for the ray generation shader stage.
raygenShaderBindingOffset is the offset in bytes (relative to raygenShaderBindingTableBuffer) of the ray generation shader being used for the trace.
missShaderBindingTableBuffer is the buffer object that holds the shader binding table data for the miss shader stage.
missShaderBindingOffset is the offset in bytes (relative to missShaderBindingTableBuffer) of the miss shader being used for the trace.
missShaderBindingStride is the size in bytes of each shader binding table record in missShaderBindingTableBuffer.
hitShaderBindingTableBuffer is the buffer object that holds the shader binding table data for the hit shader stages.
hitShaderBindingOffset is the offset in bytes (relative to hitShaderBindingTableBuffer) of the hit shader group being used for the trace.
hitShaderBindingStride is the size in bytes of each shader binding table record in hitShaderBindingTableBuffer.
callableShaderBindingTableBuffer is the buffer object that holds the shader binding table data for the callable shader stage.
callableShaderBindingOffset is the offset in bytes (relative to callableShaderBindingTableBuffer) of the callable shader being used for the trace.
callableShaderBindingStride is the size in bytes of each shader binding table record in callableShaderBindingTableBuffer.
width is the width of the ray trace query dimensions.
height is height of the ray trace query dimensions.
depth is depth of the ray trace query dimensions.
Description
When the command is executed, a ray generation group of width × height × depth rays is assembled.

Valid Usage
raygenShaderBindingOffset must be less than the size of raygenShaderBindingTableBuffer
raygenShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment
missShaderBindingOffset must be less than the size of missShaderBindingTableBuffer
missShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment
hitShaderBindingOffset must be less than the size of hitShaderBindingTableBuffer
hitShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment
callableShaderBindingOffset must be less than the size of callableShaderBindingTableBuffer
callableShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment
missShaderBindingStride must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize
hitShaderBindingStride must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize
callableShaderBindingStride must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize
missShaderBindingStride must be a less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride
hitShaderBindingStride must be a less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride
callableShaderBindingStride must be a less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride
width must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]
height must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]
depth must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]
For each set n that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, a descriptor set must have been bound to n at VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the bound VkPipeline object, specified via vkCmdBindPipeline
A valid ray tracing pipeline must be bound to the current command buffer with VK_PIPELINE_BIND_POINT_RAY_TRACING_NV
For each push constant that is statically used by the VkPipeline bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, a push constant value must have been set for VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, with a VkPipelineLayout that is compatible for push constants with the one used to create the current VkPipeline, as described in html/vkspec.html#descriptorsets-compatibility
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV uses unnormalized coordinates, it must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage
If any VkSampler object that is accessed from a shader by the VkPipeline bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV uses unnormalized coordinates, it must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV accesses a uniform buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If the robust buffer access feature is not enabled, and any shader stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV accesses a storage buffer, it must not access values outside of the range of that buffer specified in the bound descriptor set
If a VkImageView is sampled with VK_FILTER_LINEAR as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT
If a VkImageView is sampled with VK_FILTER_CUBIC_IMG as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG
Any VkImageView being sampled with VK_FILTER_CUBIC_IMG as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
If commandBuffer is an unprotected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV reads from or writes to any image or buffer, that image or buffer must not be a protected image or protected buffer
If commandBuffer is a protected command buffer, and any pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV writes to any image or buffer, that image or buffer must not be an unprotected image or unprotected buffer
If commandBuffer is a protected command buffer, and any pipeline stage other than the ray tracing pipeline stage in the VkPipeline object bound to VK_PIPELINE_BIND_POINT_RAY_TRACING_NV reads from any image or buffer, the image or buffer must not be a protected image or protected buffer
Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
raygenShaderBindingTableBuffer must be a valid VkBuffer handle
If missShaderBindingTableBuffer is not VK_NULL_HANDLE, missShaderBindingTableBuffer must be a valid VkBuffer handle
If hitShaderBindingTableBuffer is not VK_NULL_HANDLE, hitShaderBindingTableBuffer must be a valid VkBuffer handle
If callableShaderBindingTableBuffer is not VK_NULL_HANDLE, callableShaderBindingTableBuffer must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support compute operations
Each of callableShaderBindingTableBuffer, commandBuffer, hitShaderBindingTableBuffer, missShaderBindingTableBuffer, and raygenShaderBindingTableBuffer that are valid handles must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Compute
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdTraceRaysNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdUpdateBuffer(3)
Name
vkCmdUpdateBuffer - Update a buffer’s contents from host memory

C Specification
To update buffer data inline in a command buffer, call:

void vkCmdUpdateBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                dataSize,
    const void*                                 pData);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
dstBuffer is a handle to the buffer to be updated.
dstOffset is the byte offset into the buffer to start updating, and must be a multiple of 4.
dataSize is the number of bytes to update, and must be a multiple of 4.
pData is a pointer to the source data for the buffer update, and must be at least dataSize bytes in size.
Description
dataSize must be less than or equal to 65536 bytes. For larger updates, applications can use buffer to buffer copies.

Note
Buffer updates performed with vkCmdUpdateBuffer first copy the data into command buffer memory when the command is recorded (which requires additional storage and may incur an additional allocation), and then copy the data from the command buffer into dstBuffer when the command is executed on a device.

The additional cost of this functionality compared to buffer to buffer copies means it is only recommended for very small amounts of data, and is why it is limited to only 65536 bytes.

Applications can work around this by issuing multiple vkCmdUpdateBuffer commands to different ranges of the same buffer, but it is strongly recommended that they should not.
The source data is copied from the user pointer to the command buffer when the command is called.

vkCmdUpdateBuffer is only allowed outside of a render pass. This command is treated as “transfer” operation, for the purposes of synchronization barriers. The VK_BUFFER_USAGE_TRANSFER_DST_BIT must be specified in usage of VkBufferCreateInfo in order for the buffer to be compatible with vkCmdUpdateBuffer.

Valid Usage
dstOffset must be less than the size of dstBuffer
dataSize must be less than or equal to the size of dstBuffer minus dstOffset
dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag
If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
dstOffset must be a multiple of 4
dataSize must be less than or equal to 65536
dataSize must be a multiple of 4
If commandBuffer is an unprotected command buffer, then dstBuffer must not be a protected buffer
If commandBuffer is a protected command buffer, then dstBuffer must not be an unprotected buffer
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
dstBuffer must be a valid VkBuffer handle
pData must be a valid pointer to an array of dataSize bytes
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations
This command must only be called outside of a render pass instance
dataSize must be greater than 0
Both of commandBuffer, and dstBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Outside
Transfer
Graphics
Compute
Transfer
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdUpdateBuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdWaitEvents(3)
Name
vkCmdWaitEvents - Wait for one or more events and insert a set of memory

C Specification
To wait for one or more events to enter the signaled state on a device, call:

void vkCmdWaitEvents(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    eventCount,
    const VkEvent*                              pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    const VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const VkImageMemoryBarrier*                 pImageMemoryBarriers);
Parameters
commandBuffer is the command buffer into which the command is recorded.
eventCount is the length of the pEvents array.
pEvents is an array of event object handles to wait on.
srcStageMask is a bitmask of VkPipelineStageFlagBits specifying the source stage mask.
dstStageMask is a bitmask of VkPipelineStageFlagBits specifying the destination stage mask.
memoryBarrierCount is the length of the pMemoryBarriers array.
pMemoryBarriers is a pointer to an array of VkMemoryBarrier structures.
bufferMemoryBarrierCount is the length of the pBufferMemoryBarriers array.
pBufferMemoryBarriers is a pointer to an array of VkBufferMemoryBarrier structures.
imageMemoryBarrierCount is the length of the pImageMemoryBarriers array.
pImageMemoryBarriers is a pointer to an array of VkImageMemoryBarrier structures.
Description
When vkCmdWaitEvents is submitted to a queue, it defines a memory dependency between prior event signal operations on the same queue or the host, and subsequent commands. vkCmdWaitEvents must not be used to wait on event signal operations occurring on other queues.

The first synchronization scope only includes event signal operations that operate on members of pEvents, and the operations that happened-before the event signal operations. Event signal operations performed by vkCmdSetEvent that occur earlier in submission order are included in the first synchronization scope, if the logically latest pipeline stage in their stageMask parameter is logically earlier than or equal to the logically latest pipeline stage in srcStageMask. Event signal operations performed by vkSetEvent are only included in the first synchronization scope if VK_PIPELINE_STAGE_HOST_BIT is included in srcStageMask.

The second synchronization scope includes all commands that occur later in submission order. The second synchronization scope is limited to operations on the pipeline stages determined by the destination stage mask specified by dstStageMask.

The first access scope is limited to access in the pipeline stages determined by the source stage mask specified by srcStageMask. Within that, the first access scope only includes the first access scopes defined by elements of the pMemoryBarriers, pBufferMemoryBarriers and pImageMemoryBarriers arrays, which each define a set of memory barriers. If no memory barriers are specified, then the first access scope includes no accesses.

The second access scope is limited to access in the pipeline stages determined by the destination stage mask specified by dstStageMask. Within that, the second access scope only includes the second access scopes defined by elements of the pMemoryBarriers, pBufferMemoryBarriers and pImageMemoryBarriers arrays, which each define a set of memory barriers. If no memory barriers are specified, then the second access scope includes no accesses.

Note
vkCmdWaitEvents is used with vkCmdSetEvent to define a memory dependency between two sets of action commands, roughly in the same way as pipeline barriers, but split into two commands such that work between the two may execute unhindered.
Note
Applications should be careful to avoid race conditions when using events. There is no direct ordering guarantee between a vkCmdResetEvent command and a vkCmdWaitEvents command submitted after it, so some other execution dependency must be included between these commands (e.g. a semaphore).
Valid Usage
srcStageMask must be the bitwise OR of the stageMask parameter used in previous calls to vkCmdSetEvent with any of the members of pEvents and VK_PIPELINE_STAGE_HOST_BIT if any of the members of pEvents was set using vkSetEvent
If the geometry shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
If the geometry shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
If the tessellation shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
If the tessellation shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
If pEvents includes one or more events that will be signaled by vkSetEvent after commandBuffer has been submitted to a queue, then vkCmdWaitEvents must not be called inside a render pass instance
Any pipeline stage included in srcStageMask or dstStageMask must be supported by the capabilities of the queue family specified by the queueFamilyIndex member of the VkCommandPoolCreateInfo structure that was used to create the VkCommandPool that commandBuffer was allocated from, as specified in the table of supported pipeline stages.
Each element of pMemoryBarriers, pBufferMemoryBarriers or pImageMemoryBarriers must not have any access flag included in its srcAccessMask member if that bit is not supported by any of the pipeline stages in srcStageMask, as specified in the table of supported access types.
Each element of pMemoryBarriers, pBufferMemoryBarriers or pImageMemoryBarriers must not have any access flag included in its dstAccessMask member if that bit is not supported by any of the pipeline stages in dstStageMask, as specified in the table of supported access types.
commandBuffer’s current device mask must include exactly one physical device.
If the mesh shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
If the task shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
If the mesh shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
If the task shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pEvents must be a valid pointer to an array of eventCount valid VkEvent handles
srcStageMask must be a valid combination of VkPipelineStageFlagBits values
srcStageMask must not be 0
dstStageMask must be a valid combination of VkPipelineStageFlagBits values
dstStageMask must not be 0
If memoryBarrierCount is not 0, pMemoryBarriers must be a valid pointer to an array of memoryBarrierCount valid VkMemoryBarrier structures
If bufferMemoryBarrierCount is not 0, pBufferMemoryBarriers must be a valid pointer to an array of bufferMemoryBarrierCount valid VkBufferMemoryBarrier structures
If imageMemoryBarrierCount is not 0, pImageMemoryBarriers must be a valid pointer to an array of imageMemoryBarrierCount valid VkImageMemoryBarrier structures
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations
eventCount must be greater than 0
Both of commandBuffer, and the elements of pEvents must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Graphics
Compute
See Also
VkBufferMemoryBarrier, VkCommandBuffer, VkEvent, VkImageMemoryBarrier, VkMemoryBarrier, VkPipelineStageFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdWaitEvents

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdWriteAccelerationStructuresPropertiesNV(3)
Name
vkCmdWriteAccelerationStructuresPropertiesNV - Write acceleration structure result parameters to query results.

C Specification
To query acceleration structure size parameters call:

void vkCmdWriteAccelerationStructuresPropertiesNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    accelerationStructureCount,
    const VkAccelerationStructureNV*            pAccelerationStructures,
    VkQueryType                                 queryType,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
accelerationStructureCount is the count of acceleration structures for which to query the property.
pAccelerationStructures points to an array of existing previously built acceleration structures.
queryType is a VkQueryType value specifying the type of queries managed by the pool.
queryPool is the query pool that will manage the results of the query.
firstQuery is the first query index within the query pool that will contain the accelerationStructureCount number of results.
Description
Valid Usage
queryType must be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV
queryPool must have been created with a queryType matching queryType
The queries identified by queryPool and firstQuery must be unavailable
All acceleration structures in accelerationStructures must have been built with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV if queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pAccelerationStructures must be a valid pointer to an array of accelerationStructureCount valid VkAccelerationStructureNV handles
queryType must be a valid VkQueryType value
queryPool must be a valid VkQueryPool handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support compute operations
accelerationStructureCount must be greater than 0
Each of commandBuffer, queryPool, and the elements of pAccelerationStructures must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Compute
See Also
VkAccelerationStructureNV, VkCommandBuffer, VkQueryPool, VkQueryType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdWriteAccelerationStructuresPropertiesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdWriteBufferMarkerAMD(3)
Name
vkCmdWriteBufferMarkerAMD - Execute a pipelined write of a marker value into a buffer

C Specification
To write a 32-bit marker value into a buffer as a pipelined operation, call:

void vkCmdWriteBufferMarkerAMD(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    uint32_t                                    marker);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
pipelineStage is one of the VkPipelineStageFlagBits values, specifying the pipeline stage whose completion triggers the marker write.
dstBuffer is the buffer where the marker will be written to.
dstOffset is the byte offset into the buffer where the marker will be written to.
marker is the 32-bit value of the marker.
Description
The command will write the 32-bit marker value into the buffer only after all preceding commands have finished executing up to at least the specified pipeline stage. This includes the completion of other preceding vkCmdWriteBufferMarkerAMD commands so long as their specified pipeline stages occur either at the same time or earlier than this command’s specified pipelineStage.

While consecutive buffer marker writes with the same pipelineStage parameter are implicitly complete in submission order, memory and execution dependencies between buffer marker writes and other operations must still be explicitly ordered using synchronization commands. The access scope for buffer marker writes falls under the VK_ACCESS_TRANSFER_WRITE_BIT, and the pipeline stages for identifying the synchronization scope must include both pipelineStage and VK_PIPELINE_STAGE_TRANSFER_BIT.

Note
Similar to vkCmdWriteTimestamp, if an implementation is unable to write a marker at any specific pipeline stage, it may instead do so at any logically later stage.
Note
Implementations may only support a limited number of pipelined marker write operations in flight at a given time, thus excessive number of marker write operations may degrade command execution performance.
Valid Usage
dstOffset must be less than or equal to the size of dstBuffer minus 4.
dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag
If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
dstOffset must be a multiple of 4
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pipelineStage must be a valid VkPipelineStageFlagBits value
dstBuffer must be a valid VkBuffer handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations
Both of commandBuffer, and dstBuffer must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Transfer
Graphics
Compute
Transfer
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize, VkPipelineStageFlagBits

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdWriteBufferMarkerAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCmdWriteTimestamp(3)
Name
vkCmdWriteTimestamp - Write a device timestamp into a query object

C Specification
To request a timestamp, call:

void vkCmdWriteTimestamp(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    VkQueryPool                                 queryPool,
    uint32_t                                    query);
Parameters
commandBuffer is the command buffer into which the command will be recorded.
pipelineStage is one of the VkPipelineStageFlagBits, specifying a stage of the pipeline.
queryPool is the query pool that will manage the timestamp.
query is the query within the query pool that will contain the timestamp.
Description
vkCmdWriteTimestamp latches the value of the timer when all previous commands have completed executing as far as the specified pipeline stage, and writes the timestamp value to memory. When the timestamp value is written, the availability status of the query is set to available.

Note
If an implementation is unable to detect completion and latch the timer at any specific stage of the pipeline, it may instead do so at any logically later stage.
vkCmdCopyQueryPoolResults can then be called to copy the timestamp value from the query pool into buffer memory, with ordering and synchronization behavior equivalent to how other queries operate. Timestamp values can also be retrieved from the query pool using vkGetQueryPoolResults. As with other queries, the query must be reset using vkCmdResetQueryPool before requesting the timestamp value be written to it.

While vkCmdWriteTimestamp can be called inside or outside of a render pass instance, vkCmdCopyQueryPoolResults must only be called outside of a render pass instance.

Timestamps may only be meaningfully compared if they are written by commands submitted to the same queue.

Note
An example of such a comparison is determining the execution time of a sequence of commands.
If vkCmdWriteTimestamp is called while executing a render pass instance that has multiview enabled, the timestamp uses N consecutive query indices in the query pool (starting at query) where N is the number of bits set in the view mask of the subpass the command is executed in. The resulting query values are determined by an implementation-dependent choice of one of the following behaviors:

The first query is a timestamp value and (if more than one bit is set in the view mask) zero is written to the remaining queries. If two timestamps are written in the same subpass, the sum of the execution time of all views between those commands is the difference between the first query written by each command.
All N queries are timestamp values. If two timestamps are written in the same subpass, the sum of the execution time of all views between those commands is the sum of the difference between corresponding queries written by each command. The difference between corresponding queries may be the execution time of a single view.
In either case, the application can sum the differences between all N queries to determine the total execution time.

Valid Usage
queryPool must have been created with a queryType of VK_QUERY_TYPE_TIMESTAMP
The query identified by queryPool and query must be unavailable
The command pool’s queue family must support a non-zero timestampValidBits
All queries used by the command must be unavailable
If vkCmdWriteTimestamp is called within a render pass instance, the sum of query and the number of bits set in the current subpass’s view mask must be less than or equal to the number of queries in queryPool
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
pipelineStage must be a valid VkPipelineStageFlagBits value
queryPool must be a valid VkQueryPool handle
commandBuffer must be in the recording state
The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations
Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
Primary
Secondary
Both
Transfer
Graphics
Compute
Transfer
See Also
VkCommandBuffer, VkPipelineStageFlagBits, VkQueryPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCmdWriteTimestamp

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCompileDeferredNV(3)
Name
vkCompileDeferredNV - Deferred compilation of shaders

C Specification
To compile a deferred shader in a pipeline call:

VkResult vkCompileDeferredNV(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    uint32_t                                    shader);
Parameters
device is the logical device that contains the ray tracing pipeline.
pipeline is the ray tracing pipeline object that contains the shaders.
shader is the index of the shader to compile.
Description
Valid Usage
pipeline must have been created with VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV
shader must not have been called as a deferred compile before
Valid Usage (Implicit)
device must be a valid VkDevice handle
pipeline must be a valid VkPipeline handle
pipeline must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkPipeline

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCompileDeferredNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateAccelerationStructureNV(3)
Name
vkCreateAccelerationStructureNV - Create a new acceleration structure object

C Specification
To create acceleration structures, call:

VkResult vkCreateAccelerationStructureNV(
    VkDevice                                    device,
    const VkAccelerationStructureCreateInfoNV*  pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkAccelerationStructureNV*                  pAccelerationStructure);
Parameters
device is the logical device that creates the buffer object.
pCreateInfo is a pointer to an instance of the VkAccelerationStructureCreateInfoNV structure containing parameters affecting creation of the acceleration structure.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pAccelerationStructure points to a VkAccelerationStructureNV handle in which the resulting acceleration structure object is returned.
Description
Similar to other objects in Vulkan, the acceleration structure creation merely creates an object with a specific “shape” as specified by the information in VkAccelerationStructureInfoNV and compactedSize in pCreateInfo. Populating the data in the object after allocating and binding memory is done with vkCmdBuildAccelerationStructureNV and vkCmdCopyAccelerationStructureNV.

Acceleration structure creation uses the count and type information from the geometries, but does not use the data references in the structures.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkAccelerationStructureCreateInfoNV structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pAccelerationStructure must be a valid pointer to a VkAccelerationStructureNV handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
See Also
VkAccelerationStructureCreateInfoNV, VkAccelerationStructureNV, VkAllocationCallbacks, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateAccelerationStructureNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateAndroidSurfaceKHR(3)
Name
vkCreateAndroidSurfaceKHR - Create a VkSurfaceKHR object for an Android native window

C Specification
To create a VkSurfaceKHR object for an Android native window, call:

VkResult vkCreateAndroidSurfaceKHR(
    VkInstance                                  instance,
    const VkAndroidSurfaceCreateInfoKHR*        pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
Parameters
instance is the instance to associate the surface with.
pCreateInfo is a pointer to an instance of the VkAndroidSurfaceCreateInfoKHR structure containing parameters affecting the creation of the surface object.
pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).
pSurface points to a VkSurfaceKHR handle in which the created surface object is returned.
Description
During the lifetime of a surface created using a particular ANativeWindow handle any attempts to create another surface for the same ANativeWindow and any attempts to connect to the same ANativeWindow through other platform mechanisms will fail.

Note
In particular, only one VkSurfaceKHR can exist at a time for a given window. Similarly, a native window cannot be used by both a VkSurfaceKHR and EGLSurface simultaneously.
If successful, vkCreateAndroidSurfaceKHR increments the ANativeWindow’s reference count, and vkDestroySurfaceKHR will decrement it.

On Android, when a swapchain’s imageExtent does not match the surface’s currentExtent, the presentable images will be scaled to the surface’s dimensions during presentation. minImageExtent is (1,1), and maxImageExtent is the maximum image size supported by the consumer. For the system compositor, currentExtent is the window size (i.e. the consumer’s preferred size).

Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkAndroidSurfaceCreateInfoKHR structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSurface must be a valid pointer to a VkSurfaceKHR handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
See Also
VkAllocationCallbacks, VkAndroidSurfaceCreateInfoKHR, VkInstance, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateAndroidSurfaceKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateBuffer(3)
Name
vkCreateBuffer - Create a new buffer object

C Specification
To create buffers, call:

VkResult vkCreateBuffer(
    VkDevice                                    device,
    const VkBufferCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkBuffer*                                   pBuffer);
Parameters
device is the logical device that creates the buffer object.
pCreateInfo is a pointer to an instance of the VkBufferCreateInfo structure containing parameters affecting creation of the buffer.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pBuffer points to a VkBuffer handle in which the resulting buffer object is returned.
Description
Valid Usage
If the flags member of pCreateInfo includes VK_BUFFER_CREATE_SPARSE_BINDING_BIT, creating this VkBuffer must not cause the total required sparse memory for all currently valid sparse resources on the device to exceed VkPhysicalDeviceLimits::sparseAddressSpaceSize
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkBufferCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pBuffer must be a valid pointer to a VkBuffer handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_INVALID_DEVICE_ADDRESS_EXT
See Also
VkAllocationCallbacks, VkBuffer, VkBufferCreateInfo, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateBuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateBufferView(3)
Name
vkCreateBufferView - Create a new buffer view object

C Specification
To create a buffer view, call:

VkResult vkCreateBufferView(
    VkDevice                                    device,
    const VkBufferViewCreateInfo*               pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkBufferView*                               pView);
Parameters
device is the logical device that creates the buffer view.
pCreateInfo is a pointer to an instance of the VkBufferViewCreateInfo structure containing parameters to be used to create the buffer.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pView points to a VkBufferView handle in which the resulting buffer view object is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkBufferViewCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pView must be a valid pointer to a VkBufferView handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkBufferView, VkBufferViewCreateInfo, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateBufferView

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateCommandPool(3)
Name
vkCreateCommandPool - Create a new command pool object

C Specification
To create a command pool, call:

VkResult vkCreateCommandPool(
    VkDevice                                    device,
    const VkCommandPoolCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkCommandPool*                              pCommandPool);
Parameters
device is the logical device that creates the command pool.
pCreateInfo is a pointer to an instance of the VkCommandPoolCreateInfo structure specifying the state of the command pool object.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pCommandPool points to a VkCommandPool handle in which the created pool is returned.
Description
Valid Usage
pCreateInfo::queueFamilyIndex must be the index of a queue family available in the logical device device.
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkCommandPoolCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pCommandPool must be a valid pointer to a VkCommandPool handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkCommandPool, VkCommandPoolCreateInfo, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateCommandPool

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateComputePipelines(3)
Name
vkCreateComputePipelines - Creates a new compute pipeline object

C Specification
To create compute pipelines, call:

VkResult vkCreateComputePipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkComputePipelineCreateInfo*          pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);
Parameters
device is the logical device that creates the compute pipelines.
pipelineCache is either VK_NULL_HANDLE, indicating that pipeline caching is disabled; or the handle of a valid pipeline cache object, in which case use of that cache is enabled for the duration of the command.
createInfoCount is the length of the pCreateInfos and pPipelines arrays.
pCreateInfos is an array of VkComputePipelineCreateInfo structures.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pPipelines is a pointer to an array in which the resulting compute pipeline objects are returned.
editing-note
TODO (Jon) - Should we say something like “the i’th element of the pPipelines array is created based on the corresponding element of the pCreateInfos array”? Also for vkCreateGraphicsPipelines below.
Description
Valid Usage
If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element
If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set
Valid Usage (Implicit)
device must be a valid VkDevice handle
If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle
pCreateInfos must be a valid pointer to an array of createInfoCount valid VkComputePipelineCreateInfo structures
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles
createInfoCount must be greater than 0
If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_INVALID_SHADER_NV
See Also
VkAllocationCallbacks, VkComputePipelineCreateInfo, VkDevice, VkPipeline, VkPipelineCache

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateComputePipelines

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateDebugReportCallbackEXT(3)
Name
vkCreateDebugReportCallbackEXT - Create a debug report callback object

C Specification
Debug report callbacks give more detailed feedback on the application’s use of Vulkan when events of interest occur.

To register a debug report callback, an application uses vkCreateDebugReportCallbackEXT.

VkResult vkCreateDebugReportCallbackEXT(
    VkInstance                                  instance,
    const VkDebugReportCallbackCreateInfoEXT*   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDebugReportCallbackEXT*                   pCallback);
Parameters
instance the instance the callback will be logged on.
pCreateInfo points to a VkDebugReportCallbackCreateInfoEXT structure which defines the conditions under which this callback will be called.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pCallback is a pointer to record the VkDebugReportCallbackEXT object created.
Description
Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkDebugReportCallbackCreateInfoEXT structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pCallback must be a valid pointer to a VkDebugReportCallbackEXT handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
See Also
VkAllocationCallbacks, VkDebugReportCallbackCreateInfoEXT, VkDebugReportCallbackEXT, VkInstance

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateDebugReportCallbackEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateDebugUtilsMessengerEXT(3)
Name
vkCreateDebugUtilsMessengerEXT - Create a debug messenger object

C Specification
A debug messenger triggers a debug callback with a debug message when an event of interest occurs. To create a debug messenger which will trigger a debug callback, call:

VkResult vkCreateDebugUtilsMessengerEXT(
    VkInstance                                  instance,
    const VkDebugUtilsMessengerCreateInfoEXT*   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDebugUtilsMessengerEXT*                   pMessenger);
Parameters
instance the instance the messenger will be used with.
pCreateInfo points to a VkDebugUtilsMessengerCreateInfoEXT structure which contains the callback pointer as well as defines the conditions under which this messenger will trigger the callback.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pMessenger is a pointer to record the VkDebugUtilsMessengerEXT object created.
Description
Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkDebugUtilsMessengerCreateInfoEXT structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pMessenger must be a valid pointer to a VkDebugUtilsMessengerEXT handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
The application must ensure that vkCreateDebugUtilsMessengerEXT is not executed in parallel with any Vulkan command that is also called with instance or child of instance as the dispatchable argument.

See Also
VkAllocationCallbacks, VkDebugUtilsMessengerCreateInfoEXT, VkDebugUtilsMessengerEXT, VkInstance

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateDebugUtilsMessengerEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateDescriptorPool(3)
Name
vkCreateDescriptorPool - Creates a descriptor pool object

C Specification
To create a descriptor pool object, call:

VkResult vkCreateDescriptorPool(
    VkDevice                                    device,
    const VkDescriptorPoolCreateInfo*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorPool*                           pDescriptorPool);
Parameters
device is the logical device that creates the descriptor pool.
pCreateInfo is a pointer to an instance of the VkDescriptorPoolCreateInfo structure specifying the state of the descriptor pool object.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pDescriptorPool points to a VkDescriptorPool handle in which the resulting descriptor pool object is returned.
Description
pAllocator controls host memory allocation as described in the Memory Allocation chapter.

The created descriptor pool is returned in pDescriptorPool.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkDescriptorPoolCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pDescriptorPool must be a valid pointer to a VkDescriptorPool handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_FRAGMENTATION_EXT
See Also
VkAllocationCallbacks, VkDescriptorPool, VkDescriptorPoolCreateInfo, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateDescriptorPool

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateDescriptorSetLayout(3)
Name
vkCreateDescriptorSetLayout - Create a new descriptor set layout

C Specification
To create descriptor set layout objects, call:

VkResult vkCreateDescriptorSetLayout(
    VkDevice                                    device,
    const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorSetLayout*                      pSetLayout);
Parameters
device is the logical device that creates the descriptor set layout.
pCreateInfo is a pointer to an instance of the VkDescriptorSetLayoutCreateInfo structure specifying the state of the descriptor set layout object.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pSetLayout points to a VkDescriptorSetLayout handle in which the resulting descriptor set layout object is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkDescriptorSetLayoutCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSetLayout must be a valid pointer to a VkDescriptorSetLayout handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDescriptorSetLayout, VkDescriptorSetLayoutCreateInfo, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateDescriptorSetLayout

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateDescriptorUpdateTemplate(3)
Name
vkCreateDescriptorUpdateTemplate - Create a new descriptor update template

C Specification
Updating a large VkDescriptorSet array can be an expensive operation since an application must specify one VkWriteDescriptorSet structure for each descriptor or descriptor array to update, each of which re-specifies the same state when updating the same descriptor in multiple descriptor sets. For cases when an application wishes to update the same set of descriptors in multiple descriptor sets allocated using the same VkDescriptorSetLayout, vkUpdateDescriptorSetWithTemplate can be used as a replacement for vkUpdateDescriptorSets.

VkDescriptorUpdateTemplate allows implementations to convert a set of descriptor update operations on a single descriptor set to an internal format that, in conjunction with vkUpdateDescriptorSetWithTemplate or vkCmdPushDescriptorSetWithTemplateKHR , can be more efficient compared to calling vkUpdateDescriptorSets or vkCmdPushDescriptorSetKHR . The descriptors themselves are not specified in the VkDescriptorUpdateTemplate, rather, offsets into an application provided pointer to host memory are specified, which are combined with a pointer passed to vkUpdateDescriptorSetWithTemplate or vkCmdPushDescriptorSetWithTemplateKHR . This allows large batches of updates to be executed without having to convert application data structures into a strictly-defined Vulkan data structure.

To create a descriptor update template, call:

VkResult vkCreateDescriptorUpdateTemplate(
    VkDevice                                    device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorUpdateTemplate*                 pDescriptorUpdateTemplate);
or the equivalent command

VkResult vkCreateDescriptorUpdateTemplateKHR(
    VkDevice                                    device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorUpdateTemplate*                 pDescriptorUpdateTemplate);
Parameters
device is the logical device that creates the descriptor update template.
pCreateInfo is a pointer to an instance of the VkDescriptorUpdateTemplateCreateInfo structure specifying the set of descriptors to update with a single call to vkCmdPushDescriptorSetWithTemplateKHR or vkUpdateDescriptorSetWithTemplate.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pDescriptorUpdateTemplate points to a VkDescriptorUpdateTemplate handle in which the resulting descriptor update template object is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkDescriptorUpdateTemplateCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pDescriptorUpdateTemplate must be a valid pointer to a VkDescriptorUpdateTemplate handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDescriptorUpdateTemplate, VkDescriptorUpdateTemplateCreateInfo, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateDescriptorUpdateTemplate

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateDevice(3)
Name
vkCreateDevice - Create a new device instance

C Specification
A logical device is created as a connection to a physical device. To create a logical device, call:

VkResult vkCreateDevice(
    VkPhysicalDevice                            physicalDevice,
    const VkDeviceCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice);
Parameters
physicalDevice must be one of the device handles returned from a call to vkEnumeratePhysicalDevices (see Physical Device Enumeration).
pCreateInfo is a pointer to a VkDeviceCreateInfo structure containing information about how to create the device.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pDevice points to a handle in which the created VkDevice is returned.
Description
vkCreateDevice verifies that extensions and features requested in the ppEnabledExtensionNames and pEnabledFeatures members of pCreateInfo, respectively, are supported by the implementation. If any requested extension is not supported, vkCreateDevice must return VK_ERROR_EXTENSION_NOT_PRESENT. If any requested feature is not supported, vkCreateDevice must return VK_ERROR_FEATURE_NOT_PRESENT. Support for extensions can be checked before creating a device by querying vkEnumerateDeviceExtensionProperties. Support for features can similarly be checked by querying vkGetPhysicalDeviceFeatures.

After verifying and enabling the extensions the VkDevice object is created and returned to the application. If a requested extension is only supported by a layer, both the layer and the extension need to be specified at vkCreateInstance time for the creation to succeed.

Multiple logical devices can be created from the same physical device. Logical device creation may fail due to lack of device-specific resources (in addition to the other errors). If that occurs, vkCreateDevice will return VK_ERROR_TOO_MANY_OBJECTS.

Valid Usage
All required extensions for each extension in the VkDeviceCreateInfo::ppEnabledExtensionNames list must also be present in that list.
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pCreateInfo must be a valid pointer to a valid VkDeviceCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pDevice must be a valid pointer to a VkDevice handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_INITIALIZATION_FAILED
VK_ERROR_EXTENSION_NOT_PRESENT
VK_ERROR_FEATURE_NOT_PRESENT
VK_ERROR_TOO_MANY_OBJECTS
VK_ERROR_DEVICE_LOST
See Also
VkAllocationCallbacks, VkDevice, VkDeviceCreateInfo, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateDevice

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateDisplayModeKHR(3)
Name
vkCreateDisplayModeKHR - Create a display mode

C Specification
Additional modes may also be created by calling:

VkResult vkCreateDisplayModeKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    const VkDisplayModeCreateInfoKHR*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDisplayModeKHR*                           pMode);
Parameters
physicalDevice is the physical device associated with display.
display is the display to create an additional mode for.
pCreateInfo is a VkDisplayModeCreateInfoKHR structure describing the new mode to create.
pAllocator is the allocator used for host memory allocated for the display mode object when there is no more specific allocator available (see Memory Allocation).
pMode returns the handle of the mode created.
Description
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
display must be a valid VkDisplayKHR handle
pCreateInfo must be a valid pointer to a valid VkDisplayModeCreateInfoKHR structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pMode must be a valid pointer to a VkDisplayModeKHR handle
Host Synchronization
Host access to display must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_INITIALIZATION_FAILED
See Also
VkAllocationCallbacks, VkDisplayKHR, VkDisplayModeCreateInfoKHR, VkDisplayModeKHR, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateDisplayModeKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateDisplayPlaneSurfaceKHR(3)
Name
vkCreateDisplayPlaneSurfaceKHR - Create a VkSurfaceKHR structure representing a display plane and mode

C Specification
A complete display configuration includes a mode, one or more display planes and any parameters describing their behavior, and parameters describing some aspects of the images associated with those planes. Display surfaces describe the configuration of a single plane within a complete display configuration. To create a VkSurfaceKHR structure for a display surface, call:

VkResult vkCreateDisplayPlaneSurfaceKHR(
    VkInstance                                  instance,
    const VkDisplaySurfaceCreateInfoKHR*        pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
Parameters
instance is the instance corresponding to the physical device the targeted display is on.
pCreateInfo is a pointer to an instance of the VkDisplaySurfaceCreateInfoKHR structure specifying which mode, plane, and other parameters to use, as described below.
pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).
pSurface points to a VkSurfaceKHR handle in which the created surface is returned.
Description
Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkDisplaySurfaceCreateInfoKHR structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSurface must be a valid pointer to a VkSurfaceKHR handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDisplaySurfaceCreateInfoKHR, VkInstance, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateDisplayPlaneSurfaceKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateEvent(3)
Name
vkCreateEvent - Create a new event object

C Specification
To create an event, call:

VkResult vkCreateEvent(
    VkDevice                                    device,
    const VkEventCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkEvent*                                    pEvent);
Parameters
device is the logical device that creates the event.
pCreateInfo is a pointer to an instance of the VkEventCreateInfo structure which contains information about how the event is to be created.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pEvent points to a handle in which the resulting event object is returned.
Description
When created, the event object is in the unsignaled state.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkEventCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pEvent must be a valid pointer to a VkEvent handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkEvent, VkEventCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateEvent

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateFence(3)
Name
vkCreateFence - Create a new fence object

C Specification
To create a fence, call:

VkResult vkCreateFence(
    VkDevice                                    device,
    const VkFenceCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence);
Parameters
device is the logical device that creates the fence.
pCreateInfo is a pointer to an instance of the VkFenceCreateInfo structure which contains information about how the fence is to be created.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pFence points to a handle in which the resulting fence object is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkFenceCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pFence must be a valid pointer to a VkFence handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkFence, VkFenceCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateFence

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateFramebuffer(3)
Name
vkCreateFramebuffer - Create a new framebuffer object

C Specification
To create a framebuffer, call:

VkResult vkCreateFramebuffer(
    VkDevice                                    device,
    const VkFramebufferCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFramebuffer*                              pFramebuffer);
Parameters
device is the logical device that creates the framebuffer.
pCreateInfo points to a VkFramebufferCreateInfo structure which describes additional information about framebuffer creation.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pFramebuffer points to a VkFramebuffer handle in which the resulting framebuffer object is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkFramebufferCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pFramebuffer must be a valid pointer to a VkFramebuffer handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkFramebuffer, VkFramebufferCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateFramebuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateGraphicsPipelines(3)
Name
vkCreateGraphicsPipelines - Create graphics pipelines

C Specification
To create graphics pipelines, call:

VkResult vkCreateGraphicsPipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkGraphicsPipelineCreateInfo*         pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);
Parameters
device is the logical device that creates the graphics pipelines.
pipelineCache is either VK_NULL_HANDLE, indicating that pipeline caching is disabled; or the handle of a valid pipeline cache object, in which case use of that cache is enabled for the duration of the command.
createInfoCount is the length of the pCreateInfos and pPipelines arrays.
pCreateInfos is an array of VkGraphicsPipelineCreateInfo structures.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pPipelines is a pointer to an array in which the resulting graphics pipeline objects are returned.
Description
The VkGraphicsPipelineCreateInfo structure includes an array of shader create info structures containing all the desired active shader stages, as well as creation info to define all relevant fixed-function stages, and a pipeline layout.

Valid Usage
If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element
If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set
Valid Usage (Implicit)
device must be a valid VkDevice handle
If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle
pCreateInfos must be a valid pointer to an array of createInfoCount valid VkGraphicsPipelineCreateInfo structures
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles
createInfoCount must be greater than 0
If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_INVALID_SHADER_NV
See Also
VkAllocationCallbacks, VkDevice, VkGraphicsPipelineCreateInfo, VkPipeline, VkPipelineCache

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateGraphicsPipelines

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateIOSSurfaceMVK(3)
Name
vkCreateIOSSurfaceMVK - Create a VkSurfaceKHR object for an iOS UIView

C Specification
To create a VkSurfaceKHR object for an iOS UIView, call:

VkResult vkCreateIOSSurfaceMVK(
    VkInstance                                  instance,
    const VkIOSSurfaceCreateInfoMVK*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
Parameters
instance is the instance with which to associate the surface.
pCreateInfo is a pointer to an instance of the VkIOSSurfaceCreateInfoMVK structure containing parameters affecting the creation of the surface object.
pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).
pSurface points to a VkSurfaceKHR handle in which the created surface object is returned.
Description
Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkIOSSurfaceCreateInfoMVK structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSurface must be a valid pointer to a VkSurfaceKHR handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
See Also
VkAllocationCallbacks, VkIOSSurfaceCreateInfoMVK, VkInstance, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateIOSSurfaceMVK

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateImage(3)
Name
vkCreateImage - Create a new image object

C Specification
To create images, call:

VkResult vkCreateImage(
    VkDevice                                    device,
    const VkImageCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkImage*                                    pImage);
Parameters
device is the logical device that creates the image.
pCreateInfo is a pointer to an instance of the VkImageCreateInfo structure containing parameters to be used to create the image.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pImage points to a VkImage handle in which the resulting image object is returned.
Description
Valid Usage
If the flags member of pCreateInfo includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT, creating this VkImage must not cause the total required sparse memory for all currently valid sparse resources on the device to exceed VkPhysicalDeviceLimits::sparseAddressSpaceSize
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkImageCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pImage must be a valid pointer to a VkImage handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkImage, VkImageCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateImage

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateImagePipeSurfaceFUCHSIA(3)
Name
vkCreateImagePipeSurfaceFUCHSIA - Create a VkSurfaceKHR object for a Fuchsia ImagePipe

C Specification
To create a VkSurfaceKHR object for a Fuchsia ImagePipe, call:

VkResult vkCreateImagePipeSurfaceFUCHSIA(
    VkInstance                                  instance,
    const VkImagePipeSurfaceCreateInfoFUCHSIA*  pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
Parameters
instance is the instance to associate with the surface.
pCreateInfo is a pointer to an instance of the VkImagePipeSurfaceCreateInfoFUCHSIA structure containing parameters affecting the creation of the surface object.
pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).
pSurface points to a VkSurfaceKHR handle in which the created surface object is returned.
Description
Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkImagePipeSurfaceCreateInfoFUCHSIA structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSurface must be a valid pointer to a VkSurfaceKHR handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkImagePipeSurfaceCreateInfoFUCHSIA, VkInstance, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateImagePipeSurfaceFUCHSIA

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateImageView(3)
Name
vkCreateImageView - Create an image view from an existing image

C Specification
To create an image view, call:

VkResult vkCreateImageView(
    VkDevice                                    device,
    const VkImageViewCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkImageView*                                pView);
Parameters
device is the logical device that creates the image view.
pCreateInfo is a pointer to an instance of the VkImageViewCreateInfo structure containing parameters to be used to create the image view.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pView points to a VkImageView handle in which the resulting image view object is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkImageViewCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pView must be a valid pointer to a VkImageView handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkImageView, VkImageViewCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateImageView

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateIndirectCommandsLayoutNVX(3)
Name
vkCreateIndirectCommandsLayoutNVX - Create an indirect command layout object

C Specification
Indirect command layouts are created by:

VkResult vkCreateIndirectCommandsLayoutNVX(
    VkDevice                                    device,
    const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkIndirectCommandsLayoutNVX*                pIndirectCommandsLayout);
Parameters
device is the logical device that creates the indirect command layout.
pCreateInfo is a pointer to an instance of the VkIndirectCommandsLayoutCreateInfoNVX structure containing parameters affecting creation of the indirect command layout.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pIndirectCommandsLayout points to a VkIndirectCommandsLayoutNVX handle in which the resulting indirect command layout is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkIndirectCommandsLayoutCreateInfoNVX structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pIndirectCommandsLayout must be a valid pointer to a VkIndirectCommandsLayoutNVX handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkIndirectCommandsLayoutCreateInfoNVX, VkIndirectCommandsLayoutNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateIndirectCommandsLayoutNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateInstance(3)
Name
vkCreateInstance - Create a new Vulkan instance

C Specification
To create an instance object, call:

VkResult vkCreateInstance(
    const VkInstanceCreateInfo*                 pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance);
Parameters
pCreateInfo points to an instance of VkInstanceCreateInfo controlling creation of the instance.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pInstance points a VkInstance handle in which the resulting instance is returned.
Description
vkCreateInstance verifies that the requested layers exist. If not, vkCreateInstance will return VK_ERROR_LAYER_NOT_PRESENT. Next vkCreateInstance verifies that the requested extensions are supported (e.g. in the implementation or in any enabled instance layer) and if any requested extension is not supported, vkCreateInstance must return VK_ERROR_EXTENSION_NOT_PRESENT. After verifying and enabling the instance layers and extensions the VkInstance object is created and returned to the application. If a requested extension is only supported by a layer, both the layer and the extension need to be specified at vkCreateInstance time for the creation to succeed.

Valid Usage
All required extensions for each extension in the VkInstanceCreateInfo::ppEnabledExtensionNames list must also be present in that list.
Valid Usage (Implicit)
pCreateInfo must be a valid pointer to a valid VkInstanceCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pInstance must be a valid pointer to a VkInstance handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_INITIALIZATION_FAILED
VK_ERROR_LAYER_NOT_PRESENT
VK_ERROR_EXTENSION_NOT_PRESENT
VK_ERROR_INCOMPATIBLE_DRIVER
See Also
VkAllocationCallbacks, VkInstance, VkInstanceCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateInstance

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateMacOSSurfaceMVK(3)
Name
vkCreateMacOSSurfaceMVK - Create a VkSurfaceKHR object for a macOS NSView

C Specification
To create a VkSurfaceKHR object for a macOS NSView, call:

VkResult vkCreateMacOSSurfaceMVK(
    VkInstance                                  instance,
    const VkMacOSSurfaceCreateInfoMVK*          pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
Parameters
instance is the instance with which to associate the surface.
pCreateInfo is a pointer to an instance of the VkMacOSSurfaceCreateInfoMVK structure containing parameters affecting the creation of the surface object.
pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).
pSurface points to a VkSurfaceKHR handle in which the created surface object is returned.
Description
Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkMacOSSurfaceCreateInfoMVK structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSurface must be a valid pointer to a VkSurfaceKHR handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
See Also
VkAllocationCallbacks, VkInstance, VkMacOSSurfaceCreateInfoMVK, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateMacOSSurfaceMVK

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateMetalSurfaceEXT(3)
Name
vkCreateMetalSurfaceEXT - Create a VkSurfaceKHR object for CAMetalLayer

C Specification
To create a VkSurfaceKHR object for a CAMetalLayer, call:

VkResult vkCreateMetalSurfaceEXT(
    VkInstance                                  instance,
    const VkMetalSurfaceCreateInfoEXT*          pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
Parameters
instance is the instance with which to associate the surface.
pCreateInfo is a pointer to an instance of the VkMetalSurfaceCreateInfoEXT structure containing the parameters affecting the creation of the surface object.
pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).
pSurface points to a VkSurfaceKHR handle in which the created surface object is returned.
Description
Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkMetalSurfaceCreateInfoEXT structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSurface must be a valid pointer to a VkSurfaceKHR handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
See Also
VkAllocationCallbacks, VkInstance, VkMetalSurfaceCreateInfoEXT, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateMetalSurfaceEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateObjectTableNVX(3)
Name
vkCreateObjectTableNVX - Create an object table

C Specification
To create object tables, call:

VkResult vkCreateObjectTableNVX(
    VkDevice                                    device,
    const VkObjectTableCreateInfoNVX*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkObjectTableNVX*                           pObjectTable);
Parameters
device is the logical device that creates the object table.
pCreateInfo is a pointer to an instance of the VkObjectTableCreateInfoNVX structure containing parameters affecting creation of the table.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pObjectTable points to a VkObjectTableNVX handle in which the resulting object table is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkObjectTableCreateInfoNVX structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pObjectTable must be a valid pointer to a VkObjectTableNVX handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkObjectTableCreateInfoNVX, VkObjectTableNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateObjectTableNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreatePipelineCache(3)
Name
vkCreatePipelineCache - Creates a new pipeline cache

C Specification
To create pipeline cache objects, call:

VkResult vkCreatePipelineCache(
    VkDevice                                    device,
    const VkPipelineCacheCreateInfo*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPipelineCache*                            pPipelineCache);
Parameters
device is the logical device that creates the pipeline cache object.
pCreateInfo is a pointer to a VkPipelineCacheCreateInfo structure that contains the initial parameters for the pipeline cache object.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pPipelineCache is a pointer to a VkPipelineCache handle in which the resulting pipeline cache object is returned.
Description
Note
Applications can track and manage the total host memory size of a pipeline cache object using the pAllocator. Applications can limit the amount of data retrieved from a pipeline cache object in vkGetPipelineCacheData. Implementations should not internally limit the total number of entries added to a pipeline cache object or the total host memory consumed.
Once created, a pipeline cache can be passed to the vkCreateGraphicsPipelines and vkCreateComputePipelines commands. If the pipeline cache passed into these commands is not VK_NULL_HANDLE, the implementation will query it for possible reuse opportunities and update it with new content. The use of the pipeline cache object in these commands is internally synchronized, and the same pipeline cache object can be used in multiple threads simultaneously.

Note
Implementations should make every effort to limit any critical sections to the actual accesses to the cache, which is expected to be significantly shorter than the duration of the vkCreateGraphicsPipelines and vkCreateComputePipelines commands.
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkPipelineCacheCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pPipelineCache must be a valid pointer to a VkPipelineCache handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkPipelineCache, VkPipelineCacheCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreatePipelineCache

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreatePipelineLayout(3)
Name
vkCreatePipelineLayout - Creates a new pipeline layout object

C Specification
To create a pipeline layout, call:

VkResult vkCreatePipelineLayout(
    VkDevice                                    device,
    const VkPipelineLayoutCreateInfo*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPipelineLayout*                           pPipelineLayout);
Parameters
device is the logical device that creates the pipeline layout.
pCreateInfo is a pointer to an instance of the VkPipelineLayoutCreateInfo structure specifying the state of the pipeline layout object.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pPipelineLayout points to a VkPipelineLayout handle in which the resulting pipeline layout object is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkPipelineLayoutCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pPipelineLayout must be a valid pointer to a VkPipelineLayout handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkPipelineLayout, VkPipelineLayoutCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreatePipelineLayout

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateQueryPool(3)
Name
vkCreateQueryPool - Create a new query pool object

C Specification
To create a query pool, call:

VkResult vkCreateQueryPool(
    VkDevice                                    device,
    const VkQueryPoolCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkQueryPool*                                pQueryPool);
Parameters
device is the logical device that creates the query pool.
pCreateInfo is a pointer to an instance of the VkQueryPoolCreateInfo structure containing the number and type of queries to be managed by the pool.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pQueryPool is a pointer to a VkQueryPool handle in which the resulting query pool object is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkQueryPoolCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pQueryPool must be a valid pointer to a VkQueryPool handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkQueryPool, VkQueryPoolCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateQueryPool

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateRayTracingPipelinesNV(3)
Name
vkCreateRayTracingPipelinesNV - Creates a new ray tracing pipeline object

C Specification
To create ray tracing pipelines, call:

VkResult vkCreateRayTracingPipelinesNV(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkRayTracingPipelineCreateInfoNV*     pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines);
Parameters
device is the logical device that creates the ray tracing pipelines.
pipelineCache is either VK_NULL_HANDLE, indicating that pipeline caching is disabled, or the handle of a valid pipeline cache object, in which case use of that cache is enabled for the duration of the command.
createInfoCount is the length of the pCreateInfos and pPipelines arrays.
pCreateInfos is an array of VkRayTracingPipelineCreateInfoNV structures.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pPipelines is a pointer to an array in which the resulting ray tracing pipeline objects are returned.
Description
Valid Usage
If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element
If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set
Valid Usage (Implicit)
device must be a valid VkDevice handle
If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle
pCreateInfos must be a valid pointer to an array of createInfoCount valid VkRayTracingPipelineCreateInfoNV structures
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles
createInfoCount must be greater than 0
If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_INVALID_SHADER_NV
See Also
VkAllocationCallbacks, VkDevice, VkPipeline, VkPipelineCache, VkRayTracingPipelineCreateInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateRayTracingPipelinesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateRenderPass(3)
Name
vkCreateRenderPass - Create a new render pass object

C Specification
To create a render pass, call:

VkResult vkCreateRenderPass(
    VkDevice                                    device,
    const VkRenderPassCreateInfo*               pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass);
Parameters
device is the logical device that creates the render pass.
pCreateInfo is a pointer to an instance of the VkRenderPassCreateInfo structure that describes the parameters of the render pass.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pRenderPass points to a VkRenderPass handle in which the resulting render pass object is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkRenderPassCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pRenderPass must be a valid pointer to a VkRenderPass handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkRenderPass, VkRenderPassCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateRenderPass

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateRenderPass2KHR(3)
Name
vkCreateRenderPass2KHR - Create a new render pass object

C Specification
To create a render pass, call:

VkResult vkCreateRenderPass2KHR(
    VkDevice                                    device,
    const VkRenderPassCreateInfo2KHR*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass);
Parameters
device is the logical device that creates the render pass.
pCreateInfo is a pointer to an instance of the VkRenderPassCreateInfo2KHR structure that describes the parameters of the render pass.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pRenderPass points to a VkRenderPass handle in which the resulting render pass object is returned.
Description
This command is functionally identical to vkCreateRenderPass, but includes extensible sub-structures that include sType and pNext parameters, allowing them to be more easily extended.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkRenderPassCreateInfo2KHR structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pRenderPass must be a valid pointer to a VkRenderPass handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkRenderPass, VkRenderPassCreateInfo2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateRenderPass2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateSampler(3)
Name
vkCreateSampler - Create a new sampler object

C Specification
To create a sampler object, call:

VkResult vkCreateSampler(
    VkDevice                                    device,
    const VkSamplerCreateInfo*                  pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSampler*                                  pSampler);
Parameters
device is the logical device that creates the sampler.
pCreateInfo is a pointer to an instance of the VkSamplerCreateInfo structure specifying the state of the sampler object.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pSampler points to a VkSampler handle in which the resulting sampler object is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkSamplerCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSampler must be a valid pointer to a VkSampler handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_TOO_MANY_OBJECTS
See Also
VkAllocationCallbacks, VkDevice, VkSampler, VkSamplerCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateSampler

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateSamplerYcbcrConversion(3)
Name
vkCreateSamplerYcbcrConversion - Create a new Ycbcr conversion

C Specification
To create a VkSamplerYcbcrConversion, call:

VkResult vkCreateSamplerYcbcrConversion(
    VkDevice                                    device,
    const VkSamplerYcbcrConversionCreateInfo*   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSamplerYcbcrConversion*                   pYcbcrConversion);
or the equivalent command

VkResult vkCreateSamplerYcbcrConversionKHR(
    VkDevice                                    device,
    const VkSamplerYcbcrConversionCreateInfo*   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSamplerYcbcrConversion*                   pYcbcrConversion);
Parameters
device is the logical device that creates the sampler Y’CBCR conversion.
pCreateInfo is a pointer to an instance of the VkSamplerYcbcrConversionCreateInfo specifying the requested sampler Y’CBCR conversion.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pYcbcrConversion points to a VkSamplerYcbcrConversion handle in which the resulting sampler Y’CBCR conversion is returned.
Description
The interpretation of the configured sampler Y’CBCR conversion is described in more detail in the description of sampler Y’CBCR conversion in the Image Operations chapter.

Valid Usage
The sampler Y’CBCR conversion feature must be enabled
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkSamplerYcbcrConversionCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pYcbcrConversion must be a valid pointer to a VkSamplerYcbcrConversion handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkSamplerYcbcrConversion, VkSamplerYcbcrConversionCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateSamplerYcbcrConversion

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateSemaphore(3)
Name
vkCreateSemaphore - Create a new queue semaphore object

C Specification
To create a semaphore, call:

VkResult vkCreateSemaphore(
    VkDevice                                    device,
    const VkSemaphoreCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSemaphore*                                pSemaphore);
Parameters
device is the logical device that creates the semaphore.
pCreateInfo is a pointer to an instance of the VkSemaphoreCreateInfo structure which contains information about how the semaphore is to be created.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pSemaphore points to a handle in which the resulting semaphore object is returned.
Description
When created, the semaphore is in the unsignaled state.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkSemaphoreCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSemaphore must be a valid pointer to a VkSemaphore handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkSemaphore, VkSemaphoreCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateSemaphore

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateShaderModule(3)
Name
vkCreateShaderModule - Creates a new shader module object

C Specification
To create a shader module, call:

VkResult vkCreateShaderModule(
    VkDevice                                    device,
    const VkShaderModuleCreateInfo*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkShaderModule*                             pShaderModule);
Parameters
device is the logical device that creates the shader module.
pCreateInfo is a pointer to an instance of the VkShaderModuleCreateInfo structure.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pShaderModule points to a VkShaderModule handle in which the resulting shader module object is returned.
Description
Once a shader module has been created, any entry points it contains can be used in pipeline shader stages as described in Compute Pipelines and Graphics Pipelines.

If the shader stage fails to compile VK_ERROR_INVALID_SHADER_NV will be generated and the compile log will be reported back to the application by html/vkspec.html#VK_EXT_debug_report if enabled.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkShaderModuleCreateInfo structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pShaderModule must be a valid pointer to a VkShaderModule handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_INVALID_SHADER_NV
See Also
VkAllocationCallbacks, VkDevice, VkShaderModule, VkShaderModuleCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateShaderModule

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateSharedSwapchainsKHR(3)
Name
vkCreateSharedSwapchainsKHR - Create multiple swapchains that share presentable images

C Specification
When the VK_KHR_display_swapchain extension is enabled, multiple swapchains that share presentable images are created by calling:

VkResult vkCreateSharedSwapchainsKHR(
    VkDevice                                    device,
    uint32_t                                    swapchainCount,
    const VkSwapchainCreateInfoKHR*             pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchains);
Parameters
device is the device to create the swapchains for.
swapchainCount is the number of swapchains to create.
pCreateInfos is a pointer to an array of VkSwapchainCreateInfoKHR structures specifying the parameters of the created swapchains.
pAllocator is the allocator used for host memory allocated for the swapchain objects when there is no more specific allocator available (see Memory Allocation).
pSwapchains is a pointer to an array of VkSwapchainKHR handles in which the created swapchain objects will be returned.
Description
vkCreateSharedSwapchainsKHR is similar to vkCreateSwapchainKHR, except that it takes an array of VkSwapchainCreateInfoKHR structures, and returns an array of swapchain objects.

The swapchain creation parameters that affect the properties and number of presentable images must match between all the swapchains. If the displays used by any of the swapchains do not use the same presentable image layout or are incompatible in a way that prevents sharing images, swapchain creation will fail with the result code VK_ERROR_INCOMPATIBLE_DISPLAY_KHR. If any error occurs, no swapchains will be created. Images presented to multiple swapchains must be re-acquired from all of them before transitioning away from VK_IMAGE_LAYOUT_PRESENT_SRC_KHR. After destroying one or more of the swapchains, the remaining swapchains and the presentable images can continue to be used.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfos must be a valid pointer to an array of swapchainCount valid VkSwapchainCreateInfoKHR structures
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSwapchains must be a valid pointer to an array of swapchainCount VkSwapchainKHR handles
swapchainCount must be greater than 0
Host Synchronization
Host access to pCreateInfos[].surface must be externally synchronized
Host access to pCreateInfos[].oldSwapchain must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_INCOMPATIBLE_DISPLAY_KHR
VK_ERROR_DEVICE_LOST
VK_ERROR_SURFACE_LOST_KHR
See Also
VkAllocationCallbacks, VkDevice, VkSwapchainCreateInfoKHR, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateSharedSwapchainsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateStreamDescriptorSurfaceGGP(3)
Name
vkCreateStreamDescriptorSurfaceGGP - Create a VkSurfaceKHR object for a Google Games Platform stream

C Specification
To create a VkSurfaceKHR object for a Google Games Platform stream descriptor, call:

VkResult vkCreateStreamDescriptorSurfaceGGP(
    VkInstance                                  instance,
    const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
Parameters
instance is the instance to associate with the surface.
pCreateInfo is a pointer to an instance of the VkStreamDescriptorSurfaceCreateInfoGGP structure containing parameters that affect the creation of the surface object.
pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).
pSurface points to a VkSurfaceKHR handle in which the created surface object is returned.
Description
Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkStreamDescriptorSurfaceCreateInfoGGP structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSurface must be a valid pointer to a VkSurfaceKHR handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
See Also
VkAllocationCallbacks, VkInstance, VkStreamDescriptorSurfaceCreateInfoGGP, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateStreamDescriptorSurfaceGGP

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateSwapchainKHR(3)
Name
vkCreateSwapchainKHR - Create a swapchain

C Specification
To create a swapchain, call:

VkResult vkCreateSwapchainKHR(
    VkDevice                                    device,
    const VkSwapchainCreateInfoKHR*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchain);
Parameters
device is the device to create the swapchain for.
pCreateInfo is a pointer to an instance of the VkSwapchainCreateInfoKHR structure specifying the parameters of the created swapchain.
pAllocator is the allocator used for host memory allocated for the swapchain object when there is no more specific allocator available (see Memory Allocation).
pSwapchain is a pointer to a VkSwapchainKHR handle in which the created swapchain object will be returned.
Description
If the oldSwapchain parameter of pCreateInfo is a valid swapchain, which has exclusive full-screen access, that access is released from oldSwapchain. If the command succeeds in this case, the newly created swapchain will automatically acquire exclusive full-screen access from oldSwapchain.

Note
This implicit transfer is intended to avoid exiting and entering full-screen exclusive mode, which may otherwise cause unwanted visual updates to the display.
In some cases, swapchain creation may fail if exclusive full-screen mode is requested for application control, but for some implementation-specific reason exclusive full-screen access is unavailable for the particular combination of parameters provided. If this occurs, VK_ERROR_INITIALIZATION_FAILED will be returned.

Note
In particular, it will fail if the imageExtent member of pCreateInfo does not match the extents of the monitor. Other reasons for failure may include the app not being set as high-dpi aware, or if the physical device and monitor are not compatible in this mode.
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkSwapchainCreateInfoKHR structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSwapchain must be a valid pointer to a VkSwapchainKHR handle
Host Synchronization
Host access to pCreateInfo.surface must be externally synchronized
Host access to pCreateInfo.oldSwapchain must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
VK_ERROR_SURFACE_LOST_KHR
VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
VK_ERROR_INITIALIZATION_FAILED
See Also
VkAllocationCallbacks, VkDevice, VkSwapchainCreateInfoKHR, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateSwapchainKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateValidationCacheEXT(3)
Name
vkCreateValidationCacheEXT - Creates a new validation cache

C Specification
To create validation cache objects, call:

VkResult vkCreateValidationCacheEXT(
    VkDevice                                    device,
    const VkValidationCacheCreateInfoEXT*       pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkValidationCacheEXT*                       pValidationCache);
Parameters
device is the logical device that creates the validation cache object.
pCreateInfo is a pointer to a VkValidationCacheCreateInfoEXT structure that contains the initial parameters for the validation cache object.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pValidationCache is a pointer to a VkValidationCacheEXT handle in which the resulting validation cache object is returned.
Description
Note
Applications can track and manage the total host memory size of a validation cache object using the pAllocator. Applications can limit the amount of data retrieved from a validation cache object in vkGetValidationCacheDataEXT. Implementations should not internally limit the total number of entries added to a validation cache object or the total host memory consumed.
Once created, a validation cache can be passed to the vkCreateShaderModule command as part of the VkShaderModuleCreateInfo pNext chain. If a VkShaderModuleValidationCacheCreateInfoEXT object is part of the VkShaderModuleCreateInfo::pNext chain, and its validationCache field is not VK_NULL_HANDLE, the implementation will query it for possible reuse opportunities and update it with new content. The use of the validation cache object in these commands is internally synchronized, and the same validation cache object can be used in multiple threads simultaneously.

Note
Implementations should make every effort to limit any critical sections to the actual accesses to the cache, which is expected to be significantly shorter than the duration of the vkCreateShaderModule command.
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkValidationCacheCreateInfoEXT structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pValidationCache must be a valid pointer to a VkValidationCacheEXT handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
See Also
VkAllocationCallbacks, VkDevice, VkValidationCacheCreateInfoEXT, VkValidationCacheEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateValidationCacheEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateViSurfaceNN(3)
Name
vkCreateViSurfaceNN - Create a VkSurfaceKHR object for a VI layer

C Specification
To create a VkSurfaceKHR object for an nn::vi::Layer, query the layer’s native handle using nn::vi::GetNativeWindow, and then call:

VkResult vkCreateViSurfaceNN(
    VkInstance                                  instance,
    const VkViSurfaceCreateInfoNN*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
Parameters
instance is the instance with which to associate the surface.
pCreateInfo is a pointer to an instance of the VkViSurfaceCreateInfoNN structure containing parameters affecting the creation of the surface object.
pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).
pSurface points to a VkSurfaceKHR handle in which the created surface object is returned.
Description
During the lifetime of a surface created using a particular nn::vi::NativeWindowHandle, applications must not attempt to create another surface for the same nn::vi::Layer or attempt to connect to the same nn::vi::Layer through other platform mechanisms.

If the native window is created with a specified size, currentExtent will reflect that size. In this case, applications should use the same size for the swapchain’s imageExtent. Otherwise, the currentExtent will have the special value (0xFFFFFFFF, 0xFFFFFFFF), indicating that applications are expected to choose an appropriate size for the swapchain’s imageExtent (e.g., by matching the result of a call to nn::vi::GetDisplayResolution).

Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkViSurfaceCreateInfoNN structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSurface must be a valid pointer to a VkSurfaceKHR handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_NATIVE_WINDOW_IN_USE_KHR
See Also
VkAllocationCallbacks, VkInstance, VkSurfaceKHR, VkViSurfaceCreateInfoNN

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateViSurfaceNN

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateWaylandSurfaceKHR(3)
Name
vkCreateWaylandSurfaceKHR - Create a VkSurfaceKHR object for a Wayland window

C Specification
To create a VkSurfaceKHR object for a Wayland surface, call:

VkResult vkCreateWaylandSurfaceKHR(
    VkInstance                                  instance,
    const VkWaylandSurfaceCreateInfoKHR*        pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
Parameters
instance is the instance to associate the surface with.
pCreateInfo is a pointer to an instance of the VkWaylandSurfaceCreateInfoKHR structure containing parameters affecting the creation of the surface object.
pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).
pSurface points to a VkSurfaceKHR handle in which the created surface object is returned.
Description
Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkWaylandSurfaceCreateInfoKHR structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSurface must be a valid pointer to a VkSurfaceKHR handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkInstance, VkSurfaceKHR, VkWaylandSurfaceCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateWaylandSurfaceKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateWin32SurfaceKHR(3)
Name
vkCreateWin32SurfaceKHR - Create a VkSurfaceKHR object for an Win32 native window

C Specification
To create a VkSurfaceKHR object for a Win32 window, call:

VkResult vkCreateWin32SurfaceKHR(
    VkInstance                                  instance,
    const VkWin32SurfaceCreateInfoKHR*          pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
Parameters
instance is the instance to associate the surface with.
pCreateInfo is a pointer to an instance of the VkWin32SurfaceCreateInfoKHR structure containing parameters affecting the creation of the surface object.
pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).
pSurface points to a VkSurfaceKHR handle in which the created surface object is returned.
Description
Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkWin32SurfaceCreateInfoKHR structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSurface must be a valid pointer to a VkSurfaceKHR handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkInstance, VkSurfaceKHR, VkWin32SurfaceCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateWin32SurfaceKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateXcbSurfaceKHR(3)
Name
vkCreateXcbSurfaceKHR - Create a VkSurfaceKHR object for a X11 window, using the XCB client-side library

C Specification
To create a VkSurfaceKHR object for an X11 window, using the XCB client-side library, call:

VkResult vkCreateXcbSurfaceKHR(
    VkInstance                                  instance,
    const VkXcbSurfaceCreateInfoKHR*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
Parameters
instance is the instance to associate the surface with.
pCreateInfo is a pointer to an instance of the VkXcbSurfaceCreateInfoKHR structure containing parameters affecting the creation of the surface object.
pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).
pSurface points to a VkSurfaceKHR handle in which the created surface object is returned.
Description
Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkXcbSurfaceCreateInfoKHR structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSurface must be a valid pointer to a VkSurfaceKHR handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkInstance, VkSurfaceKHR, VkXcbSurfaceCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateXcbSurfaceKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkCreateXlibSurfaceKHR(3)
Name
vkCreateXlibSurfaceKHR - Create a VkSurfaceKHR object for an X11 window, using the Xlib client-side library

C Specification
To create a VkSurfaceKHR object for an X11 window, using the Xlib client-side library, call:

VkResult vkCreateXlibSurfaceKHR(
    VkInstance                                  instance,
    const VkXlibSurfaceCreateInfoKHR*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface);
Parameters
instance is the instance to associate the surface with.
pCreateInfo is a pointer to an instance of the VkXlibSurfaceCreateInfoKHR structure containing the parameters affecting the creation of the surface object.
pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).
pSurface points to a VkSurfaceKHR handle in which the created surface object is returned.
Description
Valid Usage (Implicit)
instance must be a valid VkInstance handle
pCreateInfo must be a valid pointer to a valid VkXlibSurfaceCreateInfoKHR structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pSurface must be a valid pointer to a VkSurfaceKHR handle
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAllocationCallbacks, VkInstance, VkSurfaceKHR, VkXlibSurfaceCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateXlibSurfaceKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDebugMarkerSetObjectNameEXT(3)
Name
vkDebugMarkerSetObjectNameEXT - Give a user-friendly name to an object

C Specification
An object can be given a user-friendly name by calling:

VkResult vkDebugMarkerSetObjectNameEXT(
    VkDevice                                    device,
    const VkDebugMarkerObjectNameInfoEXT*       pNameInfo);
Parameters
device is the device that created the object.
pNameInfo is a pointer to an instance of the VkDebugMarkerObjectNameInfoEXT structure specifying the parameters of the name to set on the object.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pNameInfo must be a valid pointer to a valid VkDebugMarkerObjectNameInfoEXT structure
Host Synchronization
Host access to pNameInfo.object must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDebugMarkerObjectNameInfoEXT, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDebugMarkerSetObjectNameEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDebugMarkerSetObjectTagEXT(3)
Name
vkDebugMarkerSetObjectTagEXT - Attach arbitrary data to an object

C Specification
In addition to setting a name for an object, debugging and validation layers may have uses for additional binary data on a per-object basis that has no other place in the Vulkan API. For example, a VkShaderModule could have additional debugging data attached to it to aid in offline shader tracing. To attach data to an object, call:

VkResult vkDebugMarkerSetObjectTagEXT(
    VkDevice                                    device,
    const VkDebugMarkerObjectTagInfoEXT*        pTagInfo);
Parameters
device is the device that created the object.
pTagInfo is a pointer to an instance of the VkDebugMarkerObjectTagInfoEXT structure specifying the parameters of the tag to attach to the object.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pTagInfo must be a valid pointer to a valid VkDebugMarkerObjectTagInfoEXT structure
Host Synchronization
Host access to pTagInfo.object must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDebugMarkerObjectTagInfoEXT, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDebugMarkerSetObjectTagEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDebugReportMessageEXT(3)
Name
vkDebugReportMessageEXT - Inject a message into a debug stream

C Specification
To inject its own messages into the debug stream, call:

void vkDebugReportMessageEXT(
    VkInstance                                  instance,
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    const char*                                 pLayerPrefix,
    const char*                                 pMessage);
Parameters
instance is the debug stream’s VkInstance.
flags specifies the VkDebugReportFlagBitsEXT classification of this event/message.
objectType is a VkDebugReportObjectTypeEXT specifying the type of object being used or created at the time the event was triggered.
object this is the object where the issue was detected. object can be VK_NULL_HANDLE if there is no object associated with the event.
location is an application defined value.
messageCode is an application defined value.
pLayerPrefix is the abbreviation of the component making this event/message.
pMessage is a null-terminated string detailing the trigger conditions.
Description
The call will propagate through the layers and generate callback(s) as indicated by the message’s flags. The parameters are passed on to the callback in addition to the pUserData value that was defined at the time the callback was registered.

Valid Usage
object must be a Vulkan object or VK_NULL_HANDLE
If objectType is not VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT and object is not VK_NULL_HANDLE, object must be a Vulkan object of the corresponding type associated with objectType as defined in html/vkspec.html#debug-report-object-types.
Valid Usage (Implicit)
instance must be a valid VkInstance handle
flags must be a valid combination of VkDebugReportFlagBitsEXT values
flags must not be 0
objectType must be a valid VkDebugReportObjectTypeEXT value
pLayerPrefix must be a null-terminated UTF-8 string
pMessage must be a null-terminated UTF-8 string
See Also
VkDebugReportFlagsEXT, VkDebugReportObjectTypeEXT, VkInstance

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDebugReportMessageEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyAccelerationStructureNV(3)
Name
vkDestroyAccelerationStructureNV - Destroy an acceleration structure object

C Specification
To destroy an acceleration structure, call:

void vkDestroyAccelerationStructureNV(
    VkDevice                                    device,
    VkAccelerationStructureNV                   accelerationStructure,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the buffer.
accelerationStructure is the acceleration structure to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted commands that refer to accelerationStructure must have completed execution
If VkAllocationCallbacks were provided when accelerationStructure was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when accelerationStructure was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
accelerationStructure must be a valid VkAccelerationStructureNV handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
accelerationStructure must have been created, allocated, or retrieved from device
See Also
VkAccelerationStructureNV, VkAllocationCallbacks, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyAccelerationStructureNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyBuffer(3)
Name
vkDestroyBuffer - Destroy a buffer object

C Specification
To destroy a buffer, call:

void vkDestroyBuffer(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the buffer.
buffer is the buffer to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted commands that refer to buffer, either directly or via a VkBufferView, must have completed execution
If VkAllocationCallbacks were provided when buffer was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when buffer was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If buffer is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to buffer must be externally synchronized
See Also
VkAllocationCallbacks, VkBuffer, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyBuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyBufferView(3)
Name
vkDestroyBufferView - Destroy a buffer view object

C Specification
To destroy a buffer view, call:

void vkDestroyBufferView(
    VkDevice                                    device,
    VkBufferView                                bufferView,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the buffer view.
bufferView is the buffer view to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted commands that refer to bufferView must have completed execution
If VkAllocationCallbacks were provided when bufferView was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when bufferView was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If bufferView is not VK_NULL_HANDLE, bufferView must be a valid VkBufferView handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If bufferView is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to bufferView must be externally synchronized
See Also
VkAllocationCallbacks, VkBufferView, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyBufferView

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyCommandPool(3)
Name
vkDestroyCommandPool - Destroy a command pool object

C Specification
To destroy a command pool, call:

void vkDestroyCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the command pool.
commandPool is the handle of the command pool to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
When a pool is destroyed, all command buffers allocated from the pool are freed.

Any primary command buffer allocated from another VkCommandPool that is in the recording or executable state and has a secondary command buffer allocated from commandPool recorded into it, becomes invalid.

Valid Usage
All VkCommandBuffer objects allocated from commandPool must not be in the pending state.
If VkAllocationCallbacks were provided when commandPool was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when commandPool was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If commandPool is not VK_NULL_HANDLE, commandPool must be a valid VkCommandPool handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If commandPool is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to commandPool must be externally synchronized
See Also
VkAllocationCallbacks, VkCommandPool, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyCommandPool

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyDebugReportCallbackEXT(3)
Name
vkDestroyDebugReportCallbackEXT - Destroy a debug report callback object

C Specification
To destroy a VkDebugReportCallbackEXT object, call:

void vkDestroyDebugReportCallbackEXT(
    VkInstance                                  instance,
    VkDebugReportCallbackEXT                    callback,
    const VkAllocationCallbacks*                pAllocator);
Parameters
instance the instance where the callback was created.
callback the VkDebugReportCallbackEXT object to destroy. callback is an externally synchronized object and must not be used on more than one thread at a time. This means that vkDestroyDebugReportCallbackEXT must not be called when a callback is active.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
If VkAllocationCallbacks were provided when callback was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when callback was created, pAllocator must be NULL
Valid Usage (Implicit)
instance must be a valid VkInstance handle
callback must be a valid VkDebugReportCallbackEXT handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
callback must have been created, allocated, or retrieved from instance
Host Synchronization
Host access to callback must be externally synchronized
See Also
VkAllocationCallbacks, VkDebugReportCallbackEXT, VkInstance

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyDebugReportCallbackEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyDebugUtilsMessengerEXT(3)
Name
vkDestroyDebugUtilsMessengerEXT - Destroy a debug messenger object

C Specification
To destroy a VkDebugUtilsMessengerEXT object, call:

void vkDestroyDebugUtilsMessengerEXT(
    VkInstance                                  instance,
    VkDebugUtilsMessengerEXT                    messenger,
    const VkAllocationCallbacks*                pAllocator);
Parameters
instance the instance where the callback was created.
messenger the VkDebugUtilsMessengerEXT object to destroy. messenger is an externally synchronized object and must not be used on more than one thread at a time. This means that vkDestroyDebugUtilsMessengerEXT must not be called when a callback is active.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
If VkAllocationCallbacks were provided when messenger was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when messenger was created, pAllocator must be NULL
Valid Usage (Implicit)
instance must be a valid VkInstance handle
messenger must be a valid VkDebugUtilsMessengerEXT handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
messenger must have been created, allocated, or retrieved from instance
Host Synchronization
Host access to messenger must be externally synchronized
The application must ensure that vkDestroyDebugUtilsMessengerEXT is not executed in parallel with any Vulkan command that is also called with instance or child of instance as the dispatchable argument.

See Also
VkAllocationCallbacks, VkDebugUtilsMessengerEXT, VkInstance

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyDebugUtilsMessengerEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyDescriptorPool(3)
Name
vkDestroyDescriptorPool - Destroy a descriptor pool object

C Specification
To destroy a descriptor pool, call:

void vkDestroyDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the descriptor pool.
descriptorPool is the descriptor pool to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
When a pool is destroyed, all descriptor sets allocated from the pool are implicitly freed and become invalid. Descriptor sets allocated from a given pool do not need to be freed before destroying that descriptor pool.

Valid Usage
All submitted commands that refer to descriptorPool (via any allocated descriptor sets) must have completed execution
If VkAllocationCallbacks were provided when descriptorPool was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when descriptorPool was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If descriptorPool is not VK_NULL_HANDLE, descriptorPool must be a valid VkDescriptorPool handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If descriptorPool is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to descriptorPool must be externally synchronized
See Also
VkAllocationCallbacks, VkDescriptorPool, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyDescriptorPool

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyDescriptorSetLayout(3)
Name
vkDestroyDescriptorSetLayout - Destroy a descriptor set layout object

C Specification
To destroy a descriptor set layout, call:

void vkDestroyDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayout                       descriptorSetLayout,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the descriptor set layout.
descriptorSetLayout is the descriptor set layout to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
If VkAllocationCallbacks were provided when descriptorSetLayout was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when descriptorSetLayout was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If descriptorSetLayout is not VK_NULL_HANDLE, descriptorSetLayout must be a valid VkDescriptorSetLayout handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If descriptorSetLayout is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to descriptorSetLayout must be externally synchronized
See Also
VkAllocationCallbacks, VkDescriptorSetLayout, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyDescriptorSetLayout

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyDescriptorUpdateTemplate(3)
Name
vkDestroyDescriptorUpdateTemplate - Destroy a descriptor update template object

C Specification
To destroy a descriptor update template, call:

void vkDestroyDescriptorUpdateTemplate(
    VkDevice                                    device,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    const VkAllocationCallbacks*                pAllocator);
or the equivalent command

void vkDestroyDescriptorUpdateTemplateKHR(
    VkDevice                                    device,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that has been used to create the descriptor update template
descriptorUpdateTemplate is the descriptor update template to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
If VkAllocationCallbacks were provided when descriptorSetLayout was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when descriptorSetLayout was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If descriptorUpdateTemplate is not VK_NULL_HANDLE, descriptorUpdateTemplate must be a valid VkDescriptorUpdateTemplate handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If descriptorUpdateTemplate is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to descriptorUpdateTemplate must be externally synchronized
See Also
VkAllocationCallbacks, VkDescriptorUpdateTemplate, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyDescriptorUpdateTemplate

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyDevice(3)
Name
vkDestroyDevice - Destroy a logical device

C Specification
To destroy a device, call:

void vkDestroyDevice(
    VkDevice                                    device,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
To ensure that no work is active on the device, vkDeviceWaitIdle can be used to gate the destruction of the device. Prior to destroying a device, an application is responsible for destroying/freeing any Vulkan objects that were created using that device as the first parameter of the corresponding vkCreate* or vkAllocate* command.

Note
The lifetime of each of these objects is bound by the lifetime of the VkDevice object. Therefore, to avoid resource leaks, it is critical that an application explicitly free all of these resources prior to calling vkDestroyDevice.
Valid Usage
All child objects created on device must have been destroyed prior to destroying device
If VkAllocationCallbacks were provided when device was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when device was created, pAllocator must be NULL
Valid Usage (Implicit)
If device is not NULL, device must be a valid VkDevice handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
Host Synchronization
Host access to device must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyDevice

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyEvent(3)
Name
vkDestroyEvent - Destroy an event object

C Specification
To destroy an event, call:

void vkDestroyEvent(
    VkDevice                                    device,
    VkEvent                                     event,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the event.
event is the handle of the event to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted commands that refer to event must have completed execution
If VkAllocationCallbacks were provided when event was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when event was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If event is not VK_NULL_HANDLE, event must be a valid VkEvent handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If event is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to event must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkEvent

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyEvent

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyFence(3)
Name
vkDestroyFence - Destroy a fence object

C Specification
To destroy a fence, call:

void vkDestroyFence(
    VkDevice                                    device,
    VkFence                                     fence,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the fence.
fence is the handle of the fence to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All queue submission commands that refer to fence must have completed execution
If VkAllocationCallbacks were provided when fence was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when fence was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If fence is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to fence must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkFence

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyFence

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyFramebuffer(3)
Name
vkDestroyFramebuffer - Destroy a framebuffer object

C Specification
To destroy a framebuffer, call:

void vkDestroyFramebuffer(
    VkDevice                                    device,
    VkFramebuffer                               framebuffer,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the framebuffer.
framebuffer is the handle of the framebuffer to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted commands that refer to framebuffer must have completed execution
If VkAllocationCallbacks were provided when framebuffer was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when framebuffer was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If framebuffer is not VK_NULL_HANDLE, framebuffer must be a valid VkFramebuffer handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If framebuffer is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to framebuffer must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkFramebuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyFramebuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyImage(3)
Name
vkDestroyImage - Destroy an image object

C Specification
To destroy an image, call:

void vkDestroyImage(
    VkDevice                                    device,
    VkImage                                     image,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the image.
image is the image to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted commands that refer to image, either directly or via a VkImageView, must have completed execution
If VkAllocationCallbacks were provided when image was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when image was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If image is not VK_NULL_HANDLE, image must be a valid VkImage handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If image is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to image must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkImage

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyImage

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyImageView(3)
Name
vkDestroyImageView - Destroy an image view object

C Specification
To destroy an image view, call:

void vkDestroyImageView(
    VkDevice                                    device,
    VkImageView                                 imageView,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the image view.
imageView is the image view to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted commands that refer to imageView must have completed execution
If VkAllocationCallbacks were provided when imageView was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when imageView was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If imageView is not VK_NULL_HANDLE, imageView must be a valid VkImageView handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If imageView is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to imageView must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkImageView

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyImageView

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyIndirectCommandsLayoutNVX(3)
Name
vkDestroyIndirectCommandsLayoutNVX - Destroy an object table

C Specification
Indirect command layouts are destroyed by:

void vkDestroyIndirectCommandsLayoutNVX(
    VkDevice                                    device,
    VkIndirectCommandsLayoutNVX                 indirectCommandsLayout,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the layout.
indirectCommandsLayout is the table to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted commands that refer to indirectCommandsLayout must have completed execution
If VkAllocationCallbacks were provided when objectTable was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when objectTable was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNVX handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
indirectCommandsLayout must have been created, allocated, or retrieved from device
See Also
VkAllocationCallbacks, VkDevice, VkIndirectCommandsLayoutNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyIndirectCommandsLayoutNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyInstance(3)
Name
vkDestroyInstance - Destroy an instance of Vulkan

C Specification
To destroy an instance, call:

void vkDestroyInstance(
    VkInstance                                  instance,
    const VkAllocationCallbacks*                pAllocator);
Parameters
instance is the handle of the instance to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All child objects created using instance must have been destroyed prior to destroying instance
If VkAllocationCallbacks were provided when instance was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when instance was created, pAllocator must be NULL
Valid Usage (Implicit)
If instance is not NULL, instance must be a valid VkInstance handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
Host Synchronization
Host access to instance must be externally synchronized
See Also
VkAllocationCallbacks, VkInstance

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyInstance

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyObjectTableNVX(3)
Name
vkDestroyObjectTableNVX - Destroy an object table

C Specification
To destroy an object table, call:

void vkDestroyObjectTableNVX(
    VkDevice                                    device,
    VkObjectTableNVX                            objectTable,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the table.
objectTable is the table to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted commands that refer to objectTable must have completed execution.
If VkAllocationCallbacks were provided when objectTable was created, a compatible set of callbacks must be provided here.
If no VkAllocationCallbacks were provided when objectTable was created, pAllocator must be NULL.
Valid Usage (Implicit)
device must be a valid VkDevice handle
objectTable must be a valid VkObjectTableNVX handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
objectTable must have been created, allocated, or retrieved from device
Host Synchronization
Host access to objectTable must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkObjectTableNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyObjectTableNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyPipeline(3)
Name
vkDestroyPipeline - Destroy a pipeline object

C Specification
To destroy a graphics or compute pipeline, call:

void vkDestroyPipeline(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the pipeline.
pipeline is the handle of the pipeline to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted commands that refer to pipeline must have completed execution
If VkAllocationCallbacks were provided when pipeline was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when pipeline was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If pipeline is not VK_NULL_HANDLE, pipeline must be a valid VkPipeline handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If pipeline is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to pipeline must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkPipeline

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyPipeline

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyPipelineCache(3)
Name
vkDestroyPipelineCache - Destroy a pipeline cache object

C Specification
To destroy a pipeline cache, call:

void vkDestroyPipelineCache(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the pipeline cache object.
pipelineCache is the handle of the pipeline cache to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
If VkAllocationCallbacks were provided when pipelineCache was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when pipelineCache was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to pipelineCache must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkPipelineCache

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyPipelineCache

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyPipelineLayout(3)
Name
vkDestroyPipelineLayout - Destroy a pipeline layout object

C Specification
To destroy a pipeline layout, call:

void vkDestroyPipelineLayout(
    VkDevice                                    device,
    VkPipelineLayout                            pipelineLayout,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the pipeline layout.
pipelineLayout is the pipeline layout to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
If VkAllocationCallbacks were provided when pipelineLayout was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when pipelineLayout was created, pAllocator must be NULL
pipelineLayout must not have been passed to any vkCmd* command for any command buffers that are still in the recording state when vkDestroyPipelineLayout is called
Valid Usage (Implicit)
device must be a valid VkDevice handle
If pipelineLayout is not VK_NULL_HANDLE, pipelineLayout must be a valid VkPipelineLayout handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If pipelineLayout is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to pipelineLayout must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkPipelineLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyPipelineLayout

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyQueryPool(3)
Name
vkDestroyQueryPool - Destroy a query pool object

C Specification
To destroy a query pool, call:

void vkDestroyQueryPool(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the query pool.
queryPool is the query pool to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted commands that refer to queryPool must have completed execution
If VkAllocationCallbacks were provided when queryPool was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when queryPool was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If queryPool is not VK_NULL_HANDLE, queryPool must be a valid VkQueryPool handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If queryPool is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to queryPool must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkQueryPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyQueryPool

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyRenderPass(3)
Name
vkDestroyRenderPass - Destroy a render pass object

C Specification
To destroy a render pass, call:

void vkDestroyRenderPass(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the render pass.
renderPass is the handle of the render pass to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted commands that refer to renderPass must have completed execution
If VkAllocationCallbacks were provided when renderPass was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when renderPass was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If renderPass is not VK_NULL_HANDLE, renderPass must be a valid VkRenderPass handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If renderPass is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to renderPass must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkRenderPass

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyRenderPass

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroySampler(3)
Name
vkDestroySampler - Destroy a sampler object

C Specification
To destroy a sampler, call:

void vkDestroySampler(
    VkDevice                                    device,
    VkSampler                                   sampler,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the sampler.
sampler is the sampler to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted commands that refer to sampler must have completed execution
If VkAllocationCallbacks were provided when sampler was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when sampler was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If sampler is not VK_NULL_HANDLE, sampler must be a valid VkSampler handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If sampler is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to sampler must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkSampler

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroySampler

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroySamplerYcbcrConversion(3)
Name
vkDestroySamplerYcbcrConversion - Destroy a created Y’CbCr conversion

C Specification
To destroy a sampler Y’CBCR conversion, call:

void vkDestroySamplerYcbcrConversion(
    VkDevice                                    device,
    VkSamplerYcbcrConversion                    ycbcrConversion,
    const VkAllocationCallbacks*                pAllocator);
or the equivalent command

void vkDestroySamplerYcbcrConversionKHR(
    VkDevice                                    device,
    VkSamplerYcbcrConversion                    ycbcrConversion,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the Y’CBCR conversion.
ycbcrConversion is the conversion to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
If ycbcrConversion is not VK_NULL_HANDLE, ycbcrConversion must be a valid VkSamplerYcbcrConversion handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If ycbcrConversion is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to ycbcrConversion must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkSamplerYcbcrConversion

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroySamplerYcbcrConversion

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroySemaphore(3)
Name
vkDestroySemaphore - Destroy a semaphore object

C Specification
To destroy a semaphore, call:

void vkDestroySemaphore(
    VkDevice                                    device,
    VkSemaphore                                 semaphore,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the semaphore.
semaphore is the handle of the semaphore to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
All submitted batches that refer to semaphore must have completed execution
If VkAllocationCallbacks were provided when semaphore was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when semaphore was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If semaphore is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to semaphore must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkSemaphore

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroySemaphore

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyShaderModule(3)
Name
vkDestroyShaderModule - Destroy a shader module

C Specification
To destroy a shader module, call:

void vkDestroyShaderModule(
    VkDevice                                    device,
    VkShaderModule                              shaderModule,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the shader module.
shaderModule is the handle of the shader module to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
A shader module can be destroyed while pipelines created using its shaders are still in use.

Valid Usage
If VkAllocationCallbacks were provided when shaderModule was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when shaderModule was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If shaderModule is not VK_NULL_HANDLE, shaderModule must be a valid VkShaderModule handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If shaderModule is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to shaderModule must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkShaderModule

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyShaderModule

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroySurfaceKHR(3)
Name
vkDestroySurfaceKHR - Destroy a VkSurfaceKHR object

C Specification
To destroy a VkSurfaceKHR object, call:

void vkDestroySurfaceKHR(
    VkInstance                                  instance,
    VkSurfaceKHR                                surface,
    const VkAllocationCallbacks*                pAllocator);
Parameters
instance is the instance used to create the surface.
surface is the surface to destroy.
pAllocator is the allocator used for host memory allocated for the surface object when there is no more specific allocator available (see Memory Allocation).
Description
Destroying a VkSurfaceKHR merely severs the connection between Vulkan and the native surface, and does not imply destroying the native surface, closing a window, or similar behavior.

Valid Usage
All VkSwapchainKHR objects created for surface must have been destroyed prior to destroying surface
If VkAllocationCallbacks were provided when surface was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when surface was created, pAllocator must be NULL
Valid Usage (Implicit)
instance must be a valid VkInstance handle
If surface is not VK_NULL_HANDLE, surface must be a valid VkSurfaceKHR handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If surface is a valid handle, it must have been created, allocated, or retrieved from instance
Host Synchronization
Host access to surface must be externally synchronized
See Also
VkAllocationCallbacks, VkInstance, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroySurfaceKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroySwapchainKHR(3)
Name
vkDestroySwapchainKHR - Destroy a swapchain object

C Specification
To destroy a swapchain object call:

void vkDestroySwapchainKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the VkDevice associated with swapchain.
swapchain is the swapchain to destroy.
pAllocator is the allocator used for host memory allocated for the swapchain object when there is no more specific allocator available (see Memory Allocation).
Description
The application must not destroy a swapchain until after completion of all outstanding operations on images that were acquired from the swapchain. swapchain and all associated VkImage handles are destroyed, and must not be acquired or used any more by the application. The memory of each VkImage will only be freed after that image is no longer used by the presentation engine. For example, if one image of the swapchain is being displayed in a window, the memory for that image may not be freed until the window is destroyed, or another swapchain is created for the window. Destroying the swapchain does not invalidate the parent VkSurfaceKHR, and a new swapchain can be created with it.

When a swapchain associated with a display surface is destroyed, if the image most recently presented to the display surface is from the swapchain being destroyed, then either any display resources modified by presenting images from any swapchain associated with the display surface must be reverted by the implementation to their state prior to the first present performed on one of these swapchains, or such resources must be left in their current state.

If swapchain has exclusive full-screen access, it is released before the swapchain is destroyed.

Valid Usage
All uses of presentable images acquired from swapchain must have completed execution
If VkAllocationCallbacks were provided when swapchain was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when swapchain was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If swapchain is not VK_NULL_HANDLE, swapchain must be a valid VkSwapchainKHR handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
Both of device, and swapchain that are valid handles must have been created, allocated, or retrieved from the same VkInstance
Host Synchronization
Host access to swapchain must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroySwapchainKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDestroyValidationCacheEXT(3)
Name
vkDestroyValidationCacheEXT - Destroy a validation cache object

C Specification
To destroy a validation cache, call:

void vkDestroyValidationCacheEXT(
    VkDevice                                    device,
    VkValidationCacheEXT                        validationCache,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that destroys the validation cache object.
validationCache is the handle of the validation cache to destroy.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Valid Usage
If VkAllocationCallbacks were provided when validationCache was created, a compatible set of callbacks must be provided here
If no VkAllocationCallbacks were provided when validationCache was created, pAllocator must be NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
If validationCache is not VK_NULL_HANDLE, validationCache must be a valid VkValidationCacheEXT handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If validationCache is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to validationCache must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkValidationCacheEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDestroyValidationCacheEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDeviceWaitIdle(3)
Name
vkDeviceWaitIdle - Wait for a device to become idle

C Specification
To wait on the host for the completion of outstanding queue operations for all queues on a given logical device, call:

VkResult vkDeviceWaitIdle(
    VkDevice                                    device);
Parameters
device is the logical device to idle.
Description
vkDeviceWaitIdle is equivalent to calling vkQueueWaitIdle for all queues owned by device.

Valid Usage (Implicit)
device must be a valid VkDevice handle
Host Synchronization
Host access to all VkQueue objects created from device must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
See Also
VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDeviceWaitIdle

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkDisplayPowerControlEXT(3)
Name
vkDisplayPowerControlEXT - Set the power state of a display

C Specification
To set the power state of a display, call:

VkResult vkDisplayPowerControlEXT(
    VkDevice                                    device,
    VkDisplayKHR                                display,
    const VkDisplayPowerInfoEXT*                pDisplayPowerInfo);
Parameters
device is a logical device associated with display.
display is the display whose power state is modified.
pDisplayPowerInfo is an instance of VkDisplayPowerInfoEXT specifying the new power state of display.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
display must be a valid VkDisplayKHR handle
pDisplayPowerInfo must be a valid pointer to a valid VkDisplayPowerInfoEXT structure
Return Codes
Success
VK_SUCCESS
See Also
VkDevice, VkDisplayKHR, VkDisplayPowerInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkDisplayPowerControlEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkEndCommandBuffer(3)
Name
vkEndCommandBuffer - Finish recording a command buffer

C Specification
To complete recording of a command buffer, call:

VkResult vkEndCommandBuffer(
    VkCommandBuffer                             commandBuffer);
Parameters
commandBuffer is the command buffer to complete recording.
Description
If there was an error during recording, the application will be notified by an unsuccessful return code returned by vkEndCommandBuffer. If the application wishes to further use the command buffer, the command buffer must be reset. The command buffer must have been in the recording state, and is moved to the executable state.

Valid Usage
commandBuffer must be in the recording state.
If commandBuffer is a primary command buffer, there must not be an active render pass instance
All queries made active during the recording of commandBuffer must have been made inactive
Conditional rendering must not be active
If commandBuffer is a secondary command buffer, there must not be an outstanding vkCmdBeginDebugUtilsLabelEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdEndDebugUtilsLabelEXT.
If commandBuffer is a secondary command buffer, there must not be an outstanding vkCmdDebugMarkerBeginEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdDebugMarkerEndEXT.
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
Host Synchronization
Host access to commandBuffer must be externally synchronized
Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkEndCommandBuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkEnumerateDeviceExtensionProperties(3)
Name
vkEnumerateDeviceExtensionProperties - Returns properties of available physical device extensions

C Specification
To query the extensions available to a given physical device, call:

VkResult vkEnumerateDeviceExtensionProperties(
    VkPhysicalDevice                            physicalDevice,
    const char*                                 pLayerName,
    uint32_t*                                   pPropertyCount,
    VkExtensionProperties*                      pProperties);
Parameters
physicalDevice is the physical device that will be queried.
pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from.
pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, and is treated in the same fashion as the vkEnumerateInstanceExtensionProperties::pPropertyCount parameter.
pProperties is either NULL or a pointer to an array of VkExtensionProperties structures.
Description
When pLayerName parameter is NULL, only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the device extensions provided by that layer are returned.

Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
If pLayerName is not NULL, pLayerName must be a null-terminated UTF-8 string
pPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkExtensionProperties structures
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_LAYER_NOT_PRESENT
See Also
VkExtensionProperties, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkEnumerateDeviceExtensionProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkEnumerateDeviceLayerProperties(3)
Name
vkEnumerateDeviceLayerProperties - Returns properties of available physical device layers

C Specification
To enumerate device layers, call:

VkResult vkEnumerateDeviceLayerProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkLayerProperties*                          pProperties);
Parameters
pPropertyCount is a pointer to an integer related to the number of layer properties available or queried.
pProperties is either NULL or a pointer to an array of VkLayerProperties structures.
Description
If pProperties is NULL, then the number of layer properties available is returned in pPropertyCount. Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties. If pPropertyCount is less than the number of layer properties available, at most pPropertyCount structures will be written. If pPropertyCount is smaller than the number of layers available, VK_INCOMPLETE will be returned instead of VK_SUCCESS, to indicate that not all the available layer properties were returned.

The list of layers enumerated by vkEnumerateDeviceLayerProperties must be exactly the sequence of layers enabled for the instance. The members of VkLayerProperties for each enumerated layer must be the same as the properties when the layer was enumerated by vkEnumerateInstanceLayerProperties.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkLayerProperties structures
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkLayerProperties, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkEnumerateDeviceLayerProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkEnumerateInstanceExtensionProperties(3)
Name
vkEnumerateInstanceExtensionProperties - Returns up to requested number of global extension properties

C Specification
To query the available instance extensions, call:

VkResult vkEnumerateInstanceExtensionProperties(
    const char*                                 pLayerName,
    uint32_t*                                   pPropertyCount,
    VkExtensionProperties*                      pProperties);
Parameters
pLayerName is either NULL or a pointer to a null-terminated UTF-8 string naming the layer to retrieve extensions from.
pPropertyCount is a pointer to an integer related to the number of extension properties available or queried, as described below.
pProperties is either NULL or a pointer to an array of VkExtensionProperties structures.
Description
When pLayerName parameter is NULL, only extensions provided by the Vulkan implementation or by implicitly enabled layers are returned. When pLayerName is the name of a layer, the instance extensions provided by that layer are returned.

If pProperties is NULL, then the number of extensions properties available is returned in pPropertyCount. Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties. If pPropertyCount is less than the number of extension properties available, at most pPropertyCount structures will be written. If pPropertyCount is smaller than the number of extensions available, VK_INCOMPLETE will be returned instead of VK_SUCCESS, to indicate that not all the available properties were returned.

Because the list of available layers may change externally between calls to vkEnumerateInstanceExtensionProperties, two calls may retrieve different results if a pLayerName is available in one call but not in another. The extensions supported by a layer may also change between two calls, e.g. if the layer implementation is replaced by a different version between those calls.

Implementations must not advertise any pair of extensions that cannot be enabled together due to behavioral differences, or any extension that cannot be enabled against the advertised version.

Valid Usage (Implicit)
If pLayerName is not NULL, pLayerName must be a null-terminated UTF-8 string
pPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkExtensionProperties structures
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_LAYER_NOT_PRESENT
See Also
VkExtensionProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkEnumerateInstanceExtensionProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkEnumerateInstanceLayerProperties(3)
Name
vkEnumerateInstanceLayerProperties - Returns up to requested number of global layer properties

C Specification
To query the available layers, call:

VkResult vkEnumerateInstanceLayerProperties(
    uint32_t*                                   pPropertyCount,
    VkLayerProperties*                          pProperties);
Parameters
pPropertyCount is a pointer to an integer related to the number of layer properties available or queried, as described below.
pProperties is either NULL or a pointer to an array of VkLayerProperties structures.
Description
If pProperties is NULL, then the number of layer properties available is returned in pPropertyCount. Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties. If pPropertyCount is less than the number of layer properties available, at most pPropertyCount structures will be written. If pPropertyCount is smaller than the number of layers available, VK_INCOMPLETE will be returned instead of VK_SUCCESS, to indicate that not all the available layer properties were returned.

The list of available layers may change at any time due to actions outside of the Vulkan implementation, so two calls to vkEnumerateInstanceLayerProperties with the same parameters may return different results, or retrieve different pPropertyCount values or pProperties contents. Once an instance has been created, the layers enabled for that instance will continue to be enabled and valid for the lifetime of that instance, even if some of them become unavailable for future instances.

Valid Usage (Implicit)
pPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkLayerProperties structures
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkLayerProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkEnumerateInstanceLayerProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkEnumerateInstanceVersion(3)
Name
vkEnumerateInstanceVersion - Query instance-level version before instance creation

C Specification
To query the version of instance-level functionality supported by the implementation, call:

VkResult vkEnumerateInstanceVersion(
    uint32_t*                                   pApiVersion);
Parameters
pApiVersion points to a uint32_t, which is the version of Vulkan supported by instance-level functionality, encoded as described in html/vkspec.html#extendingvulkan-coreversions-versionnumbers.
Description
Valid Usage (Implicit)
pApiVersion must be a valid pointer to a uint32_t value
Return Codes
Success
VK_SUCCESS
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkEnumerateInstanceVersion

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkEnumeratePhysicalDeviceGroups(3)
Name
vkEnumeratePhysicalDeviceGroups - Enumerates groups of physical devices that can be used to create a single logical device

C Specification
To retrieve a list of the device groups present in the system, call:

VkResult vkEnumeratePhysicalDeviceGroups(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties*            pPhysicalDeviceGroupProperties);
or the equivalent command

VkResult vkEnumeratePhysicalDeviceGroupsKHR(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties*            pPhysicalDeviceGroupProperties);
Parameters
instance is a handle to a Vulkan instance previously created with vkCreateInstance.
pPhysicalDeviceGroupCount is a pointer to an integer related to the number of device groups available or queried, as described below.
pPhysicalDeviceGroupProperties is either NULL or a pointer to an array of VkPhysicalDeviceGroupProperties structures.
Description
If pPhysicalDeviceGroupProperties is NULL, then the number of device groups available is returned in pPhysicalDeviceGroupCount. Otherwise, pPhysicalDeviceGroupCount must point to a variable set by the user to the number of elements in the pPhysicalDeviceGroupProperties array, and on return the variable is overwritten with the number of structures actually written to pPhysicalDeviceGroupProperties. If pPhysicalDeviceGroupCount is less than the number of device groups available, at most pPhysicalDeviceGroupCount structures will be written. If pPhysicalDeviceGroupCount is smaller than the number of device groups available, VK_INCOMPLETE will be returned instead of VK_SUCCESS, to indicate that not all the available device groups were returned.

Every physical device must be in exactly one device group.

Valid Usage (Implicit)
instance must be a valid VkInstance handle
pPhysicalDeviceGroupCount must be a valid pointer to a uint32_t value
If the value referenced by pPhysicalDeviceGroupCount is not 0, and pPhysicalDeviceGroupProperties is not NULL, pPhysicalDeviceGroupProperties must be a valid pointer to an array of pPhysicalDeviceGroupCount VkPhysicalDeviceGroupProperties structures
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_INITIALIZATION_FAILED
See Also
VkInstance, VkPhysicalDeviceGroupProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkEnumeratePhysicalDeviceGroups

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkEnumeratePhysicalDevices(3)
Name
vkEnumeratePhysicalDevices - Enumerates the physical devices accessible to a Vulkan instance

C Specification
To retrieve a list of physical device objects representing the physical devices installed in the system, call:

VkResult vkEnumeratePhysicalDevices(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceCount,
    VkPhysicalDevice*                           pPhysicalDevices);
Parameters
instance is a handle to a Vulkan instance previously created with vkCreateInstance.
pPhysicalDeviceCount is a pointer to an integer related to the number of physical devices available or queried, as described below.
pPhysicalDevices is either NULL or a pointer to an array of VkPhysicalDevice handles.
Description
If pPhysicalDevices is NULL, then the number of physical devices available is returned in pPhysicalDeviceCount. Otherwise, pPhysicalDeviceCount must point to a variable set by the user to the number of elements in the pPhysicalDevices array, and on return the variable is overwritten with the number of handles actually written to pPhysicalDevices. If pPhysicalDeviceCount is less than the number of physical devices available, at most pPhysicalDeviceCount structures will be written. If pPhysicalDeviceCount is smaller than the number of physical devices available, VK_INCOMPLETE will be returned instead of VK_SUCCESS, to indicate that not all the available physical devices were returned.

Valid Usage (Implicit)
instance must be a valid VkInstance handle
pPhysicalDeviceCount must be a valid pointer to a uint32_t value
If the value referenced by pPhysicalDeviceCount is not 0, and pPhysicalDevices is not NULL, pPhysicalDevices must be a valid pointer to an array of pPhysicalDeviceCount VkPhysicalDevice handles
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_INITIALIZATION_FAILED
See Also
VkInstance, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkEnumeratePhysicalDevices

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkFlushMappedMemoryRanges(3)
Name
vkFlushMappedMemoryRanges - Flush mapped memory ranges

C Specification
To flush ranges of non-coherent memory from the host caches, call:

VkResult vkFlushMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges);
Parameters
device is the logical device that owns the memory ranges.
memoryRangeCount is the length of the pMemoryRanges array.
pMemoryRanges is a pointer to an array of VkMappedMemoryRange structures describing the memory ranges to flush.
Description
vkFlushMappedMemoryRanges guarantees that host writes to the memory ranges described by pMemoryRanges are made available to the host memory domain, such that they can be made available to the device memory domain via memory domain operations using the VK_ACCESS_HOST_WRITE_BIT access type.

Within each range described by pMemoryRanges, each set of nonCoherentAtomSize bytes in that range is flushed if any byte in that set has been written by the host since it was first host mapped, or the last time it was flushed. If pMemoryRanges includes sets of nonCoherentAtomSize bytes where no bytes have been written by the host, those bytes must not be flushed.

Unmapping non-coherent memory does not implicitly flush the host mapped memory, and host writes that have not been flushed may not ever be visible to the device. However, implementations must ensure that writes that have not been flushed do not become visible to any other memory.

Note
The above guarantee avoids a potential memory corruption in scenarios where host writes to a mapped memory object have not been flushed before the memory is unmapped (or freed), and the virtual address range is subsequently reused for a different mapping (or memory allocation).
Valid Usage (Implicit)
device must be a valid VkDevice handle
pMemoryRanges must be a valid pointer to an array of memoryRangeCount valid VkMappedMemoryRange structures
memoryRangeCount must be greater than 0
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkMappedMemoryRange

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkFlushMappedMemoryRanges

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkFreeCommandBuffers(3)
Name
vkFreeCommandBuffers - Free command buffers

C Specification
To free command buffers, call:

void vkFreeCommandBuffers(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    uint32_t                                    commandBufferCount,
    const VkCommandBuffer*                      pCommandBuffers);
Parameters
device is the logical device that owns the command pool.
commandPool is the command pool from which the command buffers were allocated.
commandBufferCount is the length of the pCommandBuffers array.
pCommandBuffers is an array of handles of command buffers to free.
Description
Any primary command buffer that is in the recording or executable state and has any element of pCommandBuffers recorded into it, becomes invalid.

Valid Usage
All elements of pCommandBuffers must not be in the pending state
pCommandBuffers must be a valid pointer to an array of commandBufferCount VkCommandBuffer handles, each element of which must either be a valid handle or NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
commandPool must be a valid VkCommandPool handle
commandBufferCount must be greater than 0
commandPool must have been created, allocated, or retrieved from device
Each element of pCommandBuffers that is a valid handle must have been created, allocated, or retrieved from commandPool
Host Synchronization
Host access to commandPool must be externally synchronized
Host access to each member of pCommandBuffers must be externally synchronized
See Also
VkCommandBuffer, VkCommandPool, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkFreeCommandBuffers

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkFreeDescriptorSets(3)
Name
vkFreeDescriptorSets - Free one or more descriptor sets

C Specification
To free allocated descriptor sets, call:

VkResult vkFreeDescriptorSets(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    const VkDescriptorSet*                      pDescriptorSets);
Parameters
device is the logical device that owns the descriptor pool.
descriptorPool is the descriptor pool from which the descriptor sets were allocated.
descriptorSetCount is the number of elements in the pDescriptorSets array.
pDescriptorSets is an array of handles to VkDescriptorSet objects.
Description
After a successful call to vkFreeDescriptorSets, all descriptor sets in pDescriptorSets are invalid.

Valid Usage
All submitted commands that refer to any element of pDescriptorSets must have completed execution
pDescriptorSets must be a valid pointer to an array of descriptorSetCount VkDescriptorSet handles, each element of which must either be a valid handle or VK_NULL_HANDLE
Each valid handle in pDescriptorSets must have been allocated from descriptorPool
descriptorPool must have been created with the VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT flag
Valid Usage (Implicit)
device must be a valid VkDevice handle
descriptorPool must be a valid VkDescriptorPool handle
descriptorSetCount must be greater than 0
descriptorPool must have been created, allocated, or retrieved from device
Each element of pDescriptorSets that is a valid handle must have been created, allocated, or retrieved from descriptorPool
Host Synchronization
Host access to descriptorPool must be externally synchronized
Host access to each member of pDescriptorSets must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDescriptorPool, VkDescriptorSet, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkFreeDescriptorSets

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkFreeMemory(3)
Name
vkFreeMemory - Free device memory

C Specification
To free a memory object, call:

void vkFreeMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    const VkAllocationCallbacks*                pAllocator);
Parameters
device is the logical device that owns the memory.
memory is the VkDeviceMemory object to be freed.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
Description
Before freeing a memory object, an application must ensure the memory object is no longer in use by the device—​for example by command buffers in the pending state. Memory can be freed whilst still bound to resources, but those resources must not be used afterwards. If there are still any bound images or buffers, the memory may not be immediately released by the implementation, but must be released by the time all bound images and buffers have been destroyed. Once memory is released, it is returned to the heap from which it was allocated.

How memory objects are bound to Images and Buffers is described in detail in the Resource Memory Association section.

If a memory object is mapped at the time it is freed, it is implicitly unmapped.

Note
As described below, host writes are not implicitly flushed when the memory object is unmapped, but the implementation must guarantee that writes that have not been flushed do not affect any other memory.
Valid Usage
All submitted commands that refer to memory (via images or buffers) must have completed execution
Valid Usage (Implicit)
device must be a valid VkDevice handle
If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
If memory is a valid handle, it must have been created, allocated, or retrieved from device
Host Synchronization
Host access to memory must be externally synchronized
See Also
VkAllocationCallbacks, VkDevice, VkDeviceMemory

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkFreeMemory

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetAccelerationStructureHandleNV(3)
Name
vkGetAccelerationStructureHandleNV - Get opaque acceleration structure handle

C Specification
To allow constructing geometry instances with device code if desired, we need to be able to query a opaque handle for an acceleration structure. This handle is a value of 8 bytes. To get this handle, call:

VkResult vkGetAccelerationStructureHandleNV(
    VkDevice                                    device,
    VkAccelerationStructureNV                   accelerationStructure,
    size_t                                      dataSize,
    void*                                       pData);
Parameters
device is the logical device that owns the acceleration structures.
accelerationStructure is the acceleration structure.
dataSize is the size in bytes of the buffer pointed to by pData.
pData is a pointer to a user-allocated buffer where the results will be written.
Description
Valid Usage
dataSize must be large enough to contain the result of the query, as described above
Valid Usage (Implicit)
device must be a valid VkDevice handle
accelerationStructure must be a valid VkAccelerationStructureNV handle
pData must be a valid pointer to an array of dataSize bytes
dataSize must be greater than 0
accelerationStructure must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkAccelerationStructureNV, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetAccelerationStructureHandleNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetAccelerationStructureMemoryRequirementsNV(3)
Name
vkGetAccelerationStructureMemoryRequirementsNV - Get acceleration structure memory requirements

C Specification
An acceleration structure has memory requirements for the structure object itself, scratch space for the build, and scratch space for the update.

To query the memory requirements call:

void vkGetAccelerationStructureMemoryRequirementsNV(
    VkDevice                                    device,
    const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo,
    VkMemoryRequirements2KHR*                   pMemoryRequirements);
Parameters
device is the logical device on which the acceleration structure was created.
pInfo specifies the acceleration structure to get memory requirements for.
pMemoryRequirements returns the requested acceleration structure memory requirements.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pInfo must be a valid pointer to a valid VkAccelerationStructureMemoryRequirementsInfoNV structure
pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2KHR structure
See Also
VkAccelerationStructureMemoryRequirementsInfoNV, VkDevice, VkMemoryRequirements2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetAccelerationStructureMemoryRequirementsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetAndroidHardwareBufferPropertiesANDROID(3)
Name
vkGetAndroidHardwareBufferPropertiesANDROID - Get Properties of External Memory Android Hardware Buffers

C Specification
To determine the memory parameters to use when importing an Android hardware buffer, call:

VkResult vkGetAndroidHardwareBufferPropertiesANDROID(
    VkDevice                                    device,
    const struct AHardwareBuffer*               buffer,
    VkAndroidHardwareBufferPropertiesANDROID*   pProperties);
Parameters
device is the logical device that will be importing buffer.
buffer is the Android hardware buffer which will be imported.
pProperties is a pointer to a VkAndroidHardwareBufferPropertiesANDROID structure in which the properties of buffer are returned.
Description
Valid Usage
buffer must be a valid Android hardware buffer object with at least one of the AHARDWAREBUFFER_USAGE_GPU_* flags in its AHardwareBuffer_Desc::usage
Valid Usage (Implicit)
device must be a valid VkDevice handle
buffer must be a valid pointer to a valid AHardwareBuffer value
pProperties must be a valid pointer to a VkAndroidHardwareBufferPropertiesANDROID structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR
See Also
VkAndroidHardwareBufferPropertiesANDROID, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetAndroidHardwareBufferPropertiesANDROID

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetBufferDeviceAddressEXT(3)
Name
vkGetBufferDeviceAddressEXT - Query an address of a buffer

C Specification
To query a 64-bit buffer device address value through which buffer memory can be accessed in a shader, call:

VkDeviceAddress vkGetBufferDeviceAddressEXT(
    VkDevice                                    device,
    const VkBufferDeviceAddressInfoEXT*         pInfo);
Parameters
device is the logical device that the buffer was created on.
pInfo is a pointer to an instance of the VkBufferDeviceAddressInfoEXT structure specifying the buffer to retrieve an address for.
Description
The 64-bit return value is an address of the start of pInfo::buffer. The address range starting at this value and whose size is the size of the buffer can be used in a shader to access the memory bound to that buffer, using the SPV_EXT_physical_storage_buffer extension and the PhysicalStorageBufferEXT storage class. For example, this value can be stored in a uniform buffer, and the shader can read the value from the uniform buffer and use it to do a dependent read/write to this buffer. A value of zero is reserved as a “null” pointer and must not be returned as a valid buffer device address. All loads, stores, and atomics in a shader through PhysicalStorageBufferEXT pointers must access addresses in the address range of some buffer.

If the buffer was created with a non-zero value of VkBufferDeviceAddressCreateInfoEXT::deviceAddress, the return value will be the same address.

Valid Usage
The bufferDeviceAddress feature must be enabled
If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled
Valid Usage (Implicit)
device must be a valid VkDevice handle
pInfo must be a valid pointer to a valid VkBufferDeviceAddressInfoEXT structure
See Also
VkBufferDeviceAddressInfoEXT, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetBufferDeviceAddressEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetBufferMemoryRequirements(3)
Name
vkGetBufferMemoryRequirements - Returns the memory requirements for specified Vulkan object

C Specification
To determine the memory requirements for a buffer resource, call:

void vkGetBufferMemoryRequirements(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkMemoryRequirements*                       pMemoryRequirements);
Parameters
device is the logical device that owns the buffer.
buffer is the buffer to query.
pMemoryRequirements points to an instance of the VkMemoryRequirements structure in which the memory requirements of the buffer object are returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
buffer must be a valid VkBuffer handle
pMemoryRequirements must be a valid pointer to a VkMemoryRequirements structure
buffer must have been created, allocated, or retrieved from device
See Also
VkBuffer, VkDevice, VkMemoryRequirements

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetBufferMemoryRequirements

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetBufferMemoryRequirements2(3)
Name
vkGetBufferMemoryRequirements2 - Returns the memory requirements for specified Vulkan object

C Specification
To determine the memory requirements for a buffer resource, call:

void vkGetBufferMemoryRequirements2(
    VkDevice                                    device,
    const VkBufferMemoryRequirementsInfo2*      pInfo,
    VkMemoryRequirements2*                      pMemoryRequirements);
or the equivalent command

void vkGetBufferMemoryRequirements2KHR(
    VkDevice                                    device,
    const VkBufferMemoryRequirementsInfo2*      pInfo,
    VkMemoryRequirements2*                      pMemoryRequirements);
Parameters
device is the logical device that owns the buffer.
pInfo is a pointer to an instance of the VkBufferMemoryRequirementsInfo2 structure containing parameters required for the memory requirements query.
pMemoryRequirements points to an instance of the VkMemoryRequirements2 structure in which the memory requirements of the buffer object are returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pInfo must be a valid pointer to a valid VkBufferMemoryRequirementsInfo2 structure
pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure
See Also
VkBufferMemoryRequirementsInfo2, VkDevice, VkMemoryRequirements2

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetBufferMemoryRequirements2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetCalibratedTimestampsEXT(3)
Name
vkGetCalibratedTimestampsEXT - Query calibrated timestamps

C Specification
In order to be able to correlate the time a particular operation took place at on timelines of different time domains (e.g. a device operation vs a host operation), Vulkan allows querying calibrated timestamps from multiple time domains.

To query calibrated timestamps from a set of time domains, call:

VkResult vkGetCalibratedTimestampsEXT(
    VkDevice                                    device,
    uint32_t                                    timestampCount,
    const VkCalibratedTimestampInfoEXT*         pTimestampInfos,
    uint64_t*                                   pTimestamps,
    uint64_t*                                   pMaxDeviation);
Parameters
device is the logical device used to perform the query.
timestampCount is the number of timestamps to query.
pTimestampInfos is a pointer to an array of timestampCount number of structures of type VkCalibratedTimestampInfoEXT, describing the time domains the calibrated timestamps should be captured from.
pTimestamps is a pointer to an array of timestampCount number of 64-bit unsigned integer values in which the requested calibrated timestamp values are returned.
pMaxDeviation is a pointer to a 64-bit unsigned integer value in which the strictly positive maximum deviation, in nanoseconds, of the calibrated timestamp values is returned.
Description
Note
The maximum deviation may vary between calls to vkGetCalibratedTimestampsEXT even for the same set of time domains due to implementation and platform specific reasons. It is the application’s responsibility to assess whether the returned maximum deviation makes the timestamp values suitable for any particular purpose and can choose to re-issue the timestamp calibration call pursuing a lower devation value.
Calibrated timestamp values can be extrapolated to estimate future coinciding timestamp values, however, depending on the nature of the time domains and other properties of the platform extrapolating values over a sufficiently long period of time may no longer be accurate enough to fit any particular purpose so applications are expected to re-calibrate the timestamps on a regular basis.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pTimestampInfos must be a valid pointer to an array of timestampCount valid VkCalibratedTimestampInfoEXT structures
pTimestamps must be a valid pointer to an array of timestampCount uint64_t values
pMaxDeviation must be a valid pointer to a uint64_t value
timestampCount must be greater than 0
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkCalibratedTimestampInfoEXT, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetCalibratedTimestampsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDescriptorSetLayoutSupport(3)
Name
vkGetDescriptorSetLayoutSupport - Query whether a descriptor set layout can be created

C Specification
To query information about whether a descriptor set layout can be created, call:

void vkGetDescriptorSetLayoutSupport(
    VkDevice                                    device,
    const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    VkDescriptorSetLayoutSupport*               pSupport);
or the equivalent command

void vkGetDescriptorSetLayoutSupportKHR(
    VkDevice                                    device,
    const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    VkDescriptorSetLayoutSupport*               pSupport);
Parameters
device is the logical device that would create the descriptor set layout.
pCreateInfo is a pointer to an instance of the VkDescriptorSetLayoutCreateInfo structure specifying the state of the descriptor set layout object.
pSupport points to a VkDescriptorSetLayoutSupport structure in which information about support for the descriptor set layout object is returned.
Description
Some implementations have limitations on what fits in a descriptor set which are not easily expressible in terms of existing limits like maxDescriptorSet*, for example if all descriptor types share a limited space in memory but each descriptor is a different size or alignment. This command returns information about whether a descriptor set satisfies this limit. If the descriptor set layout satisfies the VkPhysicalDeviceMaintenance3Properties::maxPerSetDescriptors limit, this command is guaranteed to return VK_TRUE in VkDescriptorSetLayoutSupport::supported. If the descriptor set layout exceeds the VkPhysicalDeviceMaintenance3Properties::maxPerSetDescriptors limit, whether the descriptor set layout is supported is implementation-dependent and may depend on whether the descriptor sizes and alignments cause the layout to exceed an internal limit.

This command does not consider other limits such as maxPerStageDescriptor*, and so a descriptor set layout that is supported according to this command must still satisfy the pipeline layout limits such as maxPerStageDescriptor* in order to be used in a pipeline layout.

Note
This is a VkDevice query rather than VkPhysicalDevice because the answer may depend on enabled features.
Valid Usage (Implicit)
device must be a valid VkDevice handle
pCreateInfo must be a valid pointer to a valid VkDescriptorSetLayoutCreateInfo structure
pSupport must be a valid pointer to a VkDescriptorSetLayoutSupport structure
See Also
VkDescriptorSetLayoutCreateInfo, VkDescriptorSetLayoutSupport, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDescriptorSetLayoutSupport

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDeviceGroupPeerMemoryFeatures(3)
Name
vkGetDeviceGroupPeerMemoryFeatures - Query supported peer memory features of a device

C Specification
Peer memory is memory that is allocated for a given physical device and then bound to a resource and accessed by a different physical device, in a logical device that represents multiple physical devices. Some ways of reading and writing peer memory may not be supported by a device.

To determine how peer memory can be accessed, call:

void vkGetDeviceGroupPeerMemoryFeatures(
    VkDevice                                    device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    VkPeerMemoryFeatureFlags*                   pPeerMemoryFeatures);
or the equivalent command

void vkGetDeviceGroupPeerMemoryFeaturesKHR(
    VkDevice                                    device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    VkPeerMemoryFeatureFlags*                   pPeerMemoryFeatures);
Parameters
device is the logical device that owns the memory.
heapIndex is the index of the memory heap from which the memory is allocated.
localDeviceIndex is the device index of the physical device that performs the memory access.
remoteDeviceIndex is the device index of the physical device that the memory is allocated for.
pPeerMemoryFeatures is a pointer to a bitmask of VkPeerMemoryFeatureFlagBits indicating which types of memory accesses are supported for the combination of heap, local, and remote devices.
Description
Valid Usage
heapIndex must be less than memoryHeapCount
localDeviceIndex must be a valid device index
remoteDeviceIndex must be a valid device index
localDeviceIndex must not equal remoteDeviceIndex
Valid Usage (Implicit)
device must be a valid VkDevice handle
pPeerMemoryFeatures must be a valid pointer to a VkPeerMemoryFeatureFlags value
See Also
VkDevice, VkPeerMemoryFeatureFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDeviceGroupPeerMemoryFeatures

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDeviceGroupPresentCapabilitiesKHR(3)
Name
vkGetDeviceGroupPresentCapabilitiesKHR - Query present capabilities from other physical devices

C Specification
A logical device that represents multiple physical devices may support presenting from images on more than one physical device, or combining images from multiple physical devices.

To query these capabilities, call:

VkResult vkGetDeviceGroupPresentCapabilitiesKHR(
    VkDevice                                    device,
    VkDeviceGroupPresentCapabilitiesKHR*        pDeviceGroupPresentCapabilities);
Parameters
device is the logical device.
pDeviceGroupPresentCapabilities is a pointer to a structure of type VkDeviceGroupPresentCapabilitiesKHR that is filled with the logical device’s capabilities.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pDeviceGroupPresentCapabilities must be a valid pointer to a VkDeviceGroupPresentCapabilitiesKHR structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkDeviceGroupPresentCapabilitiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDeviceGroupPresentCapabilitiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDeviceGroupSurfacePresentModes2EXT(3)
Name
vkGetDeviceGroupSurfacePresentModes2EXT - Query device group present capabilities for a surface

C Specification
Alternatively, to query the supported device group presentation modes for a surface combined with select other fixed swapchain creation parameters, call:

VkResult vkGetDeviceGroupSurfacePresentModes2EXT(
    VkDevice                                    device,
    const VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
    VkDeviceGroupPresentModeFlagsKHR*           pModes);
Parameters
device is the logical device.
pSurfaceInfo points to an instance of the VkPhysicalDeviceSurfaceInfo2KHR structure, describing the surface and other fixed parameters that would be consumed by vkCreateSwapchainKHR.
pModes is a pointer to a value of type VkDeviceGroupPresentModeFlagsKHR that is filled with the supported device group present modes for the surface.
Description
vkGetDeviceGroupSurfacePresentModes2EXT behaves similarly to vkGetDeviceGroupSurfacePresentModesKHR, with the ability to specify extended inputs via chained input structures.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure
pModes must be a valid pointer to a VkDeviceGroupPresentModeFlagsKHR value
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_SURFACE_LOST_KHR
See Also
VkDevice, VkDeviceGroupPresentModeFlagsKHR, VkPhysicalDeviceSurfaceInfo2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDeviceGroupSurfacePresentModes2EXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDeviceGroupSurfacePresentModesKHR(3)
Name
vkGetDeviceGroupSurfacePresentModesKHR - Query present capabilities for a surface

C Specification
Some surfaces may not be capable of using all the device group present modes.

To query the supported device group present modes for a particular surface, call:

VkResult vkGetDeviceGroupSurfacePresentModesKHR(
    VkDevice                                    device,
    VkSurfaceKHR                                surface,
    VkDeviceGroupPresentModeFlagsKHR*           pModes);
Parameters
device is the logical device.
surface is the surface.
pModes is a pointer to a value of type VkDeviceGroupPresentModeFlagsKHR that is filled with the supported device group present modes for the surface.
Description
The modes returned by this command are not invariant, and may change in response to the surface being moved, resized, or occluded. These modes must be a subset of the modes returned by vkGetDeviceGroupPresentCapabilitiesKHR.

Valid Usage (Implicit)
device must be a valid VkDevice handle
surface must be a valid VkSurfaceKHR handle
pModes must be a valid pointer to a VkDeviceGroupPresentModeFlagsKHR value
Both of device, and surface must have been created, allocated, or retrieved from the same VkInstance
Host Synchronization
Host access to surface must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_SURFACE_LOST_KHR
See Also
VkDevice, VkDeviceGroupPresentModeFlagsKHR, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDeviceGroupSurfacePresentModesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDeviceMemoryCommitment(3)
Name
vkGetDeviceMemoryCommitment - Query the current commitment for a VkDeviceMemory

C Specification
To determine the amount of lazily-allocated memory that is currently committed for a memory object, call:

void vkGetDeviceMemoryCommitment(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize*                               pCommittedMemoryInBytes);
Parameters
device is the logical device that owns the memory.
memory is the memory object being queried.
pCommittedMemoryInBytes is a pointer to a VkDeviceSize value in which the number of bytes currently committed is returned, on success.
Description
The implementation may update the commitment at any time, and the value returned by this query may be out of date.

The implementation guarantees to allocate any committed memory from the heapIndex indicated by the memory type that the memory object was created with.

Valid Usage
memory must have been created with a memory type that reports VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT
Valid Usage (Implicit)
device must be a valid VkDevice handle
memory must be a valid VkDeviceMemory handle
pCommittedMemoryInBytes must be a valid pointer to a VkDeviceSize value
memory must have been created, allocated, or retrieved from device
See Also
VkDevice, VkDeviceMemory, VkDeviceSize

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDeviceMemoryCommitment

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDeviceProcAddr(3)
Name
vkGetDeviceProcAddr - Return a function pointer for a command

C Specification
In order to support systems with multiple Vulkan implementations, the function pointers returned by vkGetInstanceProcAddr may point to dispatch code that calls a different real implementation for different VkDevice objects or their child objects. The overhead of the internal dispatch for VkDevice objects can be avoided by obtaining device-specific function pointers for any commands that use a device or device-child object as their dispatchable object. Such function pointers can be obtained with the command:

PFN_vkVoidFunction vkGetDeviceProcAddr(
    VkDevice                                    device,
    const char*                                 pName);
Parameters
The table below defines the various use cases for vkGetDeviceProcAddr and expected return value for each case.

Description
The returned function pointer is of type PFN_vkVoidFunction, and must be cast to the type of the command being queried. The function pointer must only be called with a dispatchable object (the first parameter) that is device or a child of device.

Table 1. vkGetDeviceProcAddr behavior
device	pName	return value
NULL
*
undefined
invalid device
*
undefined
device
NULL
undefined
device
core device-level Vulkan command
fp
device
enabled device extension commands
fp
device
* (any pName not covered above)
NULL
Valid Usage (Implicit)
device must be a valid VkDevice handle
pName must be a null-terminated UTF-8 string
See Also
PFN_vkVoidFunction, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDeviceProcAddr

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDeviceQueue(3)
Name
vkGetDeviceQueue - Get a queue handle from a device

C Specification
To retrieve a handle to a VkQueue object, call:

void vkGetDeviceQueue(
    VkDevice                                    device,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex,
    VkQueue*                                    pQueue);
Parameters
device is the logical device that owns the queue.
queueFamilyIndex is the index of the queue family to which the queue belongs.
queueIndex is the index within this queue family of the queue to retrieve.
pQueue is a pointer to a VkQueue object that will be filled with the handle for the requested queue.
Description
vkGetDeviceQueue must only be used to get queues that were created with the flags parameter of VkDeviceQueueCreateInfo set to zero. To get queues that were created with a non-zero flags parameter use vkGetDeviceQueue2.

Valid Usage
queueFamilyIndex must be one of the queue family indices specified when device was created, via the VkDeviceQueueCreateInfo structure
queueIndex must be less than the number of queues created for the specified queue family index when device was created, via the queueCount member of the VkDeviceQueueCreateInfo structure
VkDeviceQueueCreateInfo::flags must have been set to zero when device was created
Valid Usage (Implicit)
device must be a valid VkDevice handle
pQueue must be a valid pointer to a VkQueue handle
See Also
VkDevice, VkQueue

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDeviceQueue

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDeviceQueue2(3)
Name
vkGetDeviceQueue2 - Get a queue handle from a device

C Specification
To retrieve a handle to a VkQueue object with specific VkDeviceQueueCreateFlags creation flags, call:

void vkGetDeviceQueue2(
    VkDevice                                    device,
    const VkDeviceQueueInfo2*                   pQueueInfo,
    VkQueue*                                    pQueue);
Parameters
device is the logical device that owns the queue.
pQueueInfo points to an instance of the VkDeviceQueueInfo2 structure, describing the parameters used to create the device queue.
pQueue is a pointer to a VkQueue object that will be filled with the handle for the requested queue.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pQueueInfo must be a valid pointer to a valid VkDeviceQueueInfo2 structure
pQueue must be a valid pointer to a VkQueue handle
See Also
VkDevice, VkDeviceQueueInfo2, VkQueue

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDeviceQueue2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDisplayModeProperties2KHR(3)
Name
vkGetDisplayModeProperties2KHR - Query information about the available display modes.

C Specification
To query the properties of a device’s built-in display modes, call:

VkResult vkGetDisplayModeProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    uint32_t*                                   pPropertyCount,
    VkDisplayModeProperties2KHR*                pProperties);
Parameters
physicalDevice is the physical device associated with display.
display is the display to query.
pPropertyCount is a pointer to an integer related to the number of display modes available or queried, as described below.
pProperties is either NULL or a pointer to an array of VkDisplayModeProperties2KHR structures.
Description
vkGetDisplayModeProperties2KHR behaves similarly to vkGetDisplayModePropertiesKHR, with the ability to return extended information via chained output structures.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
display must be a valid VkDisplayKHR handle
pPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayModeProperties2KHR structures
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDisplayKHR, VkDisplayModeProperties2KHR, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDisplayModeProperties2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDisplayModePropertiesKHR(3)
Name
vkGetDisplayModePropertiesKHR - Query the set of mode properties supported by the display

C Specification
Each display has one or more supported modes associated with it by default. These built-in modes are queried by calling:

VkResult vkGetDisplayModePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    uint32_t*                                   pPropertyCount,
    VkDisplayModePropertiesKHR*                 pProperties);
Parameters
physicalDevice is the physical device associated with display.
display is the display to query.
pPropertyCount is a pointer to an integer related to the number of display modes available or queried, as described below.
pProperties is either NULL or a pointer to an array of VkDisplayModePropertiesKHR structures.
Description
If pProperties is NULL, then the number of display modes available on the specified display for physicalDevice is returned in pPropertyCount. Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties. If the value of pPropertyCount is less than the number of display modes for physicalDevice, at most pPropertyCount structures will be written. If pPropertyCount is smaller than the number of display modes available on the specified display for physicalDevice, VK_INCOMPLETE will be returned instead of VK_SUCCESS to indicate that not all the available values were returned.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
display must be a valid VkDisplayKHR handle
pPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayModePropertiesKHR structures
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDisplayKHR, VkDisplayModePropertiesKHR, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDisplayModePropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDisplayPlaneCapabilities2KHR(3)
Name
vkGetDisplayPlaneCapabilities2KHR - Query capabilities of a mode and plane combination

C Specification
To query the capabilities of a given mode and plane combination, call:

VkResult vkGetDisplayPlaneCapabilities2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkDisplayPlaneInfo2KHR*               pDisplayPlaneInfo,
    VkDisplayPlaneCapabilities2KHR*             pCapabilities);
Parameters
physicalDevice is the physical device associated with pDisplayPlaneInfo.
pDisplayPlaneInfo is a pointer to an instance of the VkDisplayPlaneInfo2KHR structure describing the plane and mode.
pCapabilities is a pointer to a VkDisplayPlaneCapabilities2KHR structure in which the capabilities are returned.
Description
vkGetDisplayPlaneCapabilities2KHR behaves similarly to vkGetDisplayPlaneCapabilitiesKHR, with the ability to specify extended inputs via chained input structures, and to return extended information via chained output structures.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pDisplayPlaneInfo must be a valid pointer to a valid VkDisplayPlaneInfo2KHR structure
pCapabilities must be a valid pointer to a VkDisplayPlaneCapabilities2KHR structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDisplayPlaneCapabilities2KHR, VkDisplayPlaneInfo2KHR, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDisplayPlaneCapabilities2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDisplayPlaneCapabilitiesKHR(3)
Name
vkGetDisplayPlaneCapabilitiesKHR - Query capabilities of a mode and plane combination

C Specification
Applications that wish to present directly to a display must select which layer, or “plane” of the display they wish to target, and a mode to use with the display. Each display supports at least one plane. The capabilities of a given mode and plane combination are determined by calling:

VkResult vkGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayModeKHR                            mode,
    uint32_t                                    planeIndex,
    VkDisplayPlaneCapabilitiesKHR*              pCapabilities);
Parameters
physicalDevice is the physical device associated with display
mode is the display mode the application intends to program when using the specified plane. Note this parameter also implicitly specifies a display.
planeIndex is the plane which the application intends to use with the display, and is less than the number of display planes supported by the device.
pCapabilities is a pointer to a VkDisplayPlaneCapabilitiesKHR structure in which the capabilities are returned.
Description
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
mode must be a valid VkDisplayModeKHR handle
pCapabilities must be a valid pointer to a VkDisplayPlaneCapabilitiesKHR structure
Host Synchronization
Host access to mode must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDisplayModeKHR, VkDisplayPlaneCapabilitiesKHR, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDisplayPlaneCapabilitiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetDisplayPlaneSupportedDisplaysKHR(3)
Name
vkGetDisplayPlaneSupportedDisplaysKHR - Query the list of displays a plane supports

C Specification
To determine which displays a plane is usable with, call

VkResult vkGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    planeIndex,
    uint32_t*                                   pDisplayCount,
    VkDisplayKHR*                               pDisplays);
Parameters
physicalDevice is a physical device.
planeIndex is the plane which the application wishes to use, and must be in the range [0, physical device plane count - 1].
pDisplayCount is a pointer to an integer related to the number of displays available or queried, as described below.
pDisplays is either NULL or a pointer to an array of VkDisplayKHR handles.
Description
If pDisplays is NULL, then the number of displays usable with the specified planeIndex for physicalDevice is returned in pDisplayCount. Otherwise, pDisplayCount must point to a variable set by the user to the number of elements in the pDisplays array, and on return the variable is overwritten with the number of handles actually written to pDisplays. If the value of pDisplayCount is less than the number of display planes for physicalDevice, at most pDisplayCount handles will be written. If pDisplayCount is smaller than the number of displays usable with the specified planeIndex for physicalDevice, VK_INCOMPLETE will be returned instead of VK_SUCCESS to indicate that not all the available values were returned.

Valid Usage
planeIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pDisplayCount must be a valid pointer to a uint32_t value
If the value referenced by pDisplayCount is not 0, and pDisplays is not NULL, pDisplays must be a valid pointer to an array of pDisplayCount VkDisplayKHR handles
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDisplayKHR, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetDisplayPlaneSupportedDisplaysKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetEventStatus(3)
Name
vkGetEventStatus - Retrieve the status of an event object

C Specification
To query the state of an event from the host, call:

VkResult vkGetEventStatus(
    VkDevice                                    device,
    VkEvent                                     event);
Parameters
device is the logical device that owns the event.
event is the handle of the event to query.
Description
Upon success, vkGetEventStatus returns the state of the event object with the following return codes:

Table 2. Event Object Status Codes
Status	Meaning
VK_EVENT_SET
The event specified by event is signaled.
VK_EVENT_RESET
The event specified by event is unsignaled.
If a vkCmdSetEvent or vkCmdResetEvent command is in a command buffer that is in the pending state, then the value returned by this command may immediately be out of date.

The state of an event can be updated by the host. The state of the event is immediately changed, and subsequent calls to vkGetEventStatus will return the new state. If an event is already in the requested state, then updating it to the same state has no effect.

Valid Usage (Implicit)
device must be a valid VkDevice handle
event must be a valid VkEvent handle
event must have been created, allocated, or retrieved from device
Return Codes
Success
VK_EVENT_SET
VK_EVENT_RESET
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
See Also
VkDevice, VkEvent

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetEventStatus

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetFenceFdKHR(3)
Name
vkGetFenceFdKHR - Get a POSIX file descriptor handle for a fence

C Specification
To export a POSIX file descriptor representing the payload of a fence, call:

VkResult vkGetFenceFdKHR(
    VkDevice                                    device,
    const VkFenceGetFdInfoKHR*                  pGetFdInfo,
    int*                                        pFd);
Parameters
device is the logical device that created the fence being exported.
pGetFdInfo is a pointer to an instance of the VkFenceGetFdInfoKHR structure containing parameters of the export operation.
pFd will return the file descriptor representing the fence payload.
Description
Each call to vkGetFenceFdKHR must create a new file descriptor and transfer ownership of it to the application. To avoid leaking resources, the application must release ownership of the file descriptor when it is no longer needed.

Note
Ownership can be released in many ways. For example, the application can call close() on the file descriptor, or transfer ownership back to Vulkan by using the file descriptor to import a fence payload.
If pGetFdInfo->handleType is VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT and the fence is signaled at the time vkGetFenceFdKHR is called, pFd may return the value -1 instead of a valid file descriptor.

Where supported by the operating system, the implementation must set the file descriptor to be closed automatically when an execve system call is made.

Exporting a file descriptor from a fence may have side effects depending on the transference of the specified handle type, as described in Importing Fence State.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pGetFdInfo must be a valid pointer to a valid VkFenceGetFdInfoKHR structure
pFd must be a valid pointer to a int value
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_TOO_MANY_OBJECTS
VK_ERROR_OUT_OF_HOST_MEMORY
See Also
VkDevice, VkFenceGetFdInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetFenceFdKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetFenceStatus(3)
Name
vkGetFenceStatus - Return the status of a fence

C Specification
To query the status of a fence from the host, call:

VkResult vkGetFenceStatus(
    VkDevice                                    device,
    VkFence                                     fence);
Parameters
device is the logical device that owns the fence.
fence is the handle of the fence to query.
Description
Upon success, vkGetFenceStatus returns the status of the fence object, with the following return codes:

Table 3. Fence Object Status Codes
Status	Meaning
VK_SUCCESS
The fence specified by fence is signaled.
VK_NOT_READY
The fence specified by fence is unsignaled.
VK_ERROR_DEVICE_LOST
The device has been lost. See Lost Device.
If a queue submission command is pending execution, then the value returned by this command may immediately be out of date.

If the device has been lost (see Lost Device), vkGetFenceStatus may return any of the above status codes. If the device has been lost and vkGetFenceStatus is called repeatedly, it will eventually return either VK_SUCCESS or VK_ERROR_DEVICE_LOST.

Valid Usage (Implicit)
device must be a valid VkDevice handle
fence must be a valid VkFence handle
fence must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
VK_NOT_READY
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
See Also
VkDevice, VkFence

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetFenceStatus

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetFenceWin32HandleKHR(3)
Name
vkGetFenceWin32HandleKHR - Get a Windows HANDLE for a fence

C Specification
To export a Windows handle representing the state of a fence, call:

VkResult vkGetFenceWin32HandleKHR(
    VkDevice                                    device,
    const VkFenceGetWin32HandleInfoKHR*         pGetWin32HandleInfo,
    HANDLE*                                     pHandle);
Parameters
device is the logical device that created the fence being exported.
pGetWin32HandleInfo is a pointer to an instance of the VkFenceGetWin32HandleInfoKHR structure containing parameters of the export operation.
pHandle will return the Windows handle representing the fence state.
Description
For handle types defined as NT handles, the handles returned by vkGetFenceWin32HandleKHR are owned by the application. To avoid leaking resources, the application must release ownership of them using the CloseHandle system call when they are no longer needed.

Exporting a Windows handle from a fence may have side effects depending on the transference of the specified handle type, as described in Importing Fence Payloads.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pGetWin32HandleInfo must be a valid pointer to a valid VkFenceGetWin32HandleInfoKHR structure
pHandle must be a valid pointer to a HANDLE value
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_TOO_MANY_OBJECTS
VK_ERROR_OUT_OF_HOST_MEMORY
See Also
VkDevice, VkFenceGetWin32HandleInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetFenceWin32HandleKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetImageDrmFormatModifierPropertiesEXT(3)
Name
vkGetImageDrmFormatModifierPropertiesEXT - Returns an image’s DRM format modifier

C Specification
If an image was created with VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the image has a Linux DRM format modifier. To query the modifier, call:

VkResult vkGetImageDrmFormatModifierPropertiesEXT(
    VkDevice                                    device,
    VkImage                                     image,
    VkImageDrmFormatModifierPropertiesEXT*      pProperties);
Parameters
device is the logical device that owns the image.
image is the queried image.
pProperties will return properties of the image’s DRM format modifier.
Description
Valid Usage
image must have been created with tiling equal to VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT.
Valid Usage (Implicit)
device must be a valid VkDevice handle
image must be a valid VkImage handle
pProperties must be a valid pointer to a VkImageDrmFormatModifierPropertiesEXT structure
image must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
See Also
VkDevice, VkImage, VkImageDrmFormatModifierPropertiesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetImageDrmFormatModifierPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetImageMemoryRequirements(3)
Name
vkGetImageMemoryRequirements - Returns the memory requirements for specified Vulkan object

C Specification
To determine the memory requirements for an image resource which is not created with the VK_IMAGE_CREATE_DISJOINT_BIT flag set, call:

void vkGetImageMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    VkMemoryRequirements*                       pMemoryRequirements);
Parameters
device is the logical device that owns the image.
image is the image to query.
pMemoryRequirements points to an instance of the VkMemoryRequirements structure in which the memory requirements of the image object are returned.
Description
Valid Usage
image must not have been created with the VK_IMAGE_CREATE_DISJOINT_BIT flag set
Valid Usage (Implicit)
device must be a valid VkDevice handle
image must be a valid VkImage handle
pMemoryRequirements must be a valid pointer to a VkMemoryRequirements structure
image must have been created, allocated, or retrieved from device
See Also
VkDevice, VkImage, VkMemoryRequirements

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetImageMemoryRequirements

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetImageMemoryRequirements2(3)
Name
vkGetImageMemoryRequirements2 - Returns the memory requirements for specified Vulkan object

C Specification
To determine the memory requirements for an image resource, call:

void vkGetImageMemoryRequirements2(
    VkDevice                                    device,
    const VkImageMemoryRequirementsInfo2*       pInfo,
    VkMemoryRequirements2*                      pMemoryRequirements);
or the equivalent command

void vkGetImageMemoryRequirements2KHR(
    VkDevice                                    device,
    const VkImageMemoryRequirementsInfo2*       pInfo,
    VkMemoryRequirements2*                      pMemoryRequirements);
Parameters
device is the logical device that owns the image.
pInfo is a pointer to an instance of the VkImageMemoryRequirementsInfo2 structure containing parameters required for the memory requirements query.
pMemoryRequirements points to an instance of the VkMemoryRequirements2 structure in which the memory requirements of the image object are returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pInfo must be a valid pointer to a valid VkImageMemoryRequirementsInfo2 structure
pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure
See Also
VkDevice, VkImageMemoryRequirementsInfo2, VkMemoryRequirements2

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetImageMemoryRequirements2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetImageSparseMemoryRequirements(3)
Name
vkGetImageSparseMemoryRequirements - Query the memory requirements for a sparse image

C Specification
To query sparse memory requirements for an image, call:

void vkGetImageSparseMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements*            pSparseMemoryRequirements);
Parameters
device is the logical device that owns the image.
image is the VkImage object to get the memory requirements for.
pSparseMemoryRequirementCount is a pointer to an integer related to the number of sparse memory requirements available or queried, as described below.
pSparseMemoryRequirements is either NULL or a pointer to an array of VkSparseImageMemoryRequirements structures.
Description
If pSparseMemoryRequirements is NULL, then the number of sparse memory requirements available is returned in pSparseMemoryRequirementCount. Otherwise, pSparseMemoryRequirementCount must point to a variable set by the user to the number of elements in the pSparseMemoryRequirements array, and on return the variable is overwritten with the number of structures actually written to pSparseMemoryRequirements. If pSparseMemoryRequirementCount is less than the number of sparse memory requirements available, at most pSparseMemoryRequirementCount structures will be written.

If the image was not created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT then pSparseMemoryRequirementCount will be set to zero and pSparseMemoryRequirements will not be written to.

Note
It is legal for an implementation to report a larger value in VkMemoryRequirements::size than would be obtained by adding together memory sizes for all VkSparseImageMemoryRequirements returned by vkGetImageSparseMemoryRequirements. This may occur when the implementation requires unused padding in the address range describing the resource.
Valid Usage (Implicit)
device must be a valid VkDevice handle
image must be a valid VkImage handle
pSparseMemoryRequirementCount must be a valid pointer to a uint32_t value
If the value referenced by pSparseMemoryRequirementCount is not 0, and pSparseMemoryRequirements is not NULL, pSparseMemoryRequirements must be a valid pointer to an array of pSparseMemoryRequirementCount VkSparseImageMemoryRequirements structures
image must have been created, allocated, or retrieved from device
See Also
VkDevice, VkImage, VkSparseImageMemoryRequirements

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetImageSparseMemoryRequirements

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetImageSparseMemoryRequirements2(3)
Name
vkGetImageSparseMemoryRequirements2 - Query the memory requirements for a sparse image

C Specification
To query sparse memory requirements for an image, call:

void vkGetImageSparseMemoryRequirements2(
    VkDevice                                    device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2*           pSparseMemoryRequirements);
or the equivalent command

void vkGetImageSparseMemoryRequirements2KHR(
    VkDevice                                    device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2*           pSparseMemoryRequirements);
Parameters
device is the logical device that owns the image.
pInfo is a pointer to an instance of the VkImageSparseMemoryRequirementsInfo2 structure containing parameters required for the memory requirements query.
pSparseMemoryRequirementCount is a pointer to an integer related to the number of sparse memory requirements available or queried, as described below.
pSparseMemoryRequirements is either NULL or a pointer to an array of VkSparseImageMemoryRequirements2 structures.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pInfo must be a valid pointer to a valid VkImageSparseMemoryRequirementsInfo2 structure
pSparseMemoryRequirementCount must be a valid pointer to a uint32_t value
If the value referenced by pSparseMemoryRequirementCount is not 0, and pSparseMemoryRequirements is not NULL, pSparseMemoryRequirements must be a valid pointer to an array of pSparseMemoryRequirementCount VkSparseImageMemoryRequirements2 structures
See Also
VkDevice, VkImageSparseMemoryRequirementsInfo2, VkSparseImageMemoryRequirements2

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetImageSparseMemoryRequirements2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetImageSubresourceLayout(3)
Name
vkGetImageSubresourceLayout - Retrieve information about an image subresource

C Specification
To query the memory layout of an image subresource, call:

void vkGetImageSubresourceLayout(
    VkDevice                                    device,
    VkImage                                     image,
    const VkImageSubresource*                   pSubresource,
    VkSubresourceLayout*                        pLayout);
Parameters
device is the logical device that owns the image.
image is the image whose layout is being queried.
pSubresource is a pointer to a VkImageSubresource structure selecting a specific image for the image subresource.
pLayout points to a VkSubresourceLayout structure in which the layout is returned.
Description
If the image is linear, then the returned layout is valid for host access.

If the image’s tiling is VK_IMAGE_TILING_LINEAR and its format is a multi-planar format, then vkGetImageSubresourceLayout describes one format plane of the image. If the image’s tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then vkGetImageSubresourceLayout describes one memory plane of the image. If the image’s tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT and the image is non-linear, then the returned layout has an implementation-dependent meaning; the vendor of the image’s DRM format modifier may provide documentation that explains how to interpret the returned layout.

vkGetImageSubresourceLayout is invariant for the lifetime of a single image. However, the subresource layout of images in Android hardware buffer external memory is not known until the image has been bound to memory, so applications must not call vkGetImageSubresourceLayout for such an image before it has been bound.

Valid Usage
image must have been created with tiling equal to VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT
The aspectMask member of pSubresource must only have a single bit set
The mipLevel member of pSubresource must be less than the mipLevels specified in VkImageCreateInfo when image was created
The arrayLayer member of pSubresource must be less than the arrayLayers specified in VkImageCreateInfo when image was created
If the tiling of the image is VK_IMAGE_TILING_LINEAR and its format is a multi-planar format with two planes, the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT
If the tiling of the image is VK_IMAGE_TILING_LINEAR and its format is a multi-planar format with three planes, the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or VK_IMAGE_ASPECT_PLANE_2_BIT
If image was created with the VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID external memory handle type, then image must be bound to memory.
If the tiling of the image is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT and the index i must be less than the drmFormatModifierPlaneCount associated with the image’s format and drmFormatModifier.
Valid Usage (Implicit)
device must be a valid VkDevice handle
image must be a valid VkImage handle
pSubresource must be a valid pointer to a valid VkImageSubresource structure
pLayout must be a valid pointer to a VkSubresourceLayout structure
image must have been created, allocated, or retrieved from device
See Also
VkDevice, VkImage, VkImageSubresource, VkSubresourceLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetImageSubresourceLayout

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetImageViewHandleNVX(3)
Name
vkGetImageViewHandleNVX - Get the handle for an image view for a specific descriptor type

C Specification
To get the handle for an image view, call:

uint32_t vkGetImageViewHandleNVX(
    VkDevice                                    device,
    const VkImageViewHandleInfoNVX*             pInfo);
Parameters
device is the logical device that owns the image view.
pInfo describes the image view to query and type of handle.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pInfo must be a valid pointer to a valid VkImageViewHandleInfoNVX structure
See Also
VkDevice, VkImageViewHandleInfoNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetImageViewHandleNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetInstanceProcAddr(3)
Name
vkGetInstanceProcAddr - Return a function pointer for a command

C Specification
Function pointers for all Vulkan commands can be obtained with the command:

PFN_vkVoidFunction vkGetInstanceProcAddr(
    VkInstance                                  instance,
    const char*                                 pName);
Parameters
instance is the instance that the function pointer will be compatible with, or NULL for commands not dependent on any instance.
pName is the name of the command to obtain.
Description
vkGetInstanceProcAddr itself is obtained in a platform- and loader- specific manner. Typically, the loader library will export this command as a function symbol, so applications can link against the loader library, or load it dynamically and look up the symbol using platform-specific APIs.

The table below defines the various use cases for vkGetInstanceProcAddr and expected return value (“fp” is “function pointer”) for each case.

The returned function pointer is of type PFN_vkVoidFunction, and must be cast to the type of the command being queried.

Table 4. vkGetInstanceProcAddr behavior
instance	pName	return value
*
NULL
undefined
invalid instance
*
undefined
NULL
vkEnumerateInstanceVersion
fp
NULL
vkEnumerateInstanceExtensionProperties
fp
NULL
vkEnumerateInstanceLayerProperties
fp
NULL
vkCreateInstance
fp
NULL
* (any pName not covered above)
NULL
instance
core Vulkan command
fp1
instance
enabled instance extension commands for instance
fp1
instance
available device extension2 commands for instance
fp1
instance
* (any pName not covered above)
NULL
1
The returned function pointer must only be called with a dispatchable object (the first parameter) that is instance or a child of instance, e.g. VkInstance, VkPhysicalDevice, VkDevice, VkQueue, or VkCommandBuffer.

2
An “available device extension” is a device extension supported by any physical device enumerated by instance.
Valid Usage (Implicit)
If instance is not NULL, instance must be a valid VkInstance handle
pName must be a null-terminated UTF-8 string
See Also
PFN_vkVoidFunction, VkInstance

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetInstanceProcAddr

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetMemoryAndroidHardwareBufferANDROID(3)
Name
vkGetMemoryAndroidHardwareBufferANDROID - Get an Android hardware buffer for a memory object

C Specification
To export an Android hardware buffer representing the underlying resources of a Vulkan device memory object, call:

VkResult vkGetMemoryAndroidHardwareBufferANDROID(
    VkDevice                                    device,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    struct AHardwareBuffer**                    pBuffer);
Parameters
device is the logical device that created the device memory being exported.
pInfo is a pointer to an instance of the VkMemoryGetAndroidHardwareBufferInfoANDROID structure containing parameters of the export operation.
pBuffer will return an Android hardware buffer representing the underlying resources of the device memory object.
Description
Each call to vkGetMemoryAndroidHardwareBufferANDROID must return an Android hardware buffer with a new reference acquired in addition to the reference held by the VkDeviceMemory. To avoid leaking resources, the application must release the reference by calling AHardwareBuffer_release when it is no longer needed. When called with the same handle in VkMemoryGetAndroidHardwareBufferInfoANDROID::memory, vkGetMemoryAndroidHardwareBufferANDROID must return the same Android hardware buffer object. If the device memory was created by importing an Android hardware buffer, vkGetMemoryAndroidHardwareBufferANDROID must return that same Android hardware buffer object.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pInfo must be a valid pointer to a valid VkMemoryGetAndroidHardwareBufferInfoANDROID structure
pBuffer must be a valid pointer to a valid pointer to a AHardwareBuffer value
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_TOO_MANY_OBJECTS
VK_ERROR_OUT_OF_HOST_MEMORY
See Also
VkDevice, VkMemoryGetAndroidHardwareBufferInfoANDROID

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetMemoryAndroidHardwareBufferANDROID

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetMemoryFdKHR(3)
Name
vkGetMemoryFdKHR - Get a POSIX file descriptor for a memory object

C Specification
To export a POSIX file descriptor representing the underlying resources of a Vulkan device memory object, call:

VkResult vkGetMemoryFdKHR(
    VkDevice                                    device,
    const VkMemoryGetFdInfoKHR*                 pGetFdInfo,
    int*                                        pFd);
Parameters
device is the logical device that created the device memory being exported.
pGetFdInfo is a pointer to an instance of the VkMemoryGetFdInfoKHR structure containing parameters of the export operation.
pFd will return a file descriptor representing the underlying resources of the device memory object.
Description
Each call to vkGetMemoryFdKHR must create a new file descriptor and transfer ownership of it to the application. To avoid leaking resources, the application must release ownership of the file descriptor using the close system call when it is no longer needed, or by importing a Vulkan memory object from it. Where supported by the operating system, the implementation must set the file descriptor to be closed automatically when an execve system call is made.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pGetFdInfo must be a valid pointer to a valid VkMemoryGetFdInfoKHR structure
pFd must be a valid pointer to a int value
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_TOO_MANY_OBJECTS
VK_ERROR_OUT_OF_HOST_MEMORY
See Also
VkDevice, VkMemoryGetFdInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetMemoryFdKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetMemoryFdPropertiesKHR(3)
Name
vkGetMemoryFdPropertiesKHR - Get Properties of External Memory File Descriptors

C Specification
POSIX file descriptor memory handles compatible with Vulkan may also be created by non-Vulkan APIs using methods beyond the scope of this specification. To determine the correct parameters to use when importing such handles, call:

VkResult vkGetMemoryFdPropertiesKHR(
    VkDevice                                    device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    int                                         fd,
    VkMemoryFdPropertiesKHR*                    pMemoryFdProperties);
Parameters
device is the logical device that will be importing fd.
handleType is the type of the handle fd.
fd is the handle which will be imported.
pMemoryFdProperties is a pointer to a VkMemoryFdPropertiesKHR structure in which the properties of the handle fd are returned.
Description
Valid Usage
fd must be an external memory handle created outside of the Vulkan API.
handleType must not be VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR.
Valid Usage (Implicit)
device must be a valid VkDevice handle
handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
pMemoryFdProperties must be a valid pointer to a VkMemoryFdPropertiesKHR structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_INVALID_EXTERNAL_HANDLE
See Also
VkDevice, VkExternalMemoryHandleTypeFlagBits, VkMemoryFdPropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetMemoryFdPropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetMemoryHostPointerPropertiesEXT(3)
Name
vkGetMemoryHostPointerPropertiesEXT - Get properties of external memory host pointer

C Specification
To determine the correct parameters to use when importing host pointers, call:

VkResult vkGetMemoryHostPointerPropertiesEXT(
    VkDevice                                    device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    const void*                                 pHostPointer,
    VkMemoryHostPointerPropertiesEXT*           pMemoryHostPointerProperties);
Parameters
device is the logical device that will be importing pHostPointer.
handleType is the type of the handle pHostPointer.
pHostPointer is the host pointer to import from.
pMemoryHostPointerProperties is a pointer to a VkMemoryHostPointerPropertiesEXT structure in which the host pointer properties are returned.
Description
Valid Usage
handleType must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT
pHostPointer must be a pointer aligned to an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment
If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT, pHostPointer must be a pointer to host memory
If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT, pHostPointer must be a pointer to host mapped foreign memory
Valid Usage (Implicit)
device must be a valid VkDevice handle
handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
pMemoryHostPointerProperties must be a valid pointer to a VkMemoryHostPointerPropertiesEXT structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_INVALID_EXTERNAL_HANDLE
See Also
VkDevice, VkExternalMemoryHandleTypeFlagBits, VkMemoryHostPointerPropertiesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetMemoryHostPointerPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetMemoryWin32HandleKHR(3)
Name
vkGetMemoryWin32HandleKHR - Get a Windows HANDLE for a memory object

C Specification
To export a Windows handle representing the underlying resources of a Vulkan device memory object, call:

VkResult vkGetMemoryWin32HandleKHR(
    VkDevice                                    device,
    const VkMemoryGetWin32HandleInfoKHR*        pGetWin32HandleInfo,
    HANDLE*                                     pHandle);
Parameters
device is the logical device that created the device memory being exported.
pGetWin32HandleInfo is a pointer to an instance of the VkMemoryGetWin32HandleInfoKHR structure containing parameters of the export operation.
pHandle will return the Windows handle representing the underlying resources of the device memory object.
Description
For handle types defined as NT handles, the handles returned by vkGetMemoryWin32HandleKHR are owned by the application. To avoid leaking resources, the application must release ownership of them using the CloseHandle system call when they are no longer needed.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pGetWin32HandleInfo must be a valid pointer to a valid VkMemoryGetWin32HandleInfoKHR structure
pHandle must be a valid pointer to a HANDLE value
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_TOO_MANY_OBJECTS
VK_ERROR_OUT_OF_HOST_MEMORY
See Also
VkDevice, VkMemoryGetWin32HandleInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetMemoryWin32HandleKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetMemoryWin32HandleNV(3)
Name
vkGetMemoryWin32HandleNV - retrieve Win32 handle to a device memory object

C Specification
To retrieve the handle corresponding to a device memory object created with VkExportMemoryAllocateInfoNV::handleTypes set to include VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV or VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV, call:

VkResult vkGetMemoryWin32HandleNV(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    HANDLE*                                     pHandle);
Parameters
device is the logical device that owns the memory.
memory is the VkDeviceMemory object.
handleType is a bitmask of VkExternalMemoryHandleTypeFlagBitsNV containing a single bit specifying the type of handle requested.
handle points to a Windows HANDLE in which the handle is returned.
Description
Valid Usage
handleType must be a flag specified in VkExportMemoryAllocateInfoNV::handleTypes when allocating memory
Valid Usage (Implicit)
device must be a valid VkDevice handle
memory must be a valid VkDeviceMemory handle
handleType must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values
handleType must not be 0
pHandle must be a valid pointer to a HANDLE value
memory must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_TOO_MANY_OBJECTS
VK_ERROR_OUT_OF_HOST_MEMORY
See Also
VkDevice, VkDeviceMemory, VkExternalMemoryHandleTypeFlagsNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetMemoryWin32HandleNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetMemoryWin32HandlePropertiesKHR(3)
Name
vkGetMemoryWin32HandlePropertiesKHR - Get Properties of External Memory Win32 Handles

C Specification
Windows memory handles compatible with Vulkan may also be created by non-Vulkan APIs using methods beyond the scope of this specification. To determine the correct parameters to use when importing such handles, call:

VkResult vkGetMemoryWin32HandlePropertiesKHR(
    VkDevice                                    device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    HANDLE                                      handle,
    VkMemoryWin32HandlePropertiesKHR*           pMemoryWin32HandleProperties);
Parameters
device is the logical device that will be importing handle.
handleType is the type of the handle handle.
handle is the handle which will be imported.
pMemoryWin32HandleProperties will return properties of handle.
Description
Valid Usage
handle must be an external memory handle created outside of the Vulkan API.
handleType must not be one of the handle types defined as opaque.
Valid Usage (Implicit)
device must be a valid VkDevice handle
handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
pMemoryWin32HandleProperties must be a valid pointer to a VkMemoryWin32HandlePropertiesKHR structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_INVALID_EXTERNAL_HANDLE
See Also
VkDevice, VkExternalMemoryHandleTypeFlagBits, VkMemoryWin32HandlePropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetMemoryWin32HandlePropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPastPresentationTimingGOOGLE(3)
Name
vkGetPastPresentationTimingGOOGLE - Obtain timing of a previously-presented image

C Specification
The implementation will maintain a limited amount of history of timing information about previous presents. Because of the asynchronous nature of the presentation engine, the timing information for a given vkQueuePresentKHR command will become available some time later. These time values can be asynchronously queried, and will be returned if available. All time values are in nanoseconds, relative to a monotonically-increasing clock (e.g. CLOCK_MONOTONIC (see clock_gettime(2)) on Android and Linux).

To asynchronously query the presentation engine, for newly-available timing information about one or more previous presents to a given swapchain, call:

VkResult vkGetPastPresentationTimingGOOGLE(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t*                                   pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE*             pPresentationTimings);
Parameters
device is the device associated with swapchain.
swapchain is the swapchain to obtain presentation timing information duration for.
pPresentationTimingCount is a pointer to an integer related to the number of VkPastPresentationTimingGOOGLE structures to query, as described below.
pPresentationTimings is either NULL or a pointer to an array of VkPastPresentationTimingGOOGLE structures.
Description
If pPresentationTimings is NULL, then the number of newly-available timing records for the given swapchain is returned in pPresentationTimingCount. Otherwise, pPresentationTimingCount must point to a variable set by the user to the number of elements in the pPresentationTimings array, and on return the variable is overwritten with the number of structures actually written to pPresentationTimings. If the value of pPresentationTimingCount is less than the number of newly-available timing records, at most pPresentationTimingCount structures will be written. If pPresentationTimingCount is smaller than the number of newly-available timing records for the given swapchain, VK_INCOMPLETE will be returned instead of VK_SUCCESS to indicate that not all the available values were returned.

Valid Usage (Implicit)
device must be a valid VkDevice handle
swapchain must be a valid VkSwapchainKHR handle
pPresentationTimingCount must be a valid pointer to a uint32_t value
If the value referenced by pPresentationTimingCount is not 0, and pPresentationTimings is not NULL, pPresentationTimings must be a valid pointer to an array of pPresentationTimingCount VkPastPresentationTimingGOOGLE structures
Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance
Host Synchronization
Host access to swapchain must be externally synchronized
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_DEVICE_LOST
VK_ERROR_OUT_OF_DATE_KHR
VK_ERROR_SURFACE_LOST_KHR
See Also
VkDevice, VkPastPresentationTimingGOOGLE, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPastPresentationTimingGOOGLE

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(3)
Name
vkGetPhysicalDeviceCalibrateableTimeDomainsEXT - Query calibrateable time domains

C Specification
To query the set of time domains for which a physical device supports timestamp calibration, call:

VkResult vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pTimeDomainCount,
    VkTimeDomainEXT*                            pTimeDomains);
Parameters
physicalDevice is the physical device from which to query the set of calibrateable time domains.
pTimeDomainCount is a pointer to an integer related to the number of calibrateable time domains available or queried, as described below.
pTimeDomains is either NULL or a pointer to an array of VkTimeDomainEXT values, indicating the supported calibrateable time domains.
Description
If pTimeDomains is NULL, then the number of calibrateable time domains supported for the given physicalDevice is returned in pTimeDomainCount. Otherwise, pTimeDomainCount must point to a variable set by the user to the number of elements in the pTimeDomains array, and on return the variable is overwritten with the number of values actually written to pTimeDomains. If the value of pTimeDomainCount is less than the number of calibrateable time domains supported, at most pTimeDomainCount values will be written to pTimeDomains. If pTimeDomainCount is smaller than the number of calibrateable time domains supported for the given physicalDevice, VK_INCOMPLETE will be returned instead of VK_SUCCESS to indicate that not all the available values were returned.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pTimeDomainCount must be a valid pointer to a uint32_t value
If the value referenced by pTimeDomainCount is not 0, and pTimeDomains is not NULL, pTimeDomains must be a valid pointer to an array of pTimeDomainCount VkTimeDomainEXT values
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkPhysicalDevice, VkTimeDomainEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceCalibrateableTimeDomainsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(3)
Name
vkGetPhysicalDeviceCooperativeMatrixPropertiesNV - Returns properties describing what cooperative matrix types are supported

C Specification
To enumerate the supported cooperative matrix types and operations, call:

VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkCooperativeMatrixPropertiesNV*            pProperties);
Parameters
physicalDevice is the physical device.
pPropertyCount is a pointer to an integer related to the number of cooperative matrix properties available or queried.
pProperties is either NULL or a pointer to an array of VkCooperativeMatrixPropertiesNV structures.
Description
If pProperties is NULL, then the number of cooperative matrix properties available is returned in pPropertyCount. Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties. If pPropertyCount is less than the number of cooperative matrix properties available, at most pPropertyCount structures will be written. If pPropertyCount is smaller than the number of cooperative matrix properties available, VK_INCOMPLETE will be returned instead of VK_SUCCESS, to indicate that not all the available cooperative matrix properties were returned.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkCooperativeMatrixPropertiesNV structures
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkCooperativeMatrixPropertiesNV, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceCooperativeMatrixPropertiesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceDisplayPlaneProperties2KHR(3)
Name
vkGetPhysicalDeviceDisplayPlaneProperties2KHR - Query information about the available display planes.

C Specification
To query the properties of a device’s display planes, call:

VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPlaneProperties2KHR*               pProperties);
Parameters
physicalDevice is a physical device.
pPropertyCount is a pointer to an integer related to the number of display planes available or queried, as described below.
pProperties is either NULL or a pointer to an array of VkDisplayPlaneProperties2KHR structures.
Description
vkGetPhysicalDeviceDisplayPlaneProperties2KHR behaves similarly to vkGetPhysicalDeviceDisplayPlanePropertiesKHR, with the ability to return extended information via chained output structures.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayPlaneProperties2KHR structures
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDisplayPlaneProperties2KHR, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceDisplayPlaneProperties2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceDisplayPlanePropertiesKHR(3)
Name
vkGetPhysicalDeviceDisplayPlanePropertiesKHR - Query the plane properties

C Specification
Images are presented to individual planes on a display. Devices must support at least one plane on each display. Planes can be stacked and blended to composite multiple images on one display. Devices may support only a fixed stacking order and fixed mapping between planes and displays, or they may allow arbitrary application specified stacking orders and mappings between planes and displays. To query the properties of device display planes, call:

VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPlanePropertiesKHR*                pProperties);
Parameters
physicalDevice is a physical device.
pPropertyCount is a pointer to an integer related to the number of display planes available or queried, as described below.
pProperties is either NULL or a pointer to an array of VkDisplayPlanePropertiesKHR structures.
Description
If pProperties is NULL, then the number of display planes available for physicalDevice is returned in pPropertyCount. Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties. If the value of pPropertyCount is less than the number of display planes for physicalDevice, at most pPropertyCount structures will be written.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayPlanePropertiesKHR structures
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDisplayPlanePropertiesKHR, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceDisplayPlanePropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceDisplayProperties2KHR(3)
Name
vkGetPhysicalDeviceDisplayProperties2KHR - Query information about the available displays

C Specification
To query information about the available displays, call:

VkResult vkGetPhysicalDeviceDisplayProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayProperties2KHR*                    pProperties);
Parameters
physicalDevice is a physical device.
pPropertyCount is a pointer to an integer related to the number of display devices available or queried, as described below.
pProperties is either NULL or a pointer to an array of VkDisplayProperties2KHR structures.
Description
vkGetPhysicalDeviceDisplayProperties2KHR behaves similarly to vkGetPhysicalDeviceDisplayPropertiesKHR, with the ability to return extended information via chained output structures.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayProperties2KHR structures
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDisplayProperties2KHR, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceDisplayProperties2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceDisplayPropertiesKHR(3)
Name
vkGetPhysicalDeviceDisplayPropertiesKHR - Query information about the available displays

C Specification
Various functions are provided for enumerating the available display devices present on a Vulkan physical device. To query information about the available displays, call:

VkResult vkGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPropertiesKHR*                     pProperties);
Parameters
physicalDevice is a physical device.
pPropertyCount is a pointer to an integer related to the number of display devices available or queried, as described below.
pProperties is either NULL or a pointer to an array of VkDisplayPropertiesKHR structures.
Description
If pProperties is NULL, then the number of display devices available for physicalDevice is returned in pPropertyCount. Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties. If the value of pPropertyCount is less than the number of display devices for physicalDevice, at most pPropertyCount structures will be written. If pPropertyCount is smaller than the number of display devices available for physicalDevice, VK_INCOMPLETE will be returned instead of VK_SUCCESS to indicate that not all the available values were returned.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayPropertiesKHR structures
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDisplayPropertiesKHR, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceDisplayPropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceExternalBufferProperties(3)
Name
vkGetPhysicalDeviceExternalBufferProperties - Query external handle types supported by buffers

C Specification
To query the external handle types supported by buffers, call:

void vkGetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo*   pExternalBufferInfo,
    VkExternalBufferProperties*                 pExternalBufferProperties);
or the equivalent command

void vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo*   pExternalBufferInfo,
    VkExternalBufferProperties*                 pExternalBufferProperties);
Parameters
physicalDevice is the physical device from which to query the buffer capabilities.
pExternalBufferInfo points to an instance of the VkPhysicalDeviceExternalBufferInfo structure, describing the parameters that would be consumed by vkCreateBuffer.
pExternalBufferProperties points to an instance of the VkExternalBufferProperties structure in which capabilities are returned.
Description
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pExternalBufferInfo must be a valid pointer to a valid VkPhysicalDeviceExternalBufferInfo structure
pExternalBufferProperties must be a valid pointer to a VkExternalBufferProperties structure
See Also
VkExternalBufferProperties, VkPhysicalDevice, VkPhysicalDeviceExternalBufferInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceExternalBufferProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceExternalFenceProperties(3)
Name
vkGetPhysicalDeviceExternalFenceProperties - Function for querying external fence handle capabilities.

C Specification
Fences may support import and export of their payload to external handles. To query the external handle types supported by fences, call:

void vkGetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo*    pExternalFenceInfo,
    VkExternalFenceProperties*                  pExternalFenceProperties);
or the equivalent command

void vkGetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo*    pExternalFenceInfo,
    VkExternalFenceProperties*                  pExternalFenceProperties);
Parameters
physicalDevice is the physical device from which to query the fence capabilities.
pExternalFenceInfo points to an instance of the VkPhysicalDeviceExternalFenceInfo structure, describing the parameters that would be consumed by vkCreateFence.
pExternalFenceProperties points to an instance of the VkExternalFenceProperties structure in which capabilities are returned.
Description
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pExternalFenceInfo must be a valid pointer to a valid VkPhysicalDeviceExternalFenceInfo structure
pExternalFenceProperties must be a valid pointer to a VkExternalFenceProperties structure
See Also
VkExternalFenceProperties, VkPhysicalDevice, VkPhysicalDeviceExternalFenceInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceExternalFenceProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceExternalImageFormatPropertiesNV(3)
Name
vkGetPhysicalDeviceExternalImageFormatPropertiesNV - determine image capabilities compatible with external memory handle types

C Specification
To determine the image capabilities compatible with an external memory handle type, call:

VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkExternalMemoryHandleTypeFlagsNV           externalHandleType,
    VkExternalImageFormatPropertiesNV*          pExternalImageFormatProperties);
Parameters
physicalDevice is the physical device from which to query the image capabilities
format is the image format, corresponding to VkImageCreateInfo::format.
type is the image type, corresponding to VkImageCreateInfo::imageType.
tiling is the image tiling, corresponding to VkImageCreateInfo::tiling.
usage is the intended usage of the image, corresponding to VkImageCreateInfo::usage.
flags is a bitmask describing additional parameters of the image, corresponding to VkImageCreateInfo::flags.
externalHandleType is either one of the bits from VkExternalMemoryHandleTypeFlagBitsNV, or 0.
pExternalImageFormatProperties points to an instance of the VkExternalImageFormatPropertiesNV structure in which capabilities are returned.
Description
If externalHandleType is 0, pExternalImageFormatProperties::imageFormatProperties will return the same values as a call to vkGetPhysicalDeviceImageFormatProperties, and the other members of pExternalImageFormatProperties will all be 0. Otherwise, they are filled in as described for VkExternalImageFormatPropertiesNV.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
format must be a valid VkFormat value
type must be a valid VkImageType value
tiling must be a valid VkImageTiling value
usage must be a valid combination of VkImageUsageFlagBits values
usage must not be 0
flags must be a valid combination of VkImageCreateFlagBits values
externalHandleType must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values
pExternalImageFormatProperties must be a valid pointer to a VkExternalImageFormatPropertiesNV structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_FORMAT_NOT_SUPPORTED
See Also
VkExternalImageFormatPropertiesNV, VkExternalMemoryHandleTypeFlagsNV, VkFormat, VkImageCreateFlags, VkImageTiling, VkImageType, VkImageUsageFlags, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceExternalImageFormatPropertiesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceExternalSemaphoreProperties(3)
Name
vkGetPhysicalDeviceExternalSemaphoreProperties - Function for querying external semaphore handle capabilities.

C Specification
Semaphores may support import and export of their payload to external handles. To query the external handle types supported by semaphores, call:

void vkGetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties*              pExternalSemaphoreProperties);
or the equivalent command

void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties*              pExternalSemaphoreProperties);
Parameters
physicalDevice is the physical device from which to query the semaphore capabilities.
pExternalSemaphoreInfo points to an instance of the VkPhysicalDeviceExternalSemaphoreInfo structure, describing the parameters that would be consumed by vkCreateSemaphore.
pExternalSemaphoreProperties points to an instance of the VkExternalSemaphoreProperties structure in which capabilities are returned.
Description
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pExternalSemaphoreInfo must be a valid pointer to a valid VkPhysicalDeviceExternalSemaphoreInfo structure
pExternalSemaphoreProperties must be a valid pointer to a VkExternalSemaphoreProperties structure
See Also
VkExternalSemaphoreProperties, VkPhysicalDevice, VkPhysicalDeviceExternalSemaphoreInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceExternalSemaphoreProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceFeatures(3)
Name
vkGetPhysicalDeviceFeatures - Reports capabilities of a physical device

C Specification
To query supported features, call:

void vkGetPhysicalDeviceFeatures(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures*                   pFeatures);
Parameters
physicalDevice is the physical device from which to query the supported features.
pFeatures is a pointer to a VkPhysicalDeviceFeatures structure in which the physical device features are returned. For each feature, a value of VK_TRUE specifies that the feature is supported on this physical device, and VK_FALSE specifies that the feature is not supported.
Description
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pFeatures must be a valid pointer to a VkPhysicalDeviceFeatures structure
See Also
VkPhysicalDevice, VkPhysicalDeviceFeatures

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceFeatures

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceFeatures2(3)
Name
vkGetPhysicalDeviceFeatures2 - Reports capabilities of a physical device

C Specification
To query supported features defined by the core or extensions, call:

void vkGetPhysicalDeviceFeatures2(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures2*                  pFeatures);
or the equivalent command

void vkGetPhysicalDeviceFeatures2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures2*                  pFeatures);
Parameters
physicalDevice is the physical device from which to query the supported features.
pFeatures is a pointer to a VkPhysicalDeviceFeatures2 structure in which the physical device features are returned.
Description
Each structure in pFeatures and its pNext chain contain members corresponding to fine-grained features. vkGetPhysicalDeviceFeatures2 writes each member to a boolean value indicating whether that feature is supported.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pFeatures must be a valid pointer to a VkPhysicalDeviceFeatures2 structure
See Also
VkPhysicalDevice, VkPhysicalDeviceFeatures2

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceFeatures2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceFormatProperties(3)
Name
vkGetPhysicalDeviceFormatProperties - Lists physical device’s format capabilities

C Specification
To query supported format features which are properties of the physical device, call:

void vkGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties*                         pFormatProperties);
Parameters
physicalDevice is the physical device from which to query the format properties.
format is the format whose properties are queried.
pFormatProperties is a pointer to a VkFormatProperties structure in which physical device properties for format are returned.
Description
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
format must be a valid VkFormat value
pFormatProperties must be a valid pointer to a VkFormatProperties structure
See Also
VkFormat, VkFormatProperties, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceFormatProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceFormatProperties2(3)
Name
vkGetPhysicalDeviceFormatProperties2 - Lists physical device’s format capabilities

C Specification
To query supported format features which are properties of the physical device, call:

void vkGetPhysicalDeviceFormatProperties2(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties2*                        pFormatProperties);
or the equivalent command

void vkGetPhysicalDeviceFormatProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties2*                        pFormatProperties);
Parameters
physicalDevice is the physical device from which to query the format properties.
format is the format whose properties are queried.
pFormatProperties is a pointer to a VkFormatProperties2 structure in which physical device properties for format are returned.
Description
vkGetPhysicalDeviceFormatProperties2 behaves similarly to vkGetPhysicalDeviceFormatProperties, with the ability to return extended information in a pNext chain of output structures.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
format must be a valid VkFormat value
pFormatProperties must be a valid pointer to a VkFormatProperties2 structure
See Also
VkFormat, VkFormatProperties2, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceFormatProperties2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(3)
Name
vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX - Returns device-generated commands related properties of a physical device

C Specification
To query the support of related features and limitations, call:

void vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    VkPhysicalDevice                            physicalDevice,
    VkDeviceGeneratedCommandsFeaturesNVX*       pFeatures,
    VkDeviceGeneratedCommandsLimitsNVX*         pLimits);
Parameters
physicalDevice is the handle to the physical device whose properties will be queried.
pFeatures points to an instance of the VkDeviceGeneratedCommandsFeaturesNVX structure, that will be filled with returned information.
pLimits points to an instance of the VkDeviceGeneratedCommandsLimitsNVX structure, that will be filled with returned information.
Description
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pFeatures must be a valid pointer to a VkDeviceGeneratedCommandsFeaturesNVX structure
pLimits must be a valid pointer to a VkDeviceGeneratedCommandsLimitsNVX structure
See Also
VkDeviceGeneratedCommandsFeaturesNVX, VkDeviceGeneratedCommandsLimitsNVX, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceImageFormatProperties(3)
Name
vkGetPhysicalDeviceImageFormatProperties - Lists physical device’s image format capabilities

C Specification
To query additional capabilities specific to image types, call:

VkResult vkGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkImageFormatProperties*                    pImageFormatProperties);
Parameters
physicalDevice is the physical device from which to query the image capabilities.
format is a VkFormat value specifying the image format, corresponding to VkImageCreateInfo::format.
type is a VkImageType value specifying the image type, corresponding to VkImageCreateInfo::imageType.
tiling is a VkImageTiling value specifying the image tiling, corresponding to VkImageCreateInfo::tiling.
usage is a bitmask of VkImageUsageFlagBits specifying the intended usage of the image, corresponding to VkImageCreateInfo::usage.
flags is a bitmask of VkImageCreateFlagBits specifying additional parameters of the image, corresponding to VkImageCreateInfo::flags.
pImageFormatProperties points to an instance of the VkImageFormatProperties structure in which capabilities are returned.
Description
The format, type, tiling, usage, and flags parameters correspond to parameters that would be consumed by vkCreateImage (as members of VkImageCreateInfo).

If format is not a supported image format, or if the combination of format, type, tiling, usage, and flags is not supported for images, then vkGetPhysicalDeviceImageFormatProperties returns VK_ERROR_FORMAT_NOT_SUPPORTED.

The limitations on an image format that are reported by vkGetPhysicalDeviceImageFormatProperties have the following property: if usage1 and usage2 of type VkImageUsageFlags are such that the bits set in usage1 are a subset of the bits set in usage2, and flags1 and flags2 of type VkImageCreateFlags are such that the bits set in flags1 are a subset of the bits set in flags2, then the limitations for usage1 and flags1 must be no more strict than the limitations for usage2 and flags2, for all values of format, type, and tiling.

Valid Usage
tiling must not be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT. (Use vkGetPhysicalDeviceImageFormatProperties2 instead).
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
format must be a valid VkFormat value
type must be a valid VkImageType value
tiling must be a valid VkImageTiling value
usage must be a valid combination of VkImageUsageFlagBits values
usage must not be 0
flags must be a valid combination of VkImageCreateFlagBits values
pImageFormatProperties must be a valid pointer to a VkImageFormatProperties structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_FORMAT_NOT_SUPPORTED
See Also
VkFormat, VkImageCreateFlags, VkImageFormatProperties, VkImageTiling, VkImageType, VkImageUsageFlags, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceImageFormatProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceImageFormatProperties2(3)
Name
vkGetPhysicalDeviceImageFormatProperties2 - Lists physical device’s image format capabilities

C Specification
To query additional capabilities specific to image types, call:

VkResult vkGetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2*     pImageFormatInfo,
    VkImageFormatProperties2*                   pImageFormatProperties);
or the equivalent command

VkResult vkGetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2*     pImageFormatInfo,
    VkImageFormatProperties2*                   pImageFormatProperties);
Parameters
physicalDevice is the physical device from which to query the image capabilities.
pImageFormatInfo points to an instance of the VkPhysicalDeviceImageFormatInfo2 structure, describing the parameters that would be consumed by vkCreateImage.
pImageFormatProperties points to an instance of the VkImageFormatProperties2 structure in which capabilities are returned.
Description
vkGetPhysicalDeviceImageFormatProperties2 behaves similarly to vkGetPhysicalDeviceImageFormatProperties, with the ability to return extended information in a pNext chain of output structures.

Valid Usage
If the pNext chain of pImageFormatProperties contains an instance of VkAndroidHardwareBufferUsageANDROID, the pNext chain of pImageFormatInfo must contain an instance of VkPhysicalDeviceExternalImageFormatInfo with handleType set to VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID.
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pImageFormatInfo must be a valid pointer to a valid VkPhysicalDeviceImageFormatInfo2 structure
pImageFormatProperties must be a valid pointer to a VkImageFormatProperties2 structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_FORMAT_NOT_SUPPORTED
See Also
VkImageFormatProperties2, VkPhysicalDevice, VkPhysicalDeviceImageFormatInfo2

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceImageFormatProperties2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceMemoryProperties(3)
Name
vkGetPhysicalDeviceMemoryProperties - Reports memory information for the specified physical device

C Specification
To query memory properties, call:

void vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties*           pMemoryProperties);
Parameters
physicalDevice is the handle to the device to query.
pMemoryProperties points to an instance of VkPhysicalDeviceMemoryProperties structure in which the properties are returned.
Description
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pMemoryProperties must be a valid pointer to a VkPhysicalDeviceMemoryProperties structure
See Also
VkPhysicalDevice, VkPhysicalDeviceMemoryProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceMemoryProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceMemoryProperties2(3)
Name
vkGetPhysicalDeviceMemoryProperties2 - Reports memory information for the specified physical device

C Specification
To query memory properties, call:

void vkGetPhysicalDeviceMemoryProperties2(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties2*          pMemoryProperties);
or the equivalent command

void vkGetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties2*          pMemoryProperties);
Parameters
physicalDevice is the handle to the device to query.
pMemoryProperties points to an instance of VkPhysicalDeviceMemoryProperties2 structure in which the properties are returned.
Description
vkGetPhysicalDeviceMemoryProperties2 behaves similarly to vkGetPhysicalDeviceMemoryProperties, with the ability to return extended information in a pNext chain of output structures.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pMemoryProperties must be a valid pointer to a VkPhysicalDeviceMemoryProperties2 structure
See Also
VkPhysicalDevice, VkPhysicalDeviceMemoryProperties2

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceMemoryProperties2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceMultisamplePropertiesEXT(3)
Name
vkGetPhysicalDeviceMultisamplePropertiesEXT - Report sample count specific multisampling capabilities of a physical device

C Specification
In addition to the minimum capabilities described for (Limits) above, implementations may support additional multisampling capabilities specific to a particular sample count.

To query additional sample count specific multisampling capabilities, call:

void vkGetPhysicalDeviceMultisamplePropertiesEXT(
    VkPhysicalDevice                            physicalDevice,
    VkSampleCountFlagBits                       samples,
    VkMultisamplePropertiesEXT*                 pMultisampleProperties);
Parameters
physicalDevice is the physical device from which to query the additional multisampling capabilities.
samples is the sample count to query the capabilities for.
pMultisampleProperties is a pointer to a structure of type VkMultisamplePropertiesEXT, in which information about the additional multisampling capabilities specific to the sample count is returned.
Description
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
samples must be a valid VkSampleCountFlagBits value
pMultisampleProperties must be a valid pointer to a VkMultisamplePropertiesEXT structure
See Also
VkMultisamplePropertiesEXT, VkPhysicalDevice, VkSampleCountFlagBits

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceMultisamplePropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDevicePresentRectanglesKHR(3)
Name
vkGetPhysicalDevicePresentRectanglesKHR - Query present rectangles for a surface on a physical device

C Specification
When using VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR, the application may need to know which regions of the surface are used when presenting locally on each physical device. Presentation of swapchain images to this surface need only have valid contents in the regions returned by this command.

To query a set of rectangles used in presentation on the physical device, call:

VkResult vkGetPhysicalDevicePresentRectanglesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pRectCount,
    VkRect2D*                                   pRects);
Parameters
physicalDevice is the physical device.
surface is the surface.
pRectCount is a pointer to an integer related to the number of rectangles available or queried, as described below.
pRects is either NULL or a pointer to an array of VkRect2D structures.
Description
If pRects is NULL, then the number of rectangles used when presenting the given surface is returned in pRectCount. Otherwise, pRectCount must point to a variable set by the user to the number of elements in the pRects array, and on return the variable is overwritten with the number of structures actually written to pRects. If the value of pRectCount is less than the number of rectangles, at most pRectCount structures will be written. If pRectCount is smaller than the number of rectangles used for the given surface, VK_INCOMPLETE will be returned instead of VK_SUCCESS to indicate that not all the available values were returned.

The values returned by this command are not invariant, and may change in response to the surface being moved, resized, or occluded.

The rectangles returned by this command must not overlap.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
surface must be a valid VkSurfaceKHR handle
pRectCount must be a valid pointer to a uint32_t value
If the value referenced by pRectCount is not 0, and pRects is not NULL, pRects must be a valid pointer to an array of pRectCount VkRect2D structures
Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance
Host Synchronization
Host access to surface must be externally synchronized
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkPhysicalDevice, VkRect2D, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDevicePresentRectanglesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceProperties(3)
Name
vkGetPhysicalDeviceProperties - Returns properties of a physical device

C Specification
To query general properties of physical devices once enumerated, call:

void vkGetPhysicalDeviceProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties*                 pProperties);
Parameters
physicalDevice is the handle to the physical device whose properties will be queried.
pProperties points to an instance of the VkPhysicalDeviceProperties structure, that will be filled with returned information.
Description
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pProperties must be a valid pointer to a VkPhysicalDeviceProperties structure
See Also
VkPhysicalDevice, VkPhysicalDeviceProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceProperties2(3)
Name
vkGetPhysicalDeviceProperties2 - Returns properties of a physical device

C Specification
To query general properties of physical devices once enumerated, call:

void vkGetPhysicalDeviceProperties2(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties2*                pProperties);
or the equivalent command

void vkGetPhysicalDeviceProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties2*                pProperties);
Parameters
physicalDevice is the handle to the physical device whose properties will be queried.
pProperties points to an instance of the VkPhysicalDeviceProperties2 structure, that will be filled with returned information.
Description
Each structure in pProperties and its pNext chain contain members corresponding to properties or implementation-dependent limits. vkGetPhysicalDeviceProperties2 writes each member to a value indicating the value of that property or limit.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pProperties must be a valid pointer to a VkPhysicalDeviceProperties2 structure
See Also
VkPhysicalDevice, VkPhysicalDeviceProperties2

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceProperties2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceQueueFamilyProperties(3)
Name
vkGetPhysicalDeviceQueueFamilyProperties - Reports properties of the queues of the specified physical device

C Specification
To query properties of queues available on a physical device, call:

void vkGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties*                    pQueueFamilyProperties);
Parameters
physicalDevice is the handle to the physical device whose properties will be queried.
pQueueFamilyPropertyCount is a pointer to an integer related to the number of queue families available or queried, as described below.
pQueueFamilyProperties is either NULL or a pointer to an array of VkQueueFamilyProperties structures.
Description
If pQueueFamilyProperties is NULL, then the number of queue families available is returned in pQueueFamilyPropertyCount. Implementations must support at least one queue family. Otherwise, pQueueFamilyPropertyCount must point to a variable set by the user to the number of elements in the pQueueFamilyProperties array, and on return the variable is overwritten with the number of structures actually written to pQueueFamilyProperties. If pQueueFamilyPropertyCount is less than the number of queue families available, at most pQueueFamilyPropertyCount structures will be written.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pQueueFamilyPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pQueueFamilyPropertyCount is not 0, and pQueueFamilyProperties is not NULL, pQueueFamilyProperties must be a valid pointer to an array of pQueueFamilyPropertyCount VkQueueFamilyProperties structures
See Also
VkPhysicalDevice, VkQueueFamilyProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceQueueFamilyProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceQueueFamilyProperties2(3)
Name
vkGetPhysicalDeviceQueueFamilyProperties2 - Reports properties of the queues of the specified physical device

C Specification
To query properties of queues available on a physical device, call:

void vkGetPhysicalDeviceQueueFamilyProperties2(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2*                   pQueueFamilyProperties);
or the equivalent command

void vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2*                   pQueueFamilyProperties);
Parameters
physicalDevice is the handle to the physical device whose properties will be queried.
pQueueFamilyPropertyCount is a pointer to an integer related to the number of queue families available or queried, as described in vkGetPhysicalDeviceQueueFamilyProperties.
pQueueFamilyProperties is either NULL or a pointer to an array of VkQueueFamilyProperties2 structures.
Description
vkGetPhysicalDeviceQueueFamilyProperties2 behaves similarly to vkGetPhysicalDeviceQueueFamilyProperties, with the ability to return extended information in a pNext chain of output structures.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pQueueFamilyPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pQueueFamilyPropertyCount is not 0, and pQueueFamilyProperties is not NULL, pQueueFamilyProperties must be a valid pointer to an array of pQueueFamilyPropertyCount VkQueueFamilyProperties2 structures
See Also
VkPhysicalDevice, VkQueueFamilyProperties2

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceQueueFamilyProperties2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceSparseImageFormatProperties(3)
Name
vkGetPhysicalDeviceSparseImageFormatProperties - Retrieve properties of an image format applied to sparse images

C Specification
vkGetPhysicalDeviceSparseImageFormatProperties returns an array of VkSparseImageFormatProperties. Each element will describe properties for one set of image aspects that are bound simultaneously in the image. This is usually one element for each aspect in the image, but for interleaved depth/stencil images there is only one element describing the combined aspects.

void vkGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties*              pProperties);
Parameters
physicalDevice is the physical device from which to query the sparse image capabilities.
format is the image format.
type is the dimensionality of image.
samples is the number of samples per texel as defined in VkSampleCountFlagBits.
usage is a bitmask describing the intended usage of the image.
tiling is the tiling arrangement of the texel blocks in memory.
pPropertyCount is a pointer to an integer related to the number of sparse format properties available or queried, as described below.
pProperties is either NULL or a pointer to an array of VkSparseImageFormatProperties structures.
Description
If pProperties is NULL, then the number of sparse format properties available is returned in pPropertyCount. Otherwise, pPropertyCount must point to a variable set by the user to the number of elements in the pProperties array, and on return the variable is overwritten with the number of structures actually written to pProperties. If pPropertyCount is less than the number of sparse format properties available, at most pPropertyCount structures will be written.

If VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT is not supported for the given arguments, pPropertyCount will be set to zero upon return, and no data will be written to pProperties.

Multiple aspects are returned for depth/stencil images that are implemented as separate planes by the implementation. The depth and stencil data planes each have unique VkSparseImageFormatProperties data.

Depth/stencil images with depth and stencil data interleaved into a single plane will return a single VkSparseImageFormatProperties structure with the aspectMask set to VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT.

Valid Usage
samples must be a bit value that is set in VkImageFormatProperties::sampleCounts returned by vkGetPhysicalDeviceImageFormatProperties with format, type, tiling, and usage equal to those in this command and flags equal to the value that is set in VkImageCreateInfo::flags when the image is created
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
format must be a valid VkFormat value
type must be a valid VkImageType value
samples must be a valid VkSampleCountFlagBits value
usage must be a valid combination of VkImageUsageFlagBits values
usage must not be 0
tiling must be a valid VkImageTiling value
pPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkSparseImageFormatProperties structures
See Also
VkFormat, VkImageTiling, VkImageType, VkImageUsageFlags, VkPhysicalDevice, VkSampleCountFlagBits, VkSparseImageFormatProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceSparseImageFormatProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceSparseImageFormatProperties2(3)
Name
vkGetPhysicalDeviceSparseImageFormatProperties2 - Retrieve properties of an image format applied to sparse images

C Specification
vkGetPhysicalDeviceSparseImageFormatProperties2 returns an array of VkSparseImageFormatProperties2. Each element will describe properties for one set of image aspects that are bound simultaneously in the image. This is usually one element for each aspect in the image, but for interleaved depth/stencil images there is only one element describing the combined aspects.

void vkGetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties2*             pProperties);
or the equivalent command

void vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties2*             pProperties);
Parameters
physicalDevice is the physical device from which to query the sparse image capabilities.
pFormatInfo is a pointer to a structure of type VkPhysicalDeviceSparseImageFormatInfo2 containing input parameters to the command.
pPropertyCount is a pointer to an integer related to the number of sparse format properties available or queried, as described below.
pProperties is either NULL or a pointer to an array of VkSparseImageFormatProperties2 structures.
Description
vkGetPhysicalDeviceSparseImageFormatProperties2 behaves identically to vkGetPhysicalDeviceSparseImageFormatProperties, with the ability to return extended information by adding extension structures to the pNext chain of its pProperties parameter.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pFormatInfo must be a valid pointer to a valid VkPhysicalDeviceSparseImageFormatInfo2 structure
pPropertyCount must be a valid pointer to a uint32_t value
If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkSparseImageFormatProperties2 structures
See Also
VkPhysicalDevice, VkPhysicalDeviceSparseImageFormatInfo2, VkSparseImageFormatProperties2

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceSparseImageFormatProperties2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceSurfaceCapabilities2EXT(3)
Name
vkGetPhysicalDeviceSurfaceCapabilities2EXT - Query surface capabilities

C Specification
To query the basic capabilities of a surface, needed in order to create a swapchain, call:

VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    VkSurfaceCapabilities2EXT*                  pSurfaceCapabilities);
Parameters
physicalDevice is the physical device that will be associated with the swapchain to be created, as described for vkCreateSwapchainKHR.
surface is the surface that will be associated with the swapchain.
pSurfaceCapabilities is a pointer to an instance of the VkSurfaceCapabilities2EXT structure in which the capabilities are returned.
Description
vkGetPhysicalDeviceSurfaceCapabilities2EXT behaves similarly to vkGetPhysicalDeviceSurfaceCapabilitiesKHR, with the ability to return extended information by adding extension structures to the pNext chain of its pSurfaceCapabilities parameter.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
surface must be a valid VkSurfaceKHR handle
pSurfaceCapabilities must be a valid pointer to a VkSurfaceCapabilities2EXT structure
Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_SURFACE_LOST_KHR
See Also
VkPhysicalDevice, VkSurfaceCapabilities2EXT, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceSurfaceCapabilities2EXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceSurfaceCapabilities2KHR(3)
Name
vkGetPhysicalDeviceSurfaceCapabilities2KHR - Reports capabilities of a surface on a physical device

C Specification
To query the basic capabilities of a surface defined by the core or extensions, call:

VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
    VkSurfaceCapabilities2KHR*                  pSurfaceCapabilities);
Parameters
physicalDevice is the physical device that will be associated with the swapchain to be created, as described for vkCreateSwapchainKHR.
pSurfaceInfo points to an instance of the VkPhysicalDeviceSurfaceInfo2KHR structure, describing the surface and other fixed parameters that would be consumed by vkCreateSwapchainKHR.
pSurfaceCapabilities points to an instance of the VkSurfaceCapabilities2KHR structure in which the capabilities are returned.
Description
vkGetPhysicalDeviceSurfaceCapabilities2KHR behaves similarly to vkGetPhysicalDeviceSurfaceCapabilitiesKHR, with the ability to specify extended inputs via chained input structures, and to return extended information via chained output structures.

Valid Usage
If an instance of VkSurfaceCapabilitiesFullScreenExclusiveEXT is included in the pNext chain of pSurfaceCapabilities, an instance of VkSurfaceFullScreenExclusiveWin32InfoEXT must be included in the pNext chain of pSurfaceInfo.
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure
pSurfaceCapabilities must be a valid pointer to a VkSurfaceCapabilities2KHR structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_SURFACE_LOST_KHR
See Also
VkPhysicalDevice, VkPhysicalDeviceSurfaceInfo2KHR, VkSurfaceCapabilities2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceSurfaceCapabilities2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceSurfaceCapabilitiesKHR(3)
Name
vkGetPhysicalDeviceSurfaceCapabilitiesKHR - Query surface capabilities

C Specification
To query the basic capabilities of a surface, needed in order to create a swapchain, call:

VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    VkSurfaceCapabilitiesKHR*                   pSurfaceCapabilities);
Parameters
physicalDevice is the physical device that will be associated with the swapchain to be created, as described for vkCreateSwapchainKHR.
surface is the surface that will be associated with the swapchain.
pSurfaceCapabilities is a pointer to an instance of the VkSurfaceCapabilitiesKHR structure in which the capabilities are returned.
Description
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
surface must be a valid VkSurfaceKHR handle
pSurfaceCapabilities must be a valid pointer to a VkSurfaceCapabilitiesKHR structure
Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_SURFACE_LOST_KHR
See Also
VkPhysicalDevice, VkSurfaceCapabilitiesKHR, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceSurfaceCapabilitiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceSurfaceFormats2KHR(3)
Name
vkGetPhysicalDeviceSurfaceFormats2KHR - Query color formats supported by surface

C Specification
To query the supported swapchain format tuples for a surface, call:

VkResult vkGetPhysicalDeviceSurfaceFormats2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
    uint32_t*                                   pSurfaceFormatCount,
    VkSurfaceFormat2KHR*                        pSurfaceFormats);
Parameters
physicalDevice is the physical device that will be associated with the swapchain to be created, as described for vkCreateSwapchainKHR.
pSurfaceInfo points to an instance of the VkPhysicalDeviceSurfaceInfo2KHR structure, describing the surface and other fixed parameters that would be consumed by vkCreateSwapchainKHR.
pSurfaceFormatCount is a pointer to an integer related to the number of format tuples available or queried, as described below.
pSurfaceFormats is either NULL or a pointer to an array of VkSurfaceFormat2KHR structures.
Description
If pSurfaceFormats is NULL, then the number of format tuples supported for the given surface is returned in pSurfaceFormatCount. The number of format tuples supported will be greater than or equal to 1. Otherwise, pSurfaceFormatCount must point to a variable set by the user to the number of elements in the pSurfaceFormats array, and on return the variable is overwritten with the number of structures actually written to pSurfaceFormats. If the value of pSurfaceFormatCount is less than the number of format tuples supported, at most pSurfaceFormatCount structures will be written. If pSurfaceFormatCount is smaller than the number of format tuples supported for the surface parameters described in pSurfaceInfo, VK_INCOMPLETE will be returned instead of VK_SUCCESS to indicate that not all the available values were returned.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure
pSurfaceFormatCount must be a valid pointer to a uint32_t value
If the value referenced by pSurfaceFormatCount is not 0, and pSurfaceFormats is not NULL, pSurfaceFormats must be a valid pointer to an array of pSurfaceFormatCount VkSurfaceFormat2KHR structures
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_SURFACE_LOST_KHR
See Also
VkPhysicalDevice, VkPhysicalDeviceSurfaceInfo2KHR, VkSurfaceFormat2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceSurfaceFormats2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceSurfaceFormatsKHR(3)
Name
vkGetPhysicalDeviceSurfaceFormatsKHR - Query color formats supported by surface

C Specification
To query the supported swapchain format-color space pairs for a surface, call:

VkResult vkGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pSurfaceFormatCount,
    VkSurfaceFormatKHR*                         pSurfaceFormats);
Parameters
physicalDevice is the physical device that will be associated with the swapchain to be created, as described for vkCreateSwapchainKHR.
surface is the surface that will be associated with the swapchain.
pSurfaceFormatCount is a pointer to an integer related to the number of format pairs available or queried, as described below.
pSurfaceFormats is either NULL or a pointer to an array of VkSurfaceFormatKHR structures.
Description
If pSurfaceFormats is NULL, then the number of format pairs supported for the given surface is returned in pSurfaceFormatCount. The number of format pairs supported will be greater than or equal to 1. Otherwise, pSurfaceFormatCount must point to a variable set by the user to the number of elements in the pSurfaceFormats array, and on return the variable is overwritten with the number of structures actually written to pSurfaceFormats. If the value of pSurfaceFormatCount is less than the number of format pairs supported, at most pSurfaceFormatCount structures will be written. If pSurfaceFormatCount is smaller than the number of format pairs supported for the given surface, VK_INCOMPLETE will be returned instead of VK_SUCCESS to indicate that not all the available values were returned.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
surface must be a valid VkSurfaceKHR handle
pSurfaceFormatCount must be a valid pointer to a uint32_t value
If the value referenced by pSurfaceFormatCount is not 0, and pSurfaceFormats is not NULL, pSurfaceFormats must be a valid pointer to an array of pSurfaceFormatCount VkSurfaceFormatKHR structures
Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_SURFACE_LOST_KHR
See Also
VkPhysicalDevice, VkSurfaceFormatKHR, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceSurfaceFormatsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceSurfacePresentModes2EXT(3)
Name
vkGetPhysicalDeviceSurfacePresentModes2EXT - Query supported presentation modes

C Specification
Alternatively, to query the supported presentation modes for a surface combined with select other fixed swapchain creation parameters, call:

VkResult vkGetPhysicalDeviceSurfacePresentModes2EXT(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
    uint32_t*                                   pPresentModeCount,
    VkPresentModeKHR*                           pPresentModes);
Parameters
physicalDevice is the physical device that will be associated with the swapchain to be created, as described for vkCreateSwapchainKHR.
pSurfaceInfo points to an instance of the VkPhysicalDeviceSurfaceInfo2KHR structure, describing the surface and other fixed parameters that would be consumed by vkCreateSwapchainKHR.
pPresentModeCount is a pointer to an integer related to the number of presentation modes available or queried, as described below.
pPresentModes is either NULL or a pointer to an array of VkPresentModeKHR values, indicating the supported presentation modes.
Description
vkGetPhysicalDeviceSurfacePresentModes2EXT behaves similarly to vkGetPhysicalDeviceSurfacePresentModesKHR, with the ability to specify extended inputs via chained input structures.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure
pPresentModeCount must be a valid pointer to a uint32_t value
If the value referenced by pPresentModeCount is not 0, and pPresentModes is not NULL, pPresentModes must be a valid pointer to an array of pPresentModeCount VkPresentModeKHR values
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_SURFACE_LOST_KHR
See Also
VkPhysicalDevice, VkPhysicalDeviceSurfaceInfo2KHR, VkPresentModeKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceSurfacePresentModes2EXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceSurfacePresentModesKHR(3)
Name
vkGetPhysicalDeviceSurfacePresentModesKHR - Query supported presentation modes

C Specification
To query the supported presentation modes for a surface, call:

VkResult vkGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pPresentModeCount,
    VkPresentModeKHR*                           pPresentModes);
Parameters
physicalDevice is the physical device that will be associated with the swapchain to be created, as described for vkCreateSwapchainKHR.
surface is the surface that will be associated with the swapchain.
pPresentModeCount is a pointer to an integer related to the number of presentation modes available or queried, as described below.
pPresentModes is either NULL or a pointer to an array of VkPresentModeKHR values, indicating the supported presentation modes.
Description
If pPresentModes is NULL, then the number of presentation modes supported for the given surface is returned in pPresentModeCount. Otherwise, pPresentModeCount must point to a variable set by the user to the number of elements in the pPresentModes array, and on return the variable is overwritten with the number of values actually written to pPresentModes. If the value of pPresentModeCount is less than the number of presentation modes supported, at most pPresentModeCount values will be written. If pPresentModeCount is smaller than the number of presentation modes supported for the given surface, VK_INCOMPLETE will be returned instead of VK_SUCCESS to indicate that not all the available values were returned.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
surface must be a valid VkSurfaceKHR handle
pPresentModeCount must be a valid pointer to a uint32_t value
If the value referenced by pPresentModeCount is not 0, and pPresentModes is not NULL, pPresentModes must be a valid pointer to an array of pPresentModeCount VkPresentModeKHR values
Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_SURFACE_LOST_KHR
See Also
VkPhysicalDevice, VkPresentModeKHR, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceSurfacePresentModesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceSurfaceSupportKHR(3)
Name
vkGetPhysicalDeviceSurfaceSupportKHR - Query if presentation is supported

C Specification
To determine whether a queue family of a physical device supports presentation to a given surface, call:

VkResult vkGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    VkSurfaceKHR                                surface,
    VkBool32*                                   pSupported);
Parameters
physicalDevice is the physical device.
queueFamilyIndex is the queue family.
surface is the surface.
pSupported is a pointer to a VkBool32, which is set to VK_TRUE to indicate support, and VK_FALSE otherwise.
Description
Valid Usage
queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
surface must be a valid VkSurfaceKHR handle
pSupported must be a valid pointer to a VkBool32 value
Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_SURFACE_LOST_KHR
See Also
VkBool32, VkPhysicalDevice, VkSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceSurfaceSupportKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceWaylandPresentationSupportKHR(3)
Name
vkGetPhysicalDeviceWaylandPresentationSupportKHR - Query physical device for presentation to Wayland

C Specification
To determine whether a queue family of a physical device supports presentation to a Wayland compositor, call:

VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    struct wl_display*                          display);
Parameters
physicalDevice is the physical device.
queueFamilyIndex is the queue family index.
display is a pointer to the wl_display associated with a Wayland compositor.
Description
This platform-specific function can be called prior to creating a surface.

Valid Usage
queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
display must be a valid pointer to a wl_display value
See Also
VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceWaylandPresentationSupportKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceWin32PresentationSupportKHR(3)
Name
vkGetPhysicalDeviceWin32PresentationSupportKHR - query queue family support for presentation on a Win32 display

C Specification
To determine whether a queue family of a physical device supports presentation to the Microsoft Windows desktop, call:

VkBool32 vkGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex);
Parameters
physicalDevice is the physical device.
queueFamilyIndex is the queue family index.
Description
This platform-specific function can be called prior to creating a surface.

Valid Usage
queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
See Also
VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceWin32PresentationSupportKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceXcbPresentationSupportKHR(3)
Name
vkGetPhysicalDeviceXcbPresentationSupportKHR - Query physical device for presentation to X11 server using XCB

C Specification
To determine whether a queue family of a physical device supports presentation to an X11 server, using the XCB client-side library, call:

VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    xcb_connection_t*                           connection,
    xcb_visualid_t                              visual_id);
Parameters
physicalDevice is the physical device.
queueFamilyIndex is the queue family index.
connection is a pointer to an xcb_connection_t to the X server. visual_id is an X11 visual (xcb_visualid_t).
Description
This platform-specific function can be called prior to creating a surface.

Valid Usage
queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
connection must be a valid pointer to a xcb_connection_t value
See Also
VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceXcbPresentationSupportKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPhysicalDeviceXlibPresentationSupportKHR(3)
Name
vkGetPhysicalDeviceXlibPresentationSupportKHR - Query physical device for presentation to X11 server using Xlib

C Specification
To determine whether a queue family of a physical device supports presentation to an X11 server, using the Xlib client-side library, call:

VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    Display*                                    dpy,
    VisualID                                    visualID);
Parameters
physicalDevice is the physical device.
queueFamilyIndex is the queue family index.
dpy is a pointer to an Xlib Display connection to the server.
visualId is an X11 visual (VisualID).
Description
This platform-specific function can be called prior to creating a surface.

Valid Usage
queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
dpy must be a valid pointer to a Display value
See Also
VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPhysicalDeviceXlibPresentationSupportKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetPipelineCacheData(3)
Name
vkGetPipelineCacheData - Get the data store from a pipeline cache

C Specification
Data can be retrieved from a pipeline cache object using the command:

VkResult vkGetPipelineCacheData(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    size_t*                                     pDataSize,
    void*                                       pData);
Parameters
device is the logical device that owns the pipeline cache.
pipelineCache is the pipeline cache to retrieve data from.
pDataSize is a pointer to a value related to the amount of data in the pipeline cache, as described below.
pData is either NULL or a pointer to a buffer.
Description
If pData is NULL, then the maximum size of the data that can be retrieved from the pipeline cache, in bytes, is returned in pDataSize. Otherwise, pDataSize must point to a variable set by the user to the size of the buffer, in bytes, pointed to by pData, and on return the variable is overwritten with the amount of data actually written to pData.

If pDataSize is less than the maximum size that can be retrieved by the pipeline cache, at most pDataSize bytes will be written to pData, and vkGetPipelineCacheData will return VK_INCOMPLETE. Any data written to pData is valid and can be provided as the pInitialData member of the VkPipelineCacheCreateInfo structure passed to vkCreatePipelineCache.

Two calls to vkGetPipelineCacheData with the same parameters must retrieve the same data unless a command that modifies the contents of the cache is called between them.

Applications can store the data retrieved from the pipeline cache, and use these data, possibly in a future run of the application, to populate new pipeline cache objects. The results of pipeline compiles, however, may depend on the vendor ID, device ID, driver version, and other details of the device. To enable applications to detect when previously retrieved data is incompatible with the device, the initial bytes written to pData must be a header consisting of the following members:

Table 5. Layout for pipeline cache header version VK_PIPELINE_CACHE_HEADER_VERSION_ONE
Offset	Size	Meaning
0
4
length in bytes of the entire pipeline cache header written as a stream of bytes, with the least significant byte first
4
4
a VkPipelineCacheHeaderVersion value written as a stream of bytes, with the least significant byte first
8
4
a vendor ID equal to VkPhysicalDeviceProperties::vendorID written as a stream of bytes, with the least significant byte first
12
4
a device ID equal to VkPhysicalDeviceProperties::deviceID written as a stream of bytes, with the least significant byte first
16
VK_UUID_SIZE
a pipeline cache ID equal to VkPhysicalDeviceProperties::pipelineCacheUUID
The first four bytes encode the length of the entire pipeline cache header, in bytes. This value includes all fields in the header including the pipeline cache version field and the size of the length field.

The next four bytes encode the pipeline cache version, as described for VkPipelineCacheHeaderVersion. A consumer of the pipeline cache should use the cache version to interpret the remainder of the cache header.

If pDataSize is less than what is necessary to store this header, nothing will be written to pData and zero will be written to pDataSize.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pipelineCache must be a valid VkPipelineCache handle
pDataSize must be a valid pointer to a size_t value
If the value referenced by pDataSize is not 0, and pData is not NULL, pData must be a valid pointer to an array of pDataSize bytes
pipelineCache must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkPipelineCache

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetPipelineCacheData

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetQueryPoolResults(3)
Name
vkGetQueryPoolResults - Copy results of queries in a query pool to a host memory region

C Specification
To retrieve status and results for a set of queries, call:

VkResult vkGetQueryPoolResults(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    size_t                                      dataSize,
    void*                                       pData,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags);
Parameters
device is the logical device that owns the query pool.
queryPool is the query pool managing the queries containing the desired results.
firstQuery is the initial query index.
queryCount is the number of queries. firstQuery and queryCount together define a range of queries. For pipeline statistics queries, each query index in the pool contains one integer value for each bit that is enabled in VkQueryPoolCreateInfo::pipelineStatistics when the pool is created.
dataSize is the size in bytes of the buffer pointed to by pData.
pData is a pointer to a user-allocated buffer where the results will be written
stride is the stride in bytes between results for individual queries within pData.
flags is a bitmask of VkQueryResultFlagBits specifying how and when results are returned.
Description
If no bits are set in flags, and all requested queries are in the available state, results are written as an array of 32-bit unsigned integer values. The behavior when not all queries are available, is described below.

If VK_QUERY_RESULT_64_BIT is not set and the result overflows a 32-bit value, the value may either wrap or saturate. Similarly, if VK_QUERY_RESULT_64_BIT is set and the result overflows a 64-bit value, the value may either wrap or saturate.

If VK_QUERY_RESULT_WAIT_BIT is set, Vulkan will wait for each query to be in the available state before retrieving the numerical results for that query. In this case, vkGetQueryPoolResults is guaranteed to succeed and return VK_SUCCESS if the queries become available in a finite time (i.e. if they have been issued and not reset). If queries will never finish (e.g. due to being reset but not issued), then vkGetQueryPoolResults may not return in finite time.

If VK_QUERY_RESULT_WAIT_BIT and VK_QUERY_RESULT_PARTIAL_BIT are both not set then no result values are written to pData for queries that are in the unavailable state at the time of the call, and vkGetQueryPoolResults returns VK_NOT_READY. However, availability state is still written to pData for those queries if VK_QUERY_RESULT_WITH_AVAILABILITY_BIT is set.

Note
Applications must take care to ensure that use of the VK_QUERY_RESULT_WAIT_BIT bit has the desired effect.

For example, if a query has been used previously and a command buffer records the commands vkCmdResetQueryPool, vkCmdBeginQuery, and vkCmdEndQuery for that query, then the query will remain in the available state until the vkCmdResetQueryPool command executes on a queue. Applications can use fences or events to ensure that a query has already been reset before checking for its results or availability status. Otherwise, a stale value could be returned from a previous use of the query.

The above also applies when VK_QUERY_RESULT_WAIT_BIT is used in combination with VK_QUERY_RESULT_WITH_AVAILABILITY_BIT. In this case, the returned availability status may reflect the result of a previous use of the query unless the vkCmdResetQueryPool command has been executed since the last use of the query.
Note
Applications can double-buffer query pool usage, with a pool per frame, and reset queries at the end of the frame in which they are read.
If VK_QUERY_RESULT_PARTIAL_BIT is set, VK_QUERY_RESULT_WAIT_BIT is not set, and the query’s status is unavailable, an intermediate result value between zero and the final result value is written to pData for that query.

VK_QUERY_RESULT_PARTIAL_BIT must not be used if the pool’s queryType is VK_QUERY_TYPE_TIMESTAMP.

If VK_QUERY_RESULT_WITH_AVAILABILITY_BIT is set, the final integer value written for each query is non-zero if the query’s status was available or zero if the status was unavailable. When VK_QUERY_RESULT_WITH_AVAILABILITY_BIT is used, implementations must guarantee that if they return a non-zero availability value then the numerical results must be valid, assuming the results are not reset by a subsequent command.

Note
Satisfying this guarantee may require careful ordering by the application, e.g. to read the availability status before reading the results.
Valid Usage
firstQuery must be less than the number of queries in queryPool
If VK_QUERY_RESULT_64_BIT is not set in flags then pData and stride must be multiples of 4
If VK_QUERY_RESULT_64_BIT is set in flags then pData and stride must be multiples of 8
The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool
dataSize must be large enough to contain the result of each query, as described here
If the queryType used to create queryPool was VK_QUERY_TYPE_TIMESTAMP, flags must not contain VK_QUERY_RESULT_PARTIAL_BIT
Valid Usage (Implicit)
device must be a valid VkDevice handle
queryPool must be a valid VkQueryPool handle
pData must be a valid pointer to an array of dataSize bytes
flags must be a valid combination of VkQueryResultFlagBits values
dataSize must be greater than 0
queryPool must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
VK_NOT_READY
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
See Also
VkDevice, VkDeviceSize, VkQueryPool, VkQueryResultFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetQueryPoolResults

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetQueueCheckpointDataNV(3)
Name
vkGetQueueCheckpointDataNV - retrieve diagnostic checkpoint data

C Specification
If the device encounters an error during execution, the implementation will return a VK_ERROR_DEVICE_LOST error to the application at a certain point during host execution. When this happens, the application can call vkGetQueueCheckpointDataNV to retrieve information on the most recent diagnostic checkpoints that were executed by the device.

void vkGetQueueCheckpointDataNV(
    VkQueue                                     queue,
    uint32_t*                                   pCheckpointDataCount,
    VkCheckpointDataNV*                         pCheckpointData);
Parameters
queue is the VkQueue object the caller would like to retrieve checkpoint data for
pCheckpointDataCount is a pointer to an integer related to the number of checkpoint markers available or queried, as described below.
pCheckpointData is either NULL or a pointer to an array of VkCheckpointDataNV structures.
Description
If pCheckpointData is NULL, then the number of checkpoint markers available is returned in pCheckpointDataCount.

Otherwise, pCheckpointDataCount must point to a variable set by the user to the number of elements in the pCheckpointData array, and on return the variable is overwritten with the number of structures actually written to pCheckpointData.

If pCheckpointDataCount is less than the number of checkpoint markers available, at most pCheckpointDataCount structures will be written.

Valid Usage
The device that queue belongs to must be in the lost state
Valid Usage (Implicit)
queue must be a valid VkQueue handle
pCheckpointDataCount must be a valid pointer to a uint32_t value
If the value referenced by pCheckpointDataCount is not 0, and pCheckpointData is not NULL, pCheckpointData must be a valid pointer to an array of pCheckpointDataCount VkCheckpointDataNV structures
See Also
VkCheckpointDataNV, VkQueue

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetQueueCheckpointDataNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetRandROutputDisplayEXT(3)
Name
vkGetRandROutputDisplayEXT - Query the VkDisplayKHR corresponding to an X11 RandR Output

C Specification
When acquiring displays from an X11 server, an application may also wish to enumerate and identify them using a native handle rather than a VkDisplayKHR handle. To determine the VkDisplayKHR handle corresponding to an X11 RandR Output, call:

VkResult vkGetRandROutputDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    Display*                                    dpy,
    RROutput                                    rrOutput,
    VkDisplayKHR*                               pDisplay);
Parameters
physicalDevice The physical device to query the display handle on.
dpy A connection to the X11 server from which rrOutput was queried.
rrOutput An X11 RandR output ID.
pDisplay The corresponding VkDisplayKHR handle will be returned here.
Description
If there is no VkDisplayKHR corresponding to rrOutput on physicalDevice, VK_NULL_HANDLE must be returned in pDisplay.

Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
dpy must be a valid pointer to a Display value
pDisplay must be a valid pointer to a VkDisplayKHR handle
Return Codes
Success
VK_SUCCESS
See Also
VkDisplayKHR, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetRandROutputDisplayEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetRayTracingShaderGroupHandlesNV(3)
Name
vkGetRayTracingShaderGroupHandlesNV - Query ray tracing pipeline shader group handles

C Specification
To query the opaque handles of shaders in the ray tracing pipeline, call:

VkResult vkGetRayTracingShaderGroupHandlesNV(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    uint32_t                                    firstGroup,
    uint32_t                                    groupCount,
    size_t                                      dataSize,
    void*                                       pData);
Parameters
device is the logical device that contains the ray tracing pipeline.
pipeline is the ray tracing pipeline object that contains the shaders.
firstGroup is the index of the first group to retrieve a handle for from the VkRayTracingShaderGroupCreateInfoNV::pGroups array.
groupCount is the number of shader handles to retrieve.
dataSize is the size in bytes of the buffer pointed to by pData.
pData is a pointer to a user-allocated buffer where the results will be written.
Description
Valid Usage
The sum of firstGroup and groupCount must be less than the number of shader groups in pipeline.
dataSize must be at least VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize × groupCount
Valid Usage (Implicit)
device must be a valid VkDevice handle
pipeline must be a valid VkPipeline handle
pData must be a valid pointer to an array of dataSize bytes
dataSize must be greater than 0
pipeline must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkPipeline

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetRayTracingShaderGroupHandlesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetRefreshCycleDurationGOOGLE(3)
Name
vkGetRefreshCycleDurationGOOGLE - Obtain the RC duration of the PE’s display

C Specification
To query the duration of a refresh cycle (RC) for the presentation engine’s display, call:

VkResult vkGetRefreshCycleDurationGOOGLE(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkRefreshCycleDurationGOOGLE*               pDisplayTimingProperties);
Parameters
device is the device associated with swapchain.
swapchain is the swapchain to obtain the refresh duration for.
pDisplayTimingProperties is a pointer to an instance of the VkRefreshCycleDurationGOOGLE structure.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
swapchain must be a valid VkSwapchainKHR handle
pDisplayTimingProperties must be a valid pointer to a VkRefreshCycleDurationGOOGLE structure
Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance
Host Synchronization
Host access to swapchain must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_DEVICE_LOST
VK_ERROR_SURFACE_LOST_KHR
See Also
VkDevice, VkRefreshCycleDurationGOOGLE, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetRefreshCycleDurationGOOGLE

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetRenderAreaGranularity(3)
Name
vkGetRenderAreaGranularity - Returns the granularity for optimal render area

C Specification
To query the render area granularity, call:

void vkGetRenderAreaGranularity(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    VkExtent2D*                                 pGranularity);
Parameters
device is the logical device that owns the render pass.
renderPass is a handle to a render pass.
pGranularity points to a VkExtent2D structure in which the granularity is returned.
Description
The conditions leading to an optimal renderArea are:

the offset.x member in renderArea is a multiple of the width member of the returned VkExtent2D (the horizontal granularity).
the offset.y member in renderArea is a multiple of the height of the returned VkExtent2D (the vertical granularity).
either the offset.width member in renderArea is a multiple of the horizontal granularity or offset.x+offset.width is equal to the width of the framebuffer in the VkRenderPassBeginInfo.
either the offset.height member in renderArea is a multiple of the vertical granularity or offset.y+offset.height is equal to the height of the framebuffer in the VkRenderPassBeginInfo.
Subpass dependencies are not affected by the render area, and apply to the entire image subresources attached to the framebuffer as specified in the description of automatic layout transitions. Similarly, pipeline barriers are valid even if their effect extends outside the render area.

Valid Usage (Implicit)
device must be a valid VkDevice handle
renderPass must be a valid VkRenderPass handle
pGranularity must be a valid pointer to a VkExtent2D structure
renderPass must have been created, allocated, or retrieved from device
See Also
VkDevice, VkExtent2D, VkRenderPass

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetRenderAreaGranularity

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetSemaphoreFdKHR(3)
Name
vkGetSemaphoreFdKHR - Get a POSIX file descriptor handle for a semaphore

C Specification
To export a POSIX file descriptor representing the payload of a semaphore, call:

VkResult vkGetSemaphoreFdKHR(
    VkDevice                                    device,
    const VkSemaphoreGetFdInfoKHR*              pGetFdInfo,
    int*                                        pFd);
Parameters
device is the logical device that created the semaphore being exported.
pGetFdInfo is a pointer to an instance of the VkSemaphoreGetFdInfoKHR structure containing parameters of the export operation.
pFd will return the file descriptor representing the semaphore payload.
Description
Each call to vkGetSemaphoreFdKHR must create a new file descriptor and transfer ownership of it to the application. To avoid leaking resources, the application must release ownership of the file descriptor when it is no longer needed.

Note
Ownership can be released in many ways. For example, the application can call close() on the file descriptor, or transfer ownership back to Vulkan by using the file descriptor to import a semaphore payload.
Where supported by the operating system, the implementation must set the file descriptor to be closed automatically when an execve system call is made.

Exporting a file descriptor from a semaphore may have side effects depending on the transference of the specified handle type, as described in Importing Semaphore State.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pGetFdInfo must be a valid pointer to a valid VkSemaphoreGetFdInfoKHR structure
pFd must be a valid pointer to a int value
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_TOO_MANY_OBJECTS
VK_ERROR_OUT_OF_HOST_MEMORY
See Also
VkDevice, VkSemaphoreGetFdInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetSemaphoreFdKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetSemaphoreWin32HandleKHR(3)
Name
vkGetSemaphoreWin32HandleKHR - Get a Windows HANDLE for a semaphore

C Specification
To export a Windows handle representing the payload of a semaphore, call:

VkResult vkGetSemaphoreWin32HandleKHR(
    VkDevice                                    device,
    const VkSemaphoreGetWin32HandleInfoKHR*     pGetWin32HandleInfo,
    HANDLE*                                     pHandle);
Parameters
device is the logical device that created the semaphore being exported.
pGetWin32HandleInfo is a pointer to an instance of the VkSemaphoreGetWin32HandleInfoKHR structure containing parameters of the export operation.
pHandle will return the Windows handle representing the semaphore state.
Description
For handle types defined as NT handles, the handles returned by vkGetSemaphoreWin32HandleKHR are owned by the application. To avoid leaking resources, the application must release ownership of them using the CloseHandle system call when they are no longer needed.

Exporting a Windows handle from a semaphore may have side effects depending on the transference of the specified handle type, as described in Importing Semaphore Payloads.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pGetWin32HandleInfo must be a valid pointer to a valid VkSemaphoreGetWin32HandleInfoKHR structure
pHandle must be a valid pointer to a HANDLE value
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_TOO_MANY_OBJECTS
VK_ERROR_OUT_OF_HOST_MEMORY
See Also
VkDevice, VkSemaphoreGetWin32HandleInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetSemaphoreWin32HandleKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetShaderInfoAMD(3)
Name
vkGetShaderInfoAMD - Get information about a shader in a pipeline

C Specification
Information about a particular shader that has been compiled as part of a pipeline object can be extracted by calling:

VkResult vkGetShaderInfoAMD(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    VkShaderStageFlagBits                       shaderStage,
    VkShaderInfoTypeAMD                         infoType,
    size_t*                                     pInfoSize,
    void*                                       pInfo);
Parameters
device is the device that created pipeline.
pipeline is the target of the query.
shaderStage identifies the particular shader within the pipeline about which information is being queried.
infoType describes what kind of information is being queried.
pInfoSize is a pointer to a value related to the amount of data the query returns, as described below.
pInfo is either NULL or a pointer to a buffer.
Description
If pInfo is NULL, then the maximum size of the information that can be retrieved about the shader, in bytes, is returned in pInfoSize. Otherwise, pInfoSize must point to a variable set by the user to the size of the buffer, in bytes, pointed to by pInfo, and on return the variable is overwritten with the amount of data actually written to pInfo.

If pInfoSize is less than the maximum size that can be retrieved by the pipeline cache, then at most pInfoSize bytes will be written to pInfo, and vkGetShaderInfoAMD will return VK_INCOMPLETE.

Not all information is available for every shader and implementations may not support all kinds of information for any shader. When a certain type of information is unavailable, the function returns VK_ERROR_FEATURE_NOT_PRESENT.

If information is successfully and fully queried, the function will return VK_SUCCESS.

For infoType VK_SHADER_INFO_TYPE_STATISTICS_AMD, an instance of VkShaderStatisticsInfoAMD will be written to the buffer pointed to by pInfo. This structure will be populated with statistics regarding the physical device resources used by that shader along with other miscellaneous information and is described in further detail below.

For infoType VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD, pInfo points to a UTF-8 null-terminated string containing human-readable disassembly. The exact formatting and contents of the disassembly string are vendor-specific.

The formatting and contents of all other types of information, including infoType VK_SHADER_INFO_TYPE_BINARY_AMD, are left to the vendor and are not further specified by this extension.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pipeline must be a valid VkPipeline handle
shaderStage must be a valid VkShaderStageFlagBits value
infoType must be a valid VkShaderInfoTypeAMD value
pInfoSize must be a valid pointer to a size_t value
If the value referenced by pInfoSize is not 0, and pInfo is not NULL, pInfo must be a valid pointer to an array of pInfoSize bytes
pipeline must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_FEATURE_NOT_PRESENT
VK_ERROR_OUT_OF_HOST_MEMORY
See Also
VkDevice, VkPipeline, VkShaderInfoTypeAMD, VkShaderStageFlagBits

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetShaderInfoAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetSwapchainCounterEXT(3)
Name
vkGetSwapchainCounterEXT - Query the current value of a surface counter

C Specification
The requested counters become active when the first presentation command for the associated swapchain is processed by the presentation engine. To query the value of an active counter, use:

VkResult vkGetSwapchainCounterEXT(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkSurfaceCounterFlagBitsEXT                 counter,
    uint64_t*                                   pCounterValue);
Parameters
device is the VkDevice associated with swapchain.
swapchain is the swapchain from which to query the counter value.
counter is the counter to query.
pCounterValue will return the current value of the counter.
Description
If a counter is not available because the swapchain is out of date, the implementation may return VK_ERROR_OUT_OF_DATE_KHR.

Valid Usage
One or more present commands on swapchain must have been processed by the presentation engine.
Valid Usage (Implicit)
device must be a valid VkDevice handle
swapchain must be a valid VkSwapchainKHR handle
counter must be a valid VkSurfaceCounterFlagBitsEXT value
pCounterValue must be a valid pointer to a uint64_t value
Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_DEVICE_LOST
VK_ERROR_OUT_OF_DATE_KHR
See Also
VkDevice, VkSurfaceCounterFlagBitsEXT, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetSwapchainCounterEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetSwapchainImagesKHR(3)
Name
vkGetSwapchainImagesKHR - Obtain the array of presentable images associated with a swapchain

C Specification
To obtain the array of presentable images associated with a swapchain, call:

VkResult vkGetSwapchainImagesKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t*                                   pSwapchainImageCount,
    VkImage*                                    pSwapchainImages);
Parameters
device is the device associated with swapchain.
swapchain is the swapchain to query.
pSwapchainImageCount is a pointer to an integer related to the number of presentable images available or queried, as described below.
pSwapchainImages is either NULL or a pointer to an array of VkImage handles.
Description
If pSwapchainImages is NULL, then the number of presentable images for swapchain is returned in pSwapchainImageCount. Otherwise, pSwapchainImageCount must point to a variable set by the user to the number of elements in the pSwapchainImages array, and on return the variable is overwritten with the number of structures actually written to pSwapchainImages. If the value of pSwapchainImageCount is less than the number of presentable images for swapchain, at most pSwapchainImageCount structures will be written. If pSwapchainImageCount is smaller than the number of presentable images for swapchain, VK_INCOMPLETE will be returned instead of VK_SUCCESS to indicate that not all the available values were returned.

Valid Usage (Implicit)
device must be a valid VkDevice handle
swapchain must be a valid VkSwapchainKHR handle
pSwapchainImageCount must be a valid pointer to a uint32_t value
If the value referenced by pSwapchainImageCount is not 0, and pSwapchainImages is not NULL, pSwapchainImages must be a valid pointer to an array of pSwapchainImageCount VkImage handles
Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkImage, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetSwapchainImagesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetSwapchainStatusKHR(3)
Name
vkGetSwapchainStatusKHR - Get a swapchain’s status

C Specification
In order to query a swapchain’s status when rendering to a shared presentable image, call:

VkResult vkGetSwapchainStatusKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain);
Parameters
device is the device associated with swapchain.
swapchain is the swapchain to query.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
swapchain must be a valid VkSwapchainKHR handle
Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance
Host Synchronization
Host access to swapchain must be externally synchronized
Return Codes
Success
VK_SUCCESS
VK_SUBOPTIMAL_KHR
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
VK_ERROR_OUT_OF_DATE_KHR
VK_ERROR_SURFACE_LOST_KHR
VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
See Also
VkDevice, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetSwapchainStatusKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkGetValidationCacheDataEXT(3)
Name
vkGetValidationCacheDataEXT - Get the data store from a validation cache

C Specification
Data can be retrieved from a validation cache object using the command:

VkResult vkGetValidationCacheDataEXT(
    VkDevice                                    device,
    VkValidationCacheEXT                        validationCache,
    size_t*                                     pDataSize,
    void*                                       pData);
Parameters
device is the logical device that owns the validation cache.
validationCache is the validation cache to retrieve data from.
pDataSize is a pointer to a value related to the amount of data in the validation cache, as described below.
pData is either NULL or a pointer to a buffer.
Description
If pData is NULL, then the maximum size of the data that can be retrieved from the validation cache, in bytes, is returned in pDataSize. Otherwise, pDataSize must point to a variable set by the user to the size of the buffer, in bytes, pointed to by pData, and on return the variable is overwritten with the amount of data actually written to pData.

If pDataSize is less than the maximum size that can be retrieved by the validation cache, at most pDataSize bytes will be written to pData, and vkGetValidationCacheDataEXT will return VK_INCOMPLETE. Any data written to pData is valid and can be provided as the pInitialData member of the VkValidationCacheCreateInfoEXT structure passed to vkCreateValidationCacheEXT.

Two calls to vkGetValidationCacheDataEXT with the same parameters must retrieve the same data unless a command that modifies the contents of the cache is called between them.

Applications can store the data retrieved from the validation cache, and use these data, possibly in a future run of the application, to populate new validation cache objects. The results of validation, however, may depend on the vendor ID, device ID, driver version, and other details of the device. To enable applications to detect when previously retrieved data is incompatible with the device, the initial bytes written to pData must be a header consisting of the following members:

Table 6. Layout for validation cache header version VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT
Offset	Size	Meaning
0
4
length in bytes of the entire validation cache header written as a stream of bytes, with the least significant byte first
4
4
a VkValidationCacheHeaderVersionEXT value written as a stream of bytes, with the least significant byte first
8
VK_UUID_SIZE
a layer commit ID expressed as a UUID, which uniquely identifies the version of the validation layers used to generate these validation results
The first four bytes encode the length of the entire validation cache header, in bytes. This value includes all fields in the header including the validation cache version field and the size of the length field.

The next four bytes encode the validation cache version, as described for VkValidationCacheHeaderVersionEXT. A consumer of the validation cache should use the cache version to interpret the remainder of the cache header.

If pDataSize is less than what is necessary to store this header, nothing will be written to pData and zero will be written to pDataSize.

Valid Usage (Implicit)
device must be a valid VkDevice handle
validationCache must be a valid VkValidationCacheEXT handle
pDataSize must be a valid pointer to a size_t value
If the value referenced by pDataSize is not 0, and pData is not NULL, pData must be a valid pointer to an array of pDataSize bytes
validationCache must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
VK_INCOMPLETE
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkValidationCacheEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkGetValidationCacheDataEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkImportFenceFdKHR(3)
Name
vkImportFenceFdKHR - Import a fence from a POSIX file descriptor

C Specification
To import a fence payload from a POSIX file descriptor, call:

VkResult vkImportFenceFdKHR(
    VkDevice                                    device,
    const VkImportFenceFdInfoKHR*               pImportFenceFdInfo);
Parameters
device is the logical device that created the fence.
pImportFenceFdInfo points to a VkImportFenceFdInfoKHR structure specifying the fence and import parameters.
Description
Importing a fence payload from a file descriptor transfers ownership of the file descriptor from the application to the Vulkan implementation. The application must not perform any operations on the file descriptor after a successful import.

Applications can import the same fence payload into multiple instances of Vulkan, into the same instance from which it was exported, and multiple times into a given Vulkan instance.

Valid Usage
fence must not be associated with any queue command that has not yet completed execution on that queue
Valid Usage (Implicit)
device must be a valid VkDevice handle
pImportFenceFdInfo must be a valid pointer to a valid VkImportFenceFdInfoKHR structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_INVALID_EXTERNAL_HANDLE
See Also
VkDevice, VkImportFenceFdInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkImportFenceFdKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkImportFenceWin32HandleKHR(3)
Name
vkImportFenceWin32HandleKHR - Import a fence from a Windows HANDLE

C Specification
To import a fence payload from a Windows handle, call:

VkResult vkImportFenceWin32HandleKHR(
    VkDevice                                    device,
    const VkImportFenceWin32HandleInfoKHR*      pImportFenceWin32HandleInfo);
Parameters
device is the logical device that created the fence.
pImportFenceWin32HandleInfo points to a VkImportFenceWin32HandleInfoKHR structure specifying the fence and import parameters.
Description
Importing a fence payload from Windows handles does not transfer ownership of the handle to the Vulkan implementation. For handle types defined as NT handles, the application must release ownership using the CloseHandle system call when the handle is no longer needed.

Applications can import the same fence payload into multiple instances of Vulkan, into the same instance from which it was exported, and multiple times into a given Vulkan instance.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pImportFenceWin32HandleInfo must be a valid pointer to a valid VkImportFenceWin32HandleInfoKHR structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_INVALID_EXTERNAL_HANDLE
See Also
VkDevice, VkImportFenceWin32HandleInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkImportFenceWin32HandleKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkImportSemaphoreFdKHR(3)
Name
vkImportSemaphoreFdKHR - Import a semaphore from a POSIX file descriptor

C Specification
To import a semaphore payload from a POSIX file descriptor, call:

VkResult vkImportSemaphoreFdKHR(
    VkDevice                                    device,
    const VkImportSemaphoreFdInfoKHR*           pImportSemaphoreFdInfo);
Parameters
device is the logical device that created the semaphore.
pImportSemaphoreFdInfo points to a VkImportSemaphoreFdInfoKHR structure specifying the semaphore and import parameters.
Description
Importing a semaphore payload from a file descriptor transfers ownership of the file descriptor from the application to the Vulkan implementation. The application must not perform any operations on the file descriptor after a successful import.

Applications can import the same semaphore payload into multiple instances of Vulkan, into the same instance from which it was exported, and multiple times into a given Vulkan instance.

Valid Usage
semaphore must not be associated with any queue command that has not yet completed execution on that queue
Valid Usage (Implicit)
device must be a valid VkDevice handle
pImportSemaphoreFdInfo must be a valid pointer to a valid VkImportSemaphoreFdInfoKHR structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_INVALID_EXTERNAL_HANDLE
See Also
VkDevice, VkImportSemaphoreFdInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkImportSemaphoreFdKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkImportSemaphoreWin32HandleKHR(3)
Name
vkImportSemaphoreWin32HandleKHR - Import a semaphore from a Windows HANDLE

C Specification
To import a semaphore payload from a Windows handle, call:

VkResult vkImportSemaphoreWin32HandleKHR(
    VkDevice                                    device,
    const VkImportSemaphoreWin32HandleInfoKHR*  pImportSemaphoreWin32HandleInfo);
Parameters
device is the logical device that created the semaphore.
pImportSemaphoreWin32HandleInfo points to a VkImportSemaphoreWin32HandleInfoKHR structure specifying the semaphore and import parameters.
Description
Importing a semaphore payload from Windows handles does not transfer ownership of the handle to the Vulkan implementation. For handle types defined as NT handles, the application must release ownership using the CloseHandle system call when the handle is no longer needed.

Applications can import the same semaphore payload into multiple instances of Vulkan, into the same instance from which it was exported, and multiple times into a given Vulkan instance.

Valid Usage (Implicit)
device must be a valid VkDevice handle
pImportSemaphoreWin32HandleInfo must be a valid pointer to a valid VkImportSemaphoreWin32HandleInfoKHR structure
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_INVALID_EXTERNAL_HANDLE
See Also
VkDevice, VkImportSemaphoreWin32HandleInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkImportSemaphoreWin32HandleKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkInvalidateMappedMemoryRanges(3)
Name
vkInvalidateMappedMemoryRanges - Invalidate ranges of mapped memory objects

C Specification
To invalidate ranges of non-coherent memory from the host caches, call:

VkResult vkInvalidateMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges);
Parameters
device is the logical device that owns the memory ranges.
memoryRangeCount is the length of the pMemoryRanges array.
pMemoryRanges is a pointer to an array of VkMappedMemoryRange structures describing the memory ranges to invalidate.
Description
vkInvalidateMappedMemoryRanges guarantees that device writes to the memory ranges described by pMemoryRanges, which have been made available to the host memory domain using the VK_ACCESS_HOST_WRITE_BIT and VK_ACCESS_HOST_READ_BIT access types, are made visible to the host. If a range of non-coherent memory is written by the host and then invalidated without first being flushed, its contents are undefined.

Within each range described by pMemoryRanges, each set of nonCoherentAtomSize bytes in that range is invalidated if any byte in that set has been written by the device since it was first host mapped, or the last time it was invalidated.

Note
Mapping non-coherent memory does not implicitly invalidate the mapped memory, and device writes that have not been invalidated must be made visible before the host reads or overwrites them.
Valid Usage (Implicit)
device must be a valid VkDevice handle
pMemoryRanges must be a valid pointer to an array of memoryRangeCount valid VkMappedMemoryRange structures
memoryRangeCount must be greater than 0
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkMappedMemoryRange

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkInvalidateMappedMemoryRanges

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkMapMemory(3)
Name
vkMapMemory - Map a memory object into application address space

C Specification
To retrieve a host virtual address pointer to a region of a mappable memory object, call:

VkResult vkMapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    void**                                      ppData);
Parameters
device is the logical device that owns the memory.
memory is the VkDeviceMemory object to be mapped.
offset is a zero-based byte offset from the beginning of the memory object.
size is the size of the memory range to map, or VK_WHOLE_SIZE to map from offset to the end of the allocation.
flags is reserved for future use.
ppData points to a pointer in which is returned a host-accessible pointer to the beginning of the mapped range. This pointer minus offset must be aligned to at least VkPhysicalDeviceLimits::minMemoryMapAlignment.
Description
After a successful call to vkMapMemory the memory object memory is considered to be currently host mapped. It is an application error to call vkMapMemory on a memory object that is already host mapped.

Note
vkMapMemory will fail if the implementation is unable to allocate an appropriately sized contiguous virtual address range, e.g. due to virtual address space fragmentation or platform limits. In such cases, vkMapMemory must return VK_ERROR_MEMORY_MAP_FAILED. The application can improve the likelihood of success by reducing the size of the mapped range and/or removing unneeded mappings using vkUnmapMemory.
vkMapMemory does not check whether the device memory is currently in use before returning the host-accessible pointer. The application must guarantee that any previously submitted command that writes to this range has completed before the host reads from or writes to that range, and that any previously submitted command that reads from that range has completed before the host writes to that region (see here for details on fulfilling such a guarantee). If the device memory was allocated without the VK_MEMORY_PROPERTY_HOST_COHERENT_BIT set, these guarantees must be made for an extended range: the application must round down the start of the range to the nearest multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize, and round the end of the range up to the nearest multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize.

While a range of device memory is host mapped, the application is responsible for synchronizing both device and host access to that memory range.

Note
It is important for the application developer to become meticulously familiar with all of the mechanisms described in the chapter on Synchronization and Cache Control as they are crucial to maintaining memory access ordering.
Valid Usage
memory must not be currently host mapped
offset must be less than the size of memory
If size is not equal to VK_WHOLE_SIZE, size must be greater than 0
If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to the size of the memory minus offset
memory must have been created with a memory type that reports VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT
memory must not have been allocated with multiple instances.
Valid Usage (Implicit)
device must be a valid VkDevice handle
memory must be a valid VkDeviceMemory handle
flags must be 0
ppData must be a valid pointer to a pointer value
memory must have been created, allocated, or retrieved from device
Host Synchronization
Host access to memory must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_MEMORY_MAP_FAILED
See Also
VkDevice, VkDeviceMemory, VkDeviceSize, VkMemoryMapFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkMapMemory

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkMergePipelineCaches(3)
Name
vkMergePipelineCaches - Combine the data stores of pipeline caches

C Specification
Pipeline cache objects can be merged using the command:

VkResult vkMergePipelineCaches(
    VkDevice                                    device,
    VkPipelineCache                             dstCache,
    uint32_t                                    srcCacheCount,
    const VkPipelineCache*                      pSrcCaches);
Parameters
device is the logical device that owns the pipeline cache objects.
dstCache is the handle of the pipeline cache to merge results into.
srcCacheCount is the length of the pSrcCaches array.
pSrcCaches is an array of pipeline cache handles, which will be merged into dstCache. The previous contents of dstCache are included after the merge.
Description
Note
The details of the merge operation are implementation dependent, but implementations should merge the contents of the specified pipelines and prune duplicate entries.
Valid Usage
dstCache must not appear in the list of source caches
Valid Usage (Implicit)
device must be a valid VkDevice handle
dstCache must be a valid VkPipelineCache handle
pSrcCaches must be a valid pointer to an array of srcCacheCount valid VkPipelineCache handles
srcCacheCount must be greater than 0
dstCache must have been created, allocated, or retrieved from device
Each element of pSrcCaches must have been created, allocated, or retrieved from device
Host Synchronization
Host access to dstCache must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkPipelineCache

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkMergePipelineCaches

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkMergeValidationCachesEXT(3)
Name
vkMergeValidationCachesEXT - Combine the data stores of validation caches

C Specification
Validation cache objects can be merged using the command:

VkResult vkMergeValidationCachesEXT(
    VkDevice                                    device,
    VkValidationCacheEXT                        dstCache,
    uint32_t                                    srcCacheCount,
    const VkValidationCacheEXT*                 pSrcCaches);
Parameters
device is the logical device that owns the validation cache objects.
dstCache is the handle of the validation cache to merge results into.
srcCacheCount is the length of the pSrcCaches array.
pSrcCaches is an array of validation cache handles, which will be merged into dstCache. The previous contents of dstCache are included after the merge.
Description
Note
The details of the merge operation are implementation dependent, but implementations should merge the contents of the specified validation caches and prune duplicate entries.
Valid Usage
dstCache must not appear in the list of source caches
Valid Usage (Implicit)
device must be a valid VkDevice handle
dstCache must be a valid VkValidationCacheEXT handle
pSrcCaches must be a valid pointer to an array of srcCacheCount valid VkValidationCacheEXT handles
srcCacheCount must be greater than 0
dstCache must have been created, allocated, or retrieved from device
Each element of pSrcCaches must have been created, allocated, or retrieved from device
Host Synchronization
Host access to dstCache must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkValidationCacheEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkMergeValidationCachesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkQueueBeginDebugUtilsLabelEXT(3)
Name
vkQueueBeginDebugUtilsLabelEXT - Open a queue debug label region

C Specification
A queue debug label region is opened by calling:

void vkQueueBeginDebugUtilsLabelEXT(
    VkQueue                                     queue,
    const VkDebugUtilsLabelEXT*                 pLabelInfo);
Parameters
queue is the queue in which to start a debug label region.
pLabelInfo is a pointer to an instance of the VkDebugUtilsLabelEXT structure specifying the parameters of the label region to open.
Description
Valid Usage (Implicit)
queue must be a valid VkQueue handle
pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
-
-
Any
-
See Also
VkDebugUtilsLabelEXT, VkQueue

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkQueueBeginDebugUtilsLabelEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkQueueBindSparse(3)
Name
vkQueueBindSparse - Bind device memory to a sparse resource object

C Specification
To submit sparse binding operations to a queue, call:

VkResult vkQueueBindSparse(
    VkQueue                                     queue,
    uint32_t                                    bindInfoCount,
    const VkBindSparseInfo*                     pBindInfo,
    VkFence                                     fence);
Parameters
queue is the queue that the sparse binding operations will be submitted to.
bindInfoCount is the number of elements in the pBindInfo array.
pBindInfo is an array of VkBindSparseInfo structures, each specifying a sparse binding submission batch.
fence is an optional handle to a fence to be signaled. If fence is not VK_NULL_HANDLE, it defines a fence signal operation.
Description
vkQueueBindSparse is a queue submission command, with each batch defined by an element of pBindInfo as an instance of the VkBindSparseInfo structure. Batches begin execution in the order they appear in pBindInfo, but may complete out of order.

Within a batch, a given range of a resource must not be bound more than once. Across batches, if a range is to be bound to one allocation and offset and then to another allocation and offset, then the application must guarantee (usually using semaphores) that the binding operations are executed in the correct order, as well as to order binding operations against the execution of command buffer submissions.

As no operation to vkQueueBindSparse causes any pipeline stage to access memory, synchronization primitives used in this command effectively only define execution dependencies.

Additional information about fence and semaphore operation is described in the synchronization chapter.

Valid Usage
If fence is not VK_NULL_HANDLE, fence must be unsignaled
If fence is not VK_NULL_HANDLE, fence must not be associated with any other queue command that has not yet completed execution on that queue
Each element of the pSignalSemaphores member of each element of pBindInfo must be unsignaled when the semaphore signal operation it defines is executed on the device
When a semaphore unsignal operation defined by any element of the pWaitSemaphores member of any element of pBindInfo executes on queue, no other queue must be waiting on the same semaphore.
All elements of the pWaitSemaphores member of all elements of pBindInfo must be semaphores that are signaled, or have semaphore signal operations previously submitted for execution.
Valid Usage (Implicit)
queue must be a valid VkQueue handle
If bindInfoCount is not 0, pBindInfo must be a valid pointer to an array of bindInfoCount valid VkBindSparseInfo structures
If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle
The queue must support sparse binding operations
Both of fence, and queue that are valid handles must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to queue must be externally synchronized
Host access to pBindInfo[].pWaitSemaphores[] must be externally synchronized
Host access to pBindInfo[].pSignalSemaphores[] must be externally synchronized
Host access to pBindInfo[].pBufferBinds[].buffer must be externally synchronized
Host access to pBindInfo[].pImageOpaqueBinds[].image must be externally synchronized
Host access to pBindInfo[].pImageBinds[].image must be externally synchronized
Host access to fence must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
-
-
SPARSE_BINDING
-
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
See Also
VkBindSparseInfo, VkFence, VkQueue

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkQueueBindSparse

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkQueueEndDebugUtilsLabelEXT(3)
Name
vkQueueEndDebugUtilsLabelEXT - Close a queue debug label region

C Specification
A queue debug label region is closed by calling:

void vkQueueEndDebugUtilsLabelEXT(
    VkQueue                                     queue);
Parameters
queue is the queue in which a debug label region should be closed.
Description
The calls to vkQueueBeginDebugUtilsLabelEXT and vkQueueEndDebugUtilsLabelEXT must be matched and balanced.

Valid Usage
There must be an outstanding vkQueueBeginDebugUtilsLabelEXT command prior to the vkQueueEndDebugUtilsLabelEXT on the queue
Valid Usage (Implicit)
queue must be a valid VkQueue handle
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
-
-
Any
-
See Also
VkQueue

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkQueueEndDebugUtilsLabelEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkQueueInsertDebugUtilsLabelEXT(3)
Name
vkQueueInsertDebugUtilsLabelEXT - Insert a label into a queue

C Specification
A single label can be inserted into a queue by calling:

void vkQueueInsertDebugUtilsLabelEXT(
    VkQueue                                     queue,
    const VkDebugUtilsLabelEXT*                 pLabelInfo);
Parameters
queue is the queue into which a debug label will be inserted.
pLabelInfo is a pointer to an instance of the VkDebugUtilsLabelEXT structure specifying the parameters of the label to insert.
Description
Valid Usage (Implicit)
queue must be a valid VkQueue handle
pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
-
-
Any
-
See Also
VkDebugUtilsLabelEXT, VkQueue

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkQueueInsertDebugUtilsLabelEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkQueuePresentKHR(3)
Name
vkQueuePresentKHR - Queue an image for presentation

C Specification
After queueing all rendering commands and transitioning the image to the correct layout, to queue an image for presentation, call:

VkResult vkQueuePresentKHR(
    VkQueue                                     queue,
    const VkPresentInfoKHR*                     pPresentInfo);
Parameters
queue is a queue that is capable of presentation to the target surface’s platform on the same device as the image’s swapchain.
pPresentInfo is a pointer to an instance of the VkPresentInfoKHR structure specifying the parameters of the presentation.
Description
Note
There is no requirement for an application to present images in the same order that they were acquired - applications can arbitrarily present any image that is currently acquired.
Valid Usage
Each element of pSwapchains member of pPresentInfo must be a swapchain that is created for a surface for which presentation is supported from queue as determined using a call to vkGetPhysicalDeviceSurfaceSupportKHR
If more than one member of pSwapchains was created from a display surface, all display surfaces referenced that refer to the same display must use the same display mode
When a semaphore unsignal operation defined by the elements of the pWaitSemaphores member of pPresentInfo executes on queue, no other queue must be waiting on the same semaphore.
All elements of the pWaitSemaphores member of pPresentInfo must be semaphores that are signaled, or have semaphore signal operations previously submitted for execution.
Any writes to memory backing the images referenced by the pImageIndices and pSwapchains members of pPresentInfo, that are available before vkQueuePresentKHR is executed, are automatically made visible to the read access performed by the presentation engine. This automatic visibility operation for an image happens-after the semaphore signal operation, and happens-before the presentation engine accesses the image.

Queueing an image for presentation defines a set of queue operations, including waiting on the semaphores and submitting a presentation request to the presentation engine. However, the scope of this set of queue operations does not include the actual processing of the image by the presentation engine.

If vkQueuePresentKHR fails to enqueue the corresponding set of queue operations, it may return VK_ERROR_OUT_OF_HOST_MEMORY or VK_ERROR_OUT_OF_DEVICE_MEMORY. If it does, the implementation must ensure that the state and contents of any resources or synchronization primitives referenced is unaffected by the call or its failure.

If vkQueuePresentKHR fails in such a way that the implementation is unable to make that guarantee, the implementation must return VK_ERROR_DEVICE_LOST.

However, if the presentation request is rejected by the presentation engine with an error VK_ERROR_OUT_OF_DATE_KHR or VK_ERROR_SURFACE_LOST_KHR, the set of queue operations are still considered to be enqueued and thus any semaphore to be waited on gets unsignaled when the corresponding queue operation is complete.

If any swapchain member of pPresentInfo was created with VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT will be returned if that swapchain does not have exclusive full-screen access, possibly for implementation-specific reasons outside of the application’s control.

Valid Usage (Implicit)
queue must be a valid VkQueue handle
pPresentInfo must be a valid pointer to a valid VkPresentInfoKHR structure
Host Synchronization
Host access to queue must be externally synchronized
Host access to pPresentInfo.pWaitSemaphores[] must be externally synchronized
Host access to pPresentInfo.pSwapchains[] must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
-
-
Any
-
Return Codes
Success
VK_SUCCESS
VK_SUBOPTIMAL_KHR
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
VK_ERROR_OUT_OF_DATE_KHR
VK_ERROR_SURFACE_LOST_KHR
VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT
See Also
VkPresentInfoKHR, VkQueue

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkQueuePresentKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkQueueSubmit(3)
Name
vkQueueSubmit - Submits a sequence of semaphores or command buffers to a queue

C Specification
To submit command buffers to a queue, call:

VkResult vkQueueSubmit(
    VkQueue                                     queue,
    uint32_t                                    submitCount,
    const VkSubmitInfo*                         pSubmits,
    VkFence                                     fence);
Parameters
queue is the queue that the command buffers will be submitted to.
submitCount is the number of elements in the pSubmits array.
pSubmits is a pointer to an array of VkSubmitInfo structures, each specifying a command buffer submission batch.
fence is an optional handle to a fence to be signaled once all submitted command buffers have completed execution. If fence is not VK_NULL_HANDLE, it defines a fence signal operation.
Description
Note
Submission can be a high overhead operation, and applications should attempt to batch work together into as few calls to vkQueueSubmit as possible.
vkQueueSubmit is a queue submission command, with each batch defined by an element of pSubmits as an instance of the VkSubmitInfo structure. Batches begin execution in the order they appear in pSubmits, but may complete out of order.

Fence and semaphore operations submitted with vkQueueSubmit have additional ordering constraints compared to other submission commands, with dependencies involving previous and subsequent queue operations. Information about these additional constraints can be found in the semaphore and fence sections of the synchronization chapter.

Details on the interaction of pWaitDstStageMask with synchronization are described in the semaphore wait operation section of the synchronization chapter.

The order that batches appear in pSubmits is used to determine submission order, and thus all the implicit ordering guarantees that respect it. Other than these implicit ordering guarantees and any explicit synchronization primitives, these batches may overlap or otherwise execute out of order.

If any command buffer submitted to this queue is in the executable state, it is moved to the pending state. Once execution of all submissions of a command buffer complete, it moves from the pending state, back to the executable state. If a command buffer was recorded with the VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT flag, it instead moves back to the invalid state.

If vkQueueSubmit fails, it may return VK_ERROR_OUT_OF_HOST_MEMORY or VK_ERROR_OUT_OF_DEVICE_MEMORY. If it does, the implementation must ensure that the state and contents of any resources or synchronization primitives referenced by the submitted command buffers and any semaphores referenced by pSubmits is unaffected by the call or its failure. If vkQueueSubmit fails in such a way that the implementation is unable to make that guarantee, the implementation must return VK_ERROR_DEVICE_LOST. See Lost Device.

Valid Usage
If fence is not VK_NULL_HANDLE, fence must be unsignaled
If fence is not VK_NULL_HANDLE, fence must not be associated with any other queue command that has not yet completed execution on that queue
Any calls to vkCmdSetEvent, vkCmdResetEvent or vkCmdWaitEvents that have been recorded into any of the command buffer elements of the pCommandBuffers member of any element of pSubmits, must not reference any VkEvent that is referenced by any of those commands in a command buffer that has been submitted to another queue and is still in the pending state.
Any stage flag included in any element of the pWaitDstStageMask member of any element of pSubmits must be a pipeline stage supported by one of the capabilities of queue, as specified in the table of supported pipeline stages.
Each element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device
When a semaphore unsignal operation defined by any element of the pWaitSemaphores member of any element of pSubmits executes on queue, no other queue must be waiting on the same semaphore.
All elements of the pWaitSemaphores member of all elements of pSubmits must be semaphores that are signaled, or have semaphore signal operations previously submitted for execution.
Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state.
If any element of the pCommandBuffers member of any element of pSubmits was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, it must not be in the pending state.
Any secondary command buffers recorded into any element of the pCommandBuffers member of any element of pSubmits must be in the pending or executable state.
If any secondary command buffers recorded into any element of the pCommandBuffers member of any element of pSubmits was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, it must not be in the pending state.
Each element of the pCommandBuffers member of each element of pSubmits must have been allocated from a VkCommandPool that was created for the same queue family queue belongs to.
If any element of pSubmits->pCommandBuffers includes a Queue Family Transfer Acquire Operation, there must exist a previously submitted Queue Family Transfer Release Operation on a queue in the queue family identified by the acquire operation, with parameters matching the acquire operation as defined in the definition of such acquire operations, and which happens before the acquire operation.
Valid Usage (Implicit)
queue must be a valid VkQueue handle
If submitCount is not 0, pSubmits must be a valid pointer to an array of submitCount valid VkSubmitInfo structures
If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle
Both of fence, and queue that are valid handles must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to queue must be externally synchronized
Host access to pSubmits[].pWaitSemaphores[] must be externally synchronized
Host access to pSubmits[].pSignalSemaphores[] must be externally synchronized
Host access to fence must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
-
-
Any
-
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
See Also
VkFence, VkQueue, VkSubmitInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkQueueSubmit

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkQueueWaitIdle(3)
Name
vkQueueWaitIdle - Wait for a queue to become idle

C Specification
To wait on the host for the completion of outstanding queue operations for a given queue, call:

VkResult vkQueueWaitIdle(
    VkQueue                                     queue);
Parameters
queue is the queue on which to wait.
Description
vkQueueWaitIdle is equivalent to submitting a fence to a queue and waiting with an infinite timeout for that fence to signal.

Valid Usage (Implicit)
queue must be a valid VkQueue handle
Host Synchronization
Host access to queue must be externally synchronized
Command Properties
Command Buffer Levels	Render Pass Scope	Supported Queue Types	Pipeline Type
-
-
Any
-
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
See Also
VkQueue

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkQueueWaitIdle

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkRegisterDeviceEventEXT(3)
Name
vkRegisterDeviceEventEXT - Signal a fence when a device event occurs

C Specification
To create a fence that will be signaled when an event occurs on a device, call:

VkResult vkRegisterDeviceEventEXT(
    VkDevice                                    device,
    const VkDeviceEventInfoEXT*                 pDeviceEventInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence);
Parameters
device is a logical device on which the event may occur.
pDeviceEventInfo is a pointer to an instance of the VkDeviceEventInfoEXT structure describing the event of interest to the application.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pFence points to a handle in which the resulting fence object is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pDeviceEventInfo must be a valid pointer to a valid VkDeviceEventInfoEXT structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pFence must be a valid pointer to a VkFence handle
Return Codes
Success
VK_SUCCESS
See Also
VkAllocationCallbacks, VkDevice, VkDeviceEventInfoEXT, VkFence

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkRegisterDeviceEventEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkRegisterDisplayEventEXT(3)
Name
vkRegisterDisplayEventEXT - Signal a fence when a display event occurs

C Specification
To create a fence that will be signaled when an event occurs on a VkDisplayKHR object, call:

VkResult vkRegisterDisplayEventEXT(
    VkDevice                                    device,
    VkDisplayKHR                                display,
    const VkDisplayEventInfoEXT*                pDisplayEventInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence);
Parameters
device is a logical device associated with display
display is the display on which the event may occur.
pDisplayEventInfo is a pointer to an instance of the VkDisplayEventInfoEXT structure describing the event of interest to the application.
pAllocator controls host memory allocation as described in the Memory Allocation chapter.
pFence points to a handle in which the resulting fence object is returned.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
display must be a valid VkDisplayKHR handle
pDisplayEventInfo must be a valid pointer to a valid VkDisplayEventInfoEXT structure
If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure
pFence must be a valid pointer to a VkFence handle
Return Codes
Success
VK_SUCCESS
See Also
VkAllocationCallbacks, VkDevice, VkDisplayEventInfoEXT, VkDisplayKHR, VkFence

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkRegisterDisplayEventEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkRegisterObjectsNVX(3)
Name
vkRegisterObjectsNVX - Register resource bindings in an object table

C Specification
Resource bindings of Vulkan objects are registered at an arbitrary uint32_t index within an object table. As long as the object table references such objects, they must not be deleted.

VkResult vkRegisterObjectsNVX(
    VkDevice                                    device,
    VkObjectTableNVX                            objectTable,
    uint32_t                                    objectCount,
    const VkObjectTableEntryNVX* const*         ppObjectTableEntries,
    const uint32_t*                             pObjectIndices);
Parameters
device is the logical device that creates the object table.
objectTable is the table for which the resources are registered.
objectCount is the number of resources to register.
ppObjectTableEntries provides an array for detailed binding informations, each array element is a pointer to a struct of type VkObjectTablePipelineEntryNVX, VkObjectTableDescriptorSetEntryNVX, VkObjectTableVertexBufferEntryNVX, VkObjectTableIndexBufferEntryNVX or VkObjectTablePushConstantEntryNVX (see below for details).
pObjectIndices are the indices at which each resource is registered.
Description
Valid Usage
The contents of pObjectTableEntry must yield plausible bindings supported by the device.
At any pObjectIndices there must not be a registered resource already.
Any value inside pObjectIndices must be below the appropriate VkObjectTableCreateInfoNVX::pObjectEntryCounts limits provided at objectTable creation time.
Valid Usage (Implicit)
device must be a valid VkDevice handle
objectTable must be a valid VkObjectTableNVX handle
ppObjectTableEntries must be a valid pointer to an array of objectCount valid VkObjectTableEntryNVX structures
pObjectIndices must be a valid pointer to an array of objectCount uint32_t values
objectCount must be greater than 0
objectTable must have been created, allocated, or retrieved from device
Host Synchronization
Host access to objectTable must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkObjectTableEntryNVX, VkObjectTableNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkRegisterObjectsNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkReleaseDisplayEXT(3)
Name
vkReleaseDisplayEXT - Release access to an acquired VkDisplayKHR

C Specification
To release a previously acquired display, call:

VkResult vkReleaseDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display);
Parameters
physicalDevice The physical device the display is on.
display The display to release control of.
Description
Valid Usage (Implicit)
physicalDevice must be a valid VkPhysicalDevice handle
display must be a valid VkDisplayKHR handle
Return Codes
Success
VK_SUCCESS
See Also
VkDisplayKHR, VkPhysicalDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkReleaseDisplayEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkReleaseFullScreenExclusiveModeEXT(3)
Name
vkReleaseFullScreenExclusiveModeEXT - Release full-screen exclusive mode from a swapchain

C Specification
To release exclusive full-screen access from a swapchain, call:

VkResult vkReleaseFullScreenExclusiveModeEXT(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain);
Parameters
device is the device associated with swapchain.
swapchain is the swapchain to release exclusive full-screen access from.
Description
Note
Applications will not be able to present to swapchain after this call until exclusive full-screen access is reacquired. This is usually useful to handle when an application is minimised or otherwise intends to stop presenting for a time.
Valid Usage
swapchain must not be in the retired state
swapchain must be a swapchain created with an instance of VkSurfaceFullScreenExclusiveInfoEXT, with fullScreenExclusive set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT
See Also
VkDevice, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkReleaseFullScreenExclusiveModeEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkResetCommandBuffer(3)
Name
vkResetCommandBuffer - Reset a command buffer to the initial state

C Specification
To reset command buffers, call:

VkResult vkResetCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    VkCommandBufferResetFlags                   flags);
Parameters
commandBuffer is the command buffer to reset. The command buffer can be in any state other than pending, and is moved into the initial state.
flags is a bitmask of VkCommandBufferResetFlagBits controlling the reset operation.
Description
Any primary command buffer that is in the recording or executable state and has commandBuffer recorded into it, becomes invalid.

Valid Usage
commandBuffer must not be in the pending state
commandBuffer must have been allocated from a pool that was created with the VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT
Valid Usage (Implicit)
commandBuffer must be a valid VkCommandBuffer handle
flags must be a valid combination of VkCommandBufferResetFlagBits values
Host Synchronization
Host access to commandBuffer must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkCommandBuffer, VkCommandBufferResetFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkResetCommandBuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkResetCommandPool(3)
Name
vkResetCommandPool - Reset a command pool

C Specification
To reset a command pool, call:

VkResult vkResetCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolResetFlags                     flags);
Parameters
device is the logical device that owns the command pool.
commandPool is the command pool to reset.
flags is a bitmask of VkCommandPoolResetFlagBits controlling the reset operation.
Description
Resetting a command pool recycles all of the resources from all of the command buffers allocated from the command pool back to the command pool. All command buffers that have been allocated from the command pool are put in the initial state.

Any primary command buffer allocated from another VkCommandPool that is in the recording or executable state and has a secondary command buffer allocated from commandPool recorded into it, becomes invalid.

Valid Usage
All VkCommandBuffer objects allocated from commandPool must not be in the pending state
Valid Usage (Implicit)
device must be a valid VkDevice handle
commandPool must be a valid VkCommandPool handle
flags must be a valid combination of VkCommandPoolResetFlagBits values
commandPool must have been created, allocated, or retrieved from device
Host Synchronization
Host access to commandPool must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkCommandPool, VkCommandPoolResetFlags, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkResetCommandPool

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkResetDescriptorPool(3)
Name
vkResetDescriptorPool - Resets a descriptor pool object

C Specification
To return all descriptor sets allocated from a given pool to the pool, rather than freeing individual descriptor sets, call:

VkResult vkResetDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags);
Parameters
device is the logical device that owns the descriptor pool.
descriptorPool is the descriptor pool to be reset.
flags is reserved for future use.
Description
Resetting a descriptor pool recycles all of the resources from all of the descriptor sets allocated from the descriptor pool back to the descriptor pool, and the descriptor sets are implicitly freed.

Valid Usage
All uses of descriptorPool (via any allocated descriptor sets) must have completed execution
Valid Usage (Implicit)
device must be a valid VkDevice handle
descriptorPool must be a valid VkDescriptorPool handle
flags must be 0
descriptorPool must have been created, allocated, or retrieved from device
Host Synchronization
Host access to descriptorPool must be externally synchronized
Host access to any VkDescriptorSet objects allocated from descriptorPool must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDescriptorPool, VkDescriptorPoolResetFlags, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkResetDescriptorPool

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkResetEvent(3)
Name
vkResetEvent - Reset an event to non-signaled state

C Specification
To set the state of an event to unsignaled from the host, call:

VkResult vkResetEvent(
    VkDevice                                    device,
    VkEvent                                     event);
Parameters
device is the logical device that owns the event.
event is the event to reset.
Description
When vkResetEvent is executed on the host, it defines an event unsignal operation which resets the event to the unsignaled state.

If event is already in the unsignaled state when vkResetEvent is executed, then vkResetEvent has no effect, and no event unsignal operation occurs.

Valid Usage
event must not be waited on by a vkCmdWaitEvents command that is currently executing
Valid Usage (Implicit)
device must be a valid VkDevice handle
event must be a valid VkEvent handle
event must have been created, allocated, or retrieved from device
Host Synchronization
Host access to event must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkEvent

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkResetEvent

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkResetFences(3)
Name
vkResetFences - Resets one or more fence objects

C Specification
To set the state of fences to unsignaled from the host, call:

VkResult vkResetFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    const VkFence*                              pFences);
Parameters
device is the logical device that owns the fences.
fenceCount is the number of fences to reset.
pFences is a pointer to an array of fence handles to reset.
Description
If any member of pFences currently has its payload imported with temporary permanence, that fence’s prior permanent payload is first restored. The remaining operations described therefore operate on the restored payload.

When vkResetFences is executed on the host, it defines a fence unsignal operation for each fence, which resets the fence to the unsignaled state.

If any member of pFences is already in the unsignaled state when vkResetFences is executed, then vkResetFences has no effect on that fence.

Valid Usage
Each element of pFences must not be currently associated with any queue command that has not yet completed execution on that queue
Valid Usage (Implicit)
device must be a valid VkDevice handle
pFences must be a valid pointer to an array of fenceCount valid VkFence handles
fenceCount must be greater than 0
Each element of pFences must have been created, allocated, or retrieved from device
Host Synchronization
Host access to each member of pFences must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkFence

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkResetFences

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkResetQueryPoolEXT(3)
Name
vkResetQueryPoolEXT - Reset queries in a query pool

C Specification
To reset a range of queries in a query pool on the host, call:

void vkResetQueryPoolEXT(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount);
Parameters
queryPool is the handle of the query pool managing the queries being reset.
firstQuery is the initial query index to reset.
queryCount is the number of queries to reset.
Description
This command sets the status of query indices [firstQuery, firstQuery + queryCount - 1] to unavailable.

Valid Usage
The hostQueryReset feature must be enabled
firstQuery must be less than the number of queries in queryPool
The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool
Valid Usage (Implicit)
device must be a valid VkDevice handle
queryPool must be a valid VkQueryPool handle
queryPool must have been created, allocated, or retrieved from device
See Also
VkDevice, VkQueryPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkResetQueryPoolEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkSetDebugUtilsObjectNameEXT(3)
Name
vkSetDebugUtilsObjectNameEXT - Give a user-friendly name to an object

C Specification
VkResult vkSetDebugUtilsObjectNameEXT(
    VkDevice                                    device,
    const VkDebugUtilsObjectNameInfoEXT*        pNameInfo);
Parameters
device is the device that created the object.
pNameInfo is a pointer to an instance of the VkDebugUtilsObjectNameInfoEXT structure specifying the parameters of the name to set on the object.
Description
Valid Usage
pNameInfo->objectType must not be VK_OBJECT_TYPE_UNKNOWN
pNameInfo->objectHandle must not be VK_NULL_HANDLE
Valid Usage (Implicit)
device must be a valid VkDevice handle
pNameInfo must be a valid pointer to a valid VkDebugUtilsObjectNameInfoEXT structure
Host Synchronization
Host access to pNameInfo.objectHandle must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDebugUtilsObjectNameInfoEXT, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkSetDebugUtilsObjectNameEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkSetDebugUtilsObjectTagEXT(3)
Name
vkSetDebugUtilsObjectTagEXT - Attach arbitrary data to an object

C Specification
VkResult vkSetDebugUtilsObjectTagEXT(
    VkDevice                                    device,
    const VkDebugUtilsObjectTagInfoEXT*         pTagInfo);
Parameters
device is the device that created the object.
pTagInfo is a pointer to an instance of the VkDebugUtilsObjectTagInfoEXT structure specifying the parameters of the tag to attach to the object.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pTagInfo must be a valid pointer to a valid VkDebugUtilsObjectTagInfoEXT structure
Host Synchronization
Host access to pTagInfo.objectHandle must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDebugUtilsObjectTagInfoEXT, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkSetDebugUtilsObjectTagEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkSetEvent(3)
Name
vkSetEvent - Set an event to signaled state

C Specification
To set the state of an event to signaled from the host, call:

VkResult vkSetEvent(
    VkDevice                                    device,
    VkEvent                                     event);
Parameters
device is the logical device that owns the event.
event is the event to set.
Description
When vkSetEvent is executed on the host, it defines an event signal operation which sets the event to the signaled state.

If event is already in the signaled state when vkSetEvent is executed, then vkSetEvent has no effect, and no event signal operation occurs.

Valid Usage (Implicit)
device must be a valid VkDevice handle
event must be a valid VkEvent handle
event must have been created, allocated, or retrieved from device
Host Synchronization
Host access to event must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkEvent

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkSetEvent

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkSetHdrMetadataEXT(3)
Name
vkSetHdrMetadataEXT - function to set Hdr metadata

C Specification
void vkSetHdrMetadataEXT(
    VkDevice                                    device,
    uint32_t                                    swapchainCount,
    const VkSwapchainKHR*                       pSwapchains,
    const VkHdrMetadataEXT*                     pMetadata);
Parameters
device is the logical device where the swapchain(s) were created.
swapchainCount is the number of swapchains included in pSwapchains.
pSwapchains is a pointer to the array of swapchainCount VkSwapchainKHR handles.
pMetadata is a pointer to the array of swapchainCount VkHdrMetadataEXT structures.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
pSwapchains must be a valid pointer to an array of swapchainCount valid VkSwapchainKHR handles
pMetadata must be a valid pointer to an array of swapchainCount valid VkHdrMetadataEXT structures
swapchainCount must be greater than 0
Both of device, and the elements of pSwapchains must have been created, allocated, or retrieved from the same VkInstance
See Also
VkDevice, VkHdrMetadataEXT, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkSetHdrMetadataEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkSetLocalDimmingAMD(3)
Name
vkSetLocalDimmingAMD - Set Local Dimming

C Specification
The local dimming HDR setting may also be changed over the life of a swapchain by calling:

void vkSetLocalDimmingAMD(
    VkDevice                                    device,
    VkSwapchainKHR                              swapChain,
    VkBool32                                    localDimmingEnable);
Parameters
device is the device associated with swapChain.
swapChain handle to enable local dimming.
localDimmingEnable specifies whether local dimming is enabled for the swapchain.
Description
Valid Usage (Implicit)
device must be a valid VkDevice handle
swapChain must be a valid VkSwapchainKHR handle
Both of device, and swapChain must have been created, allocated, or retrieved from the same VkInstance
Valid Usage
It is only valid to call vkSetLocalDimmingAMD if VkDisplayNativeHdrSurfaceCapabilitiesAMD::localDimmingSupport is supported.
See Also
VkBool32, VkDevice, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkSetLocalDimmingAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkSubmitDebugUtilsMessageEXT(3)
Name
vkSubmitDebugUtilsMessageEXT - Inject a message into a debug stream

C Specification
There may be times that a user wishes to intentionally submit a debug message. To do this, call:

void vkSubmitDebugUtilsMessageEXT(
    VkInstance                                  instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT      messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT             messageTypes,
    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData);
Parameters
instance is the debug stream’s VkInstance.
messageSeverity is the VkDebugUtilsMessageSeverityFlagBitsEXT severity of this event/message.
messageTypes is a bitmask of VkDebugUtilsMessageTypeFlagBitsEXT specifying which type of event(s) to identify with this message.
pCallbackData contains all the callback related data in the VkDebugUtilsMessengerCallbackDataEXT structure.
Description
The call will propagate through the layers and generate callback(s) as indicated by the message’s flags. The parameters are passed on to the callback in addition to the pUserData value that was defined at the time the messenger was registered.

Valid Usage
objectType member of each element of pCallbackData->pObjects must not be VK_OBJECT_TYPE_UNKNOWN
Valid Usage (Implicit)
instance must be a valid VkInstance handle
messageSeverity must be a valid VkDebugUtilsMessageSeverityFlagBitsEXT value
messageTypes must be a valid combination of VkDebugUtilsMessageTypeFlagBitsEXT values
messageTypes must not be 0
pCallbackData must be a valid pointer to a valid VkDebugUtilsMessengerCallbackDataEXT structure
See Also
VkDebugUtilsMessageSeverityFlagBitsEXT, VkDebugUtilsMessageTypeFlagsEXT, VkDebugUtilsMessengerCallbackDataEXT, VkInstance

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkSubmitDebugUtilsMessageEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkTrimCommandPool(3)
Name
vkTrimCommandPool - Trim a command pool

C Specification
To trim a command pool, call:

void vkTrimCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolTrimFlags                      flags);
or the equivalent command

void vkTrimCommandPoolKHR(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolTrimFlags                      flags);
Parameters
device is the logical device that owns the command pool.
commandPool is the command pool to trim.
flags is reserved for future use.
Description
Trimming a command pool recycles unused memory from the command pool back to the system. Command buffers allocated from the pool are not affected by the command.

Note
This command provides applications with some control over the internal memory allocations used by command pools.

Unused memory normally arises from command buffers that have been recorded and later reset, such that they are no longer using the memory. On reset, a command buffer can return memory to its command pool, but the only way to release memory from a command pool to the system requires calling vkResetCommandPool, which cannot be executed while any command buffers from that pool are still in use. Subsequent recording operations into command buffers will re-use this memory but since total memory requirements fluctuate over time, unused memory can accumulate.

In this situation, trimming a command pool may be useful to return unused memory back to the system, returning the total outstanding memory allocated by the pool back to a more “average” value.

Implementations utilize many internal allocation strategies that make it impossible to guarantee that all unused memory is released back to the system. For instance, an implementation of a command pool may involve allocating memory in bulk from the system and sub-allocating from that memory. In such an implementation any live command buffer that holds a reference to a bulk allocation would prevent that allocation from being freed, even if only a small proportion of the bulk allocation is in use.

In most cases trimming will result in a reduction in allocated but unused memory, but it does not guarantee the “ideal” behavior.

Trimming may be an expensive operation, and should not be called frequently. Trimming should be treated as a way to relieve memory pressure after application-known points when there exists enough unused memory that the cost of trimming is “worth” it.
Valid Usage (Implicit)
device must be a valid VkDevice handle
commandPool must be a valid VkCommandPool handle
flags must be 0
commandPool must have been created, allocated, or retrieved from device
Host Synchronization
Host access to commandPool must be externally synchronized
See Also
VkCommandPool, VkCommandPoolTrimFlags, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkTrimCommandPool

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkUnmapMemory(3)
Name
vkUnmapMemory - Unmap a previously mapped memory object

C Specification
To unmap a memory object once host access to it is no longer needed by the application, call:

void vkUnmapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory);
Parameters
device is the logical device that owns the memory.
memory is the memory object to be unmapped.
Description
Valid Usage
memory must be currently host mapped
Valid Usage (Implicit)
device must be a valid VkDevice handle
memory must be a valid VkDeviceMemory handle
memory must have been created, allocated, or retrieved from device
Host Synchronization
Host access to memory must be externally synchronized
See Also
VkDevice, VkDeviceMemory

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkUnmapMemory

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkUnregisterObjectsNVX(3)
Name
vkUnregisterObjectsNVX - Unregister resource bindings in an object table

C Specification
Use the following command to unregister resources from an object table:

VkResult vkUnregisterObjectsNVX(
    VkDevice                                    device,
    VkObjectTableNVX                            objectTable,
    uint32_t                                    objectCount,
    const VkObjectEntryTypeNVX*                 pObjectEntryTypes,
    const uint32_t*                             pObjectIndices);
Parameters
device is the logical device that creates the object table.
objectTable is the table from which the resources are unregistered.
objectCount is the number of resources being removed from the object table.
pObjectEntryType provides an array of VkObjectEntryTypeNVX for the resources being removed.
pObjectIndices provides the array of object indices to be removed.
Description
Valid Usage
At any pObjectIndices there must be a registered resource already.
The pObjectEntryTypes of the resource at pObjectIndices must match.
All operations on the device using the registered resource must have been completed.
Valid Usage (Implicit)
device must be a valid VkDevice handle
objectTable must be a valid VkObjectTableNVX handle
pObjectEntryTypes must be a valid pointer to an array of objectCount valid VkObjectEntryTypeNVX values
pObjectIndices must be a valid pointer to an array of objectCount uint32_t values
objectCount must be greater than 0
objectTable must have been created, allocated, or retrieved from device
Host Synchronization
Host access to objectTable must be externally synchronized
Return Codes
Success
VK_SUCCESS
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
See Also
VkDevice, VkObjectEntryTypeNVX, VkObjectTableNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkUnregisterObjectsNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkUpdateDescriptorSetWithTemplate(3)
Name
vkUpdateDescriptorSetWithTemplate - Update the contents of a descriptor set object using an update template

C Specification
Once a VkDescriptorUpdateTemplate has been created, descriptor sets can be updated by calling:

void vkUpdateDescriptorSetWithTemplate(
    VkDevice                                    device,
    VkDescriptorSet                             descriptorSet,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    const void*                                 pData);
or the equivalent command

void vkUpdateDescriptorSetWithTemplateKHR(
    VkDevice                                    device,
    VkDescriptorSet                             descriptorSet,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    const void*                                 pData);
Parameters
device is the logical device that updates the descriptor sets.
descriptorSet is the descriptor set to update
descriptorUpdateTemplate is the VkDescriptorUpdateTemplate which specifies the update mapping between pData and the descriptor set to update.
pData is a pointer to memory which contains one or more structures of VkDescriptorImageInfo, VkDescriptorBufferInfo, or VkBufferView used to write the descriptors.
Description
Valid Usage
pData must be a valid pointer to a memory that contains one or more valid instances of VkDescriptorImageInfo, VkDescriptorBufferInfo, or VkBufferView in a layout defined by descriptorUpdateTemplate when it was created with vkCreateDescriptorUpdateTemplate
Valid Usage (Implicit)
device must be a valid VkDevice handle
descriptorSet must be a valid VkDescriptorSet handle
descriptorUpdateTemplate must be a valid VkDescriptorUpdateTemplate handle
descriptorUpdateTemplate must have been created, allocated, or retrieved from device
Host Synchronization
Host access to descriptorSet must be externally synchronized
API example
struct AppBufferView {
    VkBufferView bufferView;
    uint32_t     applicationRelatedInformation;
};

struct AppDataStructure
{
    VkDescriptorImageInfo  imageInfo;          // a single image info
    VkDescriptorBufferInfo bufferInfoArray[3]; // 3 buffer infos in an array
    AppBufferView          bufferView[2];      // An application defined structure containing a bufferView
    // ... some more application related data
};

const VkDescriptorUpdateTemplateEntry descriptorUpdateTemplateEntries[] =
{
    // binding to a single image descriptor
    {
        0,                                           // binding
        0,                                           // dstArrayElement
        1,                                           // descriptorCount
        VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,   // descriptorType
        offsetof(AppDataStructure, imageInfo),       // offset
        0                                            // stride is not required if descriptorCount is 1
    },

    // binding to an array of buffer descriptors
    {
        1,                                           // binding
        0,                                           // dstArrayElement
        3,                                           // descriptorCount
        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,           // descriptorType
        offsetof(AppDataStructure, bufferInfoArray), // offset
        sizeof(VkDescriptorBufferInfo)               // stride, descriptor buffer infos are compact
    },

    // binding to an array of buffer views
    {
        2,                                           // binding
        0,                                           // dstArrayElement
        2,                                           // descriptorCount
        VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,     // descriptorType
        offsetof(AppDataStructure, bufferView) +
          offsetof(AppBufferView, bufferView),       // offset
        sizeof(AppBufferView)                        // stride, bufferViews do not have to be compact
    },
};

// create a descriptor update template for descriptor set updates
const VkDescriptorUpdateTemplateCreateInfo createInfo =
{
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,  // sType
    NULL,                                                      // pNext
    0,                                                         // flags
    3,                                                         // descriptorUpdateEntryCount
    descriptorUpdateTemplateEntries,                           // pDescriptorUpdateEntries
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,         // templateType
    myLayout,                                                  // descriptorSetLayout
    0,                                                         // pipelineBindPoint, ignored by given templateType
    0,                                                         // pipelineLayout, ignored by given templateType
    0,                                                         // set, ignored by given templateType
};

VkDescriptorUpdateTemplate myDescriptorUpdateTemplate;
myResult = vkCreateDescriptorUpdateTemplate(
    myDevice,
    &createInfo,
    NULL,
    &myDescriptorUpdateTemplate);
}


AppDataStructure appData;

// fill appData here or cache it in your engine
vkUpdateDescriptorSetWithTemplate(myDevice, myDescriptorSet, myDescriptorUpdateTemplate, &appData);
See Also
VkDescriptorSet, VkDescriptorUpdateTemplate, VkDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkUpdateDescriptorSetWithTemplate

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkUpdateDescriptorSets(3)
Name
vkUpdateDescriptorSets - Update the contents of a descriptor set object

C Specification
Once allocated, descriptor sets can be updated with a combination of write and copy operations. To update descriptor sets, call:

void vkUpdateDescriptorSets(
    VkDevice                                    device,
    uint32_t                                    descriptorWriteCount,
    const VkWriteDescriptorSet*                 pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    const VkCopyDescriptorSet*                  pDescriptorCopies);
Parameters
device is the logical device that updates the descriptor sets.
descriptorWriteCount is the number of elements in the pDescriptorWrites array.
pDescriptorWrites is a pointer to an array of VkWriteDescriptorSet structures describing the descriptor sets to write to.
descriptorCopyCount is the number of elements in the pDescriptorCopies array.
pDescriptorCopies is a pointer to an array of VkCopyDescriptorSet structures describing the descriptor sets to copy between.
Description
The operations described by pDescriptorWrites are performed first, followed by the operations described by pDescriptorCopies. Within each array, the operations are performed in the order they appear in the array.

Each element in the pDescriptorWrites array describes an operation updating the descriptor set using descriptors for resources specified in the structure.

Each element in the pDescriptorCopies array is a VkCopyDescriptorSet structure describing an operation copying descriptors between sets.

If the dstSet member of any element of pDescriptorWrites or pDescriptorCopies is bound, accessed, or modified by any command that was recorded to a command buffer which is currently in the recording or executable state, and any of the descriptor bindings that are updated were not created with the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT or VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT bits set, that command buffer becomes invalid.

Valid Usage
Descriptor bindings updated by this command which were created without the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT or VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT bits set must not be used by any command that was recorded to a command buffer which is in the pending state.
Valid Usage (Implicit)
device must be a valid VkDevice handle
If descriptorWriteCount is not 0, pDescriptorWrites must be a valid pointer to an array of descriptorWriteCount valid VkWriteDescriptorSet structures
If descriptorCopyCount is not 0, pDescriptorCopies must be a valid pointer to an array of descriptorCopyCount valid VkCopyDescriptorSet structures
Host Synchronization
Host access to pDescriptorWrites[].dstSet must be externally synchronized
Host access to pDescriptorCopies[].dstSet must be externally synchronized
See Also
VkCopyDescriptorSet, VkDevice, VkWriteDescriptorSet

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkUpdateDescriptorSets

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

vkWaitForFences(3)
Name
vkWaitForFences - Wait for one or more fences to become signaled

C Specification
To wait for one or more fences to enter the signaled state on the host, call:

VkResult vkWaitForFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    const VkFence*                              pFences,
    VkBool32                                    waitAll,
    uint64_t                                    timeout);
Parameters
device is the logical device that owns the fences.
fenceCount is the number of fences to wait on.
pFences is a pointer to an array of fenceCount fence handles.
waitAll is the condition that must be satisfied to successfully unblock the wait. If waitAll is VK_TRUE, then the condition is that all fences in pFences are signaled. Otherwise, the condition is that at least one fence in pFences is signaled.
timeout is the timeout period in units of nanoseconds. timeout is adjusted to the closest value allowed by the implementation-dependent timeout accuracy, which may be substantially longer than one nanosecond, and may be longer than the requested period.
Description
If the condition is satisfied when vkWaitForFences is called, then vkWaitForFences returns immediately. If the condition is not satisfied at the time vkWaitForFences is called, then vkWaitForFences will block and wait up to timeout nanoseconds for the condition to become satisfied.

If timeout is zero, then vkWaitForFences does not wait, but simply returns the current state of the fences. VK_TIMEOUT will be returned in this case if the condition is not satisfied, even though no actual wait was performed.

If the specified timeout period expires before the condition is satisfied, vkWaitForFences returns VK_TIMEOUT. If the condition is satisfied before timeout nanoseconds has expired, vkWaitForFences returns VK_SUCCESS.

If device loss occurs (see Lost Device) before the timeout has expired, vkWaitForFences must return in finite time with either VK_SUCCESS or VK_ERROR_DEVICE_LOST.

Note
While we guarantee that vkWaitForFences must return in finite time, no guarantees are made that it returns immediately upon device loss. However, the client can reasonably expect that the delay will be on the order of seconds and that calling vkWaitForFences will not result in a permanently (or seemingly permanently) dead process.
Valid Usage (Implicit)
device must be a valid VkDevice handle
pFences must be a valid pointer to an array of fenceCount valid VkFence handles
fenceCount must be greater than 0
Each element of pFences must have been created, allocated, or retrieved from device
Return Codes
Success
VK_SUCCESS
VK_TIMEOUT
Failure
VK_ERROR_OUT_OF_HOST_MEMORY
VK_ERROR_OUT_OF_DEVICE_MEMORY
VK_ERROR_DEVICE_LOST
See Also
VkBool32, VkDevice, VkFence

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkWaitForFences

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Object Handles
VkAccelerationStructureNV(3)
Name
VkAccelerationStructureNV - Opaque handle to an acceleration structure object

C Specification
Acceleration structures are an opaque structure that is built by the implementation to more efficiently perform spatial queries on the provided geometric data. For this extension, an acceleration structure is either a top-level acceleration structure containing a set of bottom-level acceleration structures or a bottom-level acceleration structure containing either a set of axis-aligned bounding boxes for custom geometry or a set of triangles.

Each instance in the top-level acceleration structure contains a reference to a bottom-level acceleration structure as well as an instance transform plus information required to index into the shader bindings. The top-level acceleration structure is what is bound to the acceleration descriptor to trace inside the shader in the ray tracing pipeline.

Acceleration structures are represented by VkAccelerationStructureNV handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkAccelerationStructureNV)
Description
See Also
VkAccelerationStructureMemoryRequirementsInfoNV, VkBindAccelerationStructureMemoryInfoNV, VkWriteDescriptorSetAccelerationStructureNV, vkCmdBuildAccelerationStructureNV, vkCmdCopyAccelerationStructureNV, vkCmdWriteAccelerationStructuresPropertiesNV, vkCreateAccelerationStructureNV, vkDestroyAccelerationStructureNV, vkGetAccelerationStructureHandleNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAccelerationStructureNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBuffer(3)
Name
VkBuffer - Opaque handle to a buffer object

C Specification
Buffers represent linear arrays of data which are used for various purposes by binding them to a graphics or compute pipeline via descriptor sets or via certain commands, or by directly specifying them as parameters to certain commands.

Buffers are represented by VkBuffer handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBuffer)
Description
See Also
VkBindBufferMemoryInfo, VkBufferDeviceAddressInfoEXT, VkBufferMemoryBarrier, VkBufferMemoryRequirementsInfo2, VkBufferViewCreateInfo, VkCmdProcessCommandsInfoNVX, VkConditionalRenderingBeginInfoEXT, VkDedicatedAllocationMemoryAllocateInfoNV, VkDescriptorBufferInfo, VkGeometryAABBNV, VkGeometryTrianglesNV, VkIndirectCommandsTokenNVX, VkMemoryDedicatedAllocateInfo, VkObjectTableIndexBufferEntryNVX, VkObjectTableVertexBufferEntryNVX, VkSparseBufferMemoryBindInfo, vkBindBufferMemory, vkCmdBeginTransformFeedbackEXT, vkCmdBindIndexBuffer, vkCmdBindTransformFeedbackBuffersEXT, vkCmdBindVertexBuffers, vkCmdBuildAccelerationStructureNV, vkCmdCopyBuffer, vkCmdCopyBufferToImage, vkCmdCopyImageToBuffer, vkCmdCopyQueryPoolResults, vkCmdDispatchIndirect, vkCmdDrawIndexedIndirect, vkCmdDrawIndexedIndirectCountAMD, vkCmdDrawIndexedIndirectCountKHR, vkCmdDrawIndirect, vkCmdDrawIndirectByteCountEXT, vkCmdDrawIndirectCountAMD, vkCmdDrawIndirectCountKHR, vkCmdDrawMeshTasksIndirectCountNV, vkCmdDrawMeshTasksIndirectNV, vkCmdEndTransformFeedbackEXT, vkCmdFillBuffer, vkCmdTraceRaysNV, vkCmdUpdateBuffer, vkCmdWriteBufferMarkerAMD, vkCreateBuffer, vkDestroyBuffer, vkGetBufferMemoryRequirements

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferView(3)
Name
VkBufferView - Opaque handle to a buffer view object

C Specification
A buffer view represents a contiguous range of a buffer and a specific format to be used to interpret the data. Buffer views are used to enable shaders to access buffer contents interpreted as formatted data. In order to create a valid buffer view, the buffer must have been created with at least one of the following usage flags:

VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT
VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT
Buffer views are represented by VkBufferView handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkBufferView)
Description
See Also
VkWriteDescriptorSet, vkCreateBufferView, vkDestroyBufferView

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferView

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandBuffer(3)
Name
VkCommandBuffer - Opaque handle to a command buffer object

C Specification
Command buffers are objects used to record commands which can be subsequently submitted to a device queue for execution. There are two levels of command buffers - primary command buffers, which can execute secondary command buffers, and which are submitted to queues, and secondary command buffers, which can be executed by primary command buffers, and which are not directly submitted to queues.

Command buffers are represented by VkCommandBuffer handles:

VK_DEFINE_HANDLE(VkCommandBuffer)
Description
See Also
VkCmdProcessCommandsInfoNVX, VkSubmitInfo, vkAllocateCommandBuffers, vkBeginCommandBuffer, vkCmdBeginConditionalRenderingEXT, vkCmdBeginDebugUtilsLabelEXT, vkCmdBeginQuery, vkCmdBeginQueryIndexedEXT, vkCmdBeginRenderPass, vkCmdBeginRenderPass2KHR, vkCmdBeginTransformFeedbackEXT, vkCmdBindDescriptorSets, vkCmdBindIndexBuffer, vkCmdBindPipeline, vkCmdBindShadingRateImageNV, vkCmdBindTransformFeedbackBuffersEXT, vkCmdBindVertexBuffers, vkCmdBlitImage, vkCmdBuildAccelerationStructureNV, vkCmdClearAttachments, vkCmdClearColorImage, vkCmdClearDepthStencilImage, vkCmdCopyAccelerationStructureNV, vkCmdCopyBuffer, vkCmdCopyBufferToImage, vkCmdCopyImage, vkCmdCopyImageToBuffer, vkCmdCopyQueryPoolResults, vkCmdDebugMarkerBeginEXT, vkCmdDebugMarkerEndEXT, vkCmdDebugMarkerInsertEXT, vkCmdDispatch, vkCmdDispatchBase, vkCmdDispatchBaseKHR, vkCmdDispatchIndirect, vkCmdDraw, vkCmdDrawIndexed, vkCmdDrawIndexedIndirect, vkCmdDrawIndexedIndirectCountAMD, vkCmdDrawIndexedIndirectCountKHR, vkCmdDrawIndirect, vkCmdDrawIndirectByteCountEXT, vkCmdDrawIndirectCountAMD, vkCmdDrawIndirectCountKHR, vkCmdDrawMeshTasksIndirectCountNV, vkCmdDrawMeshTasksIndirectNV, vkCmdDrawMeshTasksNV, vkCmdEndConditionalRenderingEXT, vkCmdEndDebugUtilsLabelEXT, vkCmdEndQuery, vkCmdEndQueryIndexedEXT, vkCmdEndRenderPass, vkCmdEndRenderPass2KHR, vkCmdEndTransformFeedbackEXT, vkCmdExecuteCommands, vkCmdFillBuffer, vkCmdInsertDebugUtilsLabelEXT, vkCmdNextSubpass, vkCmdNextSubpass2KHR, vkCmdPipelineBarrier, vkCmdProcessCommandsNVX, vkCmdPushConstants, vkCmdPushDescriptorSetKHR, vkCmdPushDescriptorSetWithTemplateKHR, vkCmdReserveSpaceForCommandsNVX, vkCmdResetEvent, vkCmdResetQueryPool, vkCmdResolveImage, vkCmdSetBlendConstants, vkCmdSetCheckpointNV, vkCmdSetCoarseSampleOrderNV, vkCmdSetDepthBias, vkCmdSetDepthBounds, vkCmdSetDeviceMask, vkCmdSetDeviceMaskKHR, vkCmdSetDiscardRectangleEXT, vkCmdSetEvent, vkCmdSetExclusiveScissorNV, vkCmdSetLineWidth, vkCmdSetSampleLocationsEXT, vkCmdSetScissor, vkCmdSetStencilCompareMask, vkCmdSetStencilReference, vkCmdSetStencilWriteMask, vkCmdSetViewport, vkCmdSetViewportShadingRatePaletteNV, vkCmdSetViewportWScalingNV, vkCmdTraceRaysNV, vkCmdUpdateBuffer, vkCmdWaitEvents, vkCmdWriteAccelerationStructuresPropertiesNV, vkCmdWriteBufferMarkerAMD, vkCmdWriteTimestamp, vkEndCommandBuffer, vkFreeCommandBuffers, vkResetCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandBuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandPool(3)
Name
VkCommandPool - Opaque handle to a command pool object

C Specification
Command pools are opaque objects that command buffer memory is allocated from, and which allow the implementation to amortize the cost of resource creation across multiple command buffers. Command pools are externally synchronized, meaning that a command pool must not be used concurrently in multiple threads. That includes use via recording commands on any command buffers allocated from the pool, as well as operations that allocate, free, and reset command buffers or the pool itself.

Command pools are represented by VkCommandPool handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)
Description
See Also
VkCommandBufferAllocateInfo, vkCreateCommandPool, vkDestroyCommandPool, vkFreeCommandBuffers, vkResetCommandPool, vkTrimCommandPool, vkTrimCommandPoolKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandPool

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugReportCallbackEXT(3)
Name
VkDebugReportCallbackEXT - Opaque handle to a debug report callback object

C Specification
Debug report callbacks are represented by VkDebugReportCallbackEXT handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugReportCallbackEXT)
Description
See Also
vkCreateDebugReportCallbackEXT, vkDestroyDebugReportCallbackEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugReportCallbackEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugUtilsMessengerEXT(3)
Name
VkDebugUtilsMessengerEXT - Opaque handle to a debug messenger object

C Specification
A VkDebugUtilsMessengerEXT is a messenger object which handles passing along debug messages to a provided debug callback.

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugUtilsMessengerEXT)
Description
The debug messenger will provide detailed feedback on the application’s use of Vulkan when events of interest occur. When an event of interest does occur, the debug messenger will submit a debug message to the debug callback that was provided during its creation. Additionally, the debug messenger is responsible with filtering out debug messages that the callback is not interested in and will only provide desired debug messages.

See Also
vkCreateDebugUtilsMessengerEXT, vkDestroyDebugUtilsMessengerEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugUtilsMessengerEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorPool(3)
Name
VkDescriptorPool - Opaque handle to a descriptor pool object

C Specification
A descriptor pool maintains a pool of descriptors, from which descriptor sets are allocated. Descriptor pools are externally synchronized, meaning that the application must not allocate and/or free descriptor sets from the same pool in multiple threads simultaneously.

Descriptor pools are represented by VkDescriptorPool handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorPool)
Description
See Also
VkDescriptorSetAllocateInfo, vkCreateDescriptorPool, vkDestroyDescriptorPool, vkFreeDescriptorSets, vkResetDescriptorPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorPool

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorSet(3)
Name
VkDescriptorSet - Opaque handle to a descriptor set object

C Specification
Descriptor sets are allocated from descriptor pool objects, and are represented by VkDescriptorSet handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSet)
Description
See Also
VkCopyDescriptorSet, VkObjectTableDescriptorSetEntryNVX, VkWriteDescriptorSet, vkAllocateDescriptorSets, vkCmdBindDescriptorSets, vkFreeDescriptorSets, vkUpdateDescriptorSetWithTemplate, vkUpdateDescriptorSetWithTemplateKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorSet

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorSetLayout(3)
Name
VkDescriptorSetLayout - Opaque handle to a descriptor set layout object

C Specification
A descriptor set layout object is defined by an array of zero or more descriptor bindings. Each individual descriptor binding is specified by a descriptor type, a count (array size) of the number of descriptors in the binding, a set of shader stages that can access the binding, and (if using immutable samplers) an array of sampler descriptors.

Descriptor set layout objects are represented by VkDescriptorSetLayout handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorSetLayout)
Description
See Also
VkDescriptorSetAllocateInfo, VkDescriptorUpdateTemplateCreateInfo, VkPipelineLayoutCreateInfo, vkCreateDescriptorSetLayout, vkDestroyDescriptorSetLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorSetLayout

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorUpdateTemplate(3)
Name
VkDescriptorUpdateTemplate - Opaque handle to a descriptor update template

C Specification
A descriptor update template specifies a mapping from descriptor update information in host memory to descriptors in a descriptor set. It is designed to avoid passing redundant information to the driver when frequently updating the same set of descriptors in descriptor sets.

Descriptor update template objects are represented by VkDescriptorUpdateTemplate handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDescriptorUpdateTemplate)
or the equivalent

typedef VkDescriptorUpdateTemplate VkDescriptorUpdateTemplateKHR;
Description
See Also
vkCmdPushDescriptorSetWithTemplateKHR, vkCreateDescriptorUpdateTemplate, vkCreateDescriptorUpdateTemplateKHR, vkDestroyDescriptorUpdateTemplate, vkDestroyDescriptorUpdateTemplateKHR, vkUpdateDescriptorSetWithTemplate, vkUpdateDescriptorSetWithTemplateKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorUpdateTemplate

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDevice(3)
Name
VkDevice - Opaque handle to a device object

C Specification
Logical devices are represented by VkDevice handles:

VK_DEFINE_HANDLE(VkDevice)
Description
See Also
vkAcquireFullScreenExclusiveModeEXT, vkAcquireNextImage2KHR, vkAcquireNextImageKHR, vkAllocateCommandBuffers, vkAllocateDescriptorSets, vkAllocateMemory, vkBindAccelerationStructureMemoryNV, vkBindBufferMemory, vkBindBufferMemory2, vkBindBufferMemory2KHR, vkBindImageMemory, vkBindImageMemory2, vkBindImageMemory2KHR, vkCompileDeferredNV, vkCreateAccelerationStructureNV, vkCreateBuffer, vkCreateBufferView, vkCreateCommandPool, vkCreateComputePipelines, vkCreateDescriptorPool, vkCreateDescriptorSetLayout, vkCreateDescriptorUpdateTemplate, vkCreateDescriptorUpdateTemplateKHR, vkCreateDevice, vkCreateEvent, vkCreateFence, vkCreateFramebuffer, vkCreateGraphicsPipelines, vkCreateImage, vkCreateImageView, vkCreateIndirectCommandsLayoutNVX, vkCreateObjectTableNVX, vkCreatePipelineCache, vkCreatePipelineLayout, vkCreateQueryPool, vkCreateRayTracingPipelinesNV, vkCreateRenderPass, vkCreateRenderPass2KHR, vkCreateSampler, vkCreateSamplerYcbcrConversion, vkCreateSamplerYcbcrConversionKHR, vkCreateSemaphore, vkCreateShaderModule, vkCreateSharedSwapchainsKHR, vkCreateSwapchainKHR, vkCreateValidationCacheEXT, vkDebugMarkerSetObjectNameEXT, vkDebugMarkerSetObjectTagEXT, vkDestroyAccelerationStructureNV, vkDestroyBuffer, vkDestroyBufferView, vkDestroyCommandPool, vkDestroyDescriptorPool, vkDestroyDescriptorSetLayout, vkDestroyDescriptorUpdateTemplate, vkDestroyDescriptorUpdateTemplateKHR, vkDestroyDevice, vkDestroyEvent, vkDestroyFence, vkDestroyFramebuffer, vkDestroyImage, vkDestroyImageView, vkDestroyIndirectCommandsLayoutNVX, vkDestroyObjectTableNVX, vkDestroyPipeline, vkDestroyPipelineCache, vkDestroyPipelineLayout, vkDestroyQueryPool, vkDestroyRenderPass, vkDestroySampler, vkDestroySamplerYcbcrConversion, vkDestroySamplerYcbcrConversionKHR, vkDestroySemaphore, vkDestroyShaderModule, vkDestroySwapchainKHR, vkDestroyValidationCacheEXT, vkDeviceWaitIdle, vkDisplayPowerControlEXT, vkFlushMappedMemoryRanges, vkFreeCommandBuffers, vkFreeDescriptorSets, vkFreeMemory, vkGetAccelerationStructureHandleNV, vkGetAccelerationStructureMemoryRequirementsNV, vkGetAndroidHardwareBufferPropertiesANDROID, vkGetBufferDeviceAddressEXT, vkGetBufferMemoryRequirements, vkGetBufferMemoryRequirements2, vkGetBufferMemoryRequirements2KHR, vkGetCalibratedTimestampsEXT, vkGetDescriptorSetLayoutSupport, vkGetDescriptorSetLayoutSupportKHR, vkGetDeviceGroupPeerMemoryFeatures, vkGetDeviceGroupPeerMemoryFeaturesKHR, vkGetDeviceGroupPresentCapabilitiesKHR, vkGetDeviceGroupSurfacePresentModes2EXT, vkGetDeviceGroupSurfacePresentModesKHR, vkGetDeviceMemoryCommitment, vkGetDeviceProcAddr, vkGetDeviceQueue, vkGetDeviceQueue2, vkGetEventStatus, vkGetFenceFdKHR, vkGetFenceStatus, vkGetFenceWin32HandleKHR, vkGetImageDrmFormatModifierPropertiesEXT, vkGetImageMemoryRequirements, vkGetImageMemoryRequirements2, vkGetImageMemoryRequirements2KHR, vkGetImageSparseMemoryRequirements, vkGetImageSparseMemoryRequirements2, vkGetImageSparseMemoryRequirements2KHR, vkGetImageSubresourceLayout, vkGetImageViewHandleNVX, vkGetMemoryAndroidHardwareBufferANDROID, vkGetMemoryFdKHR, vkGetMemoryFdPropertiesKHR, vkGetMemoryHostPointerPropertiesEXT, vkGetMemoryWin32HandleKHR, vkGetMemoryWin32HandleNV, vkGetMemoryWin32HandlePropertiesKHR, vkGetPastPresentationTimingGOOGLE, vkGetPipelineCacheData, vkGetQueryPoolResults, vkGetRayTracingShaderGroupHandlesNV, vkGetRefreshCycleDurationGOOGLE, vkGetRenderAreaGranularity, vkGetSemaphoreFdKHR, vkGetSemaphoreWin32HandleKHR, vkGetShaderInfoAMD, vkGetSwapchainCounterEXT, vkGetSwapchainImagesKHR, vkGetSwapchainStatusKHR, vkGetValidationCacheDataEXT, vkImportFenceFdKHR, vkImportFenceWin32HandleKHR, vkImportSemaphoreFdKHR, vkImportSemaphoreWin32HandleKHR, vkInvalidateMappedMemoryRanges, vkMapMemory, vkMergePipelineCaches, vkMergeValidationCachesEXT, vkRegisterDeviceEventEXT, vkRegisterDisplayEventEXT, vkRegisterObjectsNVX, vkReleaseFullScreenExclusiveModeEXT, vkResetCommandPool, vkResetDescriptorPool, vkResetEvent, vkResetFences, vkResetQueryPoolEXT, vkSetDebugUtilsObjectNameEXT, vkSetDebugUtilsObjectTagEXT, vkSetEvent, vkSetHdrMetadataEXT, vkSetLocalDimmingAMD, vkTrimCommandPool, vkTrimCommandPoolKHR, vkUnmapMemory, vkUnregisterObjectsNVX, vkUpdateDescriptorSetWithTemplate, vkUpdateDescriptorSetWithTemplateKHR, vkUpdateDescriptorSets, vkWaitForFences

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDevice

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceMemory(3)
Name
VkDeviceMemory - Opaque handle to a device memory object

C Specification
A Vulkan device operates on data in device memory via memory objects that are represented in the API by a VkDeviceMemory handle:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)
Description
See Also
VkBindAccelerationStructureMemoryInfoNV, VkBindBufferMemoryInfo, VkBindImageMemoryInfo, VkMappedMemoryRange, VkMemoryGetAndroidHardwareBufferInfoANDROID, VkMemoryGetFdInfoKHR, VkMemoryGetWin32HandleInfoKHR, VkSparseImageMemoryBind, VkSparseMemoryBind, VkWin32KeyedMutexAcquireReleaseInfoKHR, VkWin32KeyedMutexAcquireReleaseInfoNV, vkAllocateMemory, vkBindBufferMemory, vkBindImageMemory, vkFreeMemory, vkGetDeviceMemoryCommitment, vkGetMemoryWin32HandleNV, vkMapMemory, vkUnmapMemory

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceMemory

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayKHR(3)
Name
VkDisplayKHR - Opaque handle to a display object

C Specification
Displays are represented by VkDisplayKHR handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)
Description
See Also
VkDisplayPlanePropertiesKHR, VkDisplayPropertiesKHR, vkAcquireXlibDisplayEXT, vkCreateDisplayModeKHR, vkDisplayPowerControlEXT, vkGetDisplayModeProperties2KHR, vkGetDisplayModePropertiesKHR, vkGetDisplayPlaneSupportedDisplaysKHR, vkGetRandROutputDisplayEXT, vkRegisterDisplayEventEXT, vkReleaseDisplayEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayModeKHR(3)
Name
VkDisplayModeKHR - Opaque handle to a display mode object

C Specification
Display modes are represented by VkDisplayModeKHR handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayModeKHR)
Description
See Also
VkDisplayModePropertiesKHR, VkDisplayPlaneInfo2KHR, VkDisplaySurfaceCreateInfoKHR, vkCreateDisplayModeKHR, vkGetDisplayPlaneCapabilitiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayModeKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkEvent(3)
Name
VkEvent - Opaque handle to an event object

C Specification
Events are a synchronization primitive that can be used to insert a fine-grained dependency between commands submitted to the same queue, or between the host and a queue. Events must not be used to insert a dependency between commands submitted to different queues. Events have two states - signaled and unsignaled. An application can signal an event, or unsignal it, on either the host or the device. A device can wait for an event to become signaled before executing further operations. No command exists to wait for an event to become signaled on the host, but the current state of an event can be queried.

Events are represented by VkEvent handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkEvent)
Description
See Also
vkCmdResetEvent, vkCmdSetEvent, vkCmdWaitEvents, vkCreateEvent, vkDestroyEvent, vkGetEventStatus, vkResetEvent, vkSetEvent

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkEvent

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFence(3)
Name
VkFence - Opaque handle to a fence object

C Specification
Fences are a synchronization primitive that can be used to insert a dependency from a queue to the host. Fences have two states - signaled and unsignaled. A fence can be signaled as part of the execution of a queue submission command. Fences can be unsignaled on the host with vkResetFences. Fences can be waited on by the host with the vkWaitForFences command, and the current state can be queried with vkGetFenceStatus.

As with most objects in Vulkan, fences are an interface to internal data which is typically opaque to applications. This internal data is referred to as a fence’s payload.

However, in order to enable communication with agents outside of the current device, it is necessary to be able to export that payload to a commonly understood format, and subsequently import from that format as well.

The internal data of a fence may include a reference to any resources and pending work associated with signal or unsignal operations performed on that fence object. Mechanisms to import and export that internal data to and from fences are provided below. These mechanisms indirectly enable applications to share fence state between two or more fences and other synchronization primitives across process and API boundaries.

Fences are represented by VkFence handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFence)
Description
See Also
VkAcquireNextImageInfoKHR, VkFenceGetFdInfoKHR, VkFenceGetWin32HandleInfoKHR, VkImportFenceFdInfoKHR, VkImportFenceWin32HandleInfoKHR, vkAcquireNextImageKHR, vkCreateFence, vkDestroyFence, vkGetFenceStatus, vkQueueBindSparse, vkQueueSubmit, vkRegisterDeviceEventEXT, vkRegisterDisplayEventEXT, vkResetFences, vkWaitForFences

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFence

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFramebuffer(3)
Name
VkFramebuffer - Opaque handle to a framebuffer object

C Specification
Render passes operate in conjunction with framebuffers. Framebuffers represent a collection of specific memory attachments that a render pass instance uses.

Framebuffers are represented by VkFramebuffer handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)
Description
See Also
VkCommandBufferInheritanceInfo, VkRenderPassBeginInfo, vkCreateFramebuffer, vkDestroyFramebuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFramebuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImage(3)
Name
VkImage - Opaque handle to an image object

C Specification
Images represent multidimensional - up to 3 - arrays of data which can be used for various purposes (e.g. attachments, textures), by binding them to a graphics or compute pipeline via descriptor sets, or by directly specifying them as parameters to certain commands.

Images are represented by VkImage handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage)
Description
See Also
VkBindImageMemoryInfo, VkDedicatedAllocationMemoryAllocateInfoNV, VkImageMemoryBarrier, VkImageMemoryRequirementsInfo2, VkImageSparseMemoryRequirementsInfo2, VkImageViewCreateInfo, VkMemoryDedicatedAllocateInfo, VkSparseImageMemoryBindInfo, VkSparseImageOpaqueMemoryBindInfo, vkBindImageMemory, vkCmdBlitImage, vkCmdClearColorImage, vkCmdClearDepthStencilImage, vkCmdCopyBufferToImage, vkCmdCopyImage, vkCmdCopyImageToBuffer, vkCmdResolveImage, vkCreateImage, vkDestroyImage, vkGetImageDrmFormatModifierPropertiesEXT, vkGetImageMemoryRequirements, vkGetImageSparseMemoryRequirements, vkGetImageSubresourceLayout, vkGetSwapchainImagesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImage

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageView(3)
Name
VkImageView - Opaque handle to an image view object

C Specification
Image objects are not directly accessed by pipeline shaders for reading or writing image data. Instead, image views representing contiguous ranges of the image subresources and containing additional metadata are used for that purpose. Views must be created on images of compatible types, and must represent a valid subset of image subresources.

Image views are represented by VkImageView handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)
Description
See Also
VkDescriptorImageInfo, VkFramebufferCreateInfo, VkImageViewHandleInfoNVX, vkCmdBindShadingRateImageNV, vkCreateImageView, vkDestroyImageView

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageView

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkIndirectCommandsLayoutNVX(3)
Name
VkIndirectCommandsLayoutNVX - Opaque handle to an indirect commands layout object

C Specification
The device-side command generation happens through an iterative processing of an atomic sequence comprised of command tokens, which are represented by:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkIndirectCommandsLayoutNVX)
Description
See Also
VkCmdProcessCommandsInfoNVX, VkCmdReserveSpaceForCommandsInfoNVX, vkCreateIndirectCommandsLayoutNVX, vkDestroyIndirectCommandsLayoutNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkIndirectCommandsLayoutNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkInstance(3)
Name
VkInstance - Opaque handle to an instance object

C Specification
There is no global state in Vulkan and all per-application state is stored in a VkInstance object. Creating a VkInstance object initializes the Vulkan library and allows the application to pass information about itself to the implementation.

Instances are represented by VkInstance handles:

VK_DEFINE_HANDLE(VkInstance)
Description
See Also
vkCreateAndroidSurfaceKHR, vkCreateDebugReportCallbackEXT, vkCreateDebugUtilsMessengerEXT, vkCreateDisplayPlaneSurfaceKHR, vkCreateIOSSurfaceMVK, vkCreateImagePipeSurfaceFUCHSIA, vkCreateInstance, vkCreateMacOSSurfaceMVK, vkCreateMetalSurfaceEXT, vkCreateStreamDescriptorSurfaceGGP, vkCreateViSurfaceNN, vkCreateWaylandSurfaceKHR, vkCreateWin32SurfaceKHR, vkCreateXcbSurfaceKHR, vkCreateXlibSurfaceKHR, vkDebugReportMessageEXT, vkDestroyDebugReportCallbackEXT, vkDestroyDebugUtilsMessengerEXT, vkDestroyInstance, vkDestroySurfaceKHR, vkEnumeratePhysicalDeviceGroups, vkEnumeratePhysicalDeviceGroupsKHR, vkEnumeratePhysicalDevices, vkGetInstanceProcAddr, vkSubmitDebugUtilsMessageEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkInstance

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkObjectTableNVX(3)
Name
VkObjectTableNVX - Opaque handle to an object table

C Specification
The device-side bindings are registered inside a table:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkObjectTableNVX)
Description
See Also
VkCmdProcessCommandsInfoNVX, VkCmdReserveSpaceForCommandsInfoNVX, vkCreateObjectTableNVX, vkDestroyObjectTableNVX, vkRegisterObjectsNVX, vkUnregisterObjectsNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkObjectTableNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDevice(3)
Name
VkPhysicalDevice - Opaque handle to a physical device object

C Specification
Vulkan separates the concept of physical and logical devices. A physical device usually represents a single complete implementation of Vulkan (excluding instance-level functionality) available to the host, of which there are a finite number. A logical device represents an instance of that implementation with its own state and resources independent of other logical devices.

Physical devices are represented by VkPhysicalDevice handles:

VK_DEFINE_HANDLE(VkPhysicalDevice)
Description
See Also
VkDeviceGroupDeviceCreateInfo, VkPhysicalDeviceGroupProperties, vkAcquireXlibDisplayEXT, vkCreateDevice, vkCreateDisplayModeKHR, vkEnumerateDeviceExtensionProperties, vkEnumerateDeviceLayerProperties, vkEnumeratePhysicalDevices, vkGetDisplayModeProperties2KHR, vkGetDisplayModePropertiesKHR, vkGetDisplayPlaneCapabilities2KHR, vkGetDisplayPlaneCapabilitiesKHR, vkGetDisplayPlaneSupportedDisplaysKHR, vkGetPhysicalDeviceCalibrateableTimeDomainsEXT, vkGetPhysicalDeviceCooperativeMatrixPropertiesNV, vkGetPhysicalDeviceDisplayPlaneProperties2KHR, vkGetPhysicalDeviceDisplayPlanePropertiesKHR, vkGetPhysicalDeviceDisplayProperties2KHR, vkGetPhysicalDeviceDisplayPropertiesKHR, vkGetPhysicalDeviceExternalBufferProperties, vkGetPhysicalDeviceExternalBufferPropertiesKHR, vkGetPhysicalDeviceExternalFenceProperties, vkGetPhysicalDeviceExternalFencePropertiesKHR, vkGetPhysicalDeviceExternalImageFormatPropertiesNV, vkGetPhysicalDeviceExternalSemaphoreProperties, vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, vkGetPhysicalDeviceFeatures, vkGetPhysicalDeviceFeatures2, vkGetPhysicalDeviceFeatures2KHR, vkGetPhysicalDeviceFormatProperties, vkGetPhysicalDeviceFormatProperties2, vkGetPhysicalDeviceFormatProperties2KHR, vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX, vkGetPhysicalDeviceImageFormatProperties, vkGetPhysicalDeviceImageFormatProperties2, vkGetPhysicalDeviceImageFormatProperties2KHR, vkGetPhysicalDeviceMemoryProperties, vkGetPhysicalDeviceMemoryProperties2, vkGetPhysicalDeviceMemoryProperties2KHR, vkGetPhysicalDeviceMultisamplePropertiesEXT, vkGetPhysicalDevicePresentRectanglesKHR, vkGetPhysicalDeviceProperties, vkGetPhysicalDeviceProperties2, vkGetPhysicalDeviceProperties2KHR, vkGetPhysicalDeviceQueueFamilyProperties, vkGetPhysicalDeviceQueueFamilyProperties2, vkGetPhysicalDeviceQueueFamilyProperties2KHR, vkGetPhysicalDeviceSparseImageFormatProperties, vkGetPhysicalDeviceSparseImageFormatProperties2, vkGetPhysicalDeviceSparseImageFormatProperties2KHR, vkGetPhysicalDeviceSurfaceCapabilities2EXT, vkGetPhysicalDeviceSurfaceCapabilities2KHR, vkGetPhysicalDeviceSurfaceCapabilitiesKHR, vkGetPhysicalDeviceSurfaceFormats2KHR, vkGetPhysicalDeviceSurfaceFormatsKHR, vkGetPhysicalDeviceSurfacePresentModes2EXT, vkGetPhysicalDeviceSurfacePresentModesKHR, vkGetPhysicalDeviceSurfaceSupportKHR, vkGetPhysicalDeviceWaylandPresentationSupportKHR, vkGetPhysicalDeviceWin32PresentationSupportKHR, vkGetPhysicalDeviceXcbPresentationSupportKHR, vkGetPhysicalDeviceXlibPresentationSupportKHR, vkGetRandROutputDisplayEXT, vkReleaseDisplayEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDevice

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipeline(3)
Name
VkPipeline - Opaque handle to a pipeline object

C Specification
Compute, graphics, and ray tracing pipelines are each represented by VkPipeline handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipeline)
Description
See Also
VkComputePipelineCreateInfo, VkGraphicsPipelineCreateInfo, VkObjectTablePipelineEntryNVX, VkRayTracingPipelineCreateInfoNV, vkCmdBindPipeline, vkCompileDeferredNV, vkCreateComputePipelines, vkCreateGraphicsPipelines, vkCreateRayTracingPipelinesNV, vkDestroyPipeline, vkGetRayTracingShaderGroupHandlesNV, vkGetShaderInfoAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipeline

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCache(3)
Name
VkPipelineCache - Opaque handle to a pipeline cache object

C Specification
Pipeline cache objects allow the result of pipeline construction to be reused between pipelines and between runs of an application. Reuse between pipelines is achieved by passing the same pipeline cache object when creating multiple related pipelines. Reuse across runs of an application is achieved by retrieving pipeline cache contents in one run of an application, saving the contents, and using them to preinitialize a pipeline cache on a subsequent run. The contents of the pipeline cache objects are managed by the implementation. Applications can manage the host memory consumed by a pipeline cache object and control the amount of data retrieved from a pipeline cache object.

Pipeline cache objects are represented by VkPipelineCache handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineCache)
Description
See Also
vkCreateComputePipelines, vkCreateGraphicsPipelines, vkCreatePipelineCache, vkCreateRayTracingPipelinesNV, vkDestroyPipelineCache, vkGetPipelineCacheData, vkMergePipelineCaches

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCache

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineLayout(3)
Name
VkPipelineLayout - Opaque handle to a pipeline layout object

C Specification
Access to descriptor sets from a pipeline is accomplished through a pipeline layout. Zero or more descriptor set layouts and zero or more push constant ranges are combined to form a pipeline layout object which describes the complete set of resources that can be accessed by a pipeline. The pipeline layout represents a sequence of descriptor sets with each having a specific layout. This sequence of layouts is used to determine the interface between shader stages and shader resources. Each pipeline is created using a pipeline layout.

Pipeline layout objects are represented by VkPipelineLayout handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkPipelineLayout)
Description
See Also
VkComputePipelineCreateInfo, VkDescriptorUpdateTemplateCreateInfo, VkGraphicsPipelineCreateInfo, VkObjectTableDescriptorSetEntryNVX, VkObjectTablePushConstantEntryNVX, VkRayTracingPipelineCreateInfoNV, vkCmdBindDescriptorSets, vkCmdPushConstants, vkCmdPushDescriptorSetKHR, vkCmdPushDescriptorSetWithTemplateKHR, vkCreatePipelineLayout, vkDestroyPipelineLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineLayout

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueryPool(3)
Name
VkQueryPool - Opaque handle to a query pool object

C Specification
Queries are managed using query pool objects. Each query pool is a collection of a specific number of queries of a particular type.

Query pools are represented by VkQueryPool handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkQueryPool)
Description
See Also
vkCmdBeginQuery, vkCmdBeginQueryIndexedEXT, vkCmdCopyQueryPoolResults, vkCmdEndQuery, vkCmdEndQueryIndexedEXT, vkCmdResetQueryPool, vkCmdWriteAccelerationStructuresPropertiesNV, vkCmdWriteTimestamp, vkCreateQueryPool, vkDestroyQueryPool, vkGetQueryPoolResults, vkResetQueryPoolEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueryPool

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueue(3)
Name
VkQueue - Opaque handle to a queue object

C Specification
Creating a logical device also creates the queues associated with that device. The queues to create are described by a set of VkDeviceQueueCreateInfo structures that are passed to vkCreateDevice in pQueueCreateInfos.

Queues are represented by VkQueue handles:

VK_DEFINE_HANDLE(VkQueue)
Description
See Also
vkGetDeviceQueue, vkGetDeviceQueue2, vkGetQueueCheckpointDataNV, vkQueueBeginDebugUtilsLabelEXT, vkQueueBindSparse, vkQueueEndDebugUtilsLabelEXT, vkQueueInsertDebugUtilsLabelEXT, vkQueuePresentKHR, vkQueueSubmit, vkQueueWaitIdle

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueue

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRenderPass(3)
Name
VkRenderPass - Opaque handle to a render pass object

C Specification
A render pass represents a collection of attachments, subpasses, and dependencies between the subpasses, and describes how the attachments are used over the course of the subpasses. The use of a render pass in a command buffer is a render pass instance.

Render passes are represented by VkRenderPass handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkRenderPass)
Description
See Also
VkCommandBufferInheritanceInfo, VkFramebufferCreateInfo, VkGraphicsPipelineCreateInfo, VkRenderPassBeginInfo, vkCreateRenderPass, vkCreateRenderPass2KHR, vkDestroyRenderPass, vkGetRenderAreaGranularity

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRenderPass

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSampler(3)
Name
VkSampler - Opaque handle to a sampler object

C Specification
VkSampler objects represent the state of an image sampler which is used by the implementation to read image data and apply filtering and other transformations for the shader.

Samplers are represented by VkSampler handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSampler)
Description
See Also
VkDescriptorImageInfo, VkDescriptorSetLayoutBinding, VkImageViewHandleInfoNVX, vkCreateSampler, vkDestroySampler

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSampler

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSamplerYcbcrConversion(3)
Name
VkSamplerYcbcrConversion - Opaque handle to a device-specific sampler Y’CBCR conversion description

C Specification
A sampler Y’CBCR conversion is an opaque representation of a device-specific sampler Y’CBCR conversion description, represented as a VkSamplerYcbcrConversion handle:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSamplerYcbcrConversion)
or the equivalent

typedef VkSamplerYcbcrConversion VkSamplerYcbcrConversionKHR;
Description
See Also
VkSamplerYcbcrConversionInfo, vkCreateSamplerYcbcrConversion, vkCreateSamplerYcbcrConversionKHR, vkDestroySamplerYcbcrConversion, vkDestroySamplerYcbcrConversionKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerYcbcrConversion

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSemaphore(3)
Name
VkSemaphore - Opaque handle to a semaphore object

C Specification
Semaphores are a synchronization primitive that can be used to insert a dependency between batches submitted to queues. Semaphores have two states - signaled and unsignaled. The state of a semaphore can be signaled after execution of a batch of commands is completed. A batch can wait for a semaphore to become signaled before it begins execution, and the semaphore is also unsignaled before the batch begins execution.

As with most objects in Vulkan, semaphores are an interface to internal data which is typically opaque to applications. This internal data is referred to as a semaphore’s payload.

However, in order to enable communication with agents outside of the current device, it is necessary to be able to export that payload to a commonly understood format, and subsequently import from that format as well.

The internal data of a semaphore may include a reference to any resources and pending work associated with signal or unsignal operations performed on that semaphore object. Mechanisms to import and export that internal data to and from semaphores are provided below. These mechanisms indirectly enable applications to share semaphore state between two or more semaphores and other synchronization primitives across process and API boundaries.

Semaphores are represented by VkSemaphore handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)
Description
See Also
VkAcquireNextImageInfoKHR, VkBindSparseInfo, VkImportSemaphoreFdInfoKHR, VkImportSemaphoreWin32HandleInfoKHR, VkPresentInfoKHR, VkSemaphoreGetFdInfoKHR, VkSemaphoreGetWin32HandleInfoKHR, VkSubmitInfo, vkAcquireNextImageKHR, vkCreateSemaphore, vkDestroySemaphore

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSemaphore

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkShaderModule(3)
Name
VkShaderModule - Opaque handle to a shader module object

C Specification
Shader modules contain shader code and one or more entry points. Shaders are selected from a shader module by specifying an entry point as part of pipeline creation. The stages of a pipeline can use shaders that come from different modules. The shader code defining a shader module must be in the SPIR-V format, as described by the Vulkan Environment for SPIR-V appendix.

Shader modules are represented by VkShaderModule handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkShaderModule)
Description
See Also
VkPipelineShaderStageCreateInfo, vkCreateShaderModule, vkDestroyShaderModule

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkShaderModule

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceKHR(3)
Name
VkSurfaceKHR - Opaque handle to a surface object

C Specification
Native platform surface or window objects are abstracted by surface objects, which are represented by VkSurfaceKHR handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSurfaceKHR)
Description
The VK_KHR_surface extension declares the VkSurfaceKHR object, and provides a function for destroying VkSurfaceKHR objects. Separate platform-specific extensions each provide a function for creating a VkSurfaceKHR object for the respective platform. From the application’s perspective this is an opaque handle, just like the handles of other Vulkan objects.

Note
On certain platforms, the Vulkan loader and ICDs may have conventions that treat the handle as a pointer to a struct that contains the platform-specific information about the surface. This will be described in the documentation for the loader-ICD interface, and in the vk_icd.h header file of the LoaderAndTools source-code repository. This does not affect the loader-layer interface; layers may wrap VkSurfaceKHR objects.
See Also
VkPhysicalDeviceSurfaceInfo2KHR, VkSwapchainCreateInfoKHR, vkCreateAndroidSurfaceKHR, vkCreateDisplayPlaneSurfaceKHR, vkCreateIOSSurfaceMVK, vkCreateImagePipeSurfaceFUCHSIA, vkCreateMacOSSurfaceMVK, vkCreateMetalSurfaceEXT, vkCreateStreamDescriptorSurfaceGGP, vkCreateViSurfaceNN, vkCreateWaylandSurfaceKHR, vkCreateWin32SurfaceKHR, vkCreateXcbSurfaceKHR, vkCreateXlibSurfaceKHR, vkDestroySurfaceKHR, vkGetDeviceGroupSurfacePresentModesKHR, vkGetPhysicalDevicePresentRectanglesKHR, vkGetPhysicalDeviceSurfaceCapabilities2EXT, vkGetPhysicalDeviceSurfaceCapabilitiesKHR, vkGetPhysicalDeviceSurfaceFormatsKHR, vkGetPhysicalDeviceSurfacePresentModesKHR, vkGetPhysicalDeviceSurfaceSupportKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSwapchainKHR(3)
Name
VkSwapchainKHR - Opaque handle to a swapchain object

C Specification
A swapchain object (a.k.a. swapchain) provides the ability to present rendering results to a surface. Swapchain objects are represented by VkSwapchainKHR handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSwapchainKHR)
Description
A swapchain is an abstraction for an array of presentable images that are associated with a surface. The presentable images are represented by VkImage objects created by the platform. One image (which can be an array image for multiview/stereoscopic-3D surfaces) is displayed at a time, but multiple images can be queued for presentation. An application renders to the image, and then queues the image for presentation to the surface.

A native window cannot be associated with more than one non-retired swapchain at a time. Further, swapchains cannot be created for native windows that have a non-Vulkan graphics API surface associated with them.

Note
The presentation engine is an abstraction for the platform’s compositor or display engine.

The presentation engine may be synchronous or asynchronous with respect to the application and/or logical device.

Some implementations may use the device’s graphics queue or dedicated presentation hardware to perform presentation.
The presentable images of a swapchain are owned by the presentation engine. An application can acquire use of a presentable image from the presentation engine. Use of a presentable image must occur only after the image is returned by vkAcquireNextImageKHR, and before it is presented by vkQueuePresentKHR. This includes transitioning the image layout and rendering commands.

An application can acquire use of a presentable image with vkAcquireNextImageKHR. After acquiring a presentable image and before modifying it, the application must use a synchronization primitive to ensure that the presentation engine has finished reading from the image. The application can then transition the image’s layout, queue rendering commands to it, etc. Finally, the application presents the image with vkQueuePresentKHR, which releases the acquisition of the image.

The presentation engine controls the order in which presentable images are acquired for use by the application.

Note
This allows the platform to handle situations which require out-of-order return of images after presentation. At the same time, it allows the application to generate command buffers referencing all of the images in the swapchain at initialization time, rather than in its main loop.
See Also
VkAcquireNextImageInfoKHR, VkBindImageMemorySwapchainInfoKHR, VkImageSwapchainCreateInfoKHR, VkPresentInfoKHR, VkSwapchainCreateInfoKHR, vkAcquireFullScreenExclusiveModeEXT, vkAcquireNextImageKHR, vkCreateSharedSwapchainsKHR, vkCreateSwapchainKHR, vkDestroySwapchainKHR, vkGetPastPresentationTimingGOOGLE, vkGetRefreshCycleDurationGOOGLE, vkGetSwapchainCounterEXT, vkGetSwapchainImagesKHR, vkGetSwapchainStatusKHR, vkReleaseFullScreenExclusiveModeEXT, vkSetHdrMetadataEXT, vkSetLocalDimmingAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSwapchainKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkValidationCacheEXT(3)
Name
VkValidationCacheEXT - Opaque handle to a validation cache object

C Specification
Validation cache objects allow the result of internal validation to be reused, both within a single application run and between multiple runs. Reuse within a single run is achieved by passing the same validation cache object when creating supported Vulkan objects. Reuse across runs of an application is achieved by retrieving validation cache contents in one run of an application, saving the contents, and using them to preinitialize a validation cache on a subsequent run. The contents of the validation cache objects are managed by the validation layers. Applications can manage the host memory consumed by a validation cache object and control the amount of data retrieved from a validation cache object.

Validation cache objects are represented by VkValidationCacheEXT handles:

VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkValidationCacheEXT)
Description
See Also
VkShaderModuleValidationCacheCreateInfoEXT, vkCreateValidationCacheEXT, vkDestroyValidationCacheEXT, vkGetValidationCacheDataEXT, vkMergeValidationCachesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkValidationCacheEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Structures
VkAccelerationStructureCreateInfoNV(3)
Name
VkAccelerationStructureCreateInfoNV - Structure specifying the parameters of a newly created acceleration structure object

C Specification
The VkAccelerationStructureCreateInfoNV structure is defined as:

typedef struct VkAccelerationStructureCreateInfoNV {
    VkStructureType                  sType;
    const void*                      pNext;
    VkDeviceSize                     compactedSize;
    VkAccelerationStructureInfoNV    info;
} VkAccelerationStructureCreateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
compactedSize is the size from the result of vkCmdWriteAccelerationStructuresPropertiesNV if this acceleration structure is going to be the target of a compacting copy.
info is the VkAccelerationStructureInfoNV structure that specifies further parameters of the created acceleration structure.
Description
Valid Usage
If compactedSize is not 0 then both info.geometryCount and info.instanceCount must be 0
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV
pNext must be NULL
info must be a valid VkAccelerationStructureInfoNV structure
See Also
VkAccelerationStructureInfoNV, VkDeviceSize, VkStructureType, vkCreateAccelerationStructureNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAccelerationStructureCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAccelerationStructureInfoNV(3)
Name
VkAccelerationStructureInfoNV - Structure specifying the parameters of acceleration structure object

C Specification
The VkAccelerationStructureInfoNV structure is defined as:

typedef struct VkAccelerationStructureInfoNV {
    VkStructureType                        sType;
    const void*                            pNext;
    VkAccelerationStructureTypeNV          type;
    VkBuildAccelerationStructureFlagsNV    flags;
    uint32_t                               instanceCount;
    uint32_t                               geometryCount;
    const VkGeometryNV*                    pGeometries;
} VkAccelerationStructureInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
type is a VkAccelerationStructureTypeNV value specifying the type of acceleration structure that will be created.
flags is a bitmask of VkBuildAccelerationStructureFlagBitsNV specifying additional parameters of the acceleration structure.
instanceCount specifies the number of instances that will be in the new acceleration structure.
geometryCount specifies the number of geometries that will be in the new acceleration structure.
pGeometries is an array of VkGeometryNV structures, which contain the scene data being passed into the acceleration structure.
Description
VkAccelerationStructureInfoNV contains information that is used both for acceleration structure creation with vkCreateAccelerationStructureNV and in combination with the actual geometric data to build the acceleration structure with vkCmdBuildAccelerationStructureNV.

Valid Usage
geometryCount must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxGeometryCount
instanceCount must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxInstanceCount
The total number of triangles in all geometries must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxTriangleCount
If type is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV then geometryCount must be 0
If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV then instanceCount must be 0
If flags has the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV bit set, then it must not have the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV bit set
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV
pNext must be NULL
type must be a valid VkAccelerationStructureTypeNV value
flags must be a valid combination of VkBuildAccelerationStructureFlagBitsNV values
If geometryCount is not 0, pGeometries must be a valid pointer to an array of geometryCount valid VkGeometryNV structures
See Also
VkAccelerationStructureCreateInfoNV, VkAccelerationStructureTypeNV, VkBuildAccelerationStructureFlagsNV, VkGeometryNV, VkStructureType, vkCmdBuildAccelerationStructureNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAccelerationStructureInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAccelerationStructureMemoryRequirementsInfoNV(3)
Name
VkAccelerationStructureMemoryRequirementsInfoNV - Structure specifying acceleration to query for memory requirements

C Specification
The VkAccelerationStructureMemoryRequirementsInfoNV structure is defined as:

typedef struct VkAccelerationStructureMemoryRequirementsInfoNV {
    VkStructureType                                    sType;
    const void*                                        pNext;
    VkAccelerationStructureMemoryRequirementsTypeNV    type;
    VkAccelerationStructureNV                          accelerationStructure;
} VkAccelerationStructureMemoryRequirementsInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
type selects the type of memory requirement being queried. VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV returns the memory requirements for the object itself. VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV returns the memory requirements for the scratch memory when doing a build. VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV returns the memory requirements for the scratch memory when doing an update.
accelerationStructure is the acceleration structure to be queried for memory requirements.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV
pNext must be NULL
type must be a valid VkAccelerationStructureMemoryRequirementsTypeNV value
accelerationStructure must be a valid VkAccelerationStructureNV handle
See Also
VkAccelerationStructureMemoryRequirementsTypeNV, VkAccelerationStructureNV, VkStructureType, vkGetAccelerationStructureMemoryRequirementsNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAccelerationStructureMemoryRequirementsInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAcquireNextImageInfoKHR(3)
Name
VkAcquireNextImageInfoKHR - Structure specifying parameters of the acquire

C Specification
The VkAcquireNextImageInfoKHR structure is defined as:

typedef struct VkAcquireNextImageInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkSwapchainKHR     swapchain;
    uint64_t           timeout;
    VkSemaphore        semaphore;
    VkFence            fence;
    uint32_t           deviceMask;
} VkAcquireNextImageInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
swapchain is a non-retired swapchain from which an image is acquired.
timeout specifies how long the function waits, in nanoseconds, if no image is available.
semaphore is VK_NULL_HANDLE or a semaphore to signal.
fence is VK_NULL_HANDLE or a fence to signal.
deviceMask is a mask of physical devices for which the swapchain image will be ready to use when the semaphore or fence is signaled.
Description
If vkAcquireNextImageKHR is used, the device mask is considered to include all physical devices in the logical device.

Note
vkAcquireNextImage2KHR signals at most one semaphore, even if the application requests waiting for multiple physical devices to be ready via the deviceMask. However, only a single physical device can wait on that semaphore, since the semaphore becomes unsignaled when the wait succeeds. For other physical devices to wait for the image to be ready, it is necessary for the application to submit semaphore signal operation(s) to that first physical device to signal additional semaphore(s) after the wait succeeds, which the other physical device(s) can wait upon.
Valid Usage
swapchain must not be in the retired state
If semaphore is not VK_NULL_HANDLE it must be unsignaled
If semaphore is not VK_NULL_HANDLE it must not have any uncompleted signal or wait operations pending
If fence is not VK_NULL_HANDLE it must be unsignaled and must not be associated with any other queue command that has not yet completed execution on that queue
semaphore and fence must not both be equal to VK_NULL_HANDLE
deviceMask must be a valid device mask
deviceMask must not be zero
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR
pNext must be NULL
swapchain must be a valid VkSwapchainKHR handle
If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle
If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle
Each of fence, semaphore, and swapchain that are valid handles must have been created, allocated, or retrieved from the same VkInstance
Host Synchronization
Host access to swapchain must be externally synchronized
Host access to semaphore must be externally synchronized
Host access to fence must be externally synchronized
See Also
VkFence, VkSemaphore, VkStructureType, VkSwapchainKHR, vkAcquireNextImage2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAcquireNextImageInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAllocationCallbacks(3)
Name
VkAllocationCallbacks - Structure containing callback function pointers for memory allocation

C Specification
Allocators are provided by the application as a pointer to a VkAllocationCallbacks structure:

typedef struct VkAllocationCallbacks {
    void*                                   pUserData;
    PFN_vkAllocationFunction                pfnAllocation;
    PFN_vkReallocationFunction              pfnReallocation;
    PFN_vkFreeFunction                      pfnFree;
    PFN_vkInternalAllocationNotification    pfnInternalAllocation;
    PFN_vkInternalFreeNotification          pfnInternalFree;
} VkAllocationCallbacks;
Members
pUserData is a value to be interpreted by the implementation of the callbacks. When any of the callbacks in VkAllocationCallbacks are called, the Vulkan implementation will pass this value as the first parameter to the callback. This value can vary each time an allocator is passed into a command, even when the same object takes an allocator in multiple commands.
pfnAllocation is a pointer to an application-defined memory allocation function of type PFN_vkAllocationFunction.
pfnReallocation is a pointer to an application-defined memory reallocation function of type PFN_vkReallocationFunction.
pfnFree is a pointer to an application-defined memory free function of type PFN_vkFreeFunction.
pfnInternalAllocation is a pointer to an application-defined function that is called by the implementation when the implementation makes internal allocations, and it is of type PFN_vkInternalAllocationNotification.
pfnInternalFree is a pointer to an application-defined function that is called by the implementation when the implementation frees internal allocations, and it is of type PFN_vkInternalFreeNotification.
Description
Valid Usage
pfnAllocation must be a valid pointer to a valid user-defined PFN_vkAllocationFunction
pfnReallocation must be a valid pointer to a valid user-defined PFN_vkReallocationFunction
pfnFree must be a valid pointer to a valid user-defined PFN_vkFreeFunction
If either of pfnInternalAllocation or pfnInternalFree is not NULL, both must be valid callbacks
See Also
PFN_vkAllocationFunction, PFN_vkFreeFunction, PFN_vkInternalAllocationNotification, PFN_vkInternalFreeNotification, PFN_vkReallocationFunction, vkAllocateMemory, vkCreateAccelerationStructureNV, vkCreateAndroidSurfaceKHR, vkCreateBuffer, vkCreateBufferView, vkCreateCommandPool, vkCreateComputePipelines, vkCreateDebugReportCallbackEXT, vkCreateDebugUtilsMessengerEXT, vkCreateDescriptorPool, vkCreateDescriptorSetLayout, vkCreateDescriptorUpdateTemplate, vkCreateDescriptorUpdateTemplateKHR, vkCreateDevice, vkCreateDisplayModeKHR, vkCreateDisplayPlaneSurfaceKHR, vkCreateEvent, vkCreateFence, vkCreateFramebuffer, vkCreateGraphicsPipelines, vkCreateIOSSurfaceMVK, vkCreateImage, vkCreateImagePipeSurfaceFUCHSIA, vkCreateImageView, vkCreateIndirectCommandsLayoutNVX, vkCreateInstance, vkCreateMacOSSurfaceMVK, vkCreateMetalSurfaceEXT, vkCreateObjectTableNVX, vkCreatePipelineCache, vkCreatePipelineLayout, vkCreateQueryPool, vkCreateRayTracingPipelinesNV, vkCreateRenderPass, vkCreateRenderPass2KHR, vkCreateSampler, vkCreateSamplerYcbcrConversion, vkCreateSamplerYcbcrConversionKHR, vkCreateSemaphore, vkCreateShaderModule, vkCreateSharedSwapchainsKHR, vkCreateStreamDescriptorSurfaceGGP, vkCreateSwapchainKHR, vkCreateValidationCacheEXT, vkCreateViSurfaceNN, vkCreateWaylandSurfaceKHR, vkCreateWin32SurfaceKHR, vkCreateXcbSurfaceKHR, vkCreateXlibSurfaceKHR, vkDestroyAccelerationStructureNV, vkDestroyBuffer, vkDestroyBufferView, vkDestroyCommandPool, vkDestroyDebugReportCallbackEXT, vkDestroyDebugUtilsMessengerEXT, vkDestroyDescriptorPool, vkDestroyDescriptorSetLayout, vkDestroyDescriptorUpdateTemplate, vkDestroyDescriptorUpdateTemplateKHR, vkDestroyDevice, vkDestroyEvent, vkDestroyFence, vkDestroyFramebuffer, vkDestroyImage, vkDestroyImageView, vkDestroyIndirectCommandsLayoutNVX, vkDestroyInstance, vkDestroyObjectTableNVX, vkDestroyPipeline, vkDestroyPipelineCache, vkDestroyPipelineLayout, vkDestroyQueryPool, vkDestroyRenderPass, vkDestroySampler, vkDestroySamplerYcbcrConversion, vkDestroySamplerYcbcrConversionKHR, vkDestroySemaphore, vkDestroyShaderModule, vkDestroySurfaceKHR, vkDestroySwapchainKHR, vkDestroyValidationCacheEXT, vkFreeMemory, vkRegisterDeviceEventEXT, vkRegisterDisplayEventEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAllocationCallbacks

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAndroidHardwareBufferFormatPropertiesANDROID(3)
Name
VkAndroidHardwareBufferFormatPropertiesANDROID - Structure describing the image format properties of an Android hardware buffer

C Specification
To obtain format properties of an Android hardware buffer, include an instance of VkAndroidHardwareBufferFormatPropertiesANDROID in the pNext chain of the VkAndroidHardwareBufferPropertiesANDROID instance passed to vkGetAndroidHardwareBufferPropertiesANDROID. This structure is defined as:

typedef struct VkAndroidHardwareBufferFormatPropertiesANDROID {
    VkStructureType                  sType;
    void*                            pNext;
    VkFormat                         format;
    uint64_t                         externalFormat;
    VkFormatFeatureFlags             formatFeatures;
    VkComponentMapping               samplerYcbcrConversionComponents;
    VkSamplerYcbcrModelConversion    suggestedYcbcrModel;
    VkSamplerYcbcrRange              suggestedYcbcrRange;
    VkChromaLocation                 suggestedXChromaOffset;
    VkChromaLocation                 suggestedYChromaOffset;
} VkAndroidHardwareBufferFormatPropertiesANDROID;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
format is the Vulkan format corresponding to the Android hardware buffer’s format, or VK_FORMAT_UNDEFINED if there is not an equivalent Vulkan format.
externalFormat is an implementation-defined external format identifier for use with VkExternalFormatANDROID. It must not be zero.
formatFeatures describes the capabilities of this external format when used with an image bound to memory imported from buffer.
samplerYcbcrConversionComponents is the component swizzle that should be used in VkSamplerYcbcrConversionCreateInfo.
suggestedYcbcrModel is a suggested color model to use in the VkSamplerYcbcrConversionCreateInfo.
suggestedYcbcrRange is a suggested numerical value range to use in VkSamplerYcbcrConversionCreateInfo.
suggestedXChromaOffset is a suggested X chroma offset to use in VkSamplerYcbcrConversionCreateInfo.
suggestedYChromaOffset is a suggested Y chroma offset to use in VkSamplerYcbcrConversionCreateInfo.
Description
If the Android hardware buffer has one of the formats listed in the Format Equivalence table, then format must have the equivalent Vulkan format listed in the table. Otherwise, format may be VK_FORMAT_UNDEFINED, indicating the Android hardware buffer can only be used with an external format.

The formatFeatures member must include VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT and at least one of VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT or VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT, and should include VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT and VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT.

Note
The formatFeatures member only indicates the features available when using an external-format image created from the Android hardware buffer. Images from Android hardware buffers with a format other than VK_FORMAT_UNDEFINED are subject to the format capabilities obtained from vkGetPhysicalDeviceFormatProperties2, and vkGetPhysicalDeviceImageFormatProperties2 with appropriate parameters. These sets of features are independent of each other, e.g. the external format will support sampler Y’CBCR conversion even if the non-external format does not, and writing to non-external format images is possible but writing to external format images is not.
Android hardware buffers with the same external format must have the same support for VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT, VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT, VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT, VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT, VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT, and VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT. in formatFeatures. Other format features may differ between Android hardware buffers that have the same external format. This allows applications to use the same VkSamplerYcbcrConversion object (and samplers and pipelines created from them) for any Android hardware buffers that have the same external format.

If format is not VK_FORMAT_UNDEFINED, then the value of samplerYcbcrConversionComponents must be valid when used as the components member of VkSamplerYcbcrConversionCreateInfo with that format. If format is VK_FORMAT_UNDEFINED, all members of samplerYcbcrConversionComponents must be VK_COMPONENT_SWIZZLE_IDENTITY.

Implementations may not always be able to determine the color model, numerical range, or chroma offsets of the image contents, so the values in VkAndroidHardwareBufferFormatPropertiesANDROID are only suggestions. Applications should treat these values as sensible defaults to use in the absence of more reliable information obtained through some other means. If the underlying physical device is also usable via OpenGL ES with the GL_OES_EGL_image_external extension, the implementation should suggest values that will produce similar sampled values as would be obtained by sampling the same external image via samplerExternalOES in OpenGL ES using equivalent sampler parameters.

Note
Since GL_OES_EGL_image_external does not require the same sampling and conversion calculations as Vulkan does, achieving identical results between APIs may not be possible on some implementations.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID
See Also
VkChromaLocation, VkComponentMapping, VkFormat, VkFormatFeatureFlags, VkSamplerYcbcrModelConversion, VkSamplerYcbcrRange, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAndroidHardwareBufferFormatPropertiesANDROID

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAndroidHardwareBufferPropertiesANDROID(3)
Name
VkAndroidHardwareBufferPropertiesANDROID - Properties of External Memory Android Hardware Buffers

C Specification
The VkAndroidHardwareBufferPropertiesANDROID structure returned is defined as:

typedef struct VkAndroidHardwareBufferPropertiesANDROID {
    VkStructureType    sType;
    void*              pNext;
    VkDeviceSize       allocationSize;
    uint32_t           memoryTypeBits;
} VkAndroidHardwareBufferPropertiesANDROID;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
allocationSize is the size of the external memory
memoryTypeBits is a bitmask containing one bit set for every memory type which the specified Android hardware buffer can be imported as.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID
pNext must be NULL or a pointer to a valid instance of VkAndroidHardwareBufferFormatPropertiesANDROID
See Also
VkDeviceSize, VkStructureType, vkGetAndroidHardwareBufferPropertiesANDROID

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAndroidHardwareBufferPropertiesANDROID

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAndroidHardwareBufferUsageANDROID(3)
Name
VkAndroidHardwareBufferUsageANDROID - Struct containing Android hardware buffer usage flags

C Specification
To obtain optimal Android hardware buffer usage flags for specific image creation parameters, attach an instance of VkAndroidHardwareBufferUsageANDROID to the pNext chain of a VkImageFormatProperties2 structure passed to vkGetPhysicalDeviceImageFormatProperties2. This structure is defined as:

typedef struct VkAndroidHardwareBufferUsageANDROID {
    VkStructureType    sType;
    void*              pNext;
    uint64_t           androidHardwareBufferUsage;
} VkAndroidHardwareBufferUsageANDROID;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
androidHardwareBufferUsage returns the Android hardware buffer usage flags.
Description
The androidHardwareBufferUsage field must include Android hardware buffer usage flags listed in the AHardwareBuffer Usage Equivalence table when the corresponding Vulkan image usage or image creation flags are included in the usage or flags fields of VkPhysicalDeviceImageFormatInfo2. It must include at least one GPU usage flag (AHARDWAREBUFFER_USAGE_GPU_*), even if none of the corresponding Vulkan usages or flags are requested.

Note
Requiring at least one GPU usage flag ensures that Android hardware buffer memory will be allocated in a memory pool accessible to the Vulkan implementation, and that specializing the memory layout based on usage flags does not prevent it from being compatible with Vulkan. Implementations may avoid unnecessary restrictions caused by this requirement by using vendor usage flags to indicate that only the Vulkan uses indicated in VkImageFormatProperties2 are required.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAndroidHardwareBufferUsageANDROID

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAndroidSurfaceCreateInfoKHR(3)
Name
VkAndroidSurfaceCreateInfoKHR - Structure specifying parameters of a newly created Android surface object

C Specification
The VkAndroidSurfaceCreateInfoKHR structure is defined as:

typedef struct VkAndroidSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    const void*                       pNext;
    VkAndroidSurfaceCreateFlagsKHR    flags;
    struct ANativeWindow*             window;
} VkAndroidSurfaceCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
window is a pointer to the ANativeWindow to associate the surface with.
Description
Valid Usage
window must point to a valid Android ANativeWindow.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR
pNext must be NULL
flags must be 0
See Also
VkAndroidSurfaceCreateFlagsKHR, VkStructureType, vkCreateAndroidSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAndroidSurfaceCreateInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkApplicationInfo(3)
Name
VkApplicationInfo - Structure specifying application info

C Specification
The VkApplicationInfo structure is defined as:

typedef struct VkApplicationInfo {
    VkStructureType    sType;
    const void*        pNext;
    const char*        pApplicationName;
    uint32_t           applicationVersion;
    const char*        pEngineName;
    uint32_t           engineVersion;
    uint32_t           apiVersion;
} VkApplicationInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
pApplicationName is NULL or is a pointer to a null-terminated UTF-8 string containing the name of the application.
applicationVersion is an unsigned integer variable containing the developer-supplied version number of the application.
pEngineName is NULL or is a pointer to a null-terminated UTF-8 string containing the name of the engine (if any) used to create the application.
engineVersion is an unsigned integer variable containing the developer-supplied version number of the engine used to create the application.
apiVersion must be the highest version of Vulkan that the application is designed to use, encoded as described in html/vkspec.html#extendingvulkan-coreversions-versionnumbers. The patch version number specified in apiVersion is ignored when creating an instance object. Only the major and minor versions of the instance must match those requested in apiVersion.
Description
Vulkan 1.0 implementations were required to return VK_ERROR_INCOMPATIBLE_DRIVER if apiVersion was larger than 1.0. Implementations that support Vulkan 1.1 or later must not return VK_ERROR_INCOMPATIBLE_DRIVER for any value of apiVersion.

Note
Because Vulkan 1.0 implementations may fail with VK_ERROR_INCOMPATIBLE_DRIVER, applications should determine the version of Vulkan available before calling vkCreateInstance. If the vkGetInstanceProcAddr returns NULL for vkEnumerateInstanceVersion, it is a Vulkan 1.0 implementation. Otherwise, the application can call vkEnumerateInstanceVersion to determine the version of Vulkan.
As long as the instance supports at least Vulkan 1.1, an application can use different versions of Vulkan with an instance than it does with a device or physical device.

Note
The Khronos validation layers will treat apiVersion as the highest API version the application targets, and will validate API usage against the minimum of that version and the implementation version (instance or device, depending on context). If an application tries to use functionality from a greater version than this, a validation error will be triggered.

For example, if the instance supports Vulkan 1.1 and three physical devices support Vulkan 1.0, Vulkan 1.1, and a hypothetical Vulkan 1.2, respectively, and if the application sets apiVersion to 1.2, the application can use the following versions of Vulkan:

Vulkan 1.0 can be used with the instance and with all physical devices.
Vulkan 1.1 can be used with the instance and with the physical devices that support Vulkan 1.1 and Vulkan 1.2.
Vulkan 1.2 can be used with the physical device that supports Vulkan 1.2.
If we modify the above example so that the application sets apiVersion to 1.1, then the application must not use Vulkan 1.2 functionality on the physical device that supports Vulkan 1.2.
Implicit layers must be disabled if they do not support a version at least as high as apiVersion. See the Vulkan Loader Specification and Architecture Overview document for additional information.

Note
Providing a NULL VkInstanceCreateInfo::pApplicationInfo or providing an apiVersion of 0 is equivalent to providing an apiVersion of VK_MAKE_VERSION(1,0,0).
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_APPLICATION_INFO
pNext must be NULL
If pApplicationName is not NULL, pApplicationName must be a null-terminated UTF-8 string
If pEngineName is not NULL, pEngineName must be a null-terminated UTF-8 string
See Also
VkInstanceCreateInfo, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkApplicationInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAttachmentDescription(3)
Name
VkAttachmentDescription - Structure specifying an attachment description

C Specification
The VkAttachmentDescription structure is defined as:

typedef struct VkAttachmentDescription {
    VkAttachmentDescriptionFlags    flags;
    VkFormat                        format;
    VkSampleCountFlagBits           samples;
    VkAttachmentLoadOp              loadOp;
    VkAttachmentStoreOp             storeOp;
    VkAttachmentLoadOp              stencilLoadOp;
    VkAttachmentStoreOp             stencilStoreOp;
    VkImageLayout                   initialLayout;
    VkImageLayout                   finalLayout;
} VkAttachmentDescription;
Members
flags is a bitmask of VkAttachmentDescriptionFlagBits specifying additional properties of the attachment.
format is a VkFormat value specifying the format of the image view that will be used for the attachment.
samples is the number of samples of the image as defined in VkSampleCountFlagBits.
loadOp is a VkAttachmentLoadOp value specifying how the contents of color and depth components of the attachment are treated at the beginning of the subpass where it is first used.
storeOp is a VkAttachmentStoreOp value specifying how the contents of color and depth components of the attachment are treated at the end of the subpass where it is last used.
stencilLoadOp is a VkAttachmentLoadOp value specifying how the contents of stencil components of the attachment are treated at the beginning of the subpass where it is first used.
stencilStoreOp is a VkAttachmentStoreOp value specifying how the contents of stencil components of the attachment are treated at the end of the last subpass where it is used.
initialLayout is the layout the attachment image subresource will be in when a render pass instance begins.
finalLayout is the layout the attachment image subresource will be transitioned to when a render pass instance ends.
Description
If the attachment uses a color format, then loadOp and storeOp are used, and stencilLoadOp and stencilStoreOp are ignored. If the format has depth and/or stencil components, loadOp and storeOp apply only to the depth data, while stencilLoadOp and stencilStoreOp define how the stencil data is handled. loadOp and stencilLoadOp define the load operations that execute as part of the first subpass that uses the attachment. storeOp and stencilStoreOp define the store operations that execute as part of the last subpass that uses the attachment.

The load operation for each sample in an attachment happens-before any recorded command which accesses the sample in the first subpass where the attachment is used. Load operations for attachments with a depth/stencil format execute in the VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT pipeline stage. Load operations for attachments with a color format execute in the VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT pipeline stage.

The store operation for each sample in an attachment happens-after any recorded command which accesses the sample in the last subpass where the attachment is used. Store operations for attachments with a depth/stencil format execute in the VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT pipeline stage. Store operations for attachments with a color format execute in the VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT pipeline stage.

If an attachment is not used by any subpass, then loadOp, storeOp, stencilStoreOp, and stencilLoadOp are ignored, and the attachment’s memory contents will not be modified by execution of a render pass instance.

The load and store operations apply on the first and last use of each view in the render pass, respectively. If a view index of an attachment is not included in the view mask in any subpass that uses it, then the load and store operations are ignored, and the attachment’s memory contents will not be modified by execution of a render pass instance.

During a render pass instance, input/color attachments with color formats that have a component size of 8, 16, or 32 bits must be represented in the attachment’s format throughout the instance. Attachments with other floating- or fixed-point color formats, or with depth components may be represented in a format with a precision higher than the attachment format, but must be represented with the same range. When such a component is loaded via the loadOp, it will be converted into an implementation-dependent format used by the render pass. Such components must be converted from the render pass format, to the format of the attachment, before they are resolved or stored at the end of a render pass instance via storeOp. Conversions occur as described in Numeric Representation and Computation and Fixed-Point Data Conversions.

If flags includes VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT, then the attachment is treated as if it shares physical memory with another attachment in the same render pass. This information limits the ability of the implementation to reorder certain operations (like layout transitions and the loadOp) such that it is not improperly reordered against other uses of the same physical memory via a different attachment. This is described in more detail below.

Valid Usage
finalLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED
Valid Usage (Implicit)
flags must be a valid combination of VkAttachmentDescriptionFlagBits values
format must be a valid VkFormat value
samples must be a valid VkSampleCountFlagBits value
loadOp must be a valid VkAttachmentLoadOp value
storeOp must be a valid VkAttachmentStoreOp value
stencilLoadOp must be a valid VkAttachmentLoadOp value
stencilStoreOp must be a valid VkAttachmentStoreOp value
initialLayout must be a valid VkImageLayout value
finalLayout must be a valid VkImageLayout value
See Also
VkAttachmentDescriptionFlags, VkAttachmentLoadOp, VkAttachmentStoreOp, VkFormat, VkImageLayout, VkRenderPassCreateInfo, VkSampleCountFlagBits

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAttachmentDescription

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAttachmentDescription2KHR(3)
Name
VkAttachmentDescription2KHR - Structure specifying an attachment description

C Specification
The VkAttachmentDescription2KHR structure is defined as:

typedef struct VkAttachmentDescription2KHR {
    VkStructureType                 sType;
    const void*                     pNext;
    VkAttachmentDescriptionFlags    flags;
    VkFormat                        format;
    VkSampleCountFlagBits           samples;
    VkAttachmentLoadOp              loadOp;
    VkAttachmentStoreOp             storeOp;
    VkAttachmentLoadOp              stencilLoadOp;
    VkAttachmentStoreOp             stencilStoreOp;
    VkImageLayout                   initialLayout;
    VkImageLayout                   finalLayout;
} VkAttachmentDescription2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkAttachmentDescriptionFlagBits specifying additional properties of the attachment.
format is a VkFormat value specifying the format of the image that will be used for the attachment.
samples is the number of samples of the image as defined in VkSampleCountFlagBits.
loadOp is a VkAttachmentLoadOp value specifying how the contents of color and depth components of the attachment are treated at the beginning of the subpass where it is first used.
storeOp is a VkAttachmentStoreOp value specifying how the contents of color and depth components of the attachment are treated at the end of the subpass where it is last used.
stencilLoadOp is a VkAttachmentLoadOp value specifying how the contents of stencil components of the attachment are treated at the beginning of the subpass where it is first used.
stencilStoreOp is a VkAttachmentStoreOp value specifying how the contents of stencil components of the attachment are treated at the end of the last subpass where it is used.
initialLayout is the layout the attachment image subresource will be in when a render pass instance begins.
finalLayout is the layout the attachment image subresource will be transitioned to when a render pass instance ends.
Description
Parameters defined by this structure with the same name as those in VkAttachmentDescription have the identical effect to those parameters.

Valid Usage
finalLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR
flags must be a valid combination of VkAttachmentDescriptionFlagBits values
format must be a valid VkFormat value
samples must be a valid VkSampleCountFlagBits value
loadOp must be a valid VkAttachmentLoadOp value
storeOp must be a valid VkAttachmentStoreOp value
stencilLoadOp must be a valid VkAttachmentLoadOp value
stencilStoreOp must be a valid VkAttachmentStoreOp value
initialLayout must be a valid VkImageLayout value
finalLayout must be a valid VkImageLayout value
See Also
VkAttachmentDescriptionFlags, VkAttachmentLoadOp, VkAttachmentStoreOp, VkFormat, VkImageLayout, VkRenderPassCreateInfo2KHR, VkSampleCountFlagBits, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAttachmentDescription2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAttachmentReference(3)
Name
VkAttachmentReference - Structure specifying an attachment reference

C Specification
The VkAttachmentReference structure is defined as:

typedef struct VkAttachmentReference {
    uint32_t         attachment;
    VkImageLayout    layout;
} VkAttachmentReference;
Members
attachment is either an integer value identifying an attachment at the corresponding index in VkRenderPassCreateInfo::pAttachments, or VK_ATTACHMENT_UNUSED to signify that this attachment is not used.
layout is a VkImageLayout value specifying the layout the attachment uses during the subpass.
Description
Valid Usage
If attachment is not VK_ATTACHMENT_UNUSED, layout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED
Valid Usage (Implicit)
layout must be a valid VkImageLayout value
See Also
VkImageLayout, VkRenderPassFragmentDensityMapCreateInfoEXT, VkSubpassDescription

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAttachmentReference

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAttachmentReference2KHR(3)
Name
VkAttachmentReference2KHR - Structure specifying an attachment reference

C Specification
The VkAttachmentReference2KHR structure is defined as:

typedef struct VkAttachmentReference2KHR {
    VkStructureType       sType;
    const void*           pNext;
    uint32_t              attachment;
    VkImageLayout         layout;
    VkImageAspectFlags    aspectMask;
} VkAttachmentReference2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
attachment is either an integer value identifying an attachment at the corresponding index in VkRenderPassCreateInfo::pAttachments, or VK_ATTACHMENT_UNUSED to signify that this attachment is not used.
layout is a VkImageLayout value specifying the layout the attachment uses during the subpass.
aspectMask is a mask of which aspect(s) can be accessed within the specified subpass as an input attachment.
Description
Parameters defined by this structure with the same name as those in VkAttachmentReference have the identical effect to those parameters.

aspectMask has the same effect for the described attachment as VkInputAttachmentAspectReference::aspectMask has on each corresponding attachment. It is ignored when this structure is used to describe anything other than an input attachment reference.

Valid Usage
If attachment is not VK_ATTACHMENT_UNUSED, layout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR
layout must be a valid VkImageLayout value
See Also
VkImageAspectFlags, VkImageLayout, VkStructureType, VkSubpassDescription2KHR, VkSubpassDescriptionDepthStencilResolveKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAttachmentReference2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAttachmentSampleLocationsEXT(3)
Name
VkAttachmentSampleLocationsEXT - Structure specifying the sample locations state to use in the initial layout transition of attachments

C Specification
The VkAttachmentSampleLocationsEXT structure is defined as:

typedef struct VkAttachmentSampleLocationsEXT {
    uint32_t                    attachmentIndex;
    VkSampleLocationsInfoEXT    sampleLocationsInfo;
} VkAttachmentSampleLocationsEXT;
Members
attachmentIndex is the index of the attachment for which the sample locations state is provided.
sampleLocationsInfo is the sample locations state to use for the layout transition of the given attachment from the initial layout of the attachment to the image layout specified for the attachment in the first subpass using it.
Description
If the image referenced by the framebuffer attachment at index attachmentIndex was not created with VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT then the values specified in sampleLocationsInfo are ignored.

Valid Usage
attachmentIndex must be less than the attachmentCount specified in VkRenderPassCreateInfo the render pass specified by VkRenderPassBeginInfo::renderPass was created with
Valid Usage (Implicit)
sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure
See Also
VkRenderPassSampleLocationsBeginInfoEXT, VkSampleLocationsInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAttachmentSampleLocationsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBaseInStructure(3)
Name
VkBaseInStructure - Base structure for a read-only pointer chain

C Specification
The VkBaseInStructure structure is defined as:

typedef struct VkBaseInStructure {
    VkStructureType                    sType;
    const struct VkBaseInStructure*    pNext;
} VkBaseInStructure;
Members
sType is the structure type of the structure being iterated through.
pNext is NULL or a pointer to the next structure in a structure chain.
Description
VkBaseInStructure can be used to facilitate iterating through a read-only structure pointer chain.

See Also
VkBaseInStructure, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBaseInStructure

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBaseOutStructure(3)
Name
VkBaseOutStructure - Base structure for a read-only pointer chain

C Specification
The VkBaseOutStructure structure is defined as:

typedef struct VkBaseOutStructure {
    VkStructureType               sType;
    struct VkBaseOutStructure*    pNext;
} VkBaseOutStructure;
Members
sType is the structure type of the structure being iterated through.
pNext is NULL or a pointer to the next structure in a structure chain.
Description
VkBaseOutStructure can be used to facilitate iterating through a structure pointer chain that returns data back to the application.

See Also
VkBaseOutStructure, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBaseOutStructure

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBindAccelerationStructureMemoryInfoNV(3)
Name
VkBindAccelerationStructureMemoryInfoNV - Structure specifying acceleration structure memory binding

C Specification
The VkBindAccelerationStructureMemoryInfoNV structure is defined as:

typedef struct VkBindAccelerationStructureMemoryInfoNV {
    VkStructureType              sType;
    const void*                  pNext;
    VkAccelerationStructureNV    accelerationStructure;
    VkDeviceMemory               memory;
    VkDeviceSize                 memoryOffset;
    uint32_t                     deviceIndexCount;
    const uint32_t*              pDeviceIndices;
} VkBindAccelerationStructureMemoryInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
accelerationStructure is the acceleration structure to be attached to memory.
memory is a VkDeviceMemory object describing the device memory to attach.
memoryOffset is the start offset of the region of memory that is to be bound to the acceleration structure. The number of bytes returned in the VkMemoryRequirements::size member in memory, starting from memoryOffset bytes, will be bound to the specified acceleration structure.
deviceIndexCount is the number of elements in pDeviceIndices.
pDeviceIndices is a pointer to an array of device indices.
Description
Valid Usage
accelerationStructure must not already be backed by a memory object
memoryOffset must be less than the size of memory
memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with accelerationStructure and type of VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV
memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with accelerationStructure and type of VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV
The size member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with accelerationStructure and type of VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV must be less than or equal to the size of memory minus memoryOffset
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV
pNext must be NULL
accelerationStructure must be a valid VkAccelerationStructureNV handle
memory must be a valid VkDeviceMemory handle
If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values
Both of accelerationStructure, and memory must have been created, allocated, or retrieved from the same VkDevice
See Also
VkAccelerationStructureNV, VkDeviceMemory, VkDeviceSize, VkStructureType, vkBindAccelerationStructureMemoryNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBindAccelerationStructureMemoryInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBindBufferMemoryDeviceGroupInfo(3)
Name
VkBindBufferMemoryDeviceGroupInfo - Structure specifying device within a group to bind to

C Specification
typedef struct VkBindBufferMemoryDeviceGroupInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceIndexCount;
    const uint32_t*    pDeviceIndices;
} VkBindBufferMemoryDeviceGroupInfo;
or the equivalent

typedef VkBindBufferMemoryDeviceGroupInfo VkBindBufferMemoryDeviceGroupInfoKHR;
Members
If the pNext list of VkBindBufferMemoryInfo includes a VkBindBufferMemoryDeviceGroupInfo structure, then that structure determines how memory is bound to buffers across multiple devices in a device group.

Description
The VkBindBufferMemoryDeviceGroupInfo structure is defined as:

sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
deviceIndexCount is the number of elements in pDeviceIndices.
pDeviceIndices is a pointer to an array of device indices.
If deviceIndexCount is greater than zero, then on device index i the buffer is attached to the instance of memory on the physical device with device index pDeviceIndices[i].

If deviceIndexCount is zero and memory comes from a memory heap with the VK_MEMORY_HEAP_MULTI_INSTANCE_BIT bit set, then it is as if pDeviceIndices contains consecutive indices from zero to the number of physical devices in the logical device, minus one. In other words, by default each physical device attaches to its own instance of memory.

If deviceIndexCount is zero and memory comes from a memory heap without the VK_MEMORY_HEAP_MULTI_INSTANCE_BIT bit set, then it is as if pDeviceIndices contains an array of zeros. In other words, by default each physical device attaches to instance zero.

Valid Usage
deviceIndexCount must either be zero or equal to the number of physical devices in the logical device
All elements of pDeviceIndices must be valid device indices
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO
If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBindBufferMemoryDeviceGroupInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBindBufferMemoryInfo(3)
Name
VkBindBufferMemoryInfo - Structure specifying how to bind a buffer to memory

C Specification
VkBindBufferMemoryInfo contains members corresponding to the parameters of vkBindBufferMemory.

The VkBindBufferMemoryInfo structure is defined as:

typedef struct VkBindBufferMemoryInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkBuffer           buffer;
    VkDeviceMemory     memory;
    VkDeviceSize       memoryOffset;
} VkBindBufferMemoryInfo;
or the equivalent

typedef VkBindBufferMemoryInfo VkBindBufferMemoryInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
buffer is the buffer to be attached to memory.
memory is a VkDeviceMemory object describing the device memory to attach.
memoryOffset is the start offset of the region of memory which is to be bound to the buffer. The number of bytes returned in the VkMemoryRequirements::size member in memory, starting from memoryOffset bytes, will be bound to the specified buffer.
Description
Valid Usage
buffer must not already be backed by a memory object
buffer must not have been created with any sparse memory binding flags
memoryOffset must be less than the size of memory
memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer
memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer
The size member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer must be less than or equal to the size of memory minus memoryOffset
If buffer requires a dedicated allocation(as reported by vkGetBufferMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for buffer), memory must have been created with VkMemoryDedicatedAllocateInfo::buffer equal to buffer and memoryOffset must be zero
If the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::buffer was not VK_NULL_HANDLE, then buffer must equal VkMemoryDedicatedAllocateInfo::buffer and memoryOffset must be zero.
If buffer was created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::buffer equal to buffer and memoryOffset must be zero
If the pNext chain includes VkBindBufferMemoryDeviceGroupInfo, all instances of memory specified by VkBindBufferMemoryDeviceGroupInfo::pDeviceIndices must have been allocated
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO
pNext must be NULL or a pointer to a valid instance of VkBindBufferMemoryDeviceGroupInfo
buffer must be a valid VkBuffer handle
memory must be a valid VkDeviceMemory handle
Both of buffer, and memory must have been created, allocated, or retrieved from the same VkDevice
See Also
VkBuffer, VkDeviceMemory, VkDeviceSize, VkStructureType, vkBindBufferMemory2, vkBindBufferMemory2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBindBufferMemoryInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBindImageMemoryDeviceGroupInfo(3)
Name
VkBindImageMemoryDeviceGroupInfo - Structure specifying device within a group to bind to

C Specification
typedef struct VkBindImageMemoryDeviceGroupInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceIndexCount;
    const uint32_t*    pDeviceIndices;
    uint32_t           splitInstanceBindRegionCount;
    const VkRect2D*    pSplitInstanceBindRegions;
} VkBindImageMemoryDeviceGroupInfo;
or the equivalent

typedef VkBindImageMemoryDeviceGroupInfo VkBindImageMemoryDeviceGroupInfoKHR;
Members
If the pNext list of VkBindImageMemoryInfo includes a VkBindImageMemoryDeviceGroupInfo structure, then that structure determines how memory is bound to images across multiple devices in a device group.

Description
The VkBindImageMemoryDeviceGroupInfo structure is defined as:

sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
deviceIndexCount is the number of elements in pDeviceIndices.
pDeviceIndices is a pointer to an array of device indices.
splitInstanceBindRegionCount is the number of elements in pSplitInstanceBindRegions.
pSplitInstanceBindRegions is a pointer to an array of rectangles describing which regions of the image are attached to each instance of memory.
If deviceIndexCount is greater than zero, then on device index i image is attached to the instance of the memory on the physical device with device index pDeviceIndices[i].

Let N be the number of physical devices in the logical device. If splitInstanceBindRegionCount is greater than zero, then pSplitInstanceBindRegions is an array of N2 rectangles, where the image region specified by the rectangle at element i*N+j in resource instance i is bound to the memory instance j. The blocks of the memory that are bound to each sparse image block region use an offset in memory, relative to memoryOffset, computed as if the whole image were being bound to a contiguous range of memory. In other words, horizontally adjacent image blocks use consecutive blocks of memory, vertically adjacent image blocks are separated by the number of bytes per block multiplied by the width in blocks of image, and the block at (0,0) corresponds to memory starting at memoryOffset.

If splitInstanceBindRegionCount and deviceIndexCount are zero and the memory comes from a memory heap with the VK_MEMORY_HEAP_MULTI_INSTANCE_BIT bit set, then it is as if pDeviceIndices contains consecutive indices from zero to the number of physical devices in the logical device, minus one. In other words, by default each physical device attaches to its own instance of the memory.

If splitInstanceBindRegionCount and deviceIndexCount are zero and the memory comes from a memory heap without the VK_MEMORY_HEAP_MULTI_INSTANCE_BIT bit set, then it is as if pDeviceIndices contains an array of zeros. In other words, by default each physical device attaches to instance zero.

Valid Usage
At least one of deviceIndexCount and splitInstanceBindRegionCount must be zero.
deviceIndexCount must either be zero or equal to the number of physical devices in the logical device
All elements of pDeviceIndices must be valid device indices.
splitInstanceBindRegionCount must either be zero or equal to the number of physical devices in the logical device squared
Elements of pSplitInstanceBindRegions that correspond to the same instance of an image must not overlap.
The offset.x member of any element of pSplitInstanceBindRegions must be a multiple of the sparse image block width (VkSparseImageFormatProperties::imageGranularity.width) of all non-metadata aspects of the image
The offset.y member of any element of pSplitInstanceBindRegions must be a multiple of the sparse image block height (VkSparseImageFormatProperties::imageGranularity.height) of all non-metadata aspects of the image
The extent.width member of any element of pSplitInstanceBindRegions must either be a multiple of the sparse image block width of all non-metadata aspects of the image, or else extent.width + offset.x must equal the width of the image subresource
The extent.height member of any element of pSplitInstanceBindRegions must either be a multiple of the sparse image block height of all non-metadata aspects of the image, or else extent.height
offset.y must equal the width of the image subresource
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO
If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values
If splitInstanceBindRegionCount is not 0, pSplitInstanceBindRegions must be a valid pointer to an array of splitInstanceBindRegionCount VkRect2D structures
See Also
VkRect2D, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBindImageMemoryDeviceGroupInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBindImageMemoryInfo(3)
Name
VkBindImageMemoryInfo - Structure specifying how to bind an image to memory

C Specification
VkBindImageMemoryInfo contains members corresponding to the parameters of vkBindImageMemory.

The VkBindImageMemoryInfo structure is defined as:

typedef struct VkBindImageMemoryInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
    VkDeviceMemory     memory;
    VkDeviceSize       memoryOffset;
} VkBindImageMemoryInfo;
or the equivalent

typedef VkBindImageMemoryInfo VkBindImageMemoryInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
image is the image to be attached to memory.
memory is a VkDeviceMemory object describing the device memory to attach.
memoryOffset is the start offset of the region of memory which is to be bound to the image. The number of bytes returned in the VkMemoryRequirements::size member in memory, starting from memoryOffset bytes, will be bound to the specified image.
Description
Valid Usage
image must not already be backed by a memory object
image must not have been created with any sparse memory binding flags
memoryOffset must be less than the size of memory
If the pNext chain does not include an instance of the VkBindImagePlaneMemoryInfo structure, memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image
If the pNext chain does not include an instance of the VkBindImagePlaneMemoryInfo structure, memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image
If the pNext chain does not include an instance of the VkBindImagePlaneMemoryInfo structure, the difference of the size of memory and memoryOffset must be greater than or equal to the size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with the same image
If the pNext chain includes an instance of the VkBindImagePlaneMemoryInfo structure, image must have been created with the VK_IMAGE_CREATE_DISJOINT_BIT bit set.
If the pNext chain includes an instance of the VkBindImagePlaneMemoryInfo structure, memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image and the correct planeAspect for this plane in the VkImagePlaneMemoryRequirementsInfo structure attached to the VkImageMemoryRequirementsInfo2’s pNext chain
If the pNext chain includes an instance of the VkBindImagePlaneMemoryInfo structure, memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image and the correct planeAspect for this plane in the VkImagePlaneMemoryRequirementsInfo structure attached to the VkImageMemoryRequirementsInfo2’s pNext chain
If the pNext chain includes an instance of the VkBindImagePlaneMemoryInfo structure, the difference of the size of memory and memoryOffset must be greater than or equal to the size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with the same image and the correct planeAspect for this plane in the VkImagePlaneMemoryRequirementsInfo structure attached to the VkImageMemoryRequirementsInfo2’s pNext chain
If image requires a dedicated allocation (as reported by vkGetImageMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for image), memory must have been created with VkMemoryDedicatedAllocateInfo::image equal to image and memoryOffset must be zero
If the dedicated allocation image aliasing feature is not enabled, and the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then image must equal VkMemoryDedicatedAllocateInfo::image and memoryOffset must be zero.
If the dedicated allocation image aliasing feature is enabled, and the VkMemoryAllocateInfo provided when memory was allocated included an instance of VkMemoryDedicatedAllocateInfo in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then memoryOffset must be zero, and image must be either equal to VkMemoryDedicatedAllocateInfo::image or an image that was created using the same parameters in VkImageCreateInfo, with the exception that extent and arrayLayers may differ subject to the following restrictions: every dimension in the extent parameter of the image being bound must be equal to or smaller than the original image for which the allocation was created; and the arrayLayers parameter of the image being bound must be equal to or smaller than the original image for which the allocation was created.
If image was created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::image equal to image and memoryOffset must be zero
If the pNext chain includes VkBindImageMemoryDeviceGroupInfo, all instances of memory specified by VkBindImageMemoryDeviceGroupInfo::pDeviceIndices must have been allocated
If the pNext chain includes VkBindImageMemoryDeviceGroupInfo, and VkBindImageMemoryDeviceGroupInfo::splitInstanceBindRegionCount is not zero, then image must have been created with the VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT bit set
If the pNext chain includes VkBindImageMemoryDeviceGroupInfo, all elements of VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions must be valid rectangles contained within the dimensions of image
If the pNext chain includes VkBindImageMemoryDeviceGroupInfo, the union of the areas of all elements of VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions that correspond to the same instance of image must cover the entire image.
If image was created with a valid swapchain handle in VkImageSwapchainCreateInfoKHR::swapchain, then the pNext chain must include a valid instance of VkBindImageMemorySwapchainInfoKHR
If the pNext chain includes an instance of VkBindImageMemorySwapchainInfoKHR, memory must be VK_NULL_HANDLE
If the pNext chain does not include an instance of VkBindImageMemorySwapchainInfoKHR, memory must be a valid VkDeviceMemory handle
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkBindImageMemoryDeviceGroupInfo, VkBindImageMemorySwapchainInfoKHR, or VkBindImagePlaneMemoryInfo
Each sType member in the pNext chain must be unique
image must be a valid VkImage handle
Both of image, and memory that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkDeviceMemory, VkDeviceSize, VkImage, VkStructureType, vkBindImageMemory2, vkBindImageMemory2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBindImageMemoryInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBindImageMemorySwapchainInfoKHR(3)
Name
VkBindImageMemorySwapchainInfoKHR - Structure specifying swapchain image memory to bind to

C Specification
If the pNext chain of VkBindImageMemoryInfo includes a VkBindImageMemorySwapchainInfoKHR structure, then that structure includes a swapchain handle and image index indicating that the image will be bound to memory from that swapchain.

The VkBindImageMemorySwapchainInfoKHR structure is defined as:

typedef struct VkBindImageMemorySwapchainInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkSwapchainKHR     swapchain;
    uint32_t           imageIndex;
} VkBindImageMemorySwapchainInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
swapchain is VK_NULL_HANDLE or a swapchain handle.
imageIndex is an image index within swapchain.
Description
If swapchain is not NULL, the swapchain and imageIndex are used to determine the memory that the image is bound to, instead of memory and memoryOffset.

Memory can be bound to a swapchain and use the pDeviceIndices or pSplitInstanceBindRegions members of VkBindImageMemoryDeviceGroupInfo.

Valid Usage
imageIndex must be less than the number of images in swapchain
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR
swapchain must be a valid VkSwapchainKHR handle
Host Synchronization
Host access to swapchain must be externally synchronized
See Also
VkStructureType, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBindImageMemorySwapchainInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBindImagePlaneMemoryInfo(3)
Name
VkBindImagePlaneMemoryInfo - Structure specifying how to bind an image plane to memory

C Specification
In order to bind planes of a disjoint image, include a VkBindImagePlaneMemoryInfo structure in the pNext chain of VkBindImageMemoryInfo.

The VkBindImagePlaneMemoryInfo structure is defined as:

typedef struct VkBindImagePlaneMemoryInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkImageAspectFlagBits    planeAspect;
} VkBindImagePlaneMemoryInfo;
or the equivalent

typedef VkBindImagePlaneMemoryInfo VkBindImagePlaneMemoryInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
planeAspect is the aspect of the disjoint image plane to bind.
Description
Valid Usage
If the image’s tiling is VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_OPTIMAL, then planeAspect must be a single valid format plane for the image. (That is, planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT for “_2PLANE” formats and planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT for “_3PLANE” formats.)
If the image’s tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then planeAspect must be a single valid memory plane for the image. (That is, aspectMask must specify a plane index that is less than the drmFormatModifierPlaneCount associated with the image’s format and drmFormatModifier.)
A single call to vkBindImageMemory2 must bind all or none of the planes of an image (i.e. bindings to all planes of an image must be made in a single vkBindImageMemory2 call), as separate bindings
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO
planeAspect must be a valid VkImageAspectFlagBits value
See Also
VkImageAspectFlagBits, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBindImagePlaneMemoryInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBindSparseInfo(3)
Name
VkBindSparseInfo - Structure specifying a sparse binding operation

C Specification
The VkBindSparseInfo structure is defined as:

typedef struct VkBindSparseInfo {
    VkStructureType                             sType;
    const void*                                 pNext;
    uint32_t                                    waitSemaphoreCount;
    const VkSemaphore*                          pWaitSemaphores;
    uint32_t                                    bufferBindCount;
    const VkSparseBufferMemoryBindInfo*         pBufferBinds;
    uint32_t                                    imageOpaqueBindCount;
    const VkSparseImageOpaqueMemoryBindInfo*    pImageOpaqueBinds;
    uint32_t                                    imageBindCount;
    const VkSparseImageMemoryBindInfo*          pImageBinds;
    uint32_t                                    signalSemaphoreCount;
    const VkSemaphore*                          pSignalSemaphores;
} VkBindSparseInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
waitSemaphoreCount is the number of semaphores upon which to wait before executing the sparse binding operations for the batch.
pWaitSemaphores is a pointer to an array of semaphores upon which to wait on before the sparse binding operations for this batch begin execution. If semaphores to wait on are provided, they define a semaphore wait operation.
bufferBindCount is the number of sparse buffer bindings to perform in the batch.
pBufferBinds is a pointer to an array of VkSparseBufferMemoryBindInfo structures.
imageOpaqueBindCount is the number of opaque sparse image bindings to perform.
pImageOpaqueBinds is a pointer to an array of VkSparseImageOpaqueMemoryBindInfo structures, indicating opaque sparse image bindings to perform.
imageBindCount is the number of sparse image bindings to perform.
pImageBinds is a pointer to an array of VkSparseImageMemoryBindInfo structures, indicating sparse image bindings to perform.
signalSemaphoreCount is the number of semaphores to be signaled once the sparse binding operations specified by the structure have completed execution.
pSignalSemaphores is a pointer to an array of semaphores which will be signaled when the sparse binding operations for this batch have completed execution. If semaphores to be signaled are provided, they define a semaphore signal operation.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BIND_SPARSE_INFO
pNext must be NULL or a pointer to a valid instance of VkDeviceGroupBindSparseInfo
If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles
If bufferBindCount is not 0, pBufferBinds must be a valid pointer to an array of bufferBindCount valid VkSparseBufferMemoryBindInfo structures
If imageOpaqueBindCount is not 0, pImageOpaqueBinds must be a valid pointer to an array of imageOpaqueBindCount valid VkSparseImageOpaqueMemoryBindInfo structures
If imageBindCount is not 0, pImageBinds must be a valid pointer to an array of imageBindCount valid VkSparseImageMemoryBindInfo structures
If signalSemaphoreCount is not 0, pSignalSemaphores must be a valid pointer to an array of signalSemaphoreCount valid VkSemaphore handles
Both of the elements of pSignalSemaphores, and the elements of pWaitSemaphores that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkSemaphore, VkSparseBufferMemoryBindInfo, VkSparseImageMemoryBindInfo, VkSparseImageOpaqueMemoryBindInfo, VkStructureType, vkQueueBindSparse

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBindSparseInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferCopy(3)
Name
VkBufferCopy - Structure specifying a buffer copy operation

C Specification
The VkBufferCopy structure is defined as:

typedef struct VkBufferCopy {
    VkDeviceSize    srcOffset;
    VkDeviceSize    dstOffset;
    VkDeviceSize    size;
} VkBufferCopy;
Members
srcOffset is the starting offset in bytes from the start of srcBuffer.
dstOffset is the starting offset in bytes from the start of dstBuffer.
size is the number of bytes to copy.
Description
Valid Usage
The size must be greater than 0
See Also
VkDeviceSize, vkCmdCopyBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferCopy

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferCreateInfo(3)
Name
VkBufferCreateInfo - Structure specifying the parameters of a newly created buffer object

C Specification
The VkBufferCreateInfo structure is defined as:

typedef struct VkBufferCreateInfo {
    VkStructureType        sType;
    const void*            pNext;
    VkBufferCreateFlags    flags;
    VkDeviceSize           size;
    VkBufferUsageFlags     usage;
    VkSharingMode          sharingMode;
    uint32_t               queueFamilyIndexCount;
    const uint32_t*        pQueueFamilyIndices;
} VkBufferCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkBufferCreateFlagBits specifying additional parameters of the buffer.
size is the size in bytes of the buffer to be created.
usage is a bitmask of VkBufferUsageFlagBits specifying allowed usages of the buffer.
sharingMode is a VkSharingMode value specifying the sharing mode of the buffer when it will be accessed by multiple queue families.
queueFamilyIndexCount is the number of entries in the pQueueFamilyIndices array.
pQueueFamilyIndices is a list of queue families that will access this buffer (ignored if sharingMode is not VK_SHARING_MODE_CONCURRENT).
Description
editing-note
(Jon) Should the constraint on usage != 0 be converted to a Valid Usage statement? See gitlab #854.
Valid Usage
size must be greater than 0
If sharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values
If sharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1
If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by either vkGetPhysicalDeviceQueueFamilyProperties or vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device
If the sparse bindings feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_BINDING_BIT
If the sparse buffer residency feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT
If the sparse aliased residency feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_ALIASED_BIT
If flags contains VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT, it must also contain VK_BUFFER_CREATE_SPARSE_BINDING_BIT
If the pNext chain contains an instance of VkExternalMemoryBufferCreateInfo, its handleTypes member must only contain bits that are also in VkExternalBufferProperties::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceExternalBufferProperties with pExternalBufferInfo->handleType equal to any one of the handle types specified in VkExternalMemoryBufferCreateInfo::handleTypes
If the protected memory feature is not enabled, flags must not contain VK_BUFFER_CREATE_PROTECTED_BIT
If any of the bits VK_BUFFER_CREATE_SPARSE_BINDING_BIT, VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT are set, VK_BUFFER_CREATE_PROTECTED_BIT must not also be set
If the pNext chain contains an instance of VkDedicatedAllocationBufferCreateInfoNV, and the dedicatedAllocation member of the chained structure is VK_TRUE, then flags must not include VK_BUFFER_CREATE_SPARSE_BINDING_BIT, VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT
If VkBufferDeviceAddressCreateInfoEXT::deviceAddress is not zero, flags must include VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT
If flags includes VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT, the bufferDeviceAddressCaptureReplay feature must be enabled
If usage includes VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT, the bufferDeviceAddress feature must be enabled
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkBufferDeviceAddressCreateInfoEXT, VkDedicatedAllocationBufferCreateInfoNV, or VkExternalMemoryBufferCreateInfo
Each sType member in the pNext chain must be unique
flags must be a valid combination of VkBufferCreateFlagBits values
usage must be a valid combination of VkBufferUsageFlagBits values
usage must not be 0
sharingMode must be a valid VkSharingMode value
See Also
VkBufferCreateFlags, VkBufferUsageFlags, VkDeviceSize, VkSharingMode, VkStructureType, vkCreateBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferDeviceAddressCreateInfoEXT(3)
Name
VkBufferDeviceAddressCreateInfoEXT - Request a specific address for a buffer

C Specification
To request a specific device address for a buffer, add a VkBufferDeviceAddressCreateInfoEXT structure to the pNext chain of the VkBufferCreateInfo structure. The VkBufferDeviceAddressCreateInfoEXT structure is defined as:

typedef struct VkBufferDeviceAddressCreateInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceAddress    deviceAddress;
} VkBufferDeviceAddressCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
deviceAddress is the device address requested for the buffer.
Description
If deviceAddress is zero, no specific address is requested.

If deviceAddress is not zero, deviceAddress must be an address retrieved from an identically created buffer on the same implementation. The buffer must also be bound to an identically created VkDeviceMemory object.

If this structure is not present, it is as if deviceAddress is zero.

Apps should avoid creating buffers with app-provided addresses and implementation-provided addresses in the same process, to reduce the likelihood of VK_ERROR_INVALID_DEVICE_ADDRESS_EXT errors.

Note
The expected usage for this is that a trace capture/replay tool will add the VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT flag to all buffers that use VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT, and during capture will save the queried device addresses in the trace. During replay, the buffers will be created specifying the original address so any address values stored in the trace data will remain valid.

Implementations are expected to separate such buffers in the GPU address space so normal allocations will avoid using these addresses. Apps/tools should avoid mixing app-provided and implementation-provided addresses for buffers created with VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT, to avoid address space allocation conflicts.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT
See Also
VkDeviceAddress, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferDeviceAddressCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferDeviceAddressInfoEXT(3)
Name
VkBufferDeviceAddressInfoEXT - Structure specifying the buffer to query an address for

C Specification
The VkBufferDeviceAddressInfoEXT structure is defined as:

typedef struct VkBufferDeviceAddressInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    VkBuffer           buffer;
} VkBufferDeviceAddressInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
buffer specifies the buffer whose address is being queried.
Description
Valid Usage
If buffer is non-sparse and was not created with the VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT flag, then it must be bound completely and contiguously to a single VkDeviceMemory object
buffer must have been created with VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT
pNext must be NULL
buffer must be a valid VkBuffer handle
See Also
VkBuffer, VkStructureType, vkGetBufferDeviceAddressEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferDeviceAddressInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferImageCopy(3)
Name
VkBufferImageCopy - Structure specifying a buffer image copy operation

C Specification
For both vkCmdCopyBufferToImage and vkCmdCopyImageToBuffer, each element of pRegions is a structure defined as:

typedef struct VkBufferImageCopy {
    VkDeviceSize                bufferOffset;
    uint32_t                    bufferRowLength;
    uint32_t                    bufferImageHeight;
    VkImageSubresourceLayers    imageSubresource;
    VkOffset3D                  imageOffset;
    VkExtent3D                  imageExtent;
} VkBufferImageCopy;
Members
bufferOffset is the offset in bytes from the start of the buffer object where the image data is copied from or to.
bufferRowLength and bufferImageHeight specify in texels a subregion of a larger two- or three-dimensional image in buffer memory, and control the addressing calculations. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the imageExtent.
imageSubresource is a VkImageSubresourceLayers used to specify the specific image subresources of the image used for the source or destination image data.
imageOffset selects the initial x, y, z offsets in texels of the sub-region of the source or destination image data.
imageExtent is the size in texels of the image to copy in width, height and depth.
Description
When copying to or from a depth or stencil aspect, the data in buffer memory uses a layout that is a (mostly) tightly packed representation of the depth or stencil data. Specifically:

data copied to or from the stencil aspect of any depth/stencil format is tightly packed with one VK_FORMAT_S8_UINT value per texel.
data copied to or from the depth aspect of a VK_FORMAT_D16_UNORM or VK_FORMAT_D16_UNORM_S8_UINT format is tightly packed with one VK_FORMAT_D16_UNORM value per texel.
data copied to or from the depth aspect of a VK_FORMAT_D32_SFLOAT or VK_FORMAT_D32_SFLOAT_S8_UINT format is tightly packed with one VK_FORMAT_D32_SFLOAT value per texel.
data copied to or from the depth aspect of a VK_FORMAT_X8_D24_UNORM_PACK32 or VK_FORMAT_D24_UNORM_S8_UINT format is packed with one 32-bit word per texel with the D24 value in the LSBs of the word, and undefined values in the eight MSBs.
Note
To copy both the depth and stencil aspects of a depth/stencil format, two entries in pRegions can be used, where one specifies the depth aspect in imageSubresource, and the other specifies the stencil aspect.
Because depth or stencil aspect buffer to image copies may require format conversions on some implementations, they are not supported on queues that do not support graphics.

Copies are done layer by layer starting with image layer baseArrayLayer member of imageSubresource. layerCount layers are copied from the source image or to the destination image.

Valid Usage
If the calling command’s VkImage parameter’s format is not a depth/stencil format or a multi-planar format, then bufferOffset must be a multiple of the format’s texel block size.
If the calling command’s VkImage parameter’s format is a multi-planar format, then bufferOffset must be a multiple of the element size of the compatible format for the format and the aspectMask of the imageSubresource as defined in html/vkspec.html#formats-compatible-planes
bufferOffset must be a multiple of 4
bufferRowLength must be 0, or greater than or equal to the width member of imageExtent
bufferImageHeight must be 0, or greater than or equal to the height member of imageExtent
imageOffset.x and (imageExtent.width + imageOffset.x) must both be greater than or equal to 0 and less than or equal to the image subresource width where this refers to the width of the plane of the image involved in the copy in the case of a multi-planar format
imageOffset.y and (imageExtent.height + imageOffset.y) must both be greater than or equal to 0 and less than or equal to the image subresource height where this refers to the height of the plane of the image involved in the copy in the case of a multi-planar format
If the calling command’s srcImage (vkCmdCopyImageToBuffer) or dstImage (vkCmdCopyBufferToImage) is of type VK_IMAGE_TYPE_1D, then imageOffset.y must be 0 and imageExtent.height must be 1.
imageOffset.z and (imageExtent.depth + imageOffset.z) must both be greater than or equal to 0 and less than or equal to the image subresource depth
If the calling command’s srcImage (vkCmdCopyImageToBuffer) or dstImage (vkCmdCopyBufferToImage) is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then imageOffset.z must be 0 and imageExtent.depth must be 1
If the calling command’s VkImage parameter is a compressed image, or a single-plane, “_422” image format, bufferRowLength must be a multiple of the compressed texel block width
If the calling command’s VkImage parameter is a compressed image, or a single-plane, “_422” image format, bufferImageHeight must be a multiple of the compressed texel block height
If the calling command’s VkImage parameter is a compressed image, or a single-plane, “_422” image format, all members of imageOffset must be a multiple of the corresponding dimensions of the compressed texel block
If the calling command’s VkImage parameter is a compressed image, or a single-plane, “_422” image format, bufferOffset must be a multiple of the compressed texel block size in bytes
If the calling command’s VkImage parameter is a compressed image, or a single-plane, “_422” image format, imageExtent.width must be a multiple of the compressed texel block width or (imageExtent.width + imageOffset.x) must equal the image subresource width
If the calling command’s VkImage parameter is a compressed image, or a single-plane, “_422” image format, imageExtent.height must be a multiple of the compressed texel block height or (imageExtent.height + imageOffset.y) must equal the image subresource height
If the calling command’s VkImage parameter is a compressed image, or a single-plane, “_422” image format, imageExtent.depth must be a multiple of the compressed texel block depth or (imageExtent.depth + imageOffset.z) must equal the image subresource depth
The aspectMask member of imageSubresource must specify aspects present in the calling command’s VkImage parameter
If the calling command’s VkImage parameter’s format is a multi-planar format, then the aspectMask member of imageSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT (with VK_IMAGE_ASPECT_PLANE_2_BIT valid only for image formats with three planes)
The aspectMask member of imageSubresource must only have a single bit set
If the calling command’s VkImage parameter is of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of imageSubresource must be 0 and 1, respectively
Valid Usage (Implicit)
imageSubresource must be a valid VkImageSubresourceLayers structure
See Also
VkDeviceSize, VkExtent3D, VkImageSubresourceLayers, VkOffset3D, vkCmdCopyBufferToImage, vkCmdCopyImageToBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferImageCopy

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferMemoryBarrier(3)
Name
VkBufferMemoryBarrier - Structure specifying a buffer memory barrier

C Specification
The VkBufferMemoryBarrier structure is defined as:

typedef struct VkBufferMemoryBarrier {
    VkStructureType    sType;
    const void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
    uint32_t           srcQueueFamilyIndex;
    uint32_t           dstQueueFamilyIndex;
    VkBuffer           buffer;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkBufferMemoryBarrier;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
srcAccessMask is a bitmask of VkAccessFlagBits specifying a source access mask.
dstAccessMask is a bitmask of VkAccessFlagBits specifying a destination access mask.
srcQueueFamilyIndex is the source queue family for a queue family ownership transfer.
dstQueueFamilyIndex is the destination queue family for a queue family ownership transfer.
buffer is a handle to the buffer whose backing memory is affected by the barrier.
offset is an offset in bytes into the backing memory for buffer; this is relative to the base offset as bound to the buffer (see vkBindBufferMemory).
size is a size in bytes of the affected area of backing memory for buffer, or VK_WHOLE_SIZE to use the range from offset to the end of the buffer.
Description
The first access scope is limited to access to memory through the specified buffer range, via access types in the source access mask specified by srcAccessMask. If srcAccessMask includes VK_ACCESS_HOST_WRITE_BIT, memory writes performed by that access type are also made visible, as that access type is not performed through a resource.

The second access scope is limited to access to memory through the specified buffer range, via access types in the destination access mask. specified by dstAccessMask. If dstAccessMask includes VK_ACCESS_HOST_WRITE_BIT or VK_ACCESS_HOST_READ_BIT, available memory writes are also made visible to accesses of those types, as those access types are not performed through a resource.

If srcQueueFamilyIndex is not equal to dstQueueFamilyIndex, and srcQueueFamilyIndex is equal to the current queue family, then the memory barrier defines a queue family release operation for the specified buffer range, and the second access scope includes no access, as if dstAccessMask was 0.

If dstQueueFamilyIndex is not equal to srcQueueFamilyIndex, and dstQueueFamilyIndex is equal to the current queue family, then the memory barrier defines a queue family acquire operation for the specified buffer range, and the first access scope includes no access, as if srcAccessMask was 0.

Valid Usage
offset must be less than the size of buffer
If size is not equal to VK_WHOLE_SIZE, size must be greater than 0
If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to than the size of buffer minus offset
If buffer was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, at least one of srcQueueFamilyIndex and dstQueueFamilyIndex must be VK_QUEUE_FAMILY_IGNORED
If buffer was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, and one of srcQueueFamilyIndex and dstQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, the other must be VK_QUEUE_FAMILY_IGNORED or a special queue family reserved for external memory ownership transfers, as described in html/vkspec.html#synchronization-queue-transfers.
If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, dstQueueFamilyIndex must also be VK_QUEUE_FAMILY_IGNORED
If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is not VK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or a special queue family reserved for external memory transfers, as described in html/vkspec.html#synchronization-queue-transfers.
If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and dstQueueFamilyIndex is not VK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or a special queue family reserved for external memory transfers, as described in html/vkspec.html#synchronization-queue-transfers.
If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not VK_QUEUE_FAMILY_IGNORED, at least one of them must be the same as the family of the queue that will execute this barrier
If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER
pNext must be NULL
srcAccessMask must be a valid combination of VkAccessFlagBits values
dstAccessMask must be a valid combination of VkAccessFlagBits values
buffer must be a valid VkBuffer handle
See Also
VkAccessFlags, VkBuffer, VkDeviceSize, VkStructureType, vkCmdPipelineBarrier, vkCmdWaitEvents

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferMemoryBarrier

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferMemoryRequirementsInfo2(3)
Name
VkBufferMemoryRequirementsInfo2 - (None)

C Specification
The VkBufferMemoryRequirementsInfo2 structure is defined as:

typedef struct VkBufferMemoryRequirementsInfo2 {
    VkStructureType    sType;
    const void*        pNext;
    VkBuffer           buffer;
} VkBufferMemoryRequirementsInfo2;
or the equivalent

typedef VkBufferMemoryRequirementsInfo2 VkBufferMemoryRequirementsInfo2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
buffer is the buffer to query.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2
pNext must be NULL
buffer must be a valid VkBuffer handle
See Also
VkBuffer, VkStructureType, vkGetBufferMemoryRequirements2, vkGetBufferMemoryRequirements2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferMemoryRequirementsInfo2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferViewCreateInfo(3)
Name
VkBufferViewCreateInfo - Structure specifying parameters of a newly created buffer view

C Specification
The VkBufferViewCreateInfo structure is defined as:

typedef struct VkBufferViewCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    VkBufferViewCreateFlags    flags;
    VkBuffer                   buffer;
    VkFormat                   format;
    VkDeviceSize               offset;
    VkDeviceSize               range;
} VkBufferViewCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
buffer is a VkBuffer on which the view will be created.
format is a VkFormat describing the format of the data elements in the buffer.
offset is an offset in bytes from the base address of the buffer. Accesses to the buffer view from shaders use addressing that is relative to this starting offset.
range is a size in bytes of the buffer view. If range is equal to VK_WHOLE_SIZE, the range from offset to the end of the buffer is used. If VK_WHOLE_SIZE is used and the remaining size of the buffer is not a multiple of the texel block size of format, the nearest smaller multiple is used.
Description
Valid Usage
offset must be less than the size of buffer
offset must be a multiple of VkPhysicalDeviceLimits::minTexelBufferOffsetAlignment
If range is not equal to VK_WHOLE_SIZE, range must be greater than 0
If range is not equal to VK_WHOLE_SIZE, range must be an integer multiple of the texel block size of format
If range is not equal to VK_WHOLE_SIZE, range divided by the texel block size of format, multiplied by the number of texels per texel block for that format (as defined in the Compatible Formats table), must be less than or equal to VkPhysicalDeviceLimits::maxTexelBufferElements
If range is not equal to VK_WHOLE_SIZE, the sum of offset and range must be less than or equal to the size of buffer
buffer must have been created with a usage value containing at least one of VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT
If buffer was created with usage containing VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT, format must be supported for uniform texel buffers, as specified by the VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT flag in VkFormatProperties::bufferFeatures returned by vkGetPhysicalDeviceFormatProperties
If buffer was created with usage containing VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, format must be supported for storage texel buffers, as specified by the VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT flag in VkFormatProperties::bufferFeatures returned by vkGetPhysicalDeviceFormatProperties
If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO
pNext must be NULL
flags must be 0
buffer must be a valid VkBuffer handle
format must be a valid VkFormat value
See Also
VkBuffer, VkBufferViewCreateFlags, VkDeviceSize, VkFormat, VkStructureType, vkCreateBufferView

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferViewCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCalibratedTimestampInfoEXT(3)
Name
VkCalibratedTimestampInfoEXT - Structure specifying the input parameters of a calibrated timestamp query

C Specification
The VkCalibratedTimestampInfoEXT structure is defined as:

typedef struct VkCalibratedTimestampInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    VkTimeDomainEXT    timeDomain;
} VkCalibratedTimestampInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
timeDomain is a VkTimeDomainEXT value specifying the time domain from which the calibrated timestamp value should be returned.
Description
Valid Usage
timeDomain must be one of the VkTimeDomainEXT values returned by vkGetPhysicalDeviceCalibrateableTimeDomainsEXT
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT
pNext must be NULL
timeDomain must be a valid VkTimeDomainEXT value
See Also
VkStructureType, VkTimeDomainEXT, vkGetCalibratedTimestampsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCalibratedTimestampInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCheckpointDataNV(3)
Name
VkCheckpointDataNV - return structure for command buffer checkpoint data

C Specification
The VkCheckpointDataNV structure is defined as:

typedef struct VkCheckpointDataNV {
    VkStructureType            sType;
    void*                      pNext;
    VkPipelineStageFlagBits    stage;
    void*                      pCheckpointMarker;
} VkCheckpointDataNV;
Members
sType is the type of this structure
pNext is NULL or a pointer to an extension-specific structure.
stage indicates which pipeline stage the checkpoint marker data refers to.
pCheckpointMarker contains the value of the last checkpoint marker executed in the stage that stage refers to.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV
pNext must be NULL
Note that the stages at which a checkpoint marker can be executed are implementation-defined and can be queried by calling vkGetPhysicalDeviceQueueFamilyProperties2.

See Also
VkPipelineStageFlagBits, VkStructureType, vkGetQueueCheckpointDataNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCheckpointDataNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkClearAttachment(3)
Name
VkClearAttachment - Structure specifying a clear attachment

C Specification
The VkClearAttachment structure is defined as:

typedef struct VkClearAttachment {
    VkImageAspectFlags    aspectMask;
    uint32_t              colorAttachment;
    VkClearValue          clearValue;
} VkClearAttachment;
Members
aspectMask is a mask selecting the color, depth and/or stencil aspects of the attachment to be cleared.
colorAttachment is only meaningful if VK_IMAGE_ASPECT_COLOR_BIT is set in aspectMask, in which case it is an index to the pColorAttachments array in the VkSubpassDescription structure of the current subpass which selects the color attachment to clear.
clearValue is the color or depth/stencil value to clear the attachment to, as described in Clear Values below.
Description
No memory barriers are needed between vkCmdClearAttachments and preceding or subsequent draw or attachment clear commands in the same subpass.

The vkCmdClearAttachments command is not affected by the bound pipeline state.

Attachments can also be cleared at the beginning of a render pass instance by setting loadOp (or stencilLoadOp) of VkAttachmentDescription to VK_ATTACHMENT_LOAD_OP_CLEAR, as described for vkCreateRenderPass.

Valid Usage
If aspectMask includes VK_IMAGE_ASPECT_COLOR_BIT, it must not include VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT
aspectMask must not include VK_IMAGE_ASPECT_METADATA_BIT
aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i.
clearValue must be a valid VkClearValue union
Valid Usage (Implicit)
aspectMask must be a valid combination of VkImageAspectFlagBits values
aspectMask must not be 0
See Also
VkClearValue, VkImageAspectFlags, vkCmdClearAttachments

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkClearAttachment

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkClearColorValue(3)
Name
VkClearColorValue - Structure specifying a clear color value

C Specification
The VkClearColorValue structure is defined as:

typedef union VkClearColorValue {
    float       float32[4];
    int32_t     int32[4];
    uint32_t    uint32[4];
} VkClearColorValue;
Members
float32 are the color clear values when the format of the image or attachment is one of the formats in the Interpretation of Numeric Format table other than signed integer (SINT) or unsigned integer (UINT). Floating point values are automatically converted to the format of the image, with the clear value being treated as linear if the image is sRGB.
int32 are the color clear values when the format of the image or attachment is signed integer (SINT). Signed integer values are converted to the format of the image by casting to the smaller type (with negative 32-bit values mapping to negative values in the smaller type). If the integer clear value is not representable in the target type (e.g. would overflow in conversion to that type), the clear value is undefined.
uint32 are the color clear values when the format of the image or attachment is unsigned integer (UINT). Unsigned integer values are converted to the format of the image by casting to the integer type with fewer bits.
Description
The four array elements of the clear color map to R, G, B, and A components of image formats, in order.

If the image has more than one sample, the same value is written to all samples for any pixels being cleared.

See Also
VkClearValue, vkCmdClearColorImage

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkClearColorValue

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkClearDepthStencilValue(3)
Name
VkClearDepthStencilValue - Structure specifying a clear depth stencil value

C Specification
The VkClearDepthStencilValue structure is defined as:

typedef struct VkClearDepthStencilValue {
    float       depth;
    uint32_t    stencil;
} VkClearDepthStencilValue;
Members
depth is the clear value for the depth aspect of the depth/stencil attachment. It is a floating-point value which is automatically converted to the attachment’s format.
stencil is the clear value for the stencil aspect of the depth/stencil attachment. It is a 32-bit integer value which is converted to the attachment’s format by taking the appropriate number of LSBs.
Description
Valid Usage
Unless the html/vkspec.html#VK_EXT_depth_range_unrestricted extension is enabled depth must be between 0.0 and 1.0, inclusive
See Also
VkClearValue, vkCmdClearDepthStencilImage

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkClearDepthStencilValue

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkClearRect(3)
Name
VkClearRect - Structure specifying a clear rectangle

C Specification
The VkClearRect structure is defined as:

typedef struct VkClearRect {
    VkRect2D    rect;
    uint32_t    baseArrayLayer;
    uint32_t    layerCount;
} VkClearRect;
Members
rect is the two-dimensional region to be cleared.
baseArrayLayer is the first layer to be cleared.
layerCount is the number of layers to clear.
Description
The layers [baseArrayLayer, baseArrayLayer + layerCount) counting from the base layer of the attachment image view are cleared.

See Also
VkRect2D, vkCmdClearAttachments

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkClearRect

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkClearValue(3)
Name
VkClearValue - Structure specifying a clear value

C Specification
The VkClearValue union is defined as:

typedef union VkClearValue {
    VkClearColorValue           color;
    VkClearDepthStencilValue    depthStencil;
} VkClearValue;
Members
color specifies the color image clear values to use when clearing a color image or attachment.
depthStencil specifies the depth and stencil clear values to use when clearing a depth/stencil image or attachment.
Description
This union is used where part of the API requires either color or depth/stencil clear values, depending on the attachment, and defines the initial clear values in the VkRenderPassBeginInfo structure.

See Also
VkClearAttachment, VkClearColorValue, VkClearDepthStencilValue, VkRenderPassBeginInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkClearValue

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCmdProcessCommandsInfoNVX(3)
Name
VkCmdProcessCommandsInfoNVX - Structure specifying parameters for the generation of commands

C Specification
typedef struct VkCmdProcessCommandsInfoNVX {
    VkStructureType                      sType;
    const void*                          pNext;
    VkObjectTableNVX                     objectTable;
    VkIndirectCommandsLayoutNVX          indirectCommandsLayout;
    uint32_t                             indirectCommandsTokenCount;
    const VkIndirectCommandsTokenNVX*    pIndirectCommandsTokens;
    uint32_t                             maxSequencesCount;
    VkCommandBuffer                      targetCommandBuffer;
    VkBuffer                             sequencesCountBuffer;
    VkDeviceSize                         sequencesCountOffset;
    VkBuffer                             sequencesIndexBuffer;
    VkDeviceSize                         sequencesIndexOffset;
} VkCmdProcessCommandsInfoNVX;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
objectTable is the VkObjectTableNVX to be used for the generation process. Only registered objects at the time vkCmdReserveSpaceForCommandsNVX is called, will be taken into account for the reservation.
indirectCommandsLayout is the VkIndirectCommandsLayoutNVX that provides the command sequence to generate.
indirectCommandsTokenCount defines the number of input tokens used.
pIndirectCommandsTokens provides an array of VkIndirectCommandsTokenNVX that reference the input data for each token command.
maxSequencesCount is the maximum number of sequences for which command buffer space will be reserved. If sequencesCountBuffer is VK_NULL_HANDLE, this is also the actual number of sequences generated.
targetCommandBuffer can be the secondary VkCommandBuffer in which the commands should be recorded. If targetCommandBuffer is NULL an implicit reservation as well as execution takes place on the processing VkCommandBuffer.
sequencesCountBuffer can be VkBuffer from which the actual amount of sequences is sourced from as uint32_t value.
sequencesCountOffset is the byte offset into sequencesCountBuffer where the count value is stored.
sequencesIndexBuffer must be set if indirectCommandsLayout’s VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX is set and provides the used sequence indices as uint32_t array. Otherwise it must be VK_NULL_HANDLE.
sequencesIndexOffset is the byte offset into sequencesIndexBuffer where the index values start.
Description
Valid Usage
The provided objectTable must include all objects referenced by the generation process
indirectCommandsTokenCount must match the indirectCommandsLayout’s tokenCount
The tokenType member of each entry in the pIndirectCommandsTokens array must match the values used at creation time of indirectCommandsLayout
If targetCommandBuffer is provided, it must have reserved command space
If targetCommandBuffer is provided, the objectTable must match the reservation’s objectTable and must have had all referenced objects registered at reservation time
If targetCommandBuffer is provided, the indirectCommandsLayout must match the reservation’s indirectCommandsLayout
If targetCommandBuffer is provided, the maxSequencesCount must not exceed the reservation’s maxSequencesCount
If sequencesCountBuffer is used, its usage flag must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
If sequencesCountBuffer is used, sequencesCountOffset must be aligned to VkDeviceGeneratedCommandsLimitsNVX::minSequenceCountBufferOffsetAlignment
If sequencesIndexBuffer is used, its usage flag must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set
If sequencesIndexBuffer is used, sequencesIndexOffset must be aligned to VkDeviceGeneratedCommandsLimitsNVX::minSequenceIndexBufferOffsetAlignment
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX
pNext must be NULL
objectTable must be a valid VkObjectTableNVX handle
indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNVX handle
pIndirectCommandsTokens must be a valid pointer to an array of indirectCommandsTokenCount valid VkIndirectCommandsTokenNVX structures
If targetCommandBuffer is not NULL, targetCommandBuffer must be a valid VkCommandBuffer handle
If sequencesCountBuffer is not VK_NULL_HANDLE, sequencesCountBuffer must be a valid VkBuffer handle
If sequencesIndexBuffer is not VK_NULL_HANDLE, sequencesIndexBuffer must be a valid VkBuffer handle
indirectCommandsTokenCount must be greater than 0
Each of indirectCommandsLayout, objectTable, sequencesCountBuffer, sequencesIndexBuffer, and targetCommandBuffer that are valid handles must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to objectTable must be externally synchronized
Host access to targetCommandBuffer must be externally synchronized
See Also
VkBuffer, VkCommandBuffer, VkDeviceSize, VkIndirectCommandsLayoutNVX, VkIndirectCommandsTokenNVX, VkObjectTableNVX, VkStructureType, vkCmdProcessCommandsNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCmdProcessCommandsInfoNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCmdReserveSpaceForCommandsInfoNVX(3)
Name
VkCmdReserveSpaceForCommandsInfoNVX - Structure specifying parameters for the reservation of command buffer space

C Specification
typedef struct VkCmdReserveSpaceForCommandsInfoNVX {
    VkStructureType                sType;
    const void*                    pNext;
    VkObjectTableNVX               objectTable;
    VkIndirectCommandsLayoutNVX    indirectCommandsLayout;
    uint32_t                       maxSequencesCount;
} VkCmdReserveSpaceForCommandsInfoNVX;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
objectTable is the VkObjectTableNVX to be used for the generation process. Only registered objects at the time vkCmdReserveSpaceForCommandsNVX is called, will be taken into account for the reservation.
indirectCommandsLayout is the VkIndirectCommandsLayoutNVX that must also be used at generation time.
maxSequencesCount is the maximum number of sequences for which command buffer space will be reserved.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX
pNext must be NULL
objectTable must be a valid VkObjectTableNVX handle
indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNVX handle
Both of indirectCommandsLayout, and objectTable must have been created, allocated, or retrieved from the same VkDevice
Host Synchronization
Host access to objectTable must be externally synchronized
See Also
VkIndirectCommandsLayoutNVX, VkObjectTableNVX, VkStructureType, vkCmdReserveSpaceForCommandsNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCmdReserveSpaceForCommandsInfoNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCoarseSampleLocationNV(3)
Name
VkCoarseSampleLocationNV - Structure specifying parameters controlling shading rate image usage

C Specification
The VkCoarseSampleLocationNV structure identifies a specific pixel and sample number for one of the coverage samples in a fragment that is larger than one pixel. This structure is defined as:

typedef struct VkCoarseSampleLocationNV {
    uint32_t    pixelX;
    uint32_t    pixelY;
    uint32_t    sample;
} VkCoarseSampleLocationNV;
Members
pixelX is added to the x coordinate of the upper-leftmost pixel of each fragment to identify the pixel containing the coverage sample.
pixelY is added to the y coordinate of the upper-leftmost pixel of each fragment to identify the pixel containing the coverage sample.
sample is the number of the coverage sample in the pixel identified by pixelX and pixelY.
Description
Valid Usage
pixelX must be less than the width (in pixels) of the fragment.
pixelY must be less than the height (in pixels) of the fragment.
sample must be less than the number of coverage samples in each pixel belonging to the fragment.
See Also
VkCoarseSampleOrderCustomNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCoarseSampleLocationNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCoarseSampleOrderCustomNV(3)
Name
VkCoarseSampleOrderCustomNV - Structure specifying parameters controlling shading rate image usage

C Specification
The VkCoarseSampleOrderCustomNV structure is used with a coverage sample ordering type of VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV to specify the order of coverage samples for one combination of fragment width, fragment height, and coverage sample count. The structure is defined as:

typedef struct VkCoarseSampleOrderCustomNV {
    VkShadingRatePaletteEntryNV        shadingRate;
    uint32_t                           sampleCount;
    uint32_t                           sampleLocationCount;
    const VkCoarseSampleLocationNV*    pSampleLocations;
} VkCoarseSampleOrderCustomNV;
Members
shadingRate is a shading rate palette entry that identifies the fragment width and height for the combination of fragment area and per-pixel coverage sample count to control.
sampleCount identifies the per-pixel coverage sample count for the combination of fragment area and coverage sample count to control.
sampleLocationCount specifies the number of sample locations in the custom ordering.
pSampleLocations is a pointer to an array of VkCoarseSampleOrderCustomNV structures that specifies the location of each sample in the custom ordering.
Description
When using a custom sample ordering, element i in pSampleLocations specifies a specific pixel and per-pixel coverage sample number that corresponds to the coverage sample numbered i in the multi-pixel fragment.

Valid Usage
shadingRate must be a shading rate that generates fragments with more than one pixel.
sampleCount must correspond to a sample count enumerated in VkSampleCountFlags whose corresponding bit is set in VkPhysicalDeviceLimits::framebufferNoAttachmentsSampleCounts.
sampleLocationCount must be equal to the product of sampleCount, the fragment width for shadingRate, and the fragment height for shadingRate.
sampleLocationCount must be less than or equal to the value of VkPhysicalDeviceShadingRateImagePropertiesNV::shadingRateMaxCoarseSamples.
The array pSampleLocations must contain exactly one entry for every combination of valid values for pixelX, pixelY, and sample in the structure VkCoarseSampleOrderCustomNV.
Valid Usage (Implicit)
shadingRate must be a valid VkShadingRatePaletteEntryNV value
pSampleLocations must be a valid pointer to an array of sampleLocationCount VkCoarseSampleLocationNV structures
sampleLocationCount must be greater than 0
See Also
VkCoarseSampleLocationNV, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, VkShadingRatePaletteEntryNV, vkCmdSetCoarseSampleOrderNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCoarseSampleOrderCustomNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandBufferAllocateInfo(3)
Name
VkCommandBufferAllocateInfo - Structure specifying the allocation parameters for command buffer object

C Specification
The VkCommandBufferAllocateInfo structure is defined as:

typedef struct VkCommandBufferAllocateInfo {
    VkStructureType         sType;
    const void*             pNext;
    VkCommandPool           commandPool;
    VkCommandBufferLevel    level;
    uint32_t                commandBufferCount;
} VkCommandBufferAllocateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
commandPool is the command pool from which the command buffers are allocated.
level is a VkCommandBufferLevel value specifying the command buffer level.
commandBufferCount is the number of command buffers to allocate from the pool.
Description
Valid Usage
commandBufferCount must be greater than 0
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
pNext must be NULL
commandPool must be a valid VkCommandPool handle
level must be a valid VkCommandBufferLevel value
See Also
VkCommandBufferLevel, VkCommandPool, VkStructureType, vkAllocateCommandBuffers

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandBufferAllocateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandBufferBeginInfo(3)
Name
VkCommandBufferBeginInfo - Structure specifying a command buffer begin operation

C Specification
The VkCommandBufferBeginInfo structure is defined as:

typedef struct VkCommandBufferBeginInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkCommandBufferUsageFlags                flags;
    const VkCommandBufferInheritanceInfo*    pInheritanceInfo;
} VkCommandBufferBeginInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkCommandBufferUsageFlagBits specifying usage behavior for the command buffer.
pInheritanceInfo is a pointer to a VkCommandBufferInheritanceInfo structure, which is used if commandBuffer is a secondary command buffer. If this is a primary command buffer, then this value is ignored.
Description
Valid Usage
If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the renderPass member of pInheritanceInfo must be a valid VkRenderPass
If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the subpass member of pInheritanceInfo must be a valid subpass index within the renderPass member of pInheritanceInfo
If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the framebuffer member of pInheritanceInfo must be either VK_NULL_HANDLE, or a valid VkFramebuffer that is compatible with the renderPass member of pInheritanceInfo
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
pNext must be NULL or a pointer to a valid instance of VkDeviceGroupCommandBufferBeginInfo
flags must be a valid combination of VkCommandBufferUsageFlagBits values
See Also
VkCommandBufferInheritanceInfo, VkCommandBufferUsageFlags, VkStructureType, vkBeginCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandBufferBeginInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandBufferInheritanceConditionalRenderingInfoEXT(3)
Name
VkCommandBufferInheritanceConditionalRenderingInfoEXT - Structure specifying command buffer inheritance info

C Specification
If the pNext chain of VkCommandBufferInheritanceInfo includes a VkCommandBufferInheritanceConditionalRenderingInfoEXT structure, then that structure controls whether a command buffer can be executed while conditional rendering is active in the primary command buffer.

The VkCommandBufferInheritanceConditionalRenderingInfoEXT structure is defined as:

typedef struct VkCommandBufferInheritanceConditionalRenderingInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           conditionalRenderingEnable;
} VkCommandBufferInheritanceConditionalRenderingInfoEXT;
Members
sType is the type of this structure
pNext is NULL or a pointer to an extension-specific structure
conditionalRenderingEnable specifies whether the command buffer can be executed while conditional rendering is active in the primary command buffer. If this is VK_TRUE, then this command buffer can be executed whether the primary command buffer has active conditional rendering or not. If this is VK_FALSE, then the primary command buffer must not have conditional rendering active.
Description
If this structure is not present, the behavior is as if conditionalRenderingEnable is VK_FALSE.

Valid Usage
If the inherited conditional rendering feature is not enabled, conditionalRenderingEnable must be VK_FALSE
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandBufferInheritanceConditionalRenderingInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandBufferInheritanceInfo(3)
Name
VkCommandBufferInheritanceInfo - Structure specifying command buffer inheritance info

C Specification
If the command buffer is a secondary command buffer, then the VkCommandBufferInheritanceInfo structure defines any state that will be inherited from the primary command buffer:

typedef struct VkCommandBufferInheritanceInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkRenderPass                     renderPass;
    uint32_t                         subpass;
    VkFramebuffer                    framebuffer;
    VkBool32                         occlusionQueryEnable;
    VkQueryControlFlags              queryFlags;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkCommandBufferInheritanceInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
renderPass is a VkRenderPass object defining which render passes the VkCommandBuffer will be compatible with and can be executed within. If the VkCommandBuffer will not be executed within a render pass instance, renderPass is ignored.
subpass is the index of the subpass within the render pass instance that the VkCommandBuffer will be executed within. If the VkCommandBuffer will not be executed within a render pass instance, subpass is ignored.
framebuffer optionally refers to the VkFramebuffer object that the VkCommandBuffer will be rendering to if it is executed within a render pass instance. It can be VK_NULL_HANDLE if the framebuffer is not known, or if the VkCommandBuffer will not be executed within a render pass instance.
Note
Specifying the exact framebuffer that the secondary command buffer will be executed with may result in better performance at command buffer execution time.
occlusionQueryEnable specifies whether the command buffer can be executed while an occlusion query is active in the primary command buffer. If this is VK_TRUE, then this command buffer can be executed whether the primary command buffer has an occlusion query active or not. If this is VK_FALSE, then the primary command buffer must not have an occlusion query active.
queryFlags specifies the query flags that can be used by an active occlusion query in the primary command buffer when this secondary command buffer is executed. If this value includes the VK_QUERY_CONTROL_PRECISE_BIT bit, then the active query can return boolean results or actual sample counts. If this bit is not set, then the active query must not use the VK_QUERY_CONTROL_PRECISE_BIT bit.
pipelineStatistics is a bitmask of VkQueryPipelineStatisticFlagBits specifying the set of pipeline statistics that can be counted by an active query in the primary command buffer when this secondary command buffer is executed. If this value includes a given bit, then this command buffer can be executed whether the primary command buffer has a pipeline statistics query active that includes this bit or not. If this value excludes a given bit, then the active pipeline statistics query must not be from a query pool that counts that statistic.
Description
Valid Usage
If the inherited queries feature is not enabled, occlusionQueryEnable must be VK_FALSE
If the inherited queries feature is enabled, queryFlags must be a valid combination of VkQueryControlFlagBits values
If the pipeline statistics queries feature is not enabled, pipelineStatistics must be 0
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO
pNext must be NULL or a pointer to a valid instance of VkCommandBufferInheritanceConditionalRenderingInfoEXT
Both of framebuffer, and renderPass that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkBool32, VkCommandBufferBeginInfo, VkFramebuffer, VkQueryControlFlags, VkQueryPipelineStatisticFlags, VkRenderPass, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandBufferInheritanceInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandPoolCreateInfo(3)
Name
VkCommandPoolCreateInfo - Structure specifying parameters of a newly created command pool

C Specification
The VkCommandPoolCreateInfo structure is defined as:

typedef struct VkCommandPoolCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkCommandPoolCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
} VkCommandPoolCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkCommandPoolCreateFlagBits indicating usage behavior for the pool and command buffers allocated from it.
queueFamilyIndex designates a queue family as described in section Queue Family Properties. All command buffers allocated from this command pool must be submitted on queues from the same queue family.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
pNext must be NULL
flags must be a valid combination of VkCommandPoolCreateFlagBits values
See Also
VkCommandPoolCreateFlags, VkStructureType, vkCreateCommandPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandPoolCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkComponentMapping(3)
Name
VkComponentMapping - Structure specifying a color component mapping

C Specification
The VkComponentMapping structure is defined as:

typedef struct VkComponentMapping {
    VkComponentSwizzle    r;
    VkComponentSwizzle    g;
    VkComponentSwizzle    b;
    VkComponentSwizzle    a;
} VkComponentMapping;
Members
r is a VkComponentSwizzle specifying the component value placed in the R component of the output vector.
g is a VkComponentSwizzle specifying the component value placed in the G component of the output vector.
b is a VkComponentSwizzle specifying the component value placed in the B component of the output vector.
a is a VkComponentSwizzle specifying the component value placed in the A component of the output vector.
Description
Valid Usage (Implicit)
r must be a valid VkComponentSwizzle value
g must be a valid VkComponentSwizzle value
b must be a valid VkComponentSwizzle value
a must be a valid VkComponentSwizzle value
See Also
VkAndroidHardwareBufferFormatPropertiesANDROID, VkComponentSwizzle, VkImageViewCreateInfo, VkSamplerYcbcrConversionCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkComponentMapping

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkComputePipelineCreateInfo(3)
Name
VkComputePipelineCreateInfo - Structure specifying parameters of a newly created compute pipeline

C Specification
The VkComputePipelineCreateInfo structure is defined as:

typedef struct VkComputePipelineCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkPipelineCreateFlags              flags;
    VkPipelineShaderStageCreateInfo    stage;
    VkPipelineLayout                   layout;
    VkPipeline                         basePipelineHandle;
    int32_t                            basePipelineIndex;
} VkComputePipelineCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkPipelineCreateFlagBits specifying how the pipeline will be generated.
stage is a VkPipelineShaderStageCreateInfo describing the compute shader.
layout is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
basePipelineHandle is a pipeline to derive from
basePipelineIndex is an index into the pCreateInfos parameter to use as a pipeline to derive from
Description
The parameters basePipelineHandle and basePipelineIndex are described in more detail in Pipeline Derivatives.

stage points to a structure of type VkPipelineShaderStageCreateInfo.

Valid Usage
If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is -1, basePipelineHandle must be a valid handle to a compute VkPipeline
If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command’s pCreateInfos parameter
If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE
If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is not VK_NULL_HANDLE, basePipelineIndex must be -1
The stage member of stage must be VK_SHADER_STAGE_COMPUTE_BIT
The shader code for the entry point identified by stage and the rest of the state identified by this structure must adhere to the pipeline linking rules described in the Shader Interfaces chapter
layout must be consistent with the layout of the compute shader specified in stage
The number of resources in layout accessible to the compute shader stage must be less than or equal to VkPhysicalDeviceLimits::maxPerStageResources
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO
pNext must be NULL or a pointer to a valid instance of VkPipelineCreationFeedbackCreateInfoEXT
flags must be a valid combination of VkPipelineCreateFlagBits values
stage must be a valid VkPipelineShaderStageCreateInfo structure
layout must be a valid VkPipelineLayout handle
Both of basePipelineHandle, and layout that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkPipeline, VkPipelineCreateFlags, VkPipelineLayout, VkPipelineShaderStageCreateInfo, VkStructureType, vkCreateComputePipelines

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkComputePipelineCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkConditionalRenderingBeginInfoEXT(3)
Name
VkConditionalRenderingBeginInfoEXT - Structure specifying conditional rendering begin info

C Specification
The VkConditionalRenderingBeginInfoEXT structure is defined as:

typedef struct VkConditionalRenderingBeginInfoEXT {
    VkStructureType                   sType;
    const void*                       pNext;
    VkBuffer                          buffer;
    VkDeviceSize                      offset;
    VkConditionalRenderingFlagsEXT    flags;
} VkConditionalRenderingBeginInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
buffer is a buffer containing the predicate for conditional rendering.
offset is the byte offset into buffer where the predicate is located.
flags is a bitmask of VkConditionalRenderingFlagsEXT specifying the behavior of conditional rendering.
Description
If the 32-bit value at offset in buffer memory is zero, then the rendering commands are discarded, otherwise they are executed as normal. If the value of the predicate in buffer memory changes while conditional rendering is active, the rendering commands may be discarded in an implementation-dependent way. Some implementations may latch the value of the predicate upon beginning conditional rendering while others may read it before every rendering command.

Valid Usage
If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
buffer must have been created with the VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT bit set
offset must be less than the size of buffer by at least 32 bits.
offset must be a multiple of 4
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT
pNext must be NULL
buffer must be a valid VkBuffer handle
flags must be a valid combination of VkConditionalRenderingFlagBitsEXT values
See Also
VkBuffer, VkConditionalRenderingFlagsEXT, VkDeviceSize, VkStructureType, vkCmdBeginConditionalRenderingEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkConditionalRenderingBeginInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkConformanceVersionKHR(3)
Name
VkConformanceVersionKHR - Structure containing the conformance test suite version the implementation is compliant with

C Specification
The conformance test suite version an implementation is compliant with is described with an instance of the VkConformanceVersionKHR structure. The VkConformanceVersionKHR structure is defined as:

typedef struct VkConformanceVersionKHR {
    uint8_t    major;
    uint8_t    minor;
    uint8_t    subminor;
    uint8_t    patch;
} VkConformanceVersionKHR;
Members
major is the major version number of the conformance test suite.
minor is the minor version number of the conformance test suite.
subminor is the subminor version number of the conformance test suite.
patch is the patch version number of the conformance test suite.
Description
See Also
VkPhysicalDeviceDriverPropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkConformanceVersionKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCooperativeMatrixPropertiesNV(3)
Name
VkCooperativeMatrixPropertiesNV - Structure specifying cooperative matrix properties

C Specification
Each VkCooperativeMatrixPropertiesNV structure describes a single supported combination of types for a matrix multiply/add operation (OpCooperativeMatrixMulAddNV). The multiply can be described in terms of the following variables and types (in SPIR-V pseudocode):

    %A is of type OpTypeCooperativeMatrixNV %AType %scope %MSize %KSize
    %B is of type OpTypeCooperativeMatrixNV %BType %scope %KSize %NSize
    %C is of type OpTypeCooperativeMatrixNV %CType %scope %MSize %NSize
    %D is of type OpTypeCooperativeMatrixNV %DType %scope %MSize %NSize

    %D = %A * %B + %C // using OpCooperativeMatrixMulAddNV
A matrix multiply with these dimensions is known as an MxNxK matrix multiply.

The VkCooperativeMatrixPropertiesNV structure is defined as:

typedef struct VkCooperativeMatrixPropertiesNV {
    VkStructureType      sType;
    void*                pNext;
    uint32_t             MSize;
    uint32_t             NSize;
    uint32_t             KSize;
    VkComponentTypeNV    AType;
    VkComponentTypeNV    BType;
    VkComponentTypeNV    CType;
    VkComponentTypeNV    DType;
    VkScopeNV            scope;
} VkCooperativeMatrixPropertiesNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
MSize is the number of rows in matrices A, C, and D.
KSize is the number of columns in matrix A and rows in matrix B.
NSize is the number of columns in matrices B, C, D.
AType is the component type of matrix A, of type VkComponentTypeNV.
BType is the component type of matrix B, of type VkComponentTypeNV.
CType is the component type of matrix C, of type VkComponentTypeNV.
DType is the component type of matrix D, of type VkComponentTypeNV.
scope is the scope of all the matrix types, of type VkScopeNV.
Description
If some types are preferred over other types (e.g. for performance), they should appear earlier in the list enumerated by vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.

At least one entry in the list must have power of two values for all of MSize, KSize, and NSize.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV
pNext must be NULL
AType must be a valid VkComponentTypeNV value
BType must be a valid VkComponentTypeNV value
CType must be a valid VkComponentTypeNV value
DType must be a valid VkComponentTypeNV value
scope must be a valid VkScopeNV value
See Also
VkComponentTypeNV, VkScopeNV, VkStructureType, vkGetPhysicalDeviceCooperativeMatrixPropertiesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCooperativeMatrixPropertiesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCopyDescriptorSet(3)
Name
VkCopyDescriptorSet - Structure specifying a copy descriptor set operation

C Specification
The VkCopyDescriptorSet structure is defined as:

typedef struct VkCopyDescriptorSet {
    VkStructureType    sType;
    const void*        pNext;
    VkDescriptorSet    srcSet;
    uint32_t           srcBinding;
    uint32_t           srcArrayElement;
    VkDescriptorSet    dstSet;
    uint32_t           dstBinding;
    uint32_t           dstArrayElement;
    uint32_t           descriptorCount;
} VkCopyDescriptorSet;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
srcSet, srcBinding, and srcArrayElement are the source set, binding, and array element, respectively. If the descriptor binding identified by srcSet and srcBinding has a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then srcArrayElement specifies the starting byte offset within the binding to copy from.
dstSet, dstBinding, and dstArrayElement are the destination set, binding, and array element, respectively. If the descriptor binding identified by dstSet and dstBinding has a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then dstArrayElement specifies the starting byte offset within the binding to copy to.
descriptorCount is the number of descriptors to copy from the source to destination. If descriptorCount is greater than the number of remaining array elements in the source or destination binding, those affect consecutive bindings in a manner similar to VkWriteDescriptorSet above. If the descriptor binding identified by srcSet and srcBinding has a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then descriptorCount specifies the number of bytes to copy and the remaining array elements in the source or destination binding refer to the remaining number of bytes in those.
Description
Valid Usage
srcBinding must be a valid binding within srcSet
The sum of srcArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by srcBinding, and all applicable consecutive bindings, as described by html/vkspec.html#descriptorsets-updates-consecutive
dstBinding must be a valid binding within dstSet
The sum of dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by dstBinding, and all applicable consecutive bindings, as described by html/vkspec.html#descriptorsets-updates-consecutive
The type of dstBinding within dstSet must be equal to the type of srcBinding within srcSet
If srcSet is equal to dstSet, then the source and destination ranges of descriptors must not overlap, where the ranges may include array elements from consecutive bindings as described by html/vkspec.html#descriptorsets-updates-consecutive
If the descriptor type of the descriptor set binding specified by srcBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, srcArrayElement must be an integer multiple of 4
If the descriptor type of the descriptor set binding specified by dstBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, dstArrayElement must be an integer multiple of 4
If the descriptor type of the descriptor set binding specified by either srcBinding or dstBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, descriptorCount must be an integer multiple of 4
If srcSet’s layout was created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT flag set, then dstSet’s layout must also have been created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT flag set
If srcSet’s layout was created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT flag set, then dstSet’s layout must also have been created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT flag set
If the descriptor pool from which srcSet was allocated was created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set, then the descriptor pool from which dstSet was allocated must also have been created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set
If the descriptor pool from which srcSet was allocated was created without the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set, then the descriptor pool from which dstSet was allocated must also have been created without the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET
pNext must be NULL
srcSet must be a valid VkDescriptorSet handle
dstSet must be a valid VkDescriptorSet handle
Both of dstSet, and srcSet must have been created, allocated, or retrieved from the same VkDevice
See Also
VkDescriptorSet, VkStructureType, vkUpdateDescriptorSets

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCopyDescriptorSet

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkD3D12FenceSubmitInfoKHR(3)
Name
VkD3D12FenceSubmitInfoKHR - Structure specifying values for Direct3D 12 fence-backed semaphores

C Specification
To specify the values to use when waiting for and signaling semaphores whose current payload refers to a Direct3D 12 fence, add the VkD3D12FenceSubmitInfoKHR structure to the pNext chain of the VkSubmitInfo structure. The VkD3D12FenceSubmitInfoKHR structure is defined as:

typedef struct VkD3D12FenceSubmitInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           waitSemaphoreValuesCount;
    const uint64_t*    pWaitSemaphoreValues;
    uint32_t           signalSemaphoreValuesCount;
    const uint64_t*    pSignalSemaphoreValues;
} VkD3D12FenceSubmitInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
waitSemaphoreValuesCount is the number of semaphore wait values specified in pWaitSemaphoreValues.
pWaitSemaphoreValues is an array of length waitSemaphoreValuesCount containing values for the corresponding semaphores in VkSubmitInfo::pWaitSemaphores to wait for.
signalSemaphoreValuesCount is the number of semaphore signal values specified in pSignalSemaphoreValues.
pSignalSemaphoreValues is an array of length signalSemaphoreValuesCount containing values for the corresponding semaphores in VkSubmitInfo::pSignalSemaphores to set when signaled.
Description
If the semaphore in VkSubmitInfo::pWaitSemaphores or VkSubmitInfo::pSignalSemaphores corresponding to an entry in pWaitSemaphoreValues or pSignalSemaphoreValues respectively does not currently have a payload referring to a Direct3D 12 fence, the implementation must ignore the value in the pWaitSemaphoreValues or pSignalSemaphoreValues entry.

Valid Usage
waitSemaphoreValuesCount must be the same value as VkSubmitInfo::waitSemaphoreCount, where VkSubmitInfo is in the pNext chain of this VkD3D12FenceSubmitInfoKHR structure.
signalSemaphoreValuesCount must be the same value as VkSubmitInfo::signalSemaphoreCount, where VkSubmitInfo is in the pNext chain of this VkD3D12FenceSubmitInfoKHR structure.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR
If waitSemaphoreValuesCount is not 0, and pWaitSemaphoreValues is not NULL, pWaitSemaphoreValues must be a valid pointer to an array of waitSemaphoreValuesCount uint64_t values
If signalSemaphoreValuesCount is not 0, and pSignalSemaphoreValues is not NULL, pSignalSemaphoreValues must be a valid pointer to an array of signalSemaphoreValuesCount uint64_t values
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkD3D12FenceSubmitInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugMarkerMarkerInfoEXT(3)
Name
VkDebugMarkerMarkerInfoEXT - Specify parameters of a command buffer marker region

C Specification
The VkDebugMarkerMarkerInfoEXT structure is defined as:

typedef struct VkDebugMarkerMarkerInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    const char*        pMarkerName;
    float              color[4];
} VkDebugMarkerMarkerInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
pMarkerName is a pointer to a null-terminated UTF-8 string that contains the name of the marker.
color is an optional RGBA color value that can be associated with the marker. A particular implementation may choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in color are set to 0.0 then it is ignored.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT
pNext must be NULL
pMarkerName must be a null-terminated UTF-8 string
See Also
VkStructureType, vkCmdDebugMarkerBeginEXT, vkCmdDebugMarkerInsertEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugMarkerMarkerInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugMarkerObjectNameInfoEXT(3)
Name
VkDebugMarkerObjectNameInfoEXT - Specify parameters of a name to give to an object

C Specification
The VkDebugMarkerObjectNameInfoEXT structure is defined as:

typedef struct VkDebugMarkerObjectNameInfoEXT {
    VkStructureType               sType;
    const void*                   pNext;
    VkDebugReportObjectTypeEXT    objectType;
    uint64_t                      object;
    const char*                   pObjectName;
} VkDebugMarkerObjectNameInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
objectType is a VkDebugReportObjectTypeEXT specifying the type of the object to be named.
object is the object to be named.
pObjectName is a null-terminated UTF-8 string specifying the name to apply to object.
Description
Applications may change the name associated with an object simply by calling vkDebugMarkerSetObjectNameEXT again with a new string. To remove a previously set name, pObjectName should be set to an empty string.

Valid Usage
objectType must not be VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT
object must not be VK_NULL_HANDLE
object must be a Vulkan object of the type associated with objectType as defined in html/vkspec.html#debug-report-object-types.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT
pNext must be NULL
objectType must be a valid VkDebugReportObjectTypeEXT value
pObjectName must be a null-terminated UTF-8 string
See Also
VkDebugReportObjectTypeEXT, VkStructureType, vkDebugMarkerSetObjectNameEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugMarkerObjectNameInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugMarkerObjectTagInfoEXT(3)
Name
VkDebugMarkerObjectTagInfoEXT - Specify parameters of a tag to attach to an object

C Specification
The VkDebugMarkerObjectTagInfoEXT structure is defined as:

typedef struct VkDebugMarkerObjectTagInfoEXT {
    VkStructureType               sType;
    const void*                   pNext;
    VkDebugReportObjectTypeEXT    objectType;
    uint64_t                      object;
    uint64_t                      tagName;
    size_t                        tagSize;
    const void*                   pTag;
} VkDebugMarkerObjectTagInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
objectType is a VkDebugReportObjectTypeEXT specifying the type of the object to be named.
object is the object to be tagged.
tagName is a numerical identifier of the tag.
tagSize is the number of bytes of data to attach to the object.
pTag is an array of tagSize bytes containing the data to be associated with the object.
Description
The tagName parameter gives a name or identifier to the type of data being tagged. This can be used by debugging layers to easily filter for only data that can be used by that implementation.

Valid Usage
objectType must not be VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT
object must not be VK_NULL_HANDLE
object must be a Vulkan object of the type associated with objectType as defined in html/vkspec.html#debug-report-object-types.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT
pNext must be NULL
objectType must be a valid VkDebugReportObjectTypeEXT value
pTag must be a valid pointer to an array of tagSize bytes
tagSize must be greater than 0
See Also
VkDebugReportObjectTypeEXT, VkStructureType, vkDebugMarkerSetObjectTagEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugMarkerObjectTagInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugReportCallbackCreateInfoEXT(3)
Name
VkDebugReportCallbackCreateInfoEXT - Structure specifying parameters of a newly created debug report callback

C Specification
The definition of VkDebugReportCallbackCreateInfoEXT is:

typedef struct VkDebugReportCallbackCreateInfoEXT {
    VkStructureType                 sType;
    const void*                     pNext;
    VkDebugReportFlagsEXT           flags;
    PFN_vkDebugReportCallbackEXT    pfnCallback;
    void*                           pUserData;
} VkDebugReportCallbackCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkDebugReportFlagBitsEXT specifying which event(s) will cause this callback to be called.
pfnCallback is the application callback function to call.
pUserData is user data to be passed to the callback.
Description
For each VkDebugReportCallbackEXT that is created the VkDebugReportCallbackCreateInfoEXT::flags determine when that VkDebugReportCallbackCreateInfoEXT::pfnCallback is called. When an event happens, the implementation will do a bitwise AND of the event’s VkDebugReportFlagBitsEXT flags to each VkDebugReportCallbackEXT object’s flags. For each non-zero result the corresponding callback will be called. The callback will come directly from the component that detected the event, unless some other layer intercepts the calls for its own purposes (filter them in a different way, log to a system error log, etc.).

An application may receive multiple callbacks if multiple VkDebugReportCallbackEXT objects were created. A callback will always be executed in the same thread as the originating Vulkan call.

A callback may be called from multiple threads simultaneously (if the application is making Vulkan calls from multiple threads).

Valid Usage
pfnCallback must be a valid PFN_vkDebugReportCallbackEXT
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT
flags must be a valid combination of VkDebugReportFlagBitsEXT values
See Also
PFN_vkDebugReportCallbackEXT, VkDebugReportFlagsEXT, VkStructureType, vkCreateDebugReportCallbackEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugReportCallbackCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugUtilsLabelEXT(3)
Name
VkDebugUtilsLabelEXT - Specify parameters of a label region

C Specification
The VkDebugUtilsLabelEXT structure is defined as:

typedef struct VkDebugUtilsLabelEXT {
    VkStructureType    sType;
    const void*        pNext;
    const char*        pLabelName;
    float              color[4];
} VkDebugUtilsLabelEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
pLabelName is a pointer to a null-terminated UTF-8 string that contains the name of the label.
color is an optional RGBA color value that can be associated with the label. A particular implementation may choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in color are set to 0.0 then it is ignored.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT
pNext must be NULL
pLabelName must be a null-terminated UTF-8 string
See Also
VkDebugUtilsMessengerCallbackDataEXT, VkStructureType, vkCmdBeginDebugUtilsLabelEXT, vkCmdInsertDebugUtilsLabelEXT, vkQueueBeginDebugUtilsLabelEXT, vkQueueInsertDebugUtilsLabelEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugUtilsLabelEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugUtilsMessengerCallbackDataEXT(3)
Name
VkDebugUtilsMessengerCallbackDataEXT - Structure specifying parameters returned to the callback

C Specification
The definition of VkDebugUtilsMessengerCallbackDataEXT is:

typedef struct VkDebugUtilsMessengerCallbackDataEXT {
    VkStructureType                              sType;
    const void*                                  pNext;
    VkDebugUtilsMessengerCallbackDataFlagsEXT    flags;
    const char*                                  pMessageIdName;
    int32_t                                      messageIdNumber;
    const char*                                  pMessage;
    uint32_t                                     queueLabelCount;
    const VkDebugUtilsLabelEXT*                  pQueueLabels;
    uint32_t                                     cmdBufLabelCount;
    const VkDebugUtilsLabelEXT*                  pCmdBufLabels;
    uint32_t                                     objectCount;
    const VkDebugUtilsObjectNameInfoEXT*         pObjects;
} VkDebugUtilsMessengerCallbackDataEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is 0 and reserved for future use.
pMessageIdName is a null-terminated string that identifies the particular message ID that is associated with the provided message. If the message corresponds to a validation layer message, then this string may contain the portion of the Vulkan specification that is believed to have been violated.
messageIdNumber is the ID number of the triggering message. If the message corresponds to a validation layer message, then this number is related to the internal number associated with the message being triggered.
pMessage is a null-terminated string detailing the trigger conditions.
queueLabelCount is a count of items contained in the pQueueLabels array.
pQueueLabels is NULL or a pointer to an array of VkDebugUtilsLabelEXT active in the current VkQueue at the time the callback was triggered. Refer to Queue Labels for more information.
cmdBufLabelCount is a count of items contained in the pCmdBufLabels array.
pCmdBufLabels is NULL or a pointer to an array of VkDebugUtilsLabelEXT active in the current VkCommandBuffer at the time the callback was triggered. Refer to Command Buffer Labels for more information.
objectCount is a count of items contained in the pObjects array.
pObjects is a pointer to an array of VkDebugUtilsObjectNameInfoEXT objects related to the detected issue. The array is roughly in order or importance, but the 0th element is always guaranteed to be the most important object for this message.
Description
Note
This structure should only be considered valid during the lifetime of the triggered callback.
Since adding queue and command buffer labels behaves like pushing and popping onto a stack, the order of both pQueueLabels and pCmdBufLabels is based on the order the labels were defined. The result is that the first label in either pQueueLabels or pCmdBufLabels will be the first defined (and therefore the oldest) while the last label in each list will be the most recent.

Note
pQueueLabels will only be non-NULL if one of the objects in pObjects can be related directly to a defined VkQueue which has had one or more labels associated with it.

Likewise, pCmdBufLabels will only be non-NULL if one of the objects in pObjects can be related directly to a defined VkCommandBuffer which has had one or more labels associated with it. Additionally, while command buffer labels allow for beginning and ending across different command buffers, the debug messaging framework cannot guarantee that labels in pCmdBufLables will contain those defined outside of the associated command buffer. This is partially due to the fact that the association of one command buffer with another may not have been defined at the time the debug message is triggered.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT
pNext must be NULL
flags must be 0
If pMessageIdName is not NULL, pMessageIdName must be a null-terminated UTF-8 string
pMessage must be a null-terminated UTF-8 string
If queueLabelCount is not 0, pQueueLabels must be a valid pointer to an array of queueLabelCount valid VkDebugUtilsLabelEXT structures
If cmdBufLabelCount is not 0, pCmdBufLabels must be a valid pointer to an array of cmdBufLabelCount valid VkDebugUtilsLabelEXT structures
If objectCount is not 0, pObjects must be a valid pointer to an array of objectCount valid VkDebugUtilsObjectNameInfoEXT structures
See Also
VkDebugUtilsLabelEXT, VkDebugUtilsMessengerCallbackDataFlagsEXT, VkDebugUtilsObjectNameInfoEXT, VkStructureType, vkSubmitDebugUtilsMessageEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugUtilsMessengerCallbackDataEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugUtilsMessengerCreateInfoEXT(3)
Name
VkDebugUtilsMessengerCreateInfoEXT - Structure specifying parameters of a newly created debug messenger

C Specification
The definition of VkDebugUtilsMessengerCreateInfoEXT is:

typedef struct VkDebugUtilsMessengerCreateInfoEXT {
    VkStructureType                         sType;
    const void*                             pNext;
    VkDebugUtilsMessengerCreateFlagsEXT     flags;
    VkDebugUtilsMessageSeverityFlagsEXT     messageSeverity;
    VkDebugUtilsMessageTypeFlagsEXT         messageType;
    PFN_vkDebugUtilsMessengerCallbackEXT    pfnUserCallback;
    void*                                   pUserData;
} VkDebugUtilsMessengerCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is 0 and reserved for future use.
messageSeverity is a bitmask of VkDebugUtilsMessageSeverityFlagBitsEXT specifying which severity of event(s) will cause this callback to be called.
messageType is a bitmask of VkDebugUtilsMessageTypeFlagBitsEXT specifying which type of event(s) will cause this callback to be called.
pfnUserCallback is the application callback function to call.
pUserData is user data to be passed to the callback.
Description
For each VkDebugUtilsMessengerEXT that is created the VkDebugUtilsMessengerCreateInfoEXT::messageSeverity and VkDebugUtilsMessengerCreateInfoEXT::messageType determine when that VkDebugUtilsMessengerCreateInfoEXT::pfnUserCallback is called. The process to determine if the user’s pfnUserCallback is triggered when an event occurs is as follows:

The implementation will perform a bitwise AND of the event’s VkDebugUtilsMessageSeverityFlagBitsEXT with the messageSeverity provided during creation of the VkDebugUtilsMessengerEXT object.
If the value is 0, the message is skipped.
The implementation will perform bitwise AND of the event’s VkDebugUtilsMessageTypeFlagBitsEXT with the messageType provided during the creation of the VkDebugUtilsMessengerEXT object.
If the value is 0, the message is skipped.
The callback will trigger a debug message for the current event
The callback will come directly from the component that detected the event, unless some other layer intercepts the calls for its own purposes (filter them in a different way, log to a system error log, etc.).

An application can receive multiple callbacks if multiple VkDebugUtilsMessengerEXT objects are created. A callback will always be executed in the same thread as the originating Vulkan call.

A callback can be called from multiple threads simultaneously (if the application is making Vulkan calls from multiple threads).

Valid Usage
pfnUserCallback must be a valid PFN_vkDebugUtilsMessengerCallbackEXT
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT
flags must be 0
messageSeverity must be a valid combination of VkDebugUtilsMessageSeverityFlagBitsEXT values
messageSeverity must not be 0
messageType must be a valid combination of VkDebugUtilsMessageTypeFlagBitsEXT values
messageType must not be 0
See Also
PFN_vkDebugUtilsMessengerCallbackEXT, VkDebugUtilsMessageSeverityFlagsEXT, VkDebugUtilsMessageTypeFlagsEXT, VkDebugUtilsMessengerCreateFlagsEXT, VkStructureType, vkCreateDebugUtilsMessengerEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugUtilsMessengerCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugUtilsObjectNameInfoEXT(3)
Name
VkDebugUtilsObjectNameInfoEXT - Specify parameters of a name to give to an object

C Specification
The VkDebugUtilsObjectNameInfoEXT structure is defined as:

typedef struct VkDebugUtilsObjectNameInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    VkObjectType       objectType;
    uint64_t           objectHandle;
    const char*        pObjectName;
} VkDebugUtilsObjectNameInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
objectType is a VkObjectType specifying the type of the object to be named.
objectHandle is the object to be named.
pObjectName is a null-terminated UTF-8 string specifying the name to apply to objectHandle.
Description
Applications may change the name associated with an object simply by calling vkSetDebugUtilsObjectNameEXT again with a new string. If pObjectName is an empty string, then any previously set name is removed.

Valid Usage
If objectType is VK_OBJECT_TYPE_UNKNOWN, objectHandle must not be VK_NULL_HANDLE
If objectType is not VK_OBJECT_TYPE_UNKNOWN, objectHandle must be VK_NULL_HANDLE or a valid Vulkan handle of the type associated with objectType as defined in the VkObjectType and Vulkan Handle Relationship table
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT
pNext must be NULL
objectType must be a valid VkObjectType value
If pObjectName is not NULL, pObjectName must be a null-terminated UTF-8 string
See Also
VkDebugUtilsMessengerCallbackDataEXT, VkObjectType, VkStructureType, vkSetDebugUtilsObjectNameEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugUtilsObjectNameInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugUtilsObjectTagInfoEXT(3)
Name
VkDebugUtilsObjectTagInfoEXT - Specify parameters of a tag to attach to an object

C Specification
The VkDebugUtilsObjectTagInfoEXT structure is defined as:

typedef struct VkDebugUtilsObjectTagInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    VkObjectType       objectType;
    uint64_t           objectHandle;
    uint64_t           tagName;
    size_t             tagSize;
    const void*        pTag;
} VkDebugUtilsObjectTagInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
objectType is a VkObjectType specifying the type of the object to be named.
objectHandle is the object to be tagged.
tagName is a numerical identifier of the tag.
tagSize is the number of bytes of data to attach to the object.
pTag is an array of tagSize bytes containing the data to be associated with the object.
Description
The tagName parameter gives a name or identifier to the type of data being tagged. This can be used by debugging layers to easily filter for only data that can be used by that implementation.

Valid Usage
objectType must not be VK_OBJECT_TYPE_UNKNOWN
objectHandle must be a valid Vulkan handle of the type associated with objectType as defined in the VkObjectType and Vulkan Handle Relationship table
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT
pNext must be NULL
objectType must be a valid VkObjectType value
pTag must be a valid pointer to an array of tagSize bytes
tagSize must be greater than 0
See Also
VkObjectType, VkStructureType, vkSetDebugUtilsObjectTagEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugUtilsObjectTagInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDedicatedAllocationBufferCreateInfoNV(3)
Name
VkDedicatedAllocationBufferCreateInfoNV - Specify that a buffer is bound to a dedicated memory resource

C Specification
If the pNext chain includes a VkDedicatedAllocationBufferCreateInfoNV structure, then that structure includes an enable controlling whether the buffer will have a dedicated memory allocation bound to it.

The VkDedicatedAllocationBufferCreateInfoNV structure is defined as:

typedef struct VkDedicatedAllocationBufferCreateInfoNV {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           dedicatedAllocation;
} VkDedicatedAllocationBufferCreateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
dedicatedAllocation specifies whether the buffer will have a dedicated allocation bound to it.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDedicatedAllocationBufferCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDedicatedAllocationImageCreateInfoNV(3)
Name
VkDedicatedAllocationImageCreateInfoNV - Specify that an image is bound to a dedicated memory resource

C Specification
If the pNext chain includes a VkDedicatedAllocationImageCreateInfoNV structure, then that structure includes an enable controlling whether the image will have a dedicated memory allocation bound to it.

The VkDedicatedAllocationImageCreateInfoNV structure is defined as:

typedef struct VkDedicatedAllocationImageCreateInfoNV {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           dedicatedAllocation;
} VkDedicatedAllocationImageCreateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
dedicatedAllocation specifies whether the image will have a dedicated allocation bound to it.
Description
Note
Using a dedicated allocation for color and depth/stencil attachments or other large images may improve performance on some devices.
Valid Usage
If dedicatedAllocation is VK_TRUE, VkImageCreateInfo::flags must not include VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDedicatedAllocationImageCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDedicatedAllocationMemoryAllocateInfoNV(3)
Name
VkDedicatedAllocationMemoryAllocateInfoNV - Specify a dedicated memory allocation resource

C Specification
If the pNext chain includes a VkDedicatedAllocationMemoryAllocateInfoNV structure, then that structure includes a handle of the sole buffer or image resource that the memory can be bound to.

The VkDedicatedAllocationMemoryAllocateInfoNV structure is defined as:

typedef struct VkDedicatedAllocationMemoryAllocateInfoNV {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
    VkBuffer           buffer;
} VkDedicatedAllocationMemoryAllocateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
image is VK_NULL_HANDLE or a handle of an image which this memory will be bound to.
buffer is VK_NULL_HANDLE or a handle of a buffer which this memory will be bound to.
Description
Valid Usage
At least one of image and buffer must be VK_NULL_HANDLE
If image is not VK_NULL_HANDLE, the image must have been created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE
If buffer is not VK_NULL_HANDLE, the buffer must have been created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE
If image is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the image
If buffer is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the buffer
If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation, the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory.
If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation, the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV
If image is not VK_NULL_HANDLE, image must be a valid VkImage handle
If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle
Both of buffer, and image that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkBuffer, VkImage, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDedicatedAllocationMemoryAllocateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorBufferInfo(3)
Name
VkDescriptorBufferInfo - Structure specifying descriptor buffer info

C Specification
The VkDescriptorBufferInfo structure is defined as:

typedef struct VkDescriptorBufferInfo {
    VkBuffer        buffer;
    VkDeviceSize    offset;
    VkDeviceSize    range;
} VkDescriptorBufferInfo;
Members
buffer is the buffer resource.
offset is the offset in bytes from the start of buffer. Access to buffer memory via this descriptor uses addressing that is relative to this starting offset.
range is the size in bytes that is used for this descriptor update, or VK_WHOLE_SIZE to use the range from offset to the end of the buffer.
Description
Note
When setting range to VK_WHOLE_SIZE, the effective range must not be larger than the maximum range for the descriptor type (maxUniformBufferRange or maxStorageBufferRange). This means that VK_WHOLE_SIZE is not typically useful in the common case where uniform buffer descriptors are suballocated from a buffer that is much larger than maxUniformBufferRange.
For VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC descriptor types, offset is the base offset from which the dynamic offset is applied and range is the static size used for all dynamic offsets.

Valid Usage
offset must be less than the size of buffer
If range is not equal to VK_WHOLE_SIZE, range must be greater than 0
If range is not equal to VK_WHOLE_SIZE, range must be less than or equal to the size of buffer minus offset
Valid Usage (Implicit)
buffer must be a valid VkBuffer handle
See Also
VkBuffer, VkDeviceSize, VkWriteDescriptorSet

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorBufferInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorImageInfo(3)
Name
VkDescriptorImageInfo - Structure specifying descriptor image info

C Specification
The VkDescriptorImageInfo structure is defined as:

typedef struct VkDescriptorImageInfo {
    VkSampler        sampler;
    VkImageView      imageView;
    VkImageLayout    imageLayout;
} VkDescriptorImageInfo;
Members
sampler is a sampler handle, and is used in descriptor updates for types VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER if the binding being updated does not use immutable samplers.
imageView is an image view handle, and is used in descriptor updates for types VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.
imageLayout is the layout that the image subresources accessible from imageView will be in at the time this descriptor is accessed. imageLayout is used in descriptor updates for types VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.
Description
Members of VkDescriptorImageInfo that are not used in an update (as described above) are ignored.

Valid Usage
imageView must not be 2D or 2D array image view created from a 3D image
If imageView is created from a depth/stencil image, the aspectMask used to create the imageView must include either VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT but not both.
imageLayout must match the actual VkImageLayout of each subresource accessible from imageView at the time this descriptor is accessed as defined by the image layout matching rules
If sampler is used and the VkFormat of the image is a multi-planar format, the image must have been created with VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, and the aspectMask of the imageView must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or (for three-plane formats only) VK_IMAGE_ASPECT_PLANE_2_BIT
Valid Usage (Implicit)
Both of imageView, and sampler that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkImageLayout, VkImageView, VkSampler, VkWriteDescriptorSet

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorImageInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorPoolCreateInfo(3)
Name
VkDescriptorPoolCreateInfo - Structure specifying parameters of a newly created descriptor pool

C Specification
Additional information about the pool is passed in an instance of the VkDescriptorPoolCreateInfo structure:

typedef struct VkDescriptorPoolCreateInfo {
    VkStructureType                sType;
    const void*                    pNext;
    VkDescriptorPoolCreateFlags    flags;
    uint32_t                       maxSets;
    uint32_t                       poolSizeCount;
    const VkDescriptorPoolSize*    pPoolSizes;
} VkDescriptorPoolCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkDescriptorPoolCreateFlagBits specifying certain supported operations on the pool.
maxSets is the maximum number of descriptor sets that can be allocated from the pool.
poolSizeCount is the number of elements in pPoolSizes.
pPoolSizes is a pointer to an array of VkDescriptorPoolSize structures, each containing a descriptor type and number of descriptors of that type to be allocated in the pool.
Description
If multiple VkDescriptorPoolSize structures appear in the pPoolSizes array then the pool will be created with enough storage for the total number of descriptors of each type.

Fragmentation of a descriptor pool is possible and may lead to descriptor set allocation failures. A failure due to fragmentation is defined as failing a descriptor set allocation despite the sum of all outstanding descriptor set allocations from the pool plus the requested allocation requiring no more than the total number of descriptors requested at pool creation. Implementations provide certain guarantees of when fragmentation must not cause allocation failure, as described below.

If a descriptor pool has not had any descriptor sets freed since it was created or most recently reset then fragmentation must not cause an allocation failure (note that this is always the case for a pool created without the VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT bit set). Additionally, if all sets allocated from the pool since it was created or most recently reset use the same number of descriptors (of each type) and the requested allocation also uses that same number of descriptors (of each type), then fragmentation must not cause an allocation failure.

If an allocation failure occurs due to fragmentation, an application can create an additional descriptor pool to perform further descriptor set allocations.

If flags has the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT bit set, descriptor pool creation may fail with the error VK_ERROR_FRAGMENTATION_EXT if the total number of descriptors across all pools (including this one) created with this bit set exceeds maxUpdateAfterBindDescriptorsInAllPools, or if fragmentation of the underlying hardware resources occurs.

Valid Usage
maxSets must be greater than 0
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
pNext must be NULL or a pointer to a valid instance of VkDescriptorPoolInlineUniformBlockCreateInfoEXT
flags must be a valid combination of VkDescriptorPoolCreateFlagBits values
pPoolSizes must be a valid pointer to an array of poolSizeCount valid VkDescriptorPoolSize structures
poolSizeCount must be greater than 0
See Also
VkDescriptorPoolCreateFlags, VkDescriptorPoolSize, VkStructureType, vkCreateDescriptorPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorPoolCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorPoolInlineUniformBlockCreateInfoEXT(3)
Name
VkDescriptorPoolInlineUniformBlockCreateInfoEXT - Structure specifying the maximum number of inline uniform block bindings of a newly created descriptor pool

C Specification
In order to be able to allocate descriptor sets having inline uniform block bindings the descriptor pool must be created with specifying the inline uniform block binding capacity of the descriptor pool, in addition to the total inline uniform data capacity in bytes which is specified through an instance of the VkDescriptorPoolSize structure with a descriptorType value of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT. This can be done by chaining an instance of the VkDescriptorPoolInlineUniformBlockCreateInfoEXT structure to the pNext chain of VkDescriptorPoolCreateInfo.

The VkDescriptorPoolInlineUniformBlockCreateInfoEXT structure is defined as:

typedef struct VkDescriptorPoolInlineUniformBlockCreateInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           maxInlineUniformBlockBindings;
} VkDescriptorPoolInlineUniformBlockCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
maxInlineUniformBlockBindings is the number of inline uniform block bindings to allocate.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorPoolInlineUniformBlockCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorPoolSize(3)
Name
VkDescriptorPoolSize - Structure specifying descriptor pool size

C Specification
The VkDescriptorPoolSize structure is defined as:

typedef struct VkDescriptorPoolSize {
    VkDescriptorType    type;
    uint32_t            descriptorCount;
} VkDescriptorPoolSize;
Members
type is the type of descriptor.
descriptorCount is the number of descriptors of that type to allocate. If type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then descriptorCount is the number of bytes to allocate for descriptors of this type.
Description
Valid Usage
descriptorCount must be greater than 0
If type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then descriptorCount must be a multiple of 4
Valid Usage (Implicit)
type must be a valid VkDescriptorType value
See Also
VkDescriptorPoolCreateInfo, VkDescriptorType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorPoolSize

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorSetAllocateInfo(3)
Name
VkDescriptorSetAllocateInfo - Structure specifying the allocation parameters for descriptor sets

C Specification
The VkDescriptorSetAllocateInfo structure is defined as:

typedef struct VkDescriptorSetAllocateInfo {
    VkStructureType                 sType;
    const void*                     pNext;
    VkDescriptorPool                descriptorPool;
    uint32_t                        descriptorSetCount;
    const VkDescriptorSetLayout*    pSetLayouts;
} VkDescriptorSetAllocateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
descriptorPool is the pool which the sets will be allocated from.
descriptorSetCount determines the number of descriptor sets to be allocated from the pool.
pSetLayouts is an array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated.
Description
Valid Usage
Each element of pSetLayouts must not have been created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set
If any element of pSetLayouts was created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set, descriptorPool must have been created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT flag set
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO
pNext must be NULL or a pointer to a valid instance of VkDescriptorSetVariableDescriptorCountAllocateInfoEXT
descriptorPool must be a valid VkDescriptorPool handle
pSetLayouts must be a valid pointer to an array of descriptorSetCount valid VkDescriptorSetLayout handles
descriptorSetCount must be greater than 0
Both of descriptorPool, and the elements of pSetLayouts must have been created, allocated, or retrieved from the same VkDevice
See Also
VkDescriptorPool, VkDescriptorSetLayout, VkStructureType, vkAllocateDescriptorSets

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorSetAllocateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorSetLayoutBinding(3)
Name
VkDescriptorSetLayoutBinding - Structure specifying a descriptor set layout binding

C Specification
The VkDescriptorSetLayoutBinding structure is defined as:

typedef struct VkDescriptorSetLayoutBinding {
    uint32_t              binding;
    VkDescriptorType      descriptorType;
    uint32_t              descriptorCount;
    VkShaderStageFlags    stageFlags;
    const VkSampler*      pImmutableSamplers;
} VkDescriptorSetLayoutBinding;
Members
binding is the binding number of this entry and corresponds to a resource of the same binding number in the shader stages.
descriptorType is a VkDescriptorType specifying which type of resource descriptors are used for this binding.
descriptorCount is the number of descriptors contained in the binding, accessed in a shader as an array , except if descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT in which case descriptorCount is the size in bytes of the inline uniform block . If descriptorCount is zero this binding entry is reserved and the resource must not be accessed from any stage via this binding within any pipeline using the set layout.
stageFlags member is a bitmask of VkShaderStageFlagBits specifying which pipeline shader stages can access a resource for this binding. VK_SHADER_STAGE_ALL is a shorthand specifying that all defined shader stages, including any additional stages defined by extensions, can access the resource.
If a shader stage is not included in stageFlags, then a resource must not be accessed from that stage via this binding within any pipeline using the set layout. Other than input attachments which are limited to the fragment shader, there are no limitations on what combinations of stages can use a descriptor binding, and in particular a binding can be used by both graphics stages and the compute stage.
Description
pImmutableSamplers affects initialization of samplers. If descriptorType specifies a VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER type descriptor, then pImmutableSamplers can be used to initialize a set of immutable samplers. Immutable samplers are permanently bound into the set layout; later binding a sampler into an immutable sampler slot in a descriptor set is not allowed. If pImmutableSamplers is not NULL, then it is considered to be a pointer to an array of sampler handles that will be consumed by the set layout and used for the corresponding binding. If pImmutableSamplers is NULL, then the sampler slots are dynamic and sampler handles must be bound into descriptor sets using this layout. If descriptorType is not one of these descriptor types, then pImmutableSamplers is ignored.
The above layout definition allows the descriptor bindings to be specified sparsely such that not all binding numbers between 0 and the maximum binding number need to be specified in the pBindings array. Bindings that are not specified have a descriptorCount and stageFlags of zero, and the value of descriptorType is undefined. However, all binding numbers between 0 and the maximum binding number in the VkDescriptorSetLayoutCreateInfo::pBindings array may consume memory in the descriptor set layout even if not all descriptor bindings are used, though it should not consume additional memory from the descriptor pool.

Note
The maximum binding number specified should be as compact as possible to avoid wasted memory.
Valid Usage
If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and descriptorCount is not 0 and pImmutableSamplers is not NULL, pImmutableSamplers must be a valid pointer to an array of descriptorCount valid VkSampler handles
If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then descriptorCount must be a multiple of 4
If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then descriptorCount must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxInlineUniformBlockSize
If descriptorCount is not 0, stageFlags must be a valid combination of VkShaderStageFlagBits values
If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT and descriptorCount is not 0, then stageFlags must be 0 or VK_SHADER_STAGE_FRAGMENT_BIT
Valid Usage (Implicit)
descriptorType must be a valid VkDescriptorType value
See Also
VkDescriptorSetLayoutCreateInfo, VkDescriptorType, VkSampler, VkShaderStageFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorSetLayoutBinding

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(3)
Name
VkDescriptorSetLayoutBindingFlagsCreateInfoEXT - Structure specifying creation flags for descriptor set layout bindings

C Specification
If the pNext chain of a VkDescriptorSetLayoutCreateInfo structure includes a VkDescriptorSetLayoutBindingFlagsCreateInfoEXT structure, then that structure includes an array of flags, one for each descriptor set layout binding.

The VkDescriptorSetLayoutBindingFlagsCreateInfoEXT structure is defined as:

typedef struct VkDescriptorSetLayoutBindingFlagsCreateInfoEXT {
    VkStructureType                       sType;
    const void*                           pNext;
    uint32_t                              bindingCount;
    const VkDescriptorBindingFlagsEXT*    pBindingFlags;
} VkDescriptorSetLayoutBindingFlagsCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
bindingCount is zero or the number of elements in pBindingFlags.
pBindingFlags is a pointer to an array of VkDescriptorBindingFlagsEXT bitfields, one for each descriptor set layout binding.
Description
If bindingCount is zero or if this structure is not in the pNext chain, the VkDescriptorBindingFlagsEXT for each descriptor set layout binding is considered to be zero. Otherwise, the descriptor set layout binding at VkDescriptorSetLayoutCreateInfo::pBindings[i] uses the flags in pBindingFlags[i].

Valid Usage
If bindingCount is not zero, bindingCount must equal VkDescriptorSetLayoutCreateInfo::bindingCount
If VkDescriptorSetLayoutCreateInfo::flags includes VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT, VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT, or VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT
If an element of pBindingFlags includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT, then all other elements of VkDescriptorSetLayoutCreateInfo::pBindings must have a smaller value of binding
If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingUniformBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingSampledImageUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingStorageImageUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingStorageBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingUniformTexelBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingStorageTexelBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
If VkPhysicalDeviceInlineUniformBlockFeaturesEXT::descriptorBindingInlineUniformBlockUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
All bindings with descriptor type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT
If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingUpdateUnusedWhilePending is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT
If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingPartiallyBound is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT
If VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingVariableDescriptorCount is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT
If an element of pBindingFlags includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT, that element’s descriptorType must not be VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT
If bindingCount is not 0, and pBindingFlags is not NULL, pBindingFlags must be a valid pointer to an array of bindingCount valid combinations of VkDescriptorBindingFlagBitsEXT values
See Also
VkDescriptorBindingFlagsEXT, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorSetLayoutBindingFlagsCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorSetLayoutCreateInfo(3)
Name
VkDescriptorSetLayoutCreateInfo - Structure specifying parameters of a newly created descriptor set layout

C Specification
Information about the descriptor set layout is passed in an instance of the VkDescriptorSetLayoutCreateInfo structure:

typedef struct VkDescriptorSetLayoutCreateInfo {
    VkStructureType                        sType;
    const void*                            pNext;
    VkDescriptorSetLayoutCreateFlags       flags;
    uint32_t                               bindingCount;
    const VkDescriptorSetLayoutBinding*    pBindings;
} VkDescriptorSetLayoutCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkDescriptorSetLayoutCreateFlagBits specifying options for descriptor set layout creation.
bindingCount is the number of elements in pBindings.
pBindings is a pointer to an array of VkDescriptorSetLayoutBinding structures.
Description
Valid Usage
The VkDescriptorSetLayoutBinding::binding members of the elements of the pBindings array must each have different values.
If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC
If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT
If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then the total number of elements of all bindings must be less than or equal to VkPhysicalDevicePushDescriptorPropertiesKHR::maxPushDescriptors
If any binding has the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT bit set, flags must include VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT
If any binding has the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT bit set, then all bindings must not have descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO
pNext must be NULL or a pointer to a valid instance of VkDescriptorSetLayoutBindingFlagsCreateInfoEXT
flags must be a valid combination of VkDescriptorSetLayoutCreateFlagBits values
If bindingCount is not 0, pBindings must be a valid pointer to an array of bindingCount valid VkDescriptorSetLayoutBinding structures
See Also
VkDescriptorSetLayoutBinding, VkDescriptorSetLayoutCreateFlags, VkStructureType, vkCreateDescriptorSetLayout, vkGetDescriptorSetLayoutSupport, vkGetDescriptorSetLayoutSupportKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorSetLayoutCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorSetLayoutSupport(3)
Name
VkDescriptorSetLayoutSupport - Structure returning information about whether a descriptor set layout can be supported

C Specification
Information about support for the descriptor set layout is returned in an instance of the VkDescriptorSetLayoutSupport structure:

typedef struct VkDescriptorSetLayoutSupport {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           supported;
} VkDescriptorSetLayoutSupport;
or the equivalent

typedef VkDescriptorSetLayoutSupport VkDescriptorSetLayoutSupportKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
supported specifies whether the descriptor set layout can be created.
Description
supported is set to VK_TRUE if the descriptor set can be created, or else is set to VK_FALSE.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT
pNext must be NULL or a pointer to a valid instance of VkDescriptorSetVariableDescriptorCountLayoutSupportEXT
See Also
VkBool32, VkStructureType, vkGetDescriptorSetLayoutSupport, vkGetDescriptorSetLayoutSupportKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorSetLayoutSupport

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(3)
Name
VkDescriptorSetVariableDescriptorCountAllocateInfoEXT - Structure specifying additional allocation parameters for descriptor sets

C Specification
If the pNext chain of a VkDescriptorSetAllocateInfo structure includes a VkDescriptorSetVariableDescriptorCountAllocateInfoEXT structure, then that structure includes an array of descriptor counts for variable descriptor count bindings, one for each descriptor set being allocated.

The VkDescriptorSetVariableDescriptorCountAllocateInfoEXT structure is defined as:

typedef struct VkDescriptorSetVariableDescriptorCountAllocateInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           descriptorSetCount;
    const uint32_t*    pDescriptorCounts;
} VkDescriptorSetVariableDescriptorCountAllocateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
descriptorSetCount is zero or the number of elements in pDescriptorCounts.
pDescriptorCounts is an array of descriptor counts, with each member specifying the number of descriptors in a variable descriptor count binding in the corresponding descriptor set being allocated.
Description
If descriptorSetCount is zero or this structure is not included in the pNext chain, then the variable lengths are considered to be zero. Otherwise, pDescriptorCounts[i] is the number of descriptors in the variable count descriptor binding in the corresponding descriptor set layout. If the variable count descriptor binding in the corresponding descriptor set layout has a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then pDescriptorCounts[i] specifies the binding’s capacity in bytes. If VkDescriptorSetAllocateInfo::pSetLayouts[i] does not include a variable count descriptor binding, then pDescriptorCounts[i] is ignored.

Valid Usage
If descriptorSetCount is not zero, descriptorSetCount must equal VkDescriptorSetAllocateInfo::descriptorSetCount
If VkDescriptorSetAllocateInfo::pSetLayouts[i] has a variable descriptor count binding, then pDescriptorCounts[i] must be less than or equal to the descriptor count specified for that binding when the descriptor set layout was created.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT
If descriptorSetCount is not 0, pDescriptorCounts must be a valid pointer to an array of descriptorSetCount uint32_t values
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorSetVariableDescriptorCountAllocateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(3)
Name
VkDescriptorSetVariableDescriptorCountLayoutSupportEXT - Structure returning information about whether a descriptor set layout can be supported

C Specification
If the pNext chain of a VkDescriptorSetLayoutSupport structure includes a VkDescriptorSetVariableDescriptorCountLayoutSupportEXT structure, then that structure returns additional information about whether the descriptor set layout is supported.

typedef struct VkDescriptorSetVariableDescriptorCountLayoutSupportEXT {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxVariableDescriptorCount;
} VkDescriptorSetVariableDescriptorCountLayoutSupportEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
maxVariableDescriptorCount indicates the maximum number of descriptors supported in the highest numbered binding of the layout, if that binding is variable-sized. If the highest numbered binding of the layout has a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then maxVariableDescriptorCount indicates the maximum byte size supported for the binding, if that binding is variable-sized.
Description
If the create info includes a variable-sized descriptor, then supported is determined assuming the requested size of the variable-sized descriptor, and maxVariableDescriptorCount is set to the maximum size of that descriptor that can be successfully created (which is greater than or equal to the requested size passed in). If the create info does not include a variable-sized descriptor or if the VkPhysicalDeviceDescriptorIndexingFeaturesEXT::descriptorBindingVariableDescriptorCount feature is not enabled, then maxVariableDescriptorCount is set to zero. For the purposes of this command, a variable-sized descriptor binding with a descriptorCount of zero is treated as if the descriptorCount is one, and thus the binding is not ignored and the maximum descriptor count will be returned. If the layout is not supported, then the value written to maxVariableDescriptorCount is undefined.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorSetVariableDescriptorCountLayoutSupportEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorUpdateTemplateCreateInfo(3)
Name
VkDescriptorUpdateTemplateCreateInfo - Structure specifying parameters of a newly created descriptor update template

C Specification
The VkDescriptorUpdateTemplateCreateInfo structure is defined as:

typedef struct VkDescriptorUpdateTemplateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkDescriptorUpdateTemplateCreateFlags     flags;
    uint32_t                                  descriptorUpdateEntryCount;
    const VkDescriptorUpdateTemplateEntry*    pDescriptorUpdateEntries;
    VkDescriptorUpdateTemplateType            templateType;
    VkDescriptorSetLayout                     descriptorSetLayout;
    VkPipelineBindPoint                       pipelineBindPoint;
    VkPipelineLayout                          pipelineLayout;
    uint32_t                                  set;
} VkDescriptorUpdateTemplateCreateInfo;
or the equivalent

typedef VkDescriptorUpdateTemplateCreateInfo VkDescriptorUpdateTemplateCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
descriptorUpdateEntryCount is the number of elements in the pDescriptorUpdateEntries array.
pDescriptorUpdateEntries is a pointer to an array of VkDescriptorUpdateTemplateEntry structures describing the descriptors to be updated by the descriptor update template.
templateType Specifies the type of the descriptor update template. If set to VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET it can only be used to update descriptor sets with a fixed descriptorSetLayout. If set to VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR it can only be used to push descriptor sets using the provided pipelineBindPoint, pipelineLayout, and set number.
descriptorSetLayout is the descriptor set layout the parameter update template will be used with. All descriptor sets which are going to be updated through the newly created descriptor update template must be created with this layout. descriptorSetLayout is the descriptor set layout used to build the descriptor update template. All descriptor sets which are going to be updated through the newly created descriptor update template must be created with a layout that matches (is the same as, or defined identically to) this layout. This parameter is ignored if templateType is not VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET.
pipelineBindPoint is a VkPipelineBindPoint indicating whether the descriptors will be used by graphics pipelines or compute pipelines. This parameter is ignored if templateType is not VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
pipelineLayout is a VkPipelineLayout object used to program the bindings. This parameter is ignored if templateType is not VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
set is the set number of the descriptor set in the pipeline layout that will be updated. This parameter is ignored if templateType is not VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR
Description
Valid Usage
If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET, descriptorSetLayout must be a valid VkDescriptorSetLayout handle
If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, pipelineBindPoint must be a valid VkPipelineBindPoint value
If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, pipelineLayout must be a valid VkPipelineLayout handle
If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, set must be the unique set number in the pipeline layout that uses a descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO
pNext must be NULL
flags must be 0
pDescriptorUpdateEntries must be a valid pointer to an array of descriptorUpdateEntryCount valid VkDescriptorUpdateTemplateEntry structures
templateType must be a valid VkDescriptorUpdateTemplateType value
If descriptorSetLayout is not VK_NULL_HANDLE, descriptorSetLayout must be a valid VkDescriptorSetLayout handle
descriptorUpdateEntryCount must be greater than 0
Both of descriptorSetLayout, and pipelineLayout that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkDescriptorSetLayout, VkDescriptorUpdateTemplateCreateFlags, VkDescriptorUpdateTemplateEntry, VkDescriptorUpdateTemplateType, VkPipelineBindPoint, VkPipelineLayout, VkStructureType, vkCreateDescriptorUpdateTemplate, vkCreateDescriptorUpdateTemplateKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorUpdateTemplateCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorUpdateTemplateEntry(3)
Name
VkDescriptorUpdateTemplateEntry - Describes a single descriptor update of the descriptor update template

C Specification
The VkDescriptorUpdateTemplateEntry structure is defined as:

typedef struct VkDescriptorUpdateTemplateEntry {
    uint32_t            dstBinding;
    uint32_t            dstArrayElement;
    uint32_t            descriptorCount;
    VkDescriptorType    descriptorType;
    size_t              offset;
    size_t              stride;
} VkDescriptorUpdateTemplateEntry;
or the equivalent

typedef VkDescriptorUpdateTemplateEntry VkDescriptorUpdateTemplateEntryKHR;
Members
dstBinding is the descriptor binding to update when using this descriptor update template.
dstArrayElement is the starting element in the array belonging to dstBinding. If the descriptor binding identified by srcBinding has a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then dstArrayElement specifies the starting byte offset to update.
descriptorCount is the number of descriptors to update. If descriptorCount is greater than the number of remaining array elements in the destination binding, those affect consecutive bindings in a manner similar to VkWriteDescriptorSet above. If the descriptor binding identified by dstBinding has a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then descriptorCount specifies the number of bytes to update and the remaining array elements in the destination binding refer to the remaining number of bytes in it.
descriptorType is a VkDescriptorType specifying the type of the descriptor.
offset is the offset in bytes of the first binding in the raw data structure.
stride is the stride in bytes between two consecutive array elements of the descriptor update informations in the raw data structure. The actual pointer ptr for each array element j of update entry i is computed using the following formula:
    const char *ptr = (const char *)pData + pDescriptorUpdateEntries[i].offset + j * pDescriptorUpdateEntries[i].stride
The stride is useful in case the bindings are stored in structs along with other data. If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then the value of stride is ignored and the stride is assumed to be 1, i.e. the descriptor update information for them is always specified as a contiguous range.
Description
Valid Usage
dstBinding must be a valid binding in the descriptor set layout implicitly specified when using a descriptor update template to update descriptors.
dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding implicitly specified when using a descriptor update template to update descriptors, and all applicable consecutive bindings, as described by html/vkspec.html#descriptorsets-updates-consecutive
If descriptor type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, dstArrayElement must be an integer multiple of 4
If descriptor type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, descriptorCount must be an integer multiple of 4
Valid Usage (Implicit)
descriptorType must be a valid VkDescriptorType value
See Also
VkDescriptorType, VkDescriptorUpdateTemplateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorUpdateTemplateEntry

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceCreateInfo(3)
Name
VkDeviceCreateInfo - Structure specifying parameters of a newly created device

C Specification
The VkDeviceCreateInfo structure is defined as:

typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkDeviceCreateFlags                flags;
    uint32_t                           queueCreateInfoCount;
    const VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    const char* const*                 ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    const char* const*                 ppEnabledExtensionNames;
    const VkPhysicalDeviceFeatures*    pEnabledFeatures;
} VkDeviceCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
queueCreateInfoCount is the unsigned integer size of the pQueueCreateInfos array. Refer to the Queue Creation section below for further details.
pQueueCreateInfos is a pointer to an array of VkDeviceQueueCreateInfo structures describing the queues that are requested to be created along with the logical device. Refer to the Queue Creation section below for further details.
enabledLayerCount is deprecated and ignored.
ppEnabledLayerNames is deprecated and ignored. See html/vkspec.html#extendingvulkan-layers-devicelayerdeprecation.
enabledExtensionCount is the number of device extensions to enable.
ppEnabledExtensionNames is a pointer to an array of enabledExtensionCount null-terminated UTF-8 strings containing the names of extensions to enable for the created device. See the html/vkspec.html#extendingvulkan-extensions section for further details.
pEnabledFeatures is NULL or a pointer to a VkPhysicalDeviceFeatures structure that contains boolean indicators of all the features to be enabled. Refer to the Features section for further details.
Description
Valid Usage
The queueFamilyIndex member of each element of pQueueCreateInfos must be unique within pQueueCreateInfos, except that two members can share the same queueFamilyIndex if one is a protected-capable queue and one is not a protected-capable queue.
If the pNext chain includes a VkPhysicalDeviceFeatures2 structure, then pEnabledFeatures must be NULL
ppEnabledExtensionNames must not contain html/vkspec.html#VK_AMD_negative_viewport_height
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupDeviceCreateInfo, VkDeviceMemoryOverallocationCreateInfoAMD, VkPhysicalDevice16BitStorageFeatures, VkPhysicalDevice8BitStorageFeaturesKHR, VkPhysicalDeviceASTCDecodeFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, VkPhysicalDeviceConditionalRenderingFeaturesEXT, VkPhysicalDeviceCooperativeMatrixFeaturesNV, VkPhysicalDeviceCornerSampledImageFeaturesNV, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, VkPhysicalDeviceDepthClipEnableFeaturesEXT, VkPhysicalDeviceDescriptorIndexingFeaturesEXT, VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPhysicalDeviceFeatures2, VkPhysicalDeviceFloat16Int8FeaturesKHR, VkPhysicalDeviceFragmentDensityMapFeaturesEXT, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, VkPhysicalDeviceHostQueryResetFeaturesEXT, VkPhysicalDeviceInlineUniformBlockFeaturesEXT, VkPhysicalDeviceMemoryPriorityFeaturesEXT, VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, VkPhysicalDeviceSamplerYcbcrConversionFeatures, VkPhysicalDeviceScalarBlockLayoutFeaturesEXT, VkPhysicalDeviceShaderAtomicInt64FeaturesKHR, VkPhysicalDeviceShaderDrawParametersFeatures, VkPhysicalDeviceShaderImageFootprintFeaturesNV, VkPhysicalDeviceShadingRateImageFeaturesNV, VkPhysicalDeviceTransformFeedbackFeaturesEXT, VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, or VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
Each sType member in the pNext chain must be unique
flags must be 0
pQueueCreateInfos must be a valid pointer to an array of queueCreateInfoCount valid VkDeviceQueueCreateInfo structures
If enabledLayerCount is not 0, ppEnabledLayerNames must be a valid pointer to an array of enabledLayerCount null-terminated UTF-8 strings
If enabledExtensionCount is not 0, ppEnabledExtensionNames must be a valid pointer to an array of enabledExtensionCount null-terminated UTF-8 strings
If pEnabledFeatures is not NULL, pEnabledFeatures must be a valid pointer to a valid VkPhysicalDeviceFeatures structure
queueCreateInfoCount must be greater than 0
See Also
VkDeviceCreateFlags, VkDeviceQueueCreateInfo, VkPhysicalDeviceFeatures, VkStructureType, vkCreateDevice

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceEventInfoEXT(3)
Name
VkDeviceEventInfoEXT - Describe a device event to create

C Specification
The VkDeviceEventInfoEXT structure is defined as:

typedef struct VkDeviceEventInfoEXT {
    VkStructureType         sType;
    const void*             pNext;
    VkDeviceEventTypeEXT    deviceEvent;
} VkDeviceEventInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
device is a VkDeviceEventTypeEXT value specifying when the fence will be signaled.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT
pNext must be NULL
deviceEvent must be a valid VkDeviceEventTypeEXT value
See Also
VkDeviceEventTypeEXT, VkStructureType, vkRegisterDeviceEventEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceEventInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceGeneratedCommandsFeaturesNVX(3)
Name
VkDeviceGeneratedCommandsFeaturesNVX - Structure specifying physical device support

C Specification
The VkDeviceGeneratedCommandsFeaturesNVX structure is defined as:

typedef struct VkDeviceGeneratedCommandsFeaturesNVX {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           computeBindingPointSupport;
} VkDeviceGeneratedCommandsFeaturesNVX;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
computeBindingPointSupport specifies whether the VkObjectTableNVX supports entries with VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX bit set and VkIndirectCommandsLayoutNVX supports VK_PIPELINE_BIND_POINT_COMPUTE.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX
pNext must be NULL
See Also
VkBool32, VkStructureType, vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceGeneratedCommandsFeaturesNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceGeneratedCommandsLimitsNVX(3)
Name
VkDeviceGeneratedCommandsLimitsNVX - Structure specifying physical device limits

C Specification
The VkDeviceGeneratedCommandsLimitsNVX structure is defined as:

typedef struct VkDeviceGeneratedCommandsLimitsNVX {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           maxIndirectCommandsLayoutTokenCount;
    uint32_t           maxObjectEntryCounts;
    uint32_t           minSequenceCountBufferOffsetAlignment;
    uint32_t           minSequenceIndexBufferOffsetAlignment;
    uint32_t           minCommandsTokenBufferOffsetAlignment;
} VkDeviceGeneratedCommandsLimitsNVX;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
maxIndirectCommandsLayoutTokenCount the maximum number of tokens in VkIndirectCommandsLayoutNVX.
maxObjectEntryCounts the maximum number of entries per resource type in VkObjectTableNVX.
minSequenceCountBufferOffsetAlignment the minimum alignment for memory addresses optionally used in vkCmdProcessCommandsNVX.
minSequenceIndexBufferOffsetAlignment the minimum alignment for memory addresses optionally used in vkCmdProcessCommandsNVX.
minCommandsTokenBufferOffsetAlignment the minimum alignment for memory addresses optionally used in vkCmdProcessCommandsNVX.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX
pNext must be NULL
See Also
VkStructureType, vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceGeneratedCommandsLimitsNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceGroupBindSparseInfo(3)
Name
VkDeviceGroupBindSparseInfo - Structure indicating which instances are bound

C Specification
If the pNext chain of VkBindSparseInfo includes a VkDeviceGroupBindSparseInfo structure, then that structure includes device indices specifying which instance of the resources and memory are bound.

The VkDeviceGroupBindSparseInfo structure is defined as:

typedef struct VkDeviceGroupBindSparseInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           resourceDeviceIndex;
    uint32_t           memoryDeviceIndex;
} VkDeviceGroupBindSparseInfo;
or the equivalent

typedef VkDeviceGroupBindSparseInfo VkDeviceGroupBindSparseInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
resourceDeviceIndex is a device index indicating which instance of the resource is bound.
memoryDeviceIndex is a device index indicating which instance of the memory the resource instance is bound to.
Description
These device indices apply to all buffer and image memory binds included in the batch that points to this structure. The semaphore waits and signals for the batch are executed only by the physical device specified by the resourceDeviceIndex.

If this structure is not present, resourceDeviceIndex and memoryDeviceIndex are assumed to be zero.

Valid Usage
resourceDeviceIndex and memoryDeviceIndex must both be valid device indices.
Each memory allocation bound in this batch must have allocated an instance for memoryDeviceIndex.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceGroupBindSparseInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceGroupCommandBufferBeginInfo(3)
Name
VkDeviceGroupCommandBufferBeginInfo - Set the initial device mask for a command buffer

C Specification
If the pNext chain of VkCommandBufferBeginInfo includes a VkDeviceGroupCommandBufferBeginInfo structure, then that structure includes an initial device mask for the command buffer.

The VkDeviceGroupCommandBufferBeginInfo structure is defined as:

typedef struct VkDeviceGroupCommandBufferBeginInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceMask;
} VkDeviceGroupCommandBufferBeginInfo;
or the equivalent

typedef VkDeviceGroupCommandBufferBeginInfo VkDeviceGroupCommandBufferBeginInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
deviceMask is the initial value of the command buffer’s device mask.
Description
The initial device mask also acts as an upper bound on the set of devices that can ever be in the device mask in the command buffer.

If this structure is not present, the initial value of a command buffer’s device mask is set to include all physical devices in the logical device when the command buffer begins recording.

Valid Usage
deviceMask must be a valid device mask value
deviceMask must not be zero
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceGroupCommandBufferBeginInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceGroupDeviceCreateInfo(3)
Name
VkDeviceGroupDeviceCreateInfo - Create a logical device from multiple physical devices

C Specification
A logical device can be created that connects to one or more physical devices by including a VkDeviceGroupDeviceCreateInfo structure in the pNext chain of VkDeviceCreateInfo. The VkDeviceGroupDeviceCreateInfo structure is defined as:

typedef struct VkDeviceGroupDeviceCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    uint32_t                   physicalDeviceCount;
    const VkPhysicalDevice*    pPhysicalDevices;
} VkDeviceGroupDeviceCreateInfo;
or the equivalent

typedef VkDeviceGroupDeviceCreateInfo VkDeviceGroupDeviceCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
physicalDeviceCount is the number of elements in the pPhysicalDevices array.
pPhysicalDevices is an array of physical device handles belonging to the same device group.
Description
The elements of the pPhysicalDevices array are an ordered list of the physical devices that the logical device represents. These must be a subset of a single device group, and need not be in the same order as they were enumerated. The order of the physical devices in the pPhysicalDevices array determines the device index of each physical device, with element i being assigned a device index of i. Certain commands and structures refer to one or more physical devices by using device indices or device masks formed using device indices.

A logical device created without using VkDeviceGroupDeviceCreateInfo, or with physicalDeviceCount equal to zero, is equivalent to a physicalDeviceCount of one and pPhysicalDevices pointing to the physicalDevice parameter to vkCreateDevice. In particular, the device index of that physical device is zero.

Valid Usage
Each element of pPhysicalDevices must be unique
All elements of pPhysicalDevices must be in the same device group as enumerated by vkEnumeratePhysicalDeviceGroups
If physicalDeviceCount is not 0, the physicalDevice parameter of vkCreateDevice must be an element of pPhysicalDevices.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO
If physicalDeviceCount is not 0, pPhysicalDevices must be a valid pointer to an array of physicalDeviceCount valid VkPhysicalDevice handles
See Also
VkPhysicalDevice, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceGroupDeviceCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceGroupPresentCapabilitiesKHR(3)
Name
VkDeviceGroupPresentCapabilitiesKHR - Present capabilities from other physical devices

C Specification
The VkDeviceGroupPresentCapabilitiesKHR structure is defined as:

typedef struct VkDeviceGroupPresentCapabilitiesKHR {
    VkStructureType                     sType;
    const void*                         pNext;
    uint32_t                            presentMask[VK_MAX_DEVICE_GROUP_SIZE];
    VkDeviceGroupPresentModeFlagsKHR    modes;
} VkDeviceGroupPresentCapabilitiesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
presentMask is an array of masks, where the mask at element i is non-zero if physical device i has a presentation engine, and where bit j is set in element i if physical device i can present swapchain images from physical device j. If element i is non-zero, then bit i must be set.
modes is a bitmask of VkDeviceGroupPresentModeFlagBitsKHR indicating which device group presentation modes are supported.
Description
modes always has VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR set.

The present mode flags are also used when presenting an image, in VkDeviceGroupPresentInfoKHR::mode.

If a device group only includes a single physical device, then modes must equal VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR
pNext must be NULL
See Also
VkDeviceGroupPresentModeFlagsKHR, VkStructureType, vkGetDeviceGroupPresentCapabilitiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceGroupPresentCapabilitiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceGroupPresentInfoKHR(3)
Name
VkDeviceGroupPresentInfoKHR - Mode and mask controlling which physical devices' images are presented

C Specification
If the pNext chain of VkPresentInfoKHR includes a VkDeviceGroupPresentInfoKHR structure, then that structure includes an array of device masks and a device group present mode.

The VkDeviceGroupPresentInfoKHR structure is defined as:

typedef struct VkDeviceGroupPresentInfoKHR {
    VkStructureType                        sType;
    const void*                            pNext;
    uint32_t                               swapchainCount;
    const uint32_t*                        pDeviceMasks;
    VkDeviceGroupPresentModeFlagBitsKHR    mode;
} VkDeviceGroupPresentInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
swapchainCount is zero or the number of elements in pDeviceMasks.
pDeviceMasks is an array of device masks, one for each element of VkPresentInfoKHR::pSwapchains.
mode is the device group present mode that will be used for this present.
Description
If mode is VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR, then each element of pDeviceMasks selects which instance of the swapchain image is presented. Each element of pDeviceMasks must have exactly one bit set, and the corresponding physical device must have a presentation engine as reported by VkDeviceGroupPresentCapabilitiesKHR.

If mode is VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR, then each element of pDeviceMasks selects which instance of the swapchain image is presented. Each element of pDeviceMasks must have exactly one bit set, and some physical device in the logical device must include that bit in its VkDeviceGroupPresentCapabilitiesKHR::presentMask.

If mode is VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR, then each element of pDeviceMasks selects which instances of the swapchain image are component-wise summed and the sum of those images is presented. If the sum in any component is outside the representable range, the value of that component is undefined. Each element of pDeviceMasks must have a value for which all set bits are set in one of the elements of VkDeviceGroupPresentCapabilitiesKHR::presentMask.

If mode is VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR, then each element of pDeviceMasks selects which instance(s) of the swapchain images are presented. For each bit set in each element of pDeviceMasks, the corresponding physical device must have a presentation engine as reported by VkDeviceGroupPresentCapabilitiesKHR.

If VkDeviceGroupPresentInfoKHR is not provided or swapchainCount is zero then the masks are considered to be 1. If VkDeviceGroupPresentInfoKHR is not provided, mode is considered to be VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR.

Valid Usage
swapchainCount must equal 0 or VkPresentInfoKHR::swapchainCount
If mode is VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR, then each element of pDeviceMasks must have exactly one bit set, and the corresponding element of VkDeviceGroupPresentCapabilitiesKHR::presentMask must be non-zero
If mode is VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR, then each element of pDeviceMasks must have exactly one bit set, and some physical device in the logical device must include that bit in its VkDeviceGroupPresentCapabilitiesKHR::presentMask.
If mode is VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR, then each element of pDeviceMasks must have a value for which all set bits are set in one of the elements of VkDeviceGroupPresentCapabilitiesKHR::presentMask
If mode is VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR, then for each bit set in each element of pDeviceMasks, the corresponding element of VkDeviceGroupPresentCapabilitiesKHR::presentMask must be non-zero
The value of each element of pDeviceMasks must be equal to the device mask passed in VkAcquireNextImageInfoKHR::deviceMask when the image index was last acquired
mode must have exactly one bit set, and that bit must have been included in VkDeviceGroupSwapchainCreateInfoKHR::modes
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR
If swapchainCount is not 0, pDeviceMasks must be a valid pointer to an array of swapchainCount uint32_t values
mode must be a valid VkDeviceGroupPresentModeFlagBitsKHR value
See Also
VkDeviceGroupPresentModeFlagBitsKHR, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceGroupPresentInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceGroupRenderPassBeginInfo(3)
Name
VkDeviceGroupRenderPassBeginInfo - Set the initial device mask and render areas for a render pass instance

C Specification
If the pNext chain of VkRenderPassBeginInfo includes a VkDeviceGroupRenderPassBeginInfo structure, then that structure includes a device mask and set of render areas for the render pass instance.

The VkDeviceGroupRenderPassBeginInfo structure is defined as:

typedef struct VkDeviceGroupRenderPassBeginInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           deviceMask;
    uint32_t           deviceRenderAreaCount;
    const VkRect2D*    pDeviceRenderAreas;
} VkDeviceGroupRenderPassBeginInfo;
or the equivalent

typedef VkDeviceGroupRenderPassBeginInfo VkDeviceGroupRenderPassBeginInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
deviceMask is the device mask for the render pass instance.
deviceRenderAreaCount is the number of elements in the pDeviceRenderAreas array.
pDeviceRenderAreas is an array of structures of type VkRect2D defining the render area for each physical device.
Description
The deviceMask serves several purposes. It is an upper bound on the set of physical devices that can be used during the render pass instance, and the initial device mask when the render pass instance begins. In addition, commands transitioning to the next subpass in the render pass instance and commands ending the render pass instance, and, accordingly render pass attachment load, store, and resolve operations and subpass dependencies corresponding to the render pass instance, are executed on the physical devices included in the device mask provided here.

If deviceRenderAreaCount is not zero, then the elements of pDeviceRenderAreas override the value of VkRenderPassBeginInfo::renderArea, and provide a render area specific to each physical device. These render areas serve the same purpose as VkRenderPassBeginInfo::renderArea, including controlling the region of attachments that are cleared by VK_ATTACHMENT_LOAD_OP_CLEAR and that are resolved into resolve attachments.

If this structure is not present, the render pass instance’s device mask is the value of VkDeviceGroupCommandBufferBeginInfo::deviceMask. If this structure is not present or if deviceRenderAreaCount is zero, VkRenderPassBeginInfo::renderArea is used for all physical devices.

Valid Usage
deviceMask must be a valid device mask value
deviceMask must not be zero
deviceMask must be a subset of the command buffer’s initial device mask
deviceRenderAreaCount must either be zero or equal to the number of physical devices in the logical device.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO
If deviceRenderAreaCount is not 0, pDeviceRenderAreas must be a valid pointer to an array of deviceRenderAreaCount VkRect2D structures
See Also
VkRect2D, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceGroupRenderPassBeginInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceGroupSubmitInfo(3)
Name
VkDeviceGroupSubmitInfo - Structure indicating which physical devices execute semaphore operations and command buffers

C Specification
If the pNext chain of VkSubmitInfo includes a VkDeviceGroupSubmitInfo structure, then that structure includes device indices and masks specifying which physical devices execute semaphore operations and command buffers.

The VkDeviceGroupSubmitInfo structure is defined as:

typedef struct VkDeviceGroupSubmitInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           waitSemaphoreCount;
    const uint32_t*    pWaitSemaphoreDeviceIndices;
    uint32_t           commandBufferCount;
    const uint32_t*    pCommandBufferDeviceMasks;
    uint32_t           signalSemaphoreCount;
    const uint32_t*    pSignalSemaphoreDeviceIndices;
} VkDeviceGroupSubmitInfo;
or the equivalent

typedef VkDeviceGroupSubmitInfo VkDeviceGroupSubmitInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
waitSemaphoreCount is the number of elements in the pWaitSemaphoreDeviceIndices array.
pWaitSemaphoreDeviceIndices is an array of device indices indicating which physical device executes the semaphore wait operation in the corresponding element of VkSubmitInfo::pWaitSemaphores.
commandBufferCount is the number of elements in the pCommandBufferDeviceMasks array.
pCommandBufferDeviceMasks is an array of device masks indicating which physical devices execute the command buffer in the corresponding element of VkSubmitInfo::pCommandBuffers. A physical device executes the command buffer if the corresponding bit is set in the mask.
signalSemaphoreCount is the number of elements in the pSignalSemaphoreDeviceIndices array.
pSignalSemaphoreDeviceIndices is an array of device indices indicating which physical device executes the semaphore signal operation in the corresponding element of VkSubmitInfo::pSignalSemaphores.
Description
If this structure is not present, semaphore operations and command buffers execute on device index zero.

Valid Usage
waitSemaphoreCount must equal VkSubmitInfo::waitSemaphoreCount
commandBufferCount must equal VkSubmitInfo::commandBufferCount
signalSemaphoreCount must equal VkSubmitInfo::signalSemaphoreCount
All elements of pWaitSemaphoreDeviceIndices and pSignalSemaphoreDeviceIndices must be valid device indices
All elements of pCommandBufferDeviceMasks must be valid device masks
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO
If waitSemaphoreCount is not 0, pWaitSemaphoreDeviceIndices must be a valid pointer to an array of waitSemaphoreCount uint32_t values
If commandBufferCount is not 0, pCommandBufferDeviceMasks must be a valid pointer to an array of commandBufferCount uint32_t values
If signalSemaphoreCount is not 0, pSignalSemaphoreDeviceIndices must be a valid pointer to an array of signalSemaphoreCount uint32_t values
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceGroupSubmitInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceGroupSwapchainCreateInfoKHR(3)
Name
VkDeviceGroupSwapchainCreateInfoKHR - Structure specifying parameters of a newly created swapchain object

C Specification
If the pNext chain of VkSwapchainCreateInfoKHR includes a VkDeviceGroupSwapchainCreateInfoKHR structure, then that structure includes a set of device group present modes that the swapchain can be used with.

The VkDeviceGroupSwapchainCreateInfoKHR structure is defined as:

typedef struct VkDeviceGroupSwapchainCreateInfoKHR {
    VkStructureType                     sType;
    const void*                         pNext;
    VkDeviceGroupPresentModeFlagsKHR    modes;
} VkDeviceGroupSwapchainCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
modes is a bitfield of modes that the swapchain can be used with.
Description
If this structure is not present, modes is considered to be VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR
modes must be a valid combination of VkDeviceGroupPresentModeFlagBitsKHR values
modes must not be 0
See Also
VkDeviceGroupPresentModeFlagsKHR, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceGroupSwapchainCreateInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceMemoryOverallocationCreateInfoAMD(3)
Name
VkDeviceMemoryOverallocationCreateInfoAMD - Specify memory overallocation behavior for a Vulkan device

C Specification
To specify whether device memory allocation is allowed beyond the size reported by VkPhysicalDeviceMemoryProperties, add a VkDeviceMemoryOverallocationCreateInfoAMD structure to the pNext chain of the VkDeviceCreateInfo structure. If this structure is not specified, it is as if the VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD value is used.

typedef struct VkDeviceMemoryOverallocationCreateInfoAMD {
    VkStructureType                      sType;
    const void*                          pNext;
    VkMemoryOverallocationBehaviorAMD    overallocationBehavior;
} VkDeviceMemoryOverallocationCreateInfoAMD;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
overallocationBehavior is the desired overallocation behavior.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD
overallocationBehavior must be a valid VkMemoryOverallocationBehaviorAMD value
See Also
VkMemoryOverallocationBehaviorAMD, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceMemoryOverallocationCreateInfoAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceQueueCreateInfo(3)
Name
VkDeviceQueueCreateInfo - Structure specifying parameters of a newly created device queue

C Specification
The VkDeviceQueueCreateInfo structure is defined as:

typedef struct VkDeviceQueueCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueCount;
    const float*                pQueuePriorities;
} VkDeviceQueueCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask indicating behavior of the queue.
queueFamilyIndex is an unsigned integer indicating the index of the queue family to create on this device. This index corresponds to the index of an element of the pQueueFamilyProperties array that was returned by vkGetPhysicalDeviceQueueFamilyProperties.
queueCount is an unsigned integer specifying the number of queues to create in the queue family indicated by queueFamilyIndex.
pQueuePriorities is an array of queueCount normalized floating point values, specifying priorities of work that will be submitted to each created queue. See Queue Priority for more information.
Description
Valid Usage
queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties
queueCount must be less than or equal to the queueCount member of the VkQueueFamilyProperties structure, as returned by vkGetPhysicalDeviceQueueFamilyProperties in the pQueueFamilyProperties[queueFamilyIndex]
Each element of pQueuePriorities must be between 0.0 and 1.0 inclusive
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
pNext must be NULL or a pointer to a valid instance of VkDeviceQueueGlobalPriorityCreateInfoEXT
flags must be a valid combination of VkDeviceQueueCreateFlagBits values
pQueuePriorities must be a valid pointer to an array of queueCount float values
queueCount must be greater than 0
See Also
VkDeviceCreateInfo, VkDeviceQueueCreateFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceQueueCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceQueueGlobalPriorityCreateInfoEXT(3)
Name
VkDeviceQueueGlobalPriorityCreateInfoEXT - Specify a system wide priority

C Specification
A queue can be created with a system-wide priority by including a VkDeviceQueueGlobalPriorityCreateInfoEXT structure in the pNext chain of VkDeviceQueueCreateInfo.

The VkDeviceQueueGlobalPriorityCreateInfoEXT structure is defined as:

typedef struct VkDeviceQueueGlobalPriorityCreateInfoEXT {
    VkStructureType             sType;
    const void*                 pNext;
    VkQueueGlobalPriorityEXT    globalPriority;
} VkDeviceQueueGlobalPriorityCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
globalPriority is the system-wide priority associated to this queue as specified by VkQueueGlobalPriorityEXT
Description
A queue created without specifying VkDeviceQueueGlobalPriorityCreateInfoEXT will default to VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT
globalPriority must be a valid VkQueueGlobalPriorityEXT value
See Also
VkQueueGlobalPriorityEXT, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceQueueGlobalPriorityCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceQueueInfo2(3)
Name
VkDeviceQueueInfo2 - Structure specifying the parameters used for device queue creation

C Specification
The VkDeviceQueueInfo2 structure is defined as:

typedef struct VkDeviceQueueInfo2 {
    VkStructureType             sType;
    const void*                 pNext;
    VkDeviceQueueCreateFlags    flags;
    uint32_t                    queueFamilyIndex;
    uint32_t                    queueIndex;
} VkDeviceQueueInfo2;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure. The pNext chain of VkDeviceQueueInfo2 is used to provide additional image parameters to vkGetDeviceQueue2.
flags is a VkDeviceQueueCreateFlags value indicating the flags used to create the device queue.
queueFamilyIndex is the index of the queue family to which the queue belongs.
queueIndex is the index within this queue family of the queue to retrieve.
Description
The queue returned by vkGetDeviceQueue2 must have the same flags value from this structure as that used at device creation time in a VkDeviceQueueCreateInfo instance. If no matching flags were specified at device creation time then pQueue will return VK_NULL_HANDLE.

Valid Usage
queueFamilyIndex must be one of the queue family indices specified when device was created, via the VkDeviceQueueCreateInfo structure
queueIndex must be less than the number of queues created for the specified queue family index and VkDeviceQueueCreateFlags member flags equal to this flags value when device was created, via the queueCount member of the VkDeviceQueueCreateInfo structure
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2
pNext must be NULL
flags must be a valid combination of VkDeviceQueueCreateFlagBits values
flags must not be 0
See Also
VkDeviceQueueCreateFlags, VkStructureType, vkGetDeviceQueue2

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceQueueInfo2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDispatchIndirectCommand(3)
Name
VkDispatchIndirectCommand - Structure specifying a dispatch indirect command

C Specification
The VkDispatchIndirectCommand structure is defined as:

typedef struct VkDispatchIndirectCommand {
    uint32_t    x;
    uint32_t    y;
    uint32_t    z;
} VkDispatchIndirectCommand;
Members
x is the number of local workgroups to dispatch in the X dimension.
y is the number of local workgroups to dispatch in the Y dimension.
z is the number of local workgroups to dispatch in the Z dimension.
Description
The members of VkDispatchIndirectCommand have the same meaning as the corresponding parameters of vkCmdDispatch.

Valid Usage
x must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]
y must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]
z must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]
See Also
vkCmdDispatchIndirect

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDispatchIndirectCommand

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayEventInfoEXT(3)
Name
VkDisplayEventInfoEXT - Describe a display event to create

C Specification
The VkDisplayEventInfoEXT structure is defined as:

typedef struct VkDisplayEventInfoEXT {
    VkStructureType          sType;
    const void*              pNext;
    VkDisplayEventTypeEXT    displayEvent;
} VkDisplayEventInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
displayEvent is a VkDisplayEventTypeEXT specifying when the fence will be signaled.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT
pNext must be NULL
displayEvent must be a valid VkDisplayEventTypeEXT value
See Also
VkDisplayEventTypeEXT, VkStructureType, vkRegisterDisplayEventEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayEventInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayModeCreateInfoKHR(3)
Name
VkDisplayModeCreateInfoKHR - Structure specifying parameters of a newly created display mode object

C Specification
The VkDisplayModeCreateInfoKHR structure is defined as:

typedef struct VkDisplayModeCreateInfoKHR {
    VkStructureType                sType;
    const void*                    pNext;
    VkDisplayModeCreateFlagsKHR    flags;
    VkDisplayModeParametersKHR     parameters;
} VkDisplayModeCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use, and must be zero.
parameters is a VkDisplayModeParametersKHR structure describing the display parameters to use in creating the new mode. If the parameters are not compatible with the specified display, the implementation must return VK_ERROR_INITIALIZATION_FAILED.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR
pNext must be NULL
flags must be 0
parameters must be a valid VkDisplayModeParametersKHR structure
See Also
VkDisplayModeCreateFlagsKHR, VkDisplayModeParametersKHR, VkStructureType, vkCreateDisplayModeKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayModeCreateInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayModeParametersKHR(3)
Name
VkDisplayModeParametersKHR - Structure describing display parameters associated with a display mode

C Specification
The VkDisplayModeParametersKHR structure is defined as:

typedef struct VkDisplayModeParametersKHR {
    VkExtent2D    visibleRegion;
    uint32_t      refreshRate;
} VkDisplayModeParametersKHR;
Members
visibleRegion is the 2D extents of the visible region.
refreshRate is a uint32_t that is the number of times the display is refreshed each second multiplied by 1000.
Description
Note
For example, a 60Hz display mode would report a refreshRate of 60,000.
Valid Usage
The width member of visibleRegion must be greater than 0
The height member of visibleRegion must be greater than 0
refreshRate must be greater than 0
See Also
VkDisplayModeCreateInfoKHR, VkDisplayModePropertiesKHR, VkExtent2D

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayModeParametersKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayModeProperties2KHR(3)
Name
VkDisplayModeProperties2KHR - Structure describing an available display mode

C Specification
The VkDisplayModeProperties2KHR structure is defined as:

typedef struct VkDisplayModeProperties2KHR {
    VkStructureType               sType;
    void*                         pNext;
    VkDisplayModePropertiesKHR    displayModeProperties;
} VkDisplayModeProperties2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
displayModeProperties is an instance of the VkDisplayModePropertiesKHR structure.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR
pNext must be NULL
See Also
VkDisplayModePropertiesKHR, VkStructureType, vkGetDisplayModeProperties2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayModeProperties2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayModePropertiesKHR(3)
Name
VkDisplayModePropertiesKHR - Structure describing display mode properties

C Specification
The VkDisplayModePropertiesKHR structure is defined as:

typedef struct VkDisplayModePropertiesKHR {
    VkDisplayModeKHR              displayMode;
    VkDisplayModeParametersKHR    parameters;
} VkDisplayModePropertiesKHR;
Members
displayMode is a handle to the display mode described in this structure. This handle will be valid for the lifetime of the Vulkan instance.
parameters is a VkDisplayModeParametersKHR structure describing the display parameters associated with displayMode.
Description
See Also
VkDisplayModeKHR, VkDisplayModeParametersKHR, VkDisplayModeProperties2KHR, vkGetDisplayModePropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayModePropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayNativeHdrSurfaceCapabilitiesAMD(3)
Name
VkDisplayNativeHdrSurfaceCapabilitiesAMD - Structure describing display native HDR specific capabilities of a surface

C Specification
The VkDisplayNativeHdrSurfaceCapabilitiesAMD structure is defined as:

typedef struct VkDisplayNativeHdrSurfaceCapabilitiesAMD {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           localDimmingSupport;
} VkDisplayNativeHdrSurfaceCapabilitiesAMD;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
localDimmingSupport specifies whether the surface supports local dimming. If this is VK_TRUE, VkSwapchainDisplayNativeHdrCreateInfoAMD can be used to explicitly enable or disable local dimming for the surface. Local dimming may also be overriden by vkSetLocalDimmingAMD during the lifetime of the swapchain.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayNativeHdrSurfaceCapabilitiesAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayPlaneCapabilities2KHR(3)
Name
VkDisplayPlaneCapabilities2KHR - Structure describing the capabilities of a mode and plane combination

C Specification
The VkDisplayPlaneCapabilities2KHR structure is defined as:

typedef struct VkDisplayPlaneCapabilities2KHR {
    VkStructureType                  sType;
    void*                            pNext;
    VkDisplayPlaneCapabilitiesKHR    capabilities;
} VkDisplayPlaneCapabilities2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
capabilities is an instance of the VkDisplayPlaneCapabilitiesKHR structure.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR
pNext must be NULL
See Also
VkDisplayPlaneCapabilitiesKHR, VkStructureType, vkGetDisplayPlaneCapabilities2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayPlaneCapabilities2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayPlaneCapabilitiesKHR(3)
Name
VkDisplayPlaneCapabilitiesKHR - Structure describing capabilities of a mode and plane combination

C Specification
The VkDisplayPlaneCapabilitiesKHR structure is defined as:

typedef struct VkDisplayPlaneCapabilitiesKHR {
    VkDisplayPlaneAlphaFlagsKHR    supportedAlpha;
    VkOffset2D                     minSrcPosition;
    VkOffset2D                     maxSrcPosition;
    VkExtent2D                     minSrcExtent;
    VkExtent2D                     maxSrcExtent;
    VkOffset2D                     minDstPosition;
    VkOffset2D                     maxDstPosition;
    VkExtent2D                     minDstExtent;
    VkExtent2D                     maxDstExtent;
} VkDisplayPlaneCapabilitiesKHR;
Members
supportedAlpha is a bitmask of VkDisplayPlaneAlphaFlagBitsKHR describing the supported alpha blending modes.
minSrcPosition is the minimum source rectangle offset supported by this plane using the specified mode.
maxSrcPosition is the maximum source rectangle offset supported by this plane using the specified mode. The x and y components of maxSrcPosition must each be greater than or equal to the x and y components of minSrcPosition, respectively.
minSrcExtent is the minimum source rectangle size supported by this plane using the specified mode.
maxSrcExtent is the maximum source rectangle size supported by this plane using the specified mode.
minDstPosition, maxDstPosition, minDstExtent, maxDstExtent all have similar semantics to their corresponding *Src* equivalents, but apply to the output region within the mode rather than the input region within the source image. Unlike the *Src* offsets, minDstPosition and maxDstPosition may contain negative values.
Description
The minimum and maximum position and extent fields describe the implementation limits, if any, as they apply to the specified display mode and plane. Vendors may support displaying a subset of a swapchain’s presentable images on the specified display plane. This is expressed by returning minSrcPosition, maxSrcPosition, minSrcExtent, and maxSrcExtent values that indicate a range of possible positions and sizes may be used to specify the region within the presentable images that source pixels will be read from when creating a swapchain on the specified display mode and plane.

Vendors may also support mapping the presentable images’ content to a subset or superset of the visible region in the specified display mode. This is expressed by returning minDstPosition, maxDstPosition, minDstExtent and maxDstExtent values that indicate a range of possible positions and sizes may be used to describe the region within the display mode that the source pixels will be mapped to.

Other vendors may support only a 1-1 mapping between pixels in the presentable images and the display mode. This may be indicated by returning (0,0) for minSrcPosition, maxSrcPosition, minDstPosition, and maxDstPosition, and (display mode width, display mode height) for minSrcExtent, maxSrcExtent, minDstExtent, and maxDstExtent.

These values indicate the limits of the implementation’s individual fields. Not all combinations of values within the offset and extent ranges returned in VkDisplayPlaneCapabilitiesKHR are guaranteed to be supported. Vendors may still fail presentation requests that specify unsupported combinations.

See Also
VkDisplayPlaneAlphaFlagsKHR, VkDisplayPlaneCapabilities2KHR, VkExtent2D, VkOffset2D, vkGetDisplayPlaneCapabilitiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayPlaneCapabilitiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayPlaneInfo2KHR(3)
Name
VkDisplayPlaneInfo2KHR - Structure defining the intended configuration of a display plane

C Specification
The VkDisplayPlaneInfo2KHR structure is defined as:

typedef struct VkDisplayPlaneInfo2KHR {
    VkStructureType     sType;
    const void*         pNext;
    VkDisplayModeKHR    mode;
    uint32_t            planeIndex;
} VkDisplayPlaneInfo2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
mode is the display mode the application intends to program when using the specified plane.
Description
Note
This parameter also implicitly specifies a display.
planeIndex is the plane which the application intends to use with the display.
The members of VkDisplayPlaneInfo2KHR correspond to the arguments to vkGetDisplayPlaneCapabilitiesKHR, with sType and pNext added for extensibility.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR
pNext must be NULL
mode must be a valid VkDisplayModeKHR handle
Host Synchronization
Host access to mode must be externally synchronized
See Also
VkDisplayModeKHR, VkStructureType, vkGetDisplayPlaneCapabilities2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayPlaneInfo2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayPlaneProperties2KHR(3)
Name
VkDisplayPlaneProperties2KHR - Structure describing an available display plane

C Specification
The VkDisplayPlaneProperties2KHR structure is defined as:

typedef struct VkDisplayPlaneProperties2KHR {
    VkStructureType                sType;
    void*                          pNext;
    VkDisplayPlanePropertiesKHR    displayPlaneProperties;
} VkDisplayPlaneProperties2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
displayPlaneProperties is an instance of the VkDisplayPlanePropertiesKHR structure.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR
pNext must be NULL
See Also
VkDisplayPlanePropertiesKHR, VkStructureType, vkGetPhysicalDeviceDisplayPlaneProperties2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayPlaneProperties2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayPlanePropertiesKHR(3)
Name
VkDisplayPlanePropertiesKHR - Structure describing display plane properties

C Specification
The VkDisplayPlanePropertiesKHR structure is defined as:

typedef struct VkDisplayPlanePropertiesKHR {
    VkDisplayKHR    currentDisplay;
    uint32_t        currentStackIndex;
} VkDisplayPlanePropertiesKHR;
Members
currentDisplay is the handle of the display the plane is currently associated with. If the plane is not currently attached to any displays, this will be VK_NULL_HANDLE.
currentStackIndex is the current z-order of the plane. This will be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR in pPropertyCount.
Description
See Also
VkDisplayKHR, VkDisplayPlaneProperties2KHR, vkGetPhysicalDeviceDisplayPlanePropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayPlanePropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayPowerInfoEXT(3)
Name
VkDisplayPowerInfoEXT - Describe the power state of a display

C Specification
The VkDisplayPowerInfoEXT structure is defined as:

typedef struct VkDisplayPowerInfoEXT {
    VkStructureType           sType;
    const void*               pNext;
    VkDisplayPowerStateEXT    powerState;
} VkDisplayPowerInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
powerState is a VkDisplayPowerStateEXT value specifying the new power state of the display.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT
pNext must be NULL
powerState must be a valid VkDisplayPowerStateEXT value
See Also
VkDisplayPowerStateEXT, VkStructureType, vkDisplayPowerControlEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayPowerInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayPresentInfoKHR(3)
Name
VkDisplayPresentInfoKHR - Structure describing parameters of a queue presentation to a swapchain

C Specification
The VkDisplayPresentInfoKHR structure is defined as:

typedef struct VkDisplayPresentInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkRect2D           srcRect;
    VkRect2D           dstRect;
    VkBool32           persistent;
} VkDisplayPresentInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
srcRect is a rectangular region of pixels to present. It must be a subset of the image being presented. If VkDisplayPresentInfoKHR is not specified, this region will be assumed to be the entire presentable image.
dstRect is a rectangular region within the visible region of the swapchain’s display mode. If VkDisplayPresentInfoKHR is not specified, this region will be assumed to be the entire visible region of the visible region of the swapchain’s mode. If the specified rectangle is a subset of the display mode’s visible region, content from display planes below the swapchain’s plane will be visible outside the rectangle. If there are no planes below the swapchain’s, the area outside the specified rectangle will be black. If portions of the specified rectangle are outside of the display’s visible region, pixels mapping only to those portions of the rectangle will be discarded.
persistent: If this is VK_TRUE, the display engine will enable buffered mode on displays that support it. This allows the display engine to stop sending content to the display until a new image is presented. The display will instead maintain a copy of the last presented image. This allows less power to be used, but may increase presentation latency. If VkDisplayPresentInfoKHR is not specified, persistent mode will not be used.
Description
If the extent of the srcRect and dstRect are not equal, the presented pixels will be scaled accordingly.

Valid Usage
srcRect must specify a rectangular region that is a subset of the image being presented
dstRect must specify a rectangular region that is a subset of the visibleRegion parameter of the display mode the swapchain being presented uses
If the persistentContent member of the VkDisplayPropertiesKHR structure returned by vkGetPhysicalDeviceDisplayPropertiesKHR for the display the present operation targets then persistent must be VK_FALSE
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR
See Also
VkBool32, VkRect2D, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayPresentInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayProperties2KHR(3)
Name
VkDisplayProperties2KHR - Structure describing an available display device

C Specification
The VkDisplayProperties2KHR structure is defined as:

typedef struct VkDisplayProperties2KHR {
    VkStructureType           sType;
    void*                     pNext;
    VkDisplayPropertiesKHR    displayProperties;
} VkDisplayProperties2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
displayProperties is an instance of the VkDisplayPropertiesKHR structure.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR
pNext must be NULL
See Also
VkDisplayPropertiesKHR, VkStructureType, vkGetPhysicalDeviceDisplayProperties2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayProperties2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayPropertiesKHR(3)
Name
VkDisplayPropertiesKHR - Structure describing an available display device

C Specification
The VkDisplayPropertiesKHR structure is defined as:

typedef struct VkDisplayPropertiesKHR {
    VkDisplayKHR                  display;
    const char*                   displayName;
    VkExtent2D                    physicalDimensions;
    VkExtent2D                    physicalResolution;
    VkSurfaceTransformFlagsKHR    supportedTransforms;
    VkBool32                      planeReorderPossible;
    VkBool32                      persistentContent;
} VkDisplayPropertiesKHR;
Members
display is a handle that is used to refer to the display described here. This handle will be valid for the lifetime of the Vulkan instance.
displayName is a pointer to a NULL-terminated string containing the name of the display. Generally, this will be the name provided by the display’s EDID. It can be NULL if no suitable name is available. If not NULL, the memory it points to must remain accessible as long as display is valid.
physicalDimensions describes the physical width and height of the visible portion of the display, in millimeters.
physicalResolution describes the physical, native, or preferred resolution of the display.
Description
Note
For devices which have no natural value to return here, implementations should return the maximum resolution supported.
supportedTransforms is a bitmask of VkSurfaceTransformFlagBitsKHR describing which transforms are supported by this display.
planeReorderPossible tells whether the planes on this display can have their z order changed. If this is VK_TRUE, the application can re-arrange the planes on this display in any order relative to each other.
persistentContent tells whether the display supports self-refresh/internal buffering. If this is true, the application can submit persistent present operations on swapchains created against this display.
Note
Persistent presents may have higher latency, and may use less power when the screen content is updated infrequently, or when only a portion of the screen needs to be updated in most frames.
See Also
VkBool32, VkDisplayKHR, VkDisplayProperties2KHR, VkExtent2D, VkSurfaceTransformFlagsKHR, vkGetPhysicalDeviceDisplayPropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayPropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplaySurfaceCreateInfoKHR(3)
Name
VkDisplaySurfaceCreateInfoKHR - Structure specifying parameters of a newly created display plane surface object

C Specification
The VkDisplaySurfaceCreateInfoKHR structure is defined as:

typedef struct VkDisplaySurfaceCreateInfoKHR {
    VkStructureType                   sType;
    const void*                       pNext;
    VkDisplaySurfaceCreateFlagsKHR    flags;
    VkDisplayModeKHR                  displayMode;
    uint32_t                          planeIndex;
    uint32_t                          planeStackIndex;
    VkSurfaceTransformFlagBitsKHR     transform;
    float                             globalAlpha;
    VkDisplayPlaneAlphaFlagBitsKHR    alphaMode;
    VkExtent2D                        imageExtent;
} VkDisplaySurfaceCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use, and must be zero.
displayMode is a VkDisplayModeKHR handle specifying the mode to use when displaying this surface.
planeIndex is the plane on which this surface appears.
planeStackIndex is the z-order of the plane.
transform is a VkSurfaceTransformFlagBitsKHR value specifying the transformation to apply to images as part of the scanout operation.
globalAlpha is the global alpha value. This value is ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR.
alphaMode is a VkDisplayPlaneAlphaFlagBitsKHR value specifying the type of alpha blending to use.
imageExtent The size of the presentable images to use with the surface.
Description
Note
Creating a display surface must not modify the state of the displays, planes, or other resources it names. For example, it must not apply the specified mode to be set on the associated display. Application of display configuration occurs as a side effect of presenting to a display surface.
Valid Usage
planeIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR
If the planeReorderPossible member of the VkDisplayPropertiesKHR structure returned by vkGetPhysicalDeviceDisplayPropertiesKHR for the display corresponding to displayMode is VK_TRUE then planeStackIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR; otherwise planeStackIndex must equal the currentStackIndex member of VkDisplayPlanePropertiesKHR returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR for the display plane corresponding to displayMode
If alphaMode is VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR then globalAlpha must be between 0 and 1, inclusive
alphaMode must be 0 or one of the bits present in the supportedAlpha member of VkDisplayPlaneCapabilitiesKHR returned by vkGetDisplayPlaneCapabilitiesKHR for the display plane corresponding to displayMode
The width and height members of imageExtent must be less than the maxImageDimensions2D member of VkPhysicalDeviceLimits
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR
pNext must be NULL
flags must be 0
displayMode must be a valid VkDisplayModeKHR handle
transform must be a valid VkSurfaceTransformFlagBitsKHR value
alphaMode must be a valid VkDisplayPlaneAlphaFlagBitsKHR value
See Also
VkDisplayModeKHR, VkDisplayPlaneAlphaFlagBitsKHR, VkDisplaySurfaceCreateFlagsKHR, VkExtent2D, VkStructureType, VkSurfaceTransformFlagBitsKHR, vkCreateDisplayPlaneSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplaySurfaceCreateInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDrawIndexedIndirectCommand(3)
Name
VkDrawIndexedIndirectCommand - Structure specifying a draw indexed indirect command

C Specification
The VkDrawIndexedIndirectCommand structure is defined as:

typedef struct VkDrawIndexedIndirectCommand {
    uint32_t    indexCount;
    uint32_t    instanceCount;
    uint32_t    firstIndex;
    int32_t     vertexOffset;
    uint32_t    firstInstance;
} VkDrawIndexedIndirectCommand;
Members
indexCount is the number of vertices to draw.
instanceCount is the number of instances to draw.
firstIndex is the base index within the index buffer.
vertexOffset is the value added to the vertex index before indexing into the vertex buffer.
firstInstance is the instance ID of the first instance to draw.
Description
The members of VkDrawIndexedIndirectCommand have the same meaning as the similarly named parameters of vkCmdDrawIndexed.

Valid Usage
For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in html/vkspec.html#fxvertex-input
(indexSize * (firstIndex + indexCount) + offset) must be less than or equal to the size of the bound index buffer, with indexSize being based on the type specified by indexType, where the index buffer, indexType, and offset are specified via vkCmdBindIndexBuffer
If the drawIndirectFirstInstance feature is not enabled, firstInstance must be 0
See Also
vkCmdDrawIndexedIndirect

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDrawIndexedIndirectCommand

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDrawIndirectCommand(3)
Name
VkDrawIndirectCommand - Structure specifying a draw indirect command

C Specification
The VkDrawIndirectCommand structure is defined as:

typedef struct VkDrawIndirectCommand {
    uint32_t    vertexCount;
    uint32_t    instanceCount;
    uint32_t    firstVertex;
    uint32_t    firstInstance;
} VkDrawIndirectCommand;
Members
vertexCount is the number of vertices to draw.
instanceCount is the number of instances to draw.
firstVertex is the index of the first vertex to draw.
firstInstance is the instance ID of the first instance to draw.
Description
The members of VkDrawIndirectCommand have the same meaning as the similarly named parameters of vkCmdDraw.

Valid Usage
For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in html/vkspec.html#fxvertex-input
If the drawIndirectFirstInstance feature is not enabled, firstInstance must be 0
See Also
vkCmdDrawIndirect

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDrawIndirectCommand

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDrawMeshTasksIndirectCommandNV(3)
Name
VkDrawMeshTasksIndirectCommandNV - Structure specifying a mesh tasks draw indirect command

C Specification
The VkDrawMeshTasksIndirectCommandNV structure is defined as:

typedef struct VkDrawMeshTasksIndirectCommandNV {
    uint32_t    taskCount;
    uint32_t    firstTask;
} VkDrawMeshTasksIndirectCommandNV;
Members
taskCount is the number of local workgroups to dispatch in the X dimension. Y and Z dimension are implicitly set to one.
firstTask is the X component of the first workgroup ID.
Description
The members of VkDrawMeshTasksIndirectCommandNV have the same meaning as the similarly named parameters of vkCmdDrawMeshTasksNV.

Valid Usage
taskCount must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxDrawMeshTasksCount
See Also
vkCmdDrawMeshTasksIndirectNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDrawMeshTasksIndirectCommandNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDrmFormatModifierPropertiesEXT(3)
Name
VkDrmFormatModifierPropertiesEXT - Structure specifying properties of a format when combined with a DRM format modifier

C Specification
The VkDrmFormatModifierPropertiesEXT structure describes properties of a VkFormat when that format is combined with a Linux DRM format modifier. These properties, like those of VkFormatProperties2, are independent of any particular image.

The VkDrmFormatModifierPropertiesEXT structure is defined as:

typedef struct VkDrmFormatModifierPropertiesEXT {
    uint64_t                drmFormatModifier;
    uint32_t                drmFormatModifierPlaneCount;
    VkFormatFeatureFlags    drmFormatModifierTilingFeatures;
} VkDrmFormatModifierPropertiesEXT;
Members
drmFormatModifier is a Linux DRM format modifier.
drmFormatModifierPlaneCount is the number of memory planes in any image created with format and drmFormatModifier. An image’s memory planecount is distinct from its format planecount, as explained below.
drmFormatModifierTilingFeatures is a bitmask of VkFormatFeatureFlagBits that are supported by any image created with format and drmFormatModifier.
Description
The returned drmFormatModifierTilingFeatures must contain at least one bit.

The implementation must not return DRM_FORMAT_MOD_INVALID in drmFormatModifier.

An image’s memory planecount (as returned by drmFormatModifierPlaneCount) is distinct from its format planecount (in the sense of multi-planar Y’CBCR formats). In VkImageAspectFlags, each VK_IMAGE_ASPECT_MEMORY_PLANEi_BIT_EXT represents a _memory plane and each VK_IMAGE_ASPECT_PLANEi_BIT a _format plane.

An image’s set of format planes is an ordered partition of the image’s content into separable groups of format channels. The ordered partition is encoded in the name of each VkFormat. For example, VK_FORMAT_G8_B8R8_2PLANE_420_UNORM contains two format planes; the first plane contains the green channel and the second plane contains the blue channel and red channel. If the format name does not contain PLANE, then the format contains a single plane; for example, VK_FORMAT_R8G8B8A8_UNORM. Some commands, such as vkCmdCopyBufferToImage, do not operate on all format channels in the image, but instead operate only on the format planes explicitly chosen by the application and operate on each format plane independently.

An image’s set of memory planes is an ordered partition of the image’s memory rather than the image’s content. Each memory plane is a contiguous range of memory. The union of an image’s memory planes is not necessarily contiguous.

If an image is linear, then the partition is the same for memory planes and for format planes. Therefore, if the returned drmFormatModifier is DRM_FORMAT_MOD_LINEAR, then drmFormatModifierPlaneCount must equal the format planecount, and drmFormatModifierTilingFeatures must be identical to the VkFormatProperties2::linearTilingFeatures returned in the same pNext chain.

If an image is non-linear, then the partition of the image’s memory into memory planes is implementation-specific and may be unrelated to the partition of the image’s content into format planes. For example, consider an image whose format is VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM, tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, whose drmFormatModifier is not DRM_FORMAT_MOD_LINEAR, and flags lacks VK_IMAGE_CREATE_DISJOINT_BIT. The image has 3 format planes, and commands such vkCmdCopyBufferToImage act on each format plane independently as if the data of each format plane were separable from the data of the other planes. In a straightforward implementation, the implementation may store the image’s content in 3 adjacent memory planes where each memory plane corresponds exactly to a format plane. However, the implementation may also store the image’s content in a single memory plane where all format channels are combined using an implementation-private block-compressed format; or the implementation may store the image’s content in a collection of 7 adjacent memory planes using an implementation-private sharding technique. Because the image is non-linear and non-disjoint, the implementation has much freedom when choosing the image’s placement in memory.

The memory planecount applies to function parameters and structures only when the API specifies an explicit requirement on drmFormatModifierPlaneCount. In all other cases, the memory planecount is ignored.

See Also
VkDrmFormatModifierPropertiesListEXT, VkFormatFeatureFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDrmFormatModifierPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDrmFormatModifierPropertiesListEXT(3)
Name
VkDrmFormatModifierPropertiesListEXT - Structure specifying the list of DRM format modifiers supported for a format

C Specification
To obtain the list of Linux DRM format modifiers compatible with a VkFormat, add VkDrmFormatModifierPropertiesListEXT to the pNext chain of VkFormatProperties2.

The VkDrmFormatModifierPropertiesListEXT structure is defined as:

typedef struct VkDrmFormatModifierPropertiesListEXT {
    VkStructureType                      sType;
    void*                                pNext;
    uint32_t                             drmFormatModifierCount;
    VkDrmFormatModifierPropertiesEXT*    pDrmFormatModifierProperties;
} VkDrmFormatModifierPropertiesListEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
drmFormatModifierCount is an inout parameter related to the number of modifiers compatible with the format, as described below.
pDrmFormatModifierProperties is either NULL or an array of VkDrmFormatModifierPropertiesEXT structures.
Description
If pDrmFormatModifierProperties is NULL, then the function returns in drmFormatModifierCount the number of modifiers compatible with the queried format. Otherwise, the application must set drmFormatModifierCount to the length of the array pDrmFormatModifierProperties; the function will write at most drmFormatModifierCount elements to the array, and will return in drmFormatModifierCount the number of elements written.

Among the elements in array pDrmFormatModifierProperties, each returned drmFormatModifier must be unique.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT
See Also
VkDrmFormatModifierPropertiesEXT, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDrmFormatModifierPropertiesListEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkEventCreateInfo(3)
Name
VkEventCreateInfo - Structure specifying parameters of a newly created event

C Specification
The VkEventCreateInfo structure is defined as:

typedef struct VkEventCreateInfo {
    VkStructureType       sType;
    const void*           pNext;
    VkEventCreateFlags    flags;
} VkEventCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EVENT_CREATE_INFO
pNext must be NULL
flags must be 0
See Also
VkEventCreateFlags, VkStructureType, vkCreateEvent

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkEventCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExportFenceCreateInfo(3)
Name
VkExportFenceCreateInfo - Structure specifying handle types that can be exported from a fence

C Specification
To create a fence whose payload can be exported to external handles, add the VkExportFenceCreateInfo structure to the pNext chain of the VkFenceCreateInfo structure. The VkExportFenceCreateInfo structure is defined as:

typedef struct VkExportFenceCreateInfo {
    VkStructureType                   sType;
    const void*                       pNext;
    VkExternalFenceHandleTypeFlags    handleTypes;
} VkExportFenceCreateInfo;
or the equivalent

typedef VkExportFenceCreateInfo VkExportFenceCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
handleTypes is a bitmask of VkExternalFenceHandleTypeFlagBits specifying one or more fence handle types the application can export from the resulting fence. The application can request multiple handle types for the same fence.
Description
Valid Usage
The bits in handleTypes must be supported and compatible, as reported by VkExternalFenceProperties.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO
handleTypes must be a valid combination of VkExternalFenceHandleTypeFlagBits values
See Also
VkExternalFenceHandleTypeFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExportFenceCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExportFenceWin32HandleInfoKHR(3)
Name
VkExportFenceWin32HandleInfoKHR - Structure specifying additional attributes of Windows handles exported from a fence

C Specification
To specify additional attributes of NT handles exported from a fence, add the VkExportFenceWin32HandleInfoKHR structure to the pNext chain of the VkFenceCreateInfo structure. The VkExportFenceWin32HandleInfoKHR structure is defined as:

typedef struct VkExportFenceWin32HandleInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
    LPCWSTR                       name;
} VkExportFenceWin32HandleInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
pAttributes is a pointer to a Windows SECURITY_ATTRIBUTES structure specifying security attributes of the handle.
dwAccess is a DWORD specifying access rights of the handle.
name is a NULL-terminated UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created fence.
Description
If this structure is not present, or if pAttributes is set to NULL, default security descriptor values will be used, and child processes created by the application will not inherit the handle, as described in the MSDN documentation for “Synchronization Object Security and Access Rights”1. Further, if the structure is not present, the access rights will be

DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE

for handles of the following types:

VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT

1
https://msdn.microsoft.com/en-us/library/windows/desktop/ms686670.aspx
Valid Usage
If VkExportFenceCreateInfo::handleTypes does not include VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT, VkExportFenceWin32HandleInfoKHR must not be in the pNext chain of VkFenceCreateInfo.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR
If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExportFenceWin32HandleInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExportMemoryAllocateInfo(3)
Name
VkExportMemoryAllocateInfo - Specify exportable handle types for a device memory object

C Specification
When allocating memory that may be exported to another process or Vulkan instance, add a VkExportMemoryAllocateInfo structure to the pNext chain of the VkMemoryAllocateInfo structure, specifying the handle types that may be exported.

The VkExportMemoryAllocateInfo structure is defined as:

typedef struct VkExportMemoryAllocateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkExternalMemoryHandleTypeFlags    handleTypes;
} VkExportMemoryAllocateInfo;
or the equivalent

typedef VkExportMemoryAllocateInfo VkExportMemoryAllocateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
handleTypes is a bitmask of VkExternalMemoryHandleTypeFlagBits specifying one or more memory handle types the application can export from the resulting allocation. The application can request multiple handle types for the same allocation.
Description
Valid Usage
The bits in handleTypes must be supported and compatible, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO
handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values
See Also
VkExternalMemoryHandleTypeFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExportMemoryAllocateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExportMemoryAllocateInfoNV(3)
Name
VkExportMemoryAllocateInfoNV - Specify memory handle types that may be exported

C Specification
The VkExportMemoryAllocateInfoNV structure is defined as:

typedef struct VkExportMemoryAllocateInfoNV {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleTypes;
} VkExportMemoryAllocateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
handleTypes is a bitmask of VkExternalMemoryHandleTypeFlagBitsNV specifying one or more memory handle types that may be exported. Multiple handle types may be requested for the same allocation as long as they are compatible, as reported by vkGetPhysicalDeviceExternalImageFormatPropertiesNV.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV
handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values
See Also
VkExternalMemoryHandleTypeFlagsNV, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExportMemoryAllocateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExportMemoryWin32HandleInfoKHR(3)
Name
VkExportMemoryWin32HandleInfoKHR - Structure specifying additional attributes of Windows handles exported from a memory

C Specification
To specify additional attributes of NT handles exported from a memory object, add the VkExportMemoryWin32HandleInfoKHR structure to the pNext chain of the VkMemoryAllocateInfo structure. The VkExportMemoryWin32HandleInfoKHR structure is defined as:

typedef struct VkExportMemoryWin32HandleInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
    LPCWSTR                       name;
} VkExportMemoryWin32HandleInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
pAttributes is a pointer to a Windows SECURITY_ATTRIBUTES structure specifying security attributes of the handle.
dwAccess is a DWORD specifying access rights of the handle.
name is a NULL-terminated UTF-16 string to associate with the underlying resource referenced by NT handles exported from the created memory.
Description
If this structure is not present, or if pAttributes is set to NULL, default security descriptor values will be used, and child processes created by the application will not inherit the handle, as described in the MSDN documentation for “Synchronization Object Security and Access Rights”1. Further, if the structure is not present, the access rights will be

DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE

for handles of the following types:

VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT

And

GENERIC_ALL

for handles of the following types:

VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT

1
https://msdn.microsoft.com/en-us/library/windows/desktop/ms686670.aspx
Valid Usage
If VkExportMemoryAllocateInfo::handleTypes does not include VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, VkExportMemoryWin32HandleInfoKHR must not be in the pNext chain of VkMemoryAllocateInfo.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR
If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExportMemoryWin32HandleInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExportMemoryWin32HandleInfoNV(3)
Name
VkExportMemoryWin32HandleInfoNV - specify security attributes and access rights for Win32 memory handles

C Specification
When VkExportMemoryAllocateInfoNV::handleTypes includes VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV, add a VkExportMemoryWin32HandleInfoNV to the pNext chain of the VkExportMemoryAllocateInfoNV structure to specify security attributes and access rights for the memory object’s external handle.

The VkExportMemoryWin32HandleInfoNV structure is defined as:

typedef struct VkExportMemoryWin32HandleInfoNV {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
} VkExportMemoryWin32HandleInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
pAttributes is a pointer to a Windows SECURITY_ATTRIBUTES structure specifying security attributes of the handle.
dwAccess is a DWORD specifying access rights of the handle.
Description
If this structure is not present, or if pAttributes is set to NULL, default security descriptor values will be used, and child processes created by the application will not inherit the handle, as described in the MSDN documentation for “Synchronization Object Security and Access Rights”[1]. Further, if the structure is not present, the access rights will be

DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE
[1] https://msdn.microsoft.com/en-us/library/windows/desktop/ms686670.aspx

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV
If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExportMemoryWin32HandleInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExportSemaphoreCreateInfo(3)
Name
VkExportSemaphoreCreateInfo - Structure specifying handle types that can be exported from a semaphore

C Specification
To create a semaphore whose payload can be exported to external handles, add the VkExportSemaphoreCreateInfo structure to the pNext chain of the VkSemaphoreCreateInfo structure. The VkExportSemaphoreCreateInfo structure is defined as:

typedef struct VkExportSemaphoreCreateInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalSemaphoreHandleTypeFlags    handleTypes;
} VkExportSemaphoreCreateInfo;
or the equivalent

typedef VkExportSemaphoreCreateInfo VkExportSemaphoreCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
handleTypes is a bitmask of VkExternalSemaphoreHandleTypeFlagBits specifying one or more semaphore handle types the application can export from the resulting semaphore. The application can request multiple handle types for the same semaphore.
Description
Valid Usage
The bits in handleTypes must be supported and compatible, as reported by VkExternalSemaphoreProperties.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO
handleTypes must be a valid combination of VkExternalSemaphoreHandleTypeFlagBits values
See Also
VkExternalSemaphoreHandleTypeFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExportSemaphoreCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExportSemaphoreWin32HandleInfoKHR(3)
Name
VkExportSemaphoreWin32HandleInfoKHR - Structure specifying additional attributes of Windows handles exported from a semaphore

C Specification
To specify additional attributes of NT handles exported from a semaphore, add the VkExportSemaphoreWin32HandleInfoKHR structure to the pNext chain of the VkSemaphoreCreateInfo structure. The VkExportSemaphoreWin32HandleInfoKHR structure is defined as:

typedef struct VkExportSemaphoreWin32HandleInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    const SECURITY_ATTRIBUTES*    pAttributes;
    DWORD                         dwAccess;
    LPCWSTR                       name;
} VkExportSemaphoreWin32HandleInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
pAttributes is a pointer to a Windows SECURITY_ATTRIBUTES structure specifying security attributes of the handle.
dwAccess is a DWORD specifying access rights of the handle.
name is a NULL-terminated UTF-16 string to associate with the underlying synchronization primitive referenced by NT handles exported from the created semaphore.
Description
If this structure is not present, or if pAttributes is set to NULL, default security descriptor values will be used, and child processes created by the application will not inherit the handle, as described in the MSDN documentation for “Synchronization Object Security and Access Rights”1. Further, if the structure is not present, the access rights will be

DXGI_SHARED_RESOURCE_READ | DXGI_SHARED_RESOURCE_WRITE

for handles of the following types:

VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT

And

GENERIC_ALL

for handles of the following types:

VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT

1
https://msdn.microsoft.com/en-us/library/windows/desktop/ms686670.aspx
Valid Usage
If VkExportSemaphoreCreateInfo::handleTypes does not include VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT, VkExportSemaphoreWin32HandleInfoKHR must not be in the pNext chain of VkSemaphoreCreateInfo.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR
If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExportSemaphoreWin32HandleInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExtensionProperties(3)
Name
VkExtensionProperties - Structure specifying an extension properties

C Specification
The VkExtensionProperties structure is defined as:

typedef struct VkExtensionProperties {
    char        extensionName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
} VkExtensionProperties;
Members
extensionName is a null-terminated string specifying the name of the extension.
specVersion is the version of this extension. It is an integer, incremented with backward compatible changes.
Description
See Also
vkEnumerateDeviceExtensionProperties, vkEnumerateInstanceExtensionProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExtensionProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExtent2D(3)
Name
VkExtent2D - Structure specifying a two-dimensional extent

C Specification
A two-dimensional extent is defined by the structure:

typedef struct VkExtent2D {
    uint32_t    width;
    uint32_t    height;
} VkExtent2D;
Members
width is the width of the extent.
height is the height of the extent.
Description
See Also
VkDisplayModeParametersKHR, VkDisplayPlaneCapabilitiesKHR, VkDisplayPropertiesKHR, VkDisplaySurfaceCreateInfoKHR, VkMultisamplePropertiesEXT, VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceShadingRateImagePropertiesNV, VkRect2D, VkRectLayerKHR, VkSampleLocationsInfoEXT, VkSurfaceCapabilities2EXT, VkSurfaceCapabilitiesKHR, VkSwapchainCreateInfoKHR, vkGetRenderAreaGranularity

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExtent2D

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExtent3D(3)
Name
VkExtent3D - Structure specifying a three-dimensional extent

C Specification
A three-dimensional extent is defined by the structure:

typedef struct VkExtent3D {
    uint32_t    width;
    uint32_t    height;
    uint32_t    depth;
} VkExtent3D;
Members
width is the width of the extent.
height is the height of the extent.
depth is the depth of the extent.
Description
See Also
VkBufferImageCopy, VkImageCopy, VkImageCreateInfo, VkImageFormatProperties, VkImageResolve, VkQueueFamilyProperties, VkSparseImageFormatProperties, VkSparseImageMemoryBind

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExtent3D

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalBufferProperties(3)
Name
VkExternalBufferProperties - Structure specifying supported external handle capabilities

C Specification
The VkExternalBufferProperties structure is defined as:

typedef struct VkExternalBufferProperties {
    VkStructureType               sType;
    void*                         pNext;
    VkExternalMemoryProperties    externalMemoryProperties;
} VkExternalBufferProperties;
or the equivalent

typedef VkExternalBufferProperties VkExternalBufferPropertiesKHR;
Members
sType is the type of this structure
pNext is NULL or a pointer to an extension-specific structure.
externalMemoryProperties is an instance of the VkExternalMemoryProperties structure specifying various capabilities of the external handle type when used with the specified buffer creation parameters.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES
pNext must be NULL
See Also
VkExternalMemoryProperties, VkStructureType, vkGetPhysicalDeviceExternalBufferProperties, vkGetPhysicalDeviceExternalBufferPropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalBufferProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalFenceProperties(3)
Name
VkExternalFenceProperties - Structure describing supported external fence handle features

C Specification
The VkExternalFenceProperties structure is defined as:

typedef struct VkExternalFenceProperties {
    VkStructureType                   sType;
    void*                             pNext;
    VkExternalFenceHandleTypeFlags    exportFromImportedHandleTypes;
    VkExternalFenceHandleTypeFlags    compatibleHandleTypes;
    VkExternalFenceFeatureFlags       externalFenceFeatures;
} VkExternalFenceProperties;
or the equivalent

typedef VkExternalFenceProperties VkExternalFencePropertiesKHR;
Members
exportFromImportedHandleTypes is a bitmask of VkExternalFenceHandleTypeFlagBits indicating which types of imported handle handleType can be exported from.
compatibleHandleTypes is a bitmask of VkExternalFenceHandleTypeFlagBits specifying handle types which can be specified at the same time as handleType when creating a fence.
externalFenceFeatures is a bitmask of VkExternalFenceFeatureFlagBits indicating the features of handleType.
Description
If handleType is not supported by the implementation, then VkExternalFenceProperties::externalFenceFeatures will be set to zero.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES
pNext must be NULL
See Also
VkExternalFenceFeatureFlags, VkExternalFenceHandleTypeFlags, VkStructureType, vkGetPhysicalDeviceExternalFenceProperties, vkGetPhysicalDeviceExternalFencePropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalFenceProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalFormatANDROID(3)
Name
VkExternalFormatANDROID - Structure containing an Android hardware buffer external format

C Specification
To create an image with an external format, include an instance of VkExternalFormatANDROID in the pNext chain of VkImageCreateInfo. VkExternalFormatANDROID is defined as:

typedef struct VkExternalFormatANDROID {
    VkStructureType    sType;
    void*              pNext;
    uint64_t           externalFormat;
} VkExternalFormatANDROID;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
externalFormat is an implementation-defined identifier for the external format
Description
If externalFormat is zero, the effect is as if the VkExternalFormatANDROID structure was not present. Otherwise, the image will have the specified external format.

Valid Usage
externalFormat must be 0 or a value returned in the externalFormat member of VkAndroidHardwareBufferFormatPropertiesANDROID by an earlier call to vkGetAndroidHardwareBufferPropertiesANDROID
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalFormatANDROID

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalImageFormatProperties(3)
Name
VkExternalImageFormatProperties - Structure specifying supported external handle properties

C Specification
The VkExternalImageFormatProperties structure is defined as:

typedef struct VkExternalImageFormatProperties {
    VkStructureType               sType;
    void*                         pNext;
    VkExternalMemoryProperties    externalMemoryProperties;
} VkExternalImageFormatProperties;
or the equivalent

typedef VkExternalImageFormatProperties VkExternalImageFormatPropertiesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
externalMemoryProperties is an instance of the VkExternalMemoryProperties structure specifying various capabilities of the external handle type when used with the specified image creation parameters.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES
See Also
VkExternalMemoryProperties, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalImageFormatProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalImageFormatPropertiesNV(3)
Name
VkExternalImageFormatPropertiesNV - Structure specifying external image format properties

C Specification
The VkExternalImageFormatPropertiesNV structure is defined as:

typedef struct VkExternalImageFormatPropertiesNV {
    VkImageFormatProperties              imageFormatProperties;
    VkExternalMemoryFeatureFlagsNV       externalMemoryFeatures;
    VkExternalMemoryHandleTypeFlagsNV    exportFromImportedHandleTypes;
    VkExternalMemoryHandleTypeFlagsNV    compatibleHandleTypes;
} VkExternalImageFormatPropertiesNV;
Members
imageFormatProperties will be filled in as when calling vkGetPhysicalDeviceImageFormatProperties, but the values returned may vary depending on the external handle type requested.
externalMemoryFeatures is a bitmask of VkExternalMemoryFeatureFlagBitsNV, indicating properties of the external memory handle type (vkGetPhysicalDeviceExternalImageFormatPropertiesNV::externalHandleType) being queried, or 0 if the external memory handle type is 0.
exportFromImportedHandleTypes is a bitmask of VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for every external handle type that may be used to create memory from which the handles of the type specified in vkGetPhysicalDeviceExternalImageFormatPropertiesNV::externalHandleType can be exported, or 0 if the external memory handle type is 0.
compatibleHandleTypes is a bitmask of VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for every external handle type that may be specified simultaneously with the handle type specified by vkGetPhysicalDeviceExternalImageFormatPropertiesNV::externalHandleType when calling vkAllocateMemory, or 0 if the external memory handle type is 0. compatibleHandleTypes will always contain vkGetPhysicalDeviceExternalImageFormatPropertiesNV::externalHandleType
Description
See Also
VkExternalMemoryFeatureFlagsNV, VkExternalMemoryHandleTypeFlagsNV, VkImageFormatProperties, vkGetPhysicalDeviceExternalImageFormatPropertiesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalImageFormatPropertiesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalMemoryBufferCreateInfo(3)
Name
VkExternalMemoryBufferCreateInfo - Specify that a buffer may be backed by external memory

C Specification
To define a set of external memory handle types that may be used as backing store for a buffer, add a VkExternalMemoryBufferCreateInfo structure to the pNext chain of the VkBufferCreateInfo structure. The VkExternalMemoryBufferCreateInfo structure is defined as:

typedef struct VkExternalMemoryBufferCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkExternalMemoryHandleTypeFlags    handleTypes;
} VkExternalMemoryBufferCreateInfo;
or the equivalent

typedef VkExternalMemoryBufferCreateInfo VkExternalMemoryBufferCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
handleTypes is a bitmask of VkExternalMemoryHandleTypeFlagBits specifying one or more external memory handle types.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO
handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values
See Also
VkExternalMemoryHandleTypeFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalMemoryBufferCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalMemoryImageCreateInfo(3)
Name
VkExternalMemoryImageCreateInfo - Specify that an image may be backed by external memory

C Specification
To define a set of external memory handle types that may be used as backing store for an image, add a VkExternalMemoryImageCreateInfo structure to the pNext chain of the VkImageCreateInfo structure. The VkExternalMemoryImageCreateInfo structure is defined as:

typedef struct VkExternalMemoryImageCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkExternalMemoryHandleTypeFlags    handleTypes;
} VkExternalMemoryImageCreateInfo;
or the equivalent

typedef VkExternalMemoryImageCreateInfo VkExternalMemoryImageCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
handleTypes is a bitmask of VkExternalMemoryHandleTypeFlagBits specifying one or more external memory handle types.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO
handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values
handleTypes must not be 0
See Also
VkExternalMemoryHandleTypeFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalMemoryImageCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalMemoryImageCreateInfoNV(3)
Name
VkExternalMemoryImageCreateInfoNV - Specify that an image may be backed by external memory

C Specification
If the pNext chain includes a VkExternalMemoryImageCreateInfoNV structure, then that structure defines a set of external memory handle types that may be used as backing store for the image.

The VkExternalMemoryImageCreateInfoNV structure is defined as:

typedef struct VkExternalMemoryImageCreateInfoNV {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleTypes;
} VkExternalMemoryImageCreateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
handleTypes is a bitmask of VkExternalMemoryHandleTypeFlagBitsNV specifying one or more external memory handle types.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV
handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values
See Also
VkExternalMemoryHandleTypeFlagsNV, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalMemoryImageCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalMemoryProperties(3)
Name
VkExternalMemoryProperties - Structure specifying external memory handle type capabilities

C Specification
The VkExternalMemoryProperties structure is defined as:

typedef struct VkExternalMemoryProperties {
    VkExternalMemoryFeatureFlags       externalMemoryFeatures;
    VkExternalMemoryHandleTypeFlags    exportFromImportedHandleTypes;
    VkExternalMemoryHandleTypeFlags    compatibleHandleTypes;
} VkExternalMemoryProperties;
or the equivalent

typedef VkExternalMemoryProperties VkExternalMemoryPropertiesKHR;
Members
externalMemoryFeatures is a bitmask of VkExternalMemoryFeatureFlagBits specifying the features of handleType.
exportFromImportedHandleTypes is a bitmask of VkExternalMemoryHandleTypeFlagBits specifying which types of imported handle handleType can be exported from.
compatibleHandleTypes is a bitmask of VkExternalMemoryHandleTypeFlagBits specifying handle types which can be specified at the same time as handleType when creating an image compatible with external memory.
Description
compatibleHandleTypes must include at least handleType. Inclusion of a handle type in compatibleHandleTypes does not imply the values returned in VkImageFormatProperties2 will be the same when VkPhysicalDeviceExternalImageFormatInfo::handleType is set to that type. The application is responsible for querying the capabilities of all handle types intended for concurrent use in a single image and intersecting them to obtain the compatible set of capabilities.

See Also
VkExternalBufferProperties, VkExternalImageFormatProperties, VkExternalMemoryFeatureFlags, VkExternalMemoryHandleTypeFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalMemoryProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalSemaphoreProperties(3)
Name
VkExternalSemaphoreProperties - Structure describing supported external semaphore handle features

C Specification
The VkExternalSemaphoreProperties structure is defined as:

typedef struct VkExternalSemaphoreProperties {
    VkStructureType                       sType;
    void*                                 pNext;
    VkExternalSemaphoreHandleTypeFlags    exportFromImportedHandleTypes;
    VkExternalSemaphoreHandleTypeFlags    compatibleHandleTypes;
    VkExternalSemaphoreFeatureFlags       externalSemaphoreFeatures;
} VkExternalSemaphoreProperties;
or the equivalent

typedef VkExternalSemaphoreProperties VkExternalSemaphorePropertiesKHR;
Members
exportFromImportedHandleTypes is a bitmask of VkExternalSemaphoreHandleTypeFlagBits specifying which types of imported handle handleType can be exported from.
compatibleHandleTypes is a bitmask of VkExternalSemaphoreHandleTypeFlagBits specifying handle types which can be specified at the same time as handleType when creating a semaphore.
externalSemaphoreFeatures is a bitmask of VkExternalSemaphoreFeatureFlagBits describing the features of handleType.
Description
If handleType is not supported by the implementation, then VkExternalSemaphoreProperties::externalSemaphoreFeatures will be set to zero.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES
pNext must be NULL
See Also
VkExternalSemaphoreFeatureFlags, VkExternalSemaphoreHandleTypeFlags, VkStructureType, vkGetPhysicalDeviceExternalSemaphoreProperties, vkGetPhysicalDeviceExternalSemaphorePropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalSemaphoreProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFenceCreateInfo(3)
Name
VkFenceCreateInfo - Structure specifying parameters of a newly created fence

C Specification
The VkFenceCreateInfo structure is defined as:

typedef struct VkFenceCreateInfo {
    VkStructureType       sType;
    const void*           pNext;
    VkFenceCreateFlags    flags;
} VkFenceCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkFenceCreateFlagBits specifying the initial state and behavior of the fence.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkExportFenceCreateInfo or VkExportFenceWin32HandleInfoKHR
Each sType member in the pNext chain must be unique
flags must be a valid combination of VkFenceCreateFlagBits values
See Also
VkFenceCreateFlags, VkStructureType, vkCreateFence

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFenceCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFenceGetFdInfoKHR(3)
Name
VkFenceGetFdInfoKHR - Structure describing a POSIX FD fence export operation

C Specification
The VkFenceGetFdInfoKHR structure is defined as:

typedef struct VkFenceGetFdInfoKHR {
    VkStructureType                      sType;
    const void*                          pNext;
    VkFence                              fence;
    VkExternalFenceHandleTypeFlagBits    handleType;
} VkFenceGetFdInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
fence is the fence from which state will be exported.
handleType is the type of handle requested.
Description
The properties of the file descriptor returned depend on the value of handleType. See VkExternalFenceHandleTypeFlagBits for a description of the properties of the defined external fence handle types.

Valid Usage
handleType must have been included in VkExportFenceCreateInfo::handleTypes when fence’s current payload was created.
If handleType refers to a handle type with copy payload transference semantics, fence must be signaled, or have an associated fence signal operation pending execution.
fence must not currently have its payload replaced by an imported payload as described below in Importing Fence Payloads unless that imported payload’s handle type was included in VkExternalFenceProperties::exportFromImportedHandleTypes for handleType.
handleType must be defined as a POSIX file descriptor handle.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR
pNext must be NULL
fence must be a valid VkFence handle
handleType must be a valid VkExternalFenceHandleTypeFlagBits value
See Also
VkExternalFenceHandleTypeFlagBits, VkFence, VkStructureType, vkGetFenceFdKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFenceGetFdInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFenceGetWin32HandleInfoKHR(3)
Name
VkFenceGetWin32HandleInfoKHR - Structure describing a Win32 handle fence export operation

C Specification
The VkFenceGetWin32HandleInfoKHR structure is defined as:

typedef struct VkFenceGetWin32HandleInfoKHR {
    VkStructureType                      sType;
    const void*                          pNext;
    VkFence                              fence;
    VkExternalFenceHandleTypeFlagBits    handleType;
} VkFenceGetWin32HandleInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
fence is the fence from which state will be exported.
handleType is the type of handle requested.
Description
The properties of the handle returned depend on the value of handleType. See VkExternalFenceHandleTypeFlagBits for a description of the properties of the defined external fence handle types.

Valid Usage
handleType must have been included in VkExportFenceCreateInfo::handleTypes when the fence’s current payload was created.
If handleType is defined as an NT handle, vkGetFenceWin32HandleKHR must be called no more than once for each valid unique combination of fence and handleType.
fence must not currently have its payload replaced by an imported payload as described below in Importing Fence Payloads unless that imported payload’s handle type was included in VkExternalFenceProperties::exportFromImportedHandleTypes for handleType.
If handleType refers to a handle type with copy payload transference semantics, fence must be signaled, or have an associated fence signal operation pending execution.
handleType must be defined as an NT handle or a global share handle.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR
pNext must be NULL
fence must be a valid VkFence handle
handleType must be a valid VkExternalFenceHandleTypeFlagBits value
See Also
VkExternalFenceHandleTypeFlagBits, VkFence, VkStructureType, vkGetFenceWin32HandleKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFenceGetWin32HandleInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFilterCubicImageViewImageFormatPropertiesEXT(3)
Name
VkFilterCubicImageViewImageFormatPropertiesEXT - Structure for querying cubic filtering capabilities of an image view type

C Specification
The VkFilterCubicImageViewImageFormatPropertiesEXT structure is defined as:

typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           filterCubic;
    VkBool32           filterCubicMinmax ;
} VkFilterCubicImageViewImageFormatPropertiesEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
filterCubic tells if image format, image type and image view type can be used with cubic filtering. This field is set by the implementation. User-specified value is ignored.
filterCubicMinmax tells if image format, image type and image view type can be used with cubic filtering and minmax filtering. This field is set by the implementation. User-specified value is ignored.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT
Valid Usage
If the pNext chain of the VkImageFormatProperties2 structure contains an instance of VkFilterCubicImageViewImageFormatPropertiesEXT, the pNext chain of the VkPhysicalDeviceImageFormatInfo2 structure must contain an instance of VkPhysicalDeviceImageViewImageFormatInfoEXT with an imageViewType that is compatible with imageType.
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFilterCubicImageViewImageFormatPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFormatProperties(3)
Name
VkFormatProperties - Structure specifying image format properties

C Specification
The VkFormatProperties structure is defined as:

typedef struct VkFormatProperties {
    VkFormatFeatureFlags    linearTilingFeatures;
    VkFormatFeatureFlags    optimalTilingFeatures;
    VkFormatFeatureFlags    bufferFeatures;
} VkFormatProperties;
Members
linearTilingFeatures is a bitmask of VkFormatFeatureFlagBits specifying features supported by images created with a tiling parameter of VK_IMAGE_TILING_LINEAR.
optimalTilingFeatures is a bitmask of VkFormatFeatureFlagBits specifying features supported by images created with a tiling parameter of VK_IMAGE_TILING_OPTIMAL.
bufferFeatures is a bitmask of VkFormatFeatureFlagBits specifying features supported by buffers.
Description
Note
If no format feature flags are supported, the format itself is not supported, and images of that format cannot be created.
If format is a block-compressed format, then bufferFeatures must not support any features for the format.

If format is not a multi-plane format then linearTilingFeatures and optimalTilingFeatures must not contain VK_FORMAT_FEATURE_DISJOINT_BIT.

See Also
VkFormatFeatureFlags, VkFormatProperties2, vkGetPhysicalDeviceFormatProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFormatProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFormatProperties2(3)
Name
VkFormatProperties2 - Structure specifying image format properties

C Specification
The VkFormatProperties2 structure is defined as:

typedef struct VkFormatProperties2 {
    VkStructureType       sType;
    void*                 pNext;
    VkFormatProperties    formatProperties;
} VkFormatProperties2;
or the equivalent

typedef VkFormatProperties2 VkFormatProperties2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
formatProperties is a structure of type VkFormatProperties describing features supported by the requested format.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2
pNext must be NULL or a pointer to a valid instance of VkDrmFormatModifierPropertiesListEXT
See Also
VkFormatProperties, VkStructureType, vkGetPhysicalDeviceFormatProperties2, vkGetPhysicalDeviceFormatProperties2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFormatProperties2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFramebufferCreateInfo(3)
Name
VkFramebufferCreateInfo - Structure specifying parameters of a newly created framebuffer

C Specification
The VkFramebufferCreateInfo structure is defined as:

typedef struct VkFramebufferCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkFramebufferCreateFlags    flags;
    VkRenderPass                renderPass;
    uint32_t                    attachmentCount;
    const VkImageView*          pAttachments;
    uint32_t                    width;
    uint32_t                    height;
    uint32_t                    layers;
} VkFramebufferCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
renderPass is a render pass that defines what render passes the framebuffer will be compatible with. See Render Pass Compatibility for details.
attachmentCount is the number of attachments.
pAttachments is an array of VkImageView handles, each of which will be used as the corresponding attachment in a render pass instance.
width, height and layers define the dimensions of the framebuffer. If the render pass uses multiview, then layers must be one and each attachment requires a number of layers that is greater than the maximum bit index set in the view mask in the subpasses in which it is used.
Description
Applications must ensure that all accesses to memory that backs image subresources used as attachments in a given renderpass instance either happen-before the load operations for those attachments, or happen-after the store operations for those attachments.

For depth/stencil attachments, each aspect can be used separately as attachments and non-attachments as long as the non-attachment accesses are also via an image subresource in either the VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL layout or the VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL layout, and the attachment resource uses whichever of those two layouts the image accesses do not. Use of non-attachment aspects in this case is only well defined if the attachment is used in the subpass where the non-attachment access is being made, or the layout of the image subresource is constant throughout the entire render pass instance, including the initialLayout and finalLayout.

Note
These restrictions mean that the render pass has full knowledge of all uses of all of the attachments, so that the implementation is able to make correct decisions about when and how to perform layout transitions, when to overlap execution of subpasses, etc.
It is legal for a subpass to use no color or depth/stencil attachments, and rather use shader side effects such as image stores and atomics to produce an output. In this case, the subpass continues to use the width, height, and layers of the framebuffer to define the dimensions of the rendering area, and the rasterizationSamples from each pipeline’s VkPipelineMultisampleStateCreateInfo to define the number of samples used in rasterization; however, if VkPhysicalDeviceFeatures::variableMultisampleRate is VK_FALSE, then all pipelines to be bound with a given zero-attachment subpass must have the same value for VkPipelineMultisampleStateCreateInfo::rasterizationSamples.

Valid Usage
attachmentCount must be equal to the attachment count specified in renderPass
Each element of pAttachments that is used as a color attachment or resolve attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT
Each element of pAttachments that is used as a depth/stencil attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
Each element of pAttachments that is used as a depth/stencil resolve attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
Each element of pAttachments that is used as an input attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
Each element of pAttachments that is used as a fragment density map attachment by renderPass must not have been created with a flags value including VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT.
If renderPass has a fragment density map attachment and non-subsample image feature is not enabled, each element of pAttachments must have been created with a flags value including VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT unless that element is the fragment density map attachment.
Each element of pAttachments must have been created with an VkFormat value that matches the VkFormat specified by the corresponding VkAttachmentDescription in renderPass
Each element of pAttachments must have been created with a samples value that matches the samples value specified by the corresponding VkAttachmentDescription in renderPass
Each element of pAttachments must have dimensions at least as large as the corresponding framebuffer dimension except for any element that is referenced by fragmentDensityMapAttachment
An element of pAttachments that is referenced by fragmentDensityMapAttachment must have a width at least as large as \(\lceil{\frac{width}{maxFragmentDensityTexelSize_{width}}}\rceil\)
An element of pAttachments that is referenced by fragmentDensityMapAttachment must have a height at least as large as \(\lceil{\frac{height}{maxFragmentDensityTexelSize_{height}}}\rceil\)
Each element of pAttachments must only specify a single mip level
Each element of pAttachments must have been created with the identity swizzle
width must be greater than 0.
width must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferWidth
height must be greater than 0.
height must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferHeight
layers must be greater than 0.
layers must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferLayers
Each element of pAttachments that is a 2D or 2D array image view taken from a 3D image must not be a depth/stencil format
If renderPass was specified with non-zero view masks, layers must be greater than or equal to the greatest position of any bit included in any of those view masks
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
pNext must be NULL
flags must be 0
renderPass must be a valid VkRenderPass handle
If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkImageView handles
Both of renderPass, and the elements of pAttachments that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkFramebufferCreateFlags, VkImageView, VkRenderPass, VkStructureType, vkCreateFramebuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFramebufferCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkGeometryAABBNV(3)
Name
VkGeometryAABBNV - Structure specifying axis-aligned bounding box geometry in a bottom-level acceleration structure

C Specification
The VkGeometryAABBNV structure is defined as:

typedef struct VkGeometryAABBNV {
    VkStructureType    sType;
    const void*        pNext;
    VkBuffer           aabbData;
    uint32_t           numAABBs;
    uint32_t           stride;
    VkDeviceSize       offset;
} VkGeometryAABBNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
aabbData is the buffer containing axis-aligned bounding box data.
numAABBs is the number of AABBs in this geometry.
stride is the stride in bytes between AABBs in aabbData.
offset is the offset in bytes of the first AABB in aabbData.
Description
The AABB data in memory is six 32-bit floats consisting of the minimum x, y, and z values followed by the maximum x, y, and z values.

Valid Usage
offset must be less than the size of aabbData
offset must be a multiple of 8
stride must be a multiple of 8
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV
pNext must be NULL
If aabbData is not VK_NULL_HANDLE, aabbData must be a valid VkBuffer handle
See Also
VkBuffer, VkDeviceSize, VkGeometryDataNV, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkGeometryAABBNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkGeometryDataNV(3)
Name
VkGeometryDataNV - Structure specifying geometry in a bottom-level acceleration structure

C Specification
The VkGeometryDataNV structure is defined as:

typedef struct VkGeometryDataNV {
    VkGeometryTrianglesNV    triangles;
    VkGeometryAABBNV         aabbs;
} VkGeometryDataNV;
Members
triangles contains triangle data if VkGeometryNV::geometryType is VK_GEOMETRY_TYPE_TRIANGLES_NV.
aabbs contains axis-aligned bounding box data if VkGeometryNV::geometryType is VK_GEOMETRY_TYPE_AABBS_NV.
Description
Valid Usage (Implicit)
triangles must be a valid VkGeometryTrianglesNV structure
aabbs must be a valid VkGeometryAABBNV structure
See Also
VkGeometryAABBNV, VkGeometryNV, VkGeometryTrianglesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkGeometryDataNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkGeometryNV(3)
Name
VkGeometryNV - Structure specifying a geometry in a bottom-level acceleration structure

C Specification
The VkGeometryNV structure is defined as:

typedef struct VkGeometryNV {
    VkStructureType      sType;
    const void*          pNext;
    VkGeometryTypeNV     geometryType;
    VkGeometryDataNV     geometry;
    VkGeometryFlagsNV    flags;
} VkGeometryNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
geometryType describes which type of geometry this VkGeometryNV refers to.
geometry contains the geometry data as described in VkGeometryDataNV.
flags has flags describing options for this geometry.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_GEOMETRY_NV
pNext must be NULL
geometryType must be a valid VkGeometryTypeNV value
geometry must be a valid VkGeometryDataNV structure
flags must be a valid combination of VkGeometryFlagBitsNV values
See Also
VkAccelerationStructureInfoNV, VkGeometryDataNV, VkGeometryFlagsNV, VkGeometryTypeNV, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkGeometryNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkGeometryTrianglesNV(3)
Name
VkGeometryTrianglesNV - Structure specifying a triangle geometry in a bottom-level acceleration structure

C Specification
The VkGeometryTrianglesNV structure is defined as:

typedef struct VkGeometryTrianglesNV {
    VkStructureType    sType;
    const void*        pNext;
    VkBuffer           vertexData;
    VkDeviceSize       vertexOffset;
    uint32_t           vertexCount;
    VkDeviceSize       vertexStride;
    VkFormat           vertexFormat;
    VkBuffer           indexData;
    VkDeviceSize       indexOffset;
    uint32_t           indexCount;
    VkIndexType        indexType;
    VkBuffer           transformData;
    VkDeviceSize       transformOffset;
} VkGeometryTrianglesNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
vertexData is the buffer containing vertex data for this geometry.
vertexOffset is the offset in bytes within vertexData containing vertex data for this geometry.
vertexCount is the number of valid vertices.
vertexStride is the stride in bytes between each vertex.
vertexFormat is the format of each vertex element.
indexData is the buffer containing index data for this geometry.
indexOffset is the offset in bytes within indexData containing index data for this geometry.
indexCount is the number of indices to include in this geometry.
indexType is the format of each index.
transformData is a buffer containing optional reference to an array of 32-bit floats representing a 3x4 row major affine transformation matrix for this geometry.
transformOffset is the offset in bytes in transformData of the transform information described above.
Description
If indexType is VK_INDEX_TYPE_NONE_NV, then this structure describes a set of triangles determined by vertexCount. Otherwise, this structure describes a set of indexed triangles determined by indexCount.

Valid Usage
vertexOffset must be less than the size of vertexData
vertexOffset must be a multiple of the component size of vertexFormat
vertexFormat must be one of VK_FORMAT_R32G32B32_SFLOAT, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R16G16B16_SFLOAT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R16G16_SNORM, or VK_FORMAT_R16G16B16_SNORM
indexOffset must be less than the size of indexData
indexOffset must be a multiple of the element size of indexType
indexType must be VK_INDEX_TYPE_UINT16, VK_INDEX_TYPE_UINT32, or VK_INDEX_TYPE_NONE_NV
indexData must be VK_NULL_HANDLE if indexType is VK_INDEX_TYPE_NONE_NV
indexData must be a valid VkBuffer handle if indexType is not VK_INDEX_TYPE_NONE_NV
indexCount must be 0 if indexType is VK_INDEX_TYPE_NONE_NV
transformOffset must be less than the size of transformData
transformOffset must be a multiple of 16
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV
pNext must be NULL
If vertexData is not VK_NULL_HANDLE, vertexData must be a valid VkBuffer handle
vertexFormat must be a valid VkFormat value
If indexData is not VK_NULL_HANDLE, indexData must be a valid VkBuffer handle
indexType must be a valid VkIndexType value
If transformData is not VK_NULL_HANDLE, transformData must be a valid VkBuffer handle
Each of indexData, transformData, and vertexData that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkBuffer, VkDeviceSize, VkFormat, VkGeometryDataNV, VkIndexType, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkGeometryTrianglesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkGraphicsPipelineCreateInfo(3)
Name
VkGraphicsPipelineCreateInfo - Structure specifying parameters of a newly created graphics pipeline

C Specification
The VkGraphicsPipelineCreateInfo structure is defined as:

typedef struct VkGraphicsPipelineCreateInfo {
    VkStructureType                                  sType;
    const void*                                      pNext;
    VkPipelineCreateFlags                            flags;
    uint32_t                                         stageCount;
    const VkPipelineShaderStageCreateInfo*           pStages;
    const VkPipelineVertexInputStateCreateInfo*      pVertexInputState;
    const VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;
    const VkPipelineTessellationStateCreateInfo*     pTessellationState;
    const VkPipelineViewportStateCreateInfo*         pViewportState;
    const VkPipelineRasterizationStateCreateInfo*    pRasterizationState;
    const VkPipelineMultisampleStateCreateInfo*      pMultisampleState;
    const VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;
    const VkPipelineColorBlendStateCreateInfo*       pColorBlendState;
    const VkPipelineDynamicStateCreateInfo*          pDynamicState;
    VkPipelineLayout                                 layout;
    VkRenderPass                                     renderPass;
    uint32_t                                         subpass;
    VkPipeline                                       basePipelineHandle;
    int32_t                                          basePipelineIndex;
} VkGraphicsPipelineCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkPipelineCreateFlagBits specifying how the pipeline will be generated.
stageCount is the number of entries in the pStages array.
pStages is an array of size stageCount structures of type VkPipelineShaderStageCreateInfo describing the set of the shader stages to be included in the graphics pipeline.
pVertexInputState is a pointer to an instance of the VkPipelineVertexInputStateCreateInfo structure. It is ignored if the pipeline includes a mesh shader stage.
pInputAssemblyState is a pointer to an instance of the VkPipelineInputAssemblyStateCreateInfo structure which determines input assembly behavior, as described in Drawing Commands. It is ignored if the pipeline includes a mesh shader stage.
pTessellationState is a pointer to an instance of the VkPipelineTessellationStateCreateInfo structure, and is ignored if the pipeline does not include a tessellation control shader stage and tessellation evaluation shader stage.
pViewportState is a pointer to an instance of the VkPipelineViewportStateCreateInfo structure, and is ignored if the pipeline has rasterization disabled.
pRasterizationState is a pointer to an instance of the VkPipelineRasterizationStateCreateInfo structure.
pMultisampleState is a pointer to an instance of the VkPipelineMultisampleStateCreateInfo, and is ignored if the pipeline has rasterization disabled.
pDepthStencilState is a pointer to an instance of the VkPipelineDepthStencilStateCreateInfo structure, and is ignored if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use a depth/stencil attachment.
pColorBlendState is a pointer to an instance of the VkPipelineColorBlendStateCreateInfo structure, and is ignored if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use any color attachments.
pDynamicState is a pointer to VkPipelineDynamicStateCreateInfo and is used to indicate which properties of the pipeline state object are dynamic and can be changed independently of the pipeline state. This can be NULL, which means no state in the pipeline is considered dynamic.
layout is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
renderPass is a handle to a render pass object describing the environment in which the pipeline will be used; the pipeline must only be used with an instance of any render pass compatible with the one provided. See Render Pass Compatibility for more information.
subpass is the index of the subpass in the render pass where this pipeline will be used.
basePipelineHandle is a pipeline to derive from.
basePipelineIndex is an index into the pCreateInfos parameter to use as a pipeline to derive from.
Description
The parameters basePipelineHandle and basePipelineIndex are described in more detail in Pipeline Derivatives.

pStages points to an array of VkPipelineShaderStageCreateInfo structures, which were previously described in Compute Pipelines.

pDynamicState points to a structure of type VkPipelineDynamicStateCreateInfo.

If any shader stage fails to compile, the compile log will be reported back to the application, and VK_ERROR_INVALID_SHADER_NV will be generated.

Valid Usage
If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is -1, basePipelineHandle must be a valid handle to a graphics VkPipeline
If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command’s pCreateInfos parameter
If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE
If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is not VK_NULL_HANDLE, basePipelineIndex must be -1
The stage member of each element of pStages must be unique
The geometric shader stages provided in pStages must be either from the mesh shading pipeline (stage is VK_SHADER_STAGE_TASK_BIT_NV or VK_SHADER_STAGE_MESH_BIT_NV) or from the primitive shading pipeline (stage is VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, or VK_SHADER_STAGE_GEOMETRY_BIT).
The stage member of one element of pStages must be either VK_SHADER_STAGE_VERTEX_BIT or VK_SHADER_STAGE_MESH_BIT_NV.
The stage member of each element of pStages must not be VK_SHADER_STAGE_COMPUTE_BIT
If pStages includes a tessellation control shader stage, it must include a tessellation evaluation shader stage
If pStages includes a tessellation evaluation shader stage, it must include a tessellation control shader stage
If pStages includes a tessellation control shader stage and a tessellation evaluation shader stage, pTessellationState must be a valid pointer to a valid VkPipelineTessellationStateCreateInfo structure
If pStages includes tessellation shader stages, the shader code of at least one stage must contain an OpExecutionMode instruction that specifies the type of subdivision in the pipeline
If pStages includes tessellation shader stages, and the shader code of both stages contain an OpExecutionMode instruction that specifies the type of subdivision in the pipeline, they must both specify the same subdivision mode
If pStages includes tessellation shader stages, the shader code of at least one stage must contain an OpExecutionMode instruction that specifies the output patch size in the pipeline
If pStages includes tessellation shader stages, and the shader code of both contain an OpExecutionMode instruction that specifies the out patch size in the pipeline, they must both specify the same patch size
If pStages includes tessellation shader stages, the topology member of pInputAssembly must be VK_PRIMITIVE_TOPOLOGY_PATCH_LIST
If the topology member of pInputAssembly is VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, pStages must include tessellation shader stages
If pStages includes a geometry shader stage, and does not include any tessellation shader stages, its shader code must contain an OpExecutionMode instruction that specifies an input primitive type that is compatible with the primitive topology specified in pInputAssembly
If pStages includes a geometry shader stage, and also includes tessellation shader stages, its shader code must contain an OpExecutionMode instruction that specifies an input primitive type that is compatible with the primitive topology that is output by the tessellation stages
If pStages includes a fragment shader stage and a geometry shader stage, and the fragment shader code reads from an input variable that is decorated with PrimitiveID, then the geometry shader code must write to a matching output variable, decorated with PrimitiveID, in all execution paths
If pStages includes a fragment shader stage, its shader code must not read from any input attachment that is defined as VK_ATTACHMENT_UNUSED in subpass
The shader code for the entry points identified by pStages, and the rest of the state identified by this structure must adhere to the pipeline linking rules described in the Shader Interfaces chapter
If rasterization is not disabled and subpass uses a depth/stencil attachment in renderPass that has a layout of VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL in the VkAttachmentReference defined by subpass, the depthWriteEnable member of pDepthStencilState must be VK_FALSE
If rasterization is not disabled and subpass uses a depth/stencil attachment in renderPass that has a layout of VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL in the VkAttachmentReference defined by subpass, the failOp, passOp and depthFailOp members of each of the front and back members of pDepthStencilState must be VK_STENCIL_OP_KEEP
If rasterization is not disabled and the subpass uses color attachments, then for each color attachment in the subpass the blendEnable member of the corresponding element of the pAttachment member of pColorBlendState must be VK_FALSE if the attached image’s format features does not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT.
If rasterization is not disabled and the subpass uses color attachments, the attachmentCount member of pColorBlendState must be equal to the colorAttachmentCount used to create subpass
If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_VIEWPORT, the pViewports member of pViewportState must be a valid pointer to an array of pViewportState::viewportCount valid VkViewport structures
If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SCISSOR, the pScissors member of pViewportState must be a valid pointer to an array of pViewportState::scissorCount VkRect2D structures
If the wide lines feature is not enabled, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_LINE_WIDTH, the lineWidth member of pRasterizationState must be 1.0
If the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, pViewportState must be a valid pointer to a valid VkPipelineViewportStateCreateInfo structure
If the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, pMultisampleState must be a valid pointer to a valid VkPipelineMultisampleStateCreateInfo structure
If the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, and subpass uses a depth/stencil attachment, pDepthStencilState must be a valid pointer to a valid VkPipelineDepthStencilStateCreateInfo structure
If the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, and subpass uses color attachments, pColorBlendState must be a valid pointer to a valid VkPipelineColorBlendStateCreateInfo structure
If the depth bias clamping feature is not enabled, no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BIAS, and the depthBiasEnable member of pRasterizationState is VK_TRUE, the depthBiasClamp member of pRasterizationState must be 0.0
If the html/vkspec.html#VK_EXT_depth_range_unrestricted extension is not enabled and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the depthBoundsTestEnable member of pDepthStencilState is VK_TRUE, the minDepthBounds and maxDepthBounds members of pDepthStencilState must be between 0.0 and 1.0, inclusive
If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure chained to the pNext chain of pMultisampleState is VK_TRUE, sampleLocationsInfo.sampleLocationGridSize.width must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples
If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure chained to the pNext chain of pMultisampleState is VK_TRUE, sampleLocationsInfo.sampleLocationGridSize.height must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples
If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure chained to the pNext chain of pMultisampleState is VK_TRUE, sampleLocationsInfo.sampleLocationsPerPixel must equal rasterizationSamples
If the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure chained to the pNext chain of pMultisampleState is VK_TRUE, the fragment shader code must not statically use the extended instruction InterpolateAtSample
layout must be consistent with all shaders specified in pStages
If neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, and if subpass uses color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must be the same as the sample count for those subpass attachments
If the VK_AMD_mixed_attachment_samples extension is enabled, and if subpass uses color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must equal the maximum of the sample counts of those subpass attachments
If the VK_NV_framebuffer_mixed_samples extension is enabled, and if subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled, then the rasterizationSamples member of pMultisampleState must be the same as the sample count of the depth/stencil attachment
If the VK_NV_framebuffer_mixed_samples extension is enabled, and if subpass has any color attachments, then the rasterizationSamples member of pMultisampleState must be greater than or equal to the sample count for those subpass attachments
If subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must follow the rules for a zero-attachment subpass
subpass must be a valid subpass within renderPass
If the renderPass has multiview enabled and subpass has more than one bit set in the view mask and multiviewTessellationShader is not enabled, then pStages must not include tessellation shaders.
If the renderPass has multiview enabled and subpass has more than one bit set in the view mask and multiviewGeometryShader is not enabled, then pStages must not include a geometry shader.
If the renderPass has multiview enabled and subpass has more than one bit set in the view mask, shaders in the pipeline must not write to the Layer built-in output
If the renderPass has multiview enabled, then all shaders must not include variables decorated with the Layer built-in decoration in their interfaces.
flags must not contain the VK_PIPELINE_CREATE_DISPATCH_BASE flag.
If pStages includes a fragment shader stage and an input attachment was referenced by the VkRenderPassInputAttachmentAspectCreateInfo at renderPass create time, its shader code must not read from any aspect that was not specified in the aspectMask of the corresponding VkInputAttachmentAspectReference structure.
The number of resources in layout accessible to each shader stage that is used by the pipeline must be less than or equal to VkPhysicalDeviceLimits::maxPerStageResources
If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV, and the viewportWScalingEnable member of a VkPipelineViewportWScalingStateCreateInfoNV structure, chained to the pNext chain of pViewportState, is VK_TRUE, the pViewportWScalings member of the VkPipelineViewportWScalingStateCreateInfoNV must be a pointer to an array of VkPipelineViewportWScalingStateCreateInfoNV::viewportCount valid VkViewportWScalingNV structures
If pStages includes a vertex shader stage, pVertexInputState must be a valid pointer to a valid VkPipelineVertexInputStateCreateInfo structure
If pStages includes a vertex shader stage, pInputAssemblyState must be a valid pointer to a valid VkPipelineInputAssemblyStateCreateInfo structure
The Xfb execution mode can be specified by only one shader stage in pStages
If any shader stage in pStages specifies Xfb execution mode it must be the last vertex processing stage
If a VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream value other than zero is specified, all variables in the output interface of the entry point being compiled decorated with Position, PointSize, ClipDistance, or CullDistance must all be decorated with identical Stream values that match the rasterizationStream
If VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream is zero, or not specified, all variables in the output interface of the entry point being compiled decorated with Position, PointSize, ClipDistance, or CullDistance must all be decorated with a Stream value of zero, or must not specify the Stream decoration
If the last vertex processing stage is a geometry shader, and that geometry shader uses the GeometryStreams capability, then VkPhysicalDeviceTransformFeedbackFeaturesEXT::geometryStreams feature must be enabled
If there are any mesh shader stages in the pipeline there must not be any shader stage in the pipeline with a Xfb execution mode.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineCreationFeedbackCreateInfoEXT, VkPipelineDiscardRectangleStateCreateInfoEXT, or VkPipelineRepresentativeFragmentTestStateCreateInfoNV
Each sType member in the pNext chain must be unique
flags must be a valid combination of VkPipelineCreateFlagBits values
pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures
pRasterizationState must be a valid pointer to a valid VkPipelineRasterizationStateCreateInfo structure
If pDynamicState is not NULL, pDynamicState must be a valid pointer to a valid VkPipelineDynamicStateCreateInfo structure
layout must be a valid VkPipelineLayout handle
renderPass must be a valid VkRenderPass handle
stageCount must be greater than 0
Each of basePipelineHandle, layout, and renderPass that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkPipeline, VkPipelineColorBlendStateCreateInfo, VkPipelineCreateFlags, VkPipelineDepthStencilStateCreateInfo, VkPipelineDynamicStateCreateInfo, VkPipelineInputAssemblyStateCreateInfo, VkPipelineLayout, VkPipelineMultisampleStateCreateInfo, VkPipelineRasterizationStateCreateInfo, VkPipelineShaderStageCreateInfo, VkPipelineTessellationStateCreateInfo, VkPipelineVertexInputStateCreateInfo, VkPipelineViewportStateCreateInfo, VkRenderPass, VkStructureType, vkCreateGraphicsPipelines

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkGraphicsPipelineCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkHdrMetadataEXT(3)
Name
VkHdrMetadataEXT - structure to specify Hdr metadata

C Specification
typedef struct VkHdrMetadataEXT {
    VkStructureType    sType;
    const void*        pNext;
    VkXYColorEXT       displayPrimaryRed;
    VkXYColorEXT       displayPrimaryGreen;
    VkXYColorEXT       displayPrimaryBlue;
    VkXYColorEXT       whitePoint;
    float              maxLuminance;
    float              minLuminance;
    float              maxContentLightLevel;
    float              maxFrameAverageLightLevel;
} VkHdrMetadataEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
displayPrimaryRed is the mastering display’s red primary in chromaticity coordinates
displayPrimaryGreen is the mastering display’s green primary in chromaticity coordinates
displayPrimaryBlue is the mastering display’s blue primary in chromaticity coordinates
whitePoint is the mastering display’s white-point in chromaticity coordinates
maxLuminance is the maximum luminance of the mastering display in nits
minLuminance is the minimum luminance of the mastering display in nits
maxContentLightLevel is content’s maximum luminance in nits
maxFrameAverageLightLevel is the maximum frame average light level in nits
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_HDR_METADATA_EXT
pNext must be NULL
Note
The validity and use of this data is outside the scope of Vulkan.
See Also
VkStructureType, VkXYColorEXT, vkSetHdrMetadataEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkHdrMetadataEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkIOSSurfaceCreateInfoMVK(3)
Name
VkIOSSurfaceCreateInfoMVK - Structure specifying parameters of a newly created iOS surface object

C Specification
The VkIOSSurfaceCreateInfoMVK structure is defined as:

typedef struct VkIOSSurfaceCreateInfoMVK {
    VkStructureType               sType;
    const void*                   pNext;
    VkIOSSurfaceCreateFlagsMVK    flags;
    const void*                   pView;
} VkIOSSurfaceCreateInfoMVK;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
pView is a reference to a UIView object which will display this surface. This UIView must be backed by a CALayer instance of type CAMetalLayer.
Description
Valid Usage
pView must be a valid UIView and must be backed by a CALayer instance of type CAMetalLayer.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK
pNext must be NULL
flags must be 0
See Also
VkIOSSurfaceCreateFlagsMVK, VkStructureType, vkCreateIOSSurfaceMVK

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkIOSSurfaceCreateInfoMVK

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageBlit(3)
Name
VkImageBlit - Structure specifying an image blit operation

C Specification
The VkImageBlit structure is defined as:

typedef struct VkImageBlit {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffsets[2];
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffsets[2];
} VkImageBlit;
Members
srcSubresource is the subresource to blit from.
srcOffsets is an array of two VkOffset3D structures specifying the bounds of the source region within srcSubresource.
dstSubresource is the subresource to blit into.
dstOffsets is an array of two VkOffset3D structures specifying the bounds of the destination region within dstSubresource.
Description
For each element of the pRegions array, a blit operation is performed the specified source and destination regions.

Valid Usage
The aspectMask member of srcSubresource and dstSubresource must match
The layerCount member of srcSubresource and dstSubresource must match
If either of the calling command’s srcImage or dstImage parameters are of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of both srcSubresource and dstSubresource must be 0 and 1, respectively
The aspectMask member of srcSubresource must specify aspects present in the calling command’s srcImage
The aspectMask member of dstSubresource must specify aspects present in the calling command’s dstImage
srcOffset[0].x and srcOffset[1].x must both be greater than or equal to 0 and less than or equal to the source image subresource width
srcOffset[0].y and srcOffset[1].y must both be greater than or equal to 0 and less than or equal to the source image subresource height
If the calling command’s srcImage is of type VK_IMAGE_TYPE_1D, then srcOffset[0].y must be 0 and srcOffset[1].y must be 1.
srcOffset[0].z and srcOffset[1].z must both be greater than or equal to 0 and less than or equal to the source image subresource depth
If the calling command’s srcImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then srcOffset[0].z must be 0 and srcOffset[1].z must be 1.
dstOffset[0].x and dstOffset[1].x must both be greater than or equal to 0 and less than or equal to the destination image subresource width
dstOffset[0].y and dstOffset[1].y must both be greater than or equal to 0 and less than or equal to the destination image subresource height
If the calling command’s dstImage is of type VK_IMAGE_TYPE_1D, then dstOffset[0].y must be 0 and dstOffset[1].y must be 1.
dstOffset[0].z and dstOffset[1].z must both be greater than or equal to 0 and less than or equal to the destination image subresource depth
If the calling command’s dstImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then dstOffset[0].z must be 0 and dstOffset[1].z must be 1.
Valid Usage (Implicit)
srcSubresource must be a valid VkImageSubresourceLayers structure
dstSubresource must be a valid VkImageSubresourceLayers structure
See Also
VkImageSubresourceLayers, VkOffset3D, vkCmdBlitImage

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageBlit

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageCopy(3)
Name
VkImageCopy - Structure specifying an image copy operation

C Specification
The VkImageCopy structure is defined as:

typedef struct VkImageCopy {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageCopy;
Members
srcSubresource and dstSubresource are VkImageSubresourceLayers structures specifying the image subresources of the images used for the source and destination image data, respectively.
srcOffset and dstOffset select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data.
extent is the size in texels of the image to copy in width, height and depth.
Description
For VK_IMAGE_TYPE_3D images, copies are performed slice by slice starting with the z member of the srcOffset or dstOffset, and copying depth slices. For images with multiple layers, copies are performed layer by layer starting with the baseArrayLayer member of the srcSubresource or dstSubresource and copying layerCount layers. Image data can be copied between images with different image types. If one image is VK_IMAGE_TYPE_3D and the other image is VK_IMAGE_TYPE_2D with multiple layers, then each slice is copied to or from a different layer.

Copies involving a multi-planar image format specify the region to be copied in terms of the plane to be copied, not the coordinates of the multi-planar image. This means that copies accessing the R/B planes of “_422” format images must fit the copied region within half the width of the parent image, and that copies accessing the R/B planes of “_420” format images must fit the copied region within half the width and height of the parent image.

Valid Usage
If neither the calling command’s srcImage nor the calling command’s dstImage has a multi-planar image format then the aspectMask member of srcSubresource and dstSubresource must match
If the calling command’s srcImage has a VkFormat with two planes then the srcSubresource aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT
If the calling command’s srcImage has a VkFormat with three planes then the srcSubresource aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT
If the calling command’s dstImage has a VkFormat with two planes then the dstSubresource aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT
If the calling command’s dstImage has a VkFormat with three planes then the dstSubresource aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT
If the calling command’s srcImage has a multi-planar image format and the dstImage does not have a multi-planar image format, the dstSubresource aspectMask must be VK_IMAGE_ASPECT_COLOR_BIT
If the calling command’s dstImage has a multi-planar image format and the srcImage does not have a multi-planar image format, the srcSubresource aspectMask must be VK_IMAGE_ASPECT_COLOR_BIT
The number of slices of the extent (for 3D) or layers of the srcSubresource (for non-3D) must match the number of slices of the extent (for 3D) or layers of the dstSubresource (for non-3D)
If either of the calling command’s srcImage or dstImage parameters are of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of the corresponding subresource must be 0 and 1, respectively
The aspectMask member of srcSubresource must specify aspects present in the calling command’s srcImage
The aspectMask member of dstSubresource must specify aspects present in the calling command’s dstImage
srcOffset.x and (extent.width + srcOffset.x) must both be greater than or equal to 0 and less than or equal to the source image subresource width
srcOffset.y and (extent.height + srcOffset.y) must both be greater than or equal to 0 and less than or equal to the source image subresource height
If the calling command’s srcImage is of type VK_IMAGE_TYPE_1D, then srcOffset.y must be 0 and extent.height must be 1.
srcOffset.z and (extent.depth + srcOffset.z) must both be greater than or equal to 0 and less than or equal to the source image subresource depth
If the calling command’s srcImage is of type VK_IMAGE_TYPE_1D, then srcOffset.z must be 0 and extent.depth must be 1.
If the calling command’s dstImage is of type VK_IMAGE_TYPE_1D, then dstOffset.z must be 0 and extent.depth must be 1.
If the calling command’s srcImage is of type VK_IMAGE_TYPE_2D, then srcOffset.z must be 0.
If the calling command’s dstImage is of type VK_IMAGE_TYPE_2D, then dstOffset.z must be 0.
If both srcImage and dstImage are of type VK_IMAGE_TYPE_2D then extent.depth must be 1.
If the calling command’s srcImage is of type VK_IMAGE_TYPE_2D, and the dstImage is of type VK_IMAGE_TYPE_3D, then extent.depth must equal to the layerCount member of srcSubresource.
If the calling command’s dstImage is of type VK_IMAGE_TYPE_2D, and the srcImage is of type VK_IMAGE_TYPE_3D, then extent.depth must equal to the layerCount member of dstSubresource.
dstOffset.x and (extent.width + dstOffset.x) must both be greater than or equal to 0 and less than or equal to the destination image subresource width
dstOffset.y and (extent.height + dstOffset.y) must both be greater than or equal to 0 and less than or equal to the destination image subresource height
If the calling command’s dstImage is of type VK_IMAGE_TYPE_1D, then dstOffset.y must be 0 and extent.height must be 1.
dstOffset.z and (extent.depth + dstOffset.z) must both be greater than or equal to 0 and less than or equal to the destination image subresource depth
If the calling command’s srcImage is a compressed image, or a single-plane, “_422” image format, all members of srcOffset must be a multiple of the corresponding dimensions of the compressed texel block
If the calling command’s srcImage is a compressed image, or a single-plane, “_422” image format, extent.width must be a multiple of the compressed texel block width or (extent.width + srcOffset.x) must equal the source image subresource width
If the calling command’s srcImage is a compressed image, or a single-plane, “_422” image format, extent.height must be a multiple of the compressed texel block height or (extent.height + srcOffset.y) must equal the source image subresource height
If the calling command’s srcImage is a compressed image, or a single-plane, “_422” image format, extent.depth must be a multiple of the compressed texel block depth or (extent.depth + srcOffset.z) must equal the source image subresource depth
If the calling command’s dstImage is a compressed format image, or a single-plane, “_422” image format, all members of dstOffset must be a multiple of the corresponding dimensions of the compressed texel block
If the calling command’s dstImage is a compressed format image, or a single-plane, “_422” image format, extent.width must be a multiple of the compressed texel block width or (extent.width + dstOffset.x) must equal the destination image subresource width
If the calling command’s dstImage is a compressed format image, or a single-plane, “_422” image format, extent.height must be a multiple of the compressed texel block height or (extent.height + dstOffset.y) must equal the destination image subresource height
If the calling command’s dstImage is a compressed format image, or a single-plane, “_422” image format, extent.depth must be a multiple of the compressed texel block depth or (extent.depth + dstOffset.z) must equal the destination image subresource depth
Valid Usage (Implicit)
srcSubresource must be a valid VkImageSubresourceLayers structure
dstSubresource must be a valid VkImageSubresourceLayers structure
See Also
VkExtent3D, VkImageSubresourceLayers, VkOffset3D, vkCmdCopyImage

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageCopy

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageCreateInfo(3)
Name
VkImageCreateInfo - Structure specifying the parameters of a newly created image object

C Specification
The VkImageCreateInfo structure is defined as:

typedef struct VkImageCreateInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkImageCreateFlags       flags;
    VkImageType              imageType;
    VkFormat                 format;
    VkExtent3D               extent;
    uint32_t                 mipLevels;
    uint32_t                 arrayLayers;
    VkSampleCountFlagBits    samples;
    VkImageTiling            tiling;
    VkImageUsageFlags        usage;
    VkSharingMode            sharingMode;
    uint32_t                 queueFamilyIndexCount;
    const uint32_t*          pQueueFamilyIndices;
    VkImageLayout            initialLayout;
} VkImageCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkImageCreateFlagBits describing additional parameters of the image.
imageType is a VkImageType value specifying the basic dimensionality of the image. Layers in array textures do not count as a dimension for the purposes of the image type.
format is a VkFormat describing the format and type of the texel blocks that will be contained in the image.
extent is a VkExtent3D describing the number of data elements in each dimension of the base level.
mipLevels describes the number of levels of detail available for minified sampling of the image.
arrayLayers is the number of layers in the image.
samples is a VkSampleCountFlagBits specifying the number of samples per texel.
tiling is a VkImageTiling value specifying the tiling arrangement of the texel blocks in memory.
usage is a bitmask of VkImageUsageFlagBits describing the intended usage of the image.
sharingMode is a VkSharingMode value specifying the sharing mode of the image when it will be accessed by multiple queue families.
queueFamilyIndexCount is the number of entries in the pQueueFamilyIndices array.
pQueueFamilyIndices is a list of queue families that will access this image (ignored if sharingMode is not VK_SHARING_MODE_CONCURRENT).
initialLayout is a VkImageLayout value specifying the initial VkImageLayout of all image subresources of the image. See Image Layouts.
Description
Images created with tiling equal to VK_IMAGE_TILING_LINEAR have further restrictions on their limits and capabilities compared to images created with tiling equal to VK_IMAGE_TILING_OPTIMAL. Creation of images with tiling VK_IMAGE_TILING_LINEAR may not be supported unless other parameters meet all of the constraints:

imageType is VK_IMAGE_TYPE_2D
format is not a depth/stencil format
mipLevels is 1
arrayLayers is 1
samples is VK_SAMPLE_COUNT_1_BIT
usage only includes VK_IMAGE_USAGE_TRANSFER_SRC_BIT and/or VK_IMAGE_USAGE_TRANSFER_DST_BIT
Images created with a format from one of those listed in html/vkspec.html#formats-requiring-sampler-ycbcr-conversion have further restrictions on their limits and capabilities compared to images created with other formats. Creation of images with a format requiring Y’CBCR conversion may not be supported unless other parameters meet all of the constraints:

imageType is VK_IMAGE_TYPE_2D
mipLevels is 1
arrayLayers is 1
samples is VK_SAMPLE_COUNT_1_BIT
Implementations may support additional limits and capabilities beyond those listed above.

To determine the set of valid usage bits for a given format, call vkGetPhysicalDeviceFormatProperties.

If the size of the resultant image would exceed maxResourceSize, then vkCreateImage must fail and return VK_ERROR_OUT_OF_DEVICE_MEMORY. This failure may occur even when all image creation parameters satisfy their valid usage requirements.

Note
For images created without VK_IMAGE_CREATE_EXTENDED_USAGE_BIT a usage bit is valid if it is supported for the format the image is created with.

For images created with VK_IMAGE_CREATE_EXTENDED_USAGE_BIT a usage bit is valid if it is supported for at least one of the formats a VkImageView created from the image can have (see Image Views for more detail).
Image Creation Limits
Valid values for some image creation parameters are limited by a numerical upper bound or by inclusion in a bitset. For example, VkImageCreateInfo::arrayLayers is limited by imageCreateMaxArrayLayers, defined below; and VkImageCreateInfo::samples is limited by imageCreateSampleCounts, also defined below.

Several limiting values are defined below, as well as assisting values from which the limiting values are derived. The limiting values are referenced by the relevant valid usage statements of VkImageCreateInfo.

Let uint64_t imageCreateDrmFormatModifiers[] be the set of Linux DRM format modifiers that the resultant image may have.
If tiling is not VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then imageCreateDrmFormatModifiers is empty.
If VkImageCreateInfo::pNext contains VkImageDrmFormatModifierExplicitCreateInfoEXT, then imageCreateDrmFormatModifiers contains exactly one modifier, VkImageDrmFormatModifierExplicitCreateInfoEXT::drmFormatModifier.
If VkImageCreateInfo::pNext contains VkImageDrmFormatModifierListCreateInfoEXT, then imageCreateDrmFormatModifiers contains the exactly the modifiers in VkImageDrmFormatModifierListCreateInfoEXT::pDrmFormatModifiers.
Let VkBool32 imageCreateMaybeLinear indicate if the resultant image may be linear.
If tiling is VK_IMAGE_TILING_LINEAR, then imageCreateMaybeLinear is true.
If tiling is VK_IMAGE_TILING_OPTIMAL, then imageCreateMaybeLinear is false.
If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then imageCreateMaybeLinear_ is true if and only if imageCreateDrmFormatModifiers contains DRM_FORMAT_MOD_LINEAR.
Let VkFormatFeatureFlags imageCreateFormatFeatures be the set of format features available during image creation.
If tiling is VK_IMAGE_TILING_LINEAR, then imageCreateFormatFeatures is the value of VkImageFormatProperties::linearTilingFeatures found by calling vkGetPhysicalDeviceFormatProperties with parameter format equal to VkImageCreateInfo::format.
If tiling is VK_IMAGE_TILING_OPTIMAL, and if the pNext chain contains no instance of VkExternalFormatANDROID with non-zero externalFormat, then imageCreateFormatFeatures is value of VkImageFormatProperties::optimalTilingFeatures found by calling vkGetPhysicalDeviceFormatProperties with parameter format equal to VkImageCreateInfo::format.
If tiling is VK_IMAGE_TILING_OPTIMAL, and if the pNext chain contains an instance of VkExternalFormatANDROID with non-zero externalFormat, then imageCreateFormatFeatures is the value of VkAndroidHardwareBufferFormatPropertiesANDROID::formatFeatures obtained by vkGetAndroidHardwareBufferPropertiesANDROID with a matching externalFormat value.
If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the value of imageCreateFormatFeatures is found by calling vkGetPhysicalDeviceFormatProperties2 with VkImageFormatProperties::format equal to VkImageCreateInfo::format and with VkDrmFormatModifierPropertiesListEXT chained into VkImageFormatProperties2; by collecting all members of the returned array VkDrmFormatModifierPropertiesListEXT::pDrmFormatModifierProperties whose drmFormatModifier belongs to imageCreateDrmFormatModifiers; and by taking the bitwise intersection, over the collected array members, of drmFormatModifierTilingFeatures. (The resultant imageCreateFormatFeatures may be empty).
Let VkImageFormatProperties2 imageCreateImageFormatPropertiesList[] be defined as follows.
If VkImageCreateInfo::pNext contains no instance of VkExternalFormatANDROID with non-zero externalFormat, then imageCreateImageFormatPropertiesList is the list of structures obtained by calling vkGetPhysicalDeviceImageFormatProperties2, possibly multiple times, as follows:
The parameters VkPhysicalDeviceImageFormatInfo2::format, imageType, tiling, usage, and flags must be equal to those in VkImageCreateInfo.
If VkImageCreateInfo::pNext contains an instance of VkExternalMemoryImageCreateInfo where handleTypes is not 0, then VkPhysicalDeviceImageFormatInfo2::pNext must contain an instance of VkPhysicalDeviceExternalImageFormatInfo where handleType is not 0; and vkGetPhysicalDeviceImageFormatProperties2 must be called for each handle type in VkExternalMemoryImageCreateInfo::handleTypes, successively setting VkPhysicalDeviceExternalImageFormatInfo::handleType on each call.
If VkImageCreateInfo::pNext contains no instance of VkExternalMemoryImageCreateInfo or contains an instance where handleTypes is 0, then VkPhysicalDeviceImageFormatInfo2::pNext must either contain no instance of VkPhysicalDeviceExternalImageFormatInfo or contain an instance where handleType is 0.
If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then VkPhysicalDeviceImageFormatInfo2::pNext must contain an instance of VkPhysicalDeviceImageDrmFormatModifierInfoEXT where sharingMode is equal to VkImageCreateInfo::sharingMode; and, if sharingMode is VK_SHARING_MODE_CONCURRENT, then queueFamilyIndexCount and pQueueFamilyIndices must be equal to those in VkImageCreateInfo; and, if flags contains VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, then the instance of VkImageFormatListCreateInfoKHR in the pNext chain of VkPhysicalDeviceImageFormatInfo2 must be equivalent to the one in the pNext chain of VkImageCreateInfo; and vkGetPhysicalDeviceImageFormatProperties2 must be called for each modifier in imageCreateDrmFormatModifiers, successively setting VkPhysicalDeviceImageDrmFormatModifierInfoEXT::drmFormatModifier on each call.
If tiling is not VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then VkPhysicalDeviceImageFormatInfo2::pNext must contain no instance of VkPhysicalDeviceImageDrmFormatModifierInfoEXT.
If any call to vkGetPhysicalDeviceImageFormatProperties2 returns an error, then imageCreateImageFormatPropertiesList is defined to be the empty list.
If VkImageCreateInfo::pNext contains an instance of VkExternalFormatANDROID with non-zero externalFormat, then imageCreateImageFormatPropertiesList contains a single element where:
VkImageFormatProperties::maxMipLevels is ⌊log2(max(extent.width, extent.height, extent.depth))⌋ + 1.
VkImageFormatProperties::maxArrayLayers is VkPhysicalDeviceLimits::maxImageArrayLayers.
Each component of VkImageFormatProperties::maxExtent is VkPhysicalDeviceLimits::maxImageDimension2D.
VkImageFormatProperties::sampleCounts contains exactly VK_SAMPLE_COUNT_1_BIT.
Let uint32_t imageCreateMaxMipLevels be the minimum value of VkImageFormatProperties::maxMipLevels in imageCreateImageFormatPropertiesList. The value is undefined if imageCreateImageFormatPropertiesList is empty.
Let uint32_t imageCreateMaxArrayLayers be the minimum value of VkImageFormatProperties::maxArrayLayers in imageCreateImageFormatPropertiesList. The value is undefined if imageCreateImageFormatPropertiesList is empty.
Let VkExtent3D imageCreateMaxExtent be the component-wise minimum over all VkImageFormatProperties::maxExtent values in imageCreateImageFormatPropertiesList. The value is undefined if imageCreateImageFormatPropertiesList is empty.
Let VkSampleCountFlags imageCreateSampleCounts be the intersection of each VkImageFormatProperties::sampleCounts in imageCreateImageFormatPropertiesList. The value is undefined if imageCreateImageFormatPropertiesList is empty.
Valid Usage
Each of the following values (as described in Image Creation Limits) must not be undefined imageCreateMaxMipLevels, imageCreateMaxArrayLayers, imageCreateMaxExtent, and imageCreateSampleCounts.
If sharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values
If sharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1
If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by either vkGetPhysicalDeviceQueueFamilyProperties or vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device
If the pNext chain contains an instance of VkExternalFormatANDROID, and its member externalFormat is non-zero the format must be VK_FORMAT_UNDEFINED.
If the pNext chain does not contain an instance of VkExternalFormatANDROID, or does and its member externalFormat is 0 the format must not be VK_FORMAT_UNDEFINED.
extent::width must be greater than 0.
extent::height must be greater than 0.
extent::depth must be greater than 0.
mipLevels must be greater than 0
arrayLayers must be greater than 0
If flags contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, imageType must be VK_IMAGE_TYPE_2D
If flags contains VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, imageType must be VK_IMAGE_TYPE_2D
If flags contains VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT, imageType must be VK_IMAGE_TYPE_3D
extent.width must be less than or equal to imageCreateMaxExtent.width (as defined in Image Creation Limits).
extent.height must be less than or equal to imageCreateMaxExtent.height (as defined in Image Creation Limits).
extent.depth must be less than or equal to imageCreateMaxExtent.depth (as defined in Image Creation Limits).
If imageType is VK_IMAGE_TYPE_2D and flags contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, extent.width and extent.height must be equal and arrayLayers must be greater than or equal to 6
If imageType is VK_IMAGE_TYPE_1D, both extent.height and extent.depth must be 1
If imageType is VK_IMAGE_TYPE_2D, extent.depth must be 1
mipLevels must be less than or equal to the number of levels in the complete mipmap chain based on extent.width, extent.height, and extent.depth.
mipLevels must be less than or equal to imageCreateMaxMipLevels (as defined in Image Creation Limits).
arrayLayers must be less than or equal to imageCreateMaxArrayLayers (as defined in Image Creation Limits).
If imageType is VK_IMAGE_TYPE_3D, arrayLayers must be 1.
If samples is not VK_SAMPLE_COUNT_1_BIT, then imageType must be VK_IMAGE_TYPE_2D, flags must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, mipLevels must be equal to 1, and imageCreateMaybeLinear (as defined in Image Creation Limits) must be false,
If samples is not VK_SAMPLE_COUNT_1_BIT, usage must not contain VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT
If usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, then bits other than VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT must not be set
If usage includes VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.width must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferWidth
If usage includes VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.height must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferHeight
If usage includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, extent.width must be less than or equal to \(\lceil{\frac{maxFramebufferWidth}{minFragmentDensityTexelSize_{width}}}\rceil\)
If usage includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, extent.height must be less than or equal to \(\lceil{\frac{maxFramebufferHeight}{minFragmentDensityTexelSize_{height}}}\rceil\)
If usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, usage must also contain at least one of VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT.
samples must be a bit value that is set in imageCreateSampleCounts (as defined in Image Creation Limits).
If the multisampled storage images feature is not enabled, and usage contains VK_IMAGE_USAGE_STORAGE_BIT, samples must be VK_SAMPLE_COUNT_1_BIT
If the sparse bindings feature is not enabled, flags must not contain VK_IMAGE_CREATE_SPARSE_BINDING_BIT
If the sparse aliased residency feature is not enabled, flags must not contain VK_IMAGE_CREATE_SPARSE_ALIASED_BIT
If imageType is VK_IMAGE_TYPE_1D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
If the sparse residency for 2D images feature is not enabled, and imageType is VK_IMAGE_TYPE_2D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
If the sparse residency for 3D images feature is not enabled, and imageType is VK_IMAGE_TYPE_3D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
If the sparse residency for images with 2 samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_2_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
If the sparse residency for images with 4 samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_4_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
If the sparse residency for images with 8 samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_8_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
If the sparse residency for images with 16 samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_16_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT
If flags contains VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT, it must also contain VK_IMAGE_CREATE_SPARSE_BINDING_BIT
If any of the bits VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT must not also be set
If the protected memory feature is not enabled, flags must not contain VK_IMAGE_CREATE_PROTECTED_BIT.
If any of the bits VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set, VK_IMAGE_CREATE_PROTECTED_BIT must not also be set.
If the pNext chain contains an instance of VkExternalMemoryImageCreateInfoNV, it must not contain an instance of VkExternalMemoryImageCreateInfo.
If the pNext chain contains an instance of VkExternalMemoryImageCreateInfo, its handleTypes member must only contain bits that are also in VkExternalImageFormatProperties::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceImageFormatProperties2 with format, imageType, tiling, usage, and flags equal to those in this structure, and with an instance of VkPhysicalDeviceExternalImageFormatInfo in the pNext chain, with a handleType equal to any one of the handle types specified in VkExternalMemoryImageCreateInfo::handleTypes
If the pNext chain contains an instance of VkExternalMemoryImageCreateInfoNV, its handleTypes member must only contain bits that are also in VkExternalImageFormatPropertiesNV::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceExternalImageFormatPropertiesNV with format, imageType, tiling, usage, and flags equal to those in this structure, and with externalHandleType equal to any one of the handle types specified in VkExternalMemoryImageCreateInfoNV::handleTypes
If the logical device was created with VkDeviceGroupDeviceCreateInfo::physicalDeviceCount equal to 1, flags must not contain VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT
If flags contains VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT, then mipLevels must be one, arrayLayers must be one, imageType must be VK_IMAGE_TYPE_2D. and imageCreateMaybeLinear (as defined in Image Creation Limits) must be false.
If flags contains VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, then format must be a block-compressed image format, an ETC compressed image format, or an ASTC compressed image format.
If flags contains VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, then flags must also contain VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT.
initialLayout must be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED.
If the pNext chain includes a VkExternalMemoryImageCreateInfo or VkExternalMemoryImageCreateInfoNV structure whose handleTypes member is not 0, initialLayout must be VK_IMAGE_LAYOUT_UNDEFINED
If the image format is one of those listed in html/vkspec.html#formats-requiring-sampler-ycbcr-conversion, then mipLevels must be 1
If the image format is one of those listed in html/vkspec.html#formats-requiring-sampler-ycbcr-conversion, samples must be VK_SAMPLE_COUNT_1_BIT
If the image format is one of those listed in html/vkspec.html#formats-requiring-sampler-ycbcr-conversion, imageType must be VK_IMAGE_TYPE_2D
If the image format is one of those listed in html/vkspec.html#formats-requiring-sampler-ycbcr-conversion, and the ycbcrImageArrays feature is not enabled, arrayLayers must be 1
If format is a multi-planar format, and if imageCreateFormatFeatures (as defined in Image Creation Limits) does not contain VK_FORMAT_FEATURE_DISJOINT_BIT, then flags must not contain VK_IMAGE_CREATE_DISJOINT_BIT.
If format is not a multi-planar format, and flags does not include VK_IMAGE_CREATE_ALIAS_BIT, flags must not contain VK_IMAGE_CREATE_DISJOINT_BIT
If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the pNext chain must contain exactly one of VkImageDrmFormatModifierListCreateInfoEXT or VkImageDrmFormatModifierExplicitCreateInfoEXT.
If the pNext chain contains VkImageDrmFormatModifierListCreateInfoEXT or VkImageDrmFormatModifierExplicitCreateInfoEXT, then tiling must be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT.
If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT and flags contains VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, then the pNext chain must contain VkImageFormatListCreateInfoKHR with non-zero viewFormatCount.
If flags contains VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT format must be a depth or depth/stencil format
If the pNext chain includes a VkExternalMemoryImageCreateInfo structure whose handleTypes member includes VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, imageType must be VK_IMAGE_TYPE_2D.
If the pNext chain includes a VkExternalMemoryImageCreateInfo structure whose handleTypes member includes VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, mipLevels must either be 1 or equal to the number of levels in the complete mipmap chain based on extent.width, extent.height, and extent.depth.
If the pNext chain includes a VkExternalFormatANDROID structure whose externalFormat member is not 0, flags must not include VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT.
If the pNext chain includes a VkExternalFormatANDROID structure whose externalFormat member is not 0, usage must not include any usages except VK_IMAGE_USAGE_SAMPLED_BIT.
If the pNext chain includes a VkExternalFormatANDROID structure whose externalFormat member is not 0, tiling must be VK_IMAGE_TILING_OPTIMAL.
If format is a depth-stencil format and the pNext chain contains an instance of VkImageStencilUsageCreateInfoEXT, then its stencilUsage member must only include VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT if usage also includes it
If format is a depth-stencil format and the pNext chain contains an instance of VkImageStencilUsageCreateInfoEXT, then its stencilUsage member must only include VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT if usage also includes it
If Format is a depth-stencil format and the pNext chain contains an instance of VkImageStencilUsageCreateInfoEXT with its stencilUsage member including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.width must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferWidth
If format is a depth-stencil format and the pNext chain contains an instance of VkImageStencilUsageCreateInfoEXT with its stencilUsage member including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.height must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferHeight
If the multisampled storage images feature is not enabled, format is a depth-stencil format and the pNext chain contains an instance of VkImageStencilUsageCreateInfoEXT with its stencilUsage including VK_IMAGE_USAGE_STORAGE_BIT, samples must be VK_SAMPLE_COUNT_1_BIT
If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, imageType must be VK_IMAGE_TYPE_2D or VK_IMAGE_TYPE_3D
If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, it must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT and the format must not be a depth/stencil format
If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and imageType is VK_IMAGE_TYPE_2D, extent::width and extent::height must be greater than 1
If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and imageType is VK_IMAGE_TYPE_3D, extent::width, extent::height, and extent::depth must be greater than 1
If usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, imageType must be VK_IMAGE_TYPE_2D.
If usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, samples must be VK_SAMPLE_COUNT_1_BIT.
If usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, tiling must be VK_IMAGE_TILING_OPTIMAL.
If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, tiling must be VK_IMAGE_TILING_OPTIMAL
If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, imageType must be VK_IMAGE_TYPE_2D
If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, flags must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT
If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, mipLevels must be 1
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDedicatedAllocationImageCreateInfoNV, VkExternalFormatANDROID, VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfoNV, VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT, VkImageFormatListCreateInfoKHR, VkImageStencilUsageCreateInfoEXT, or VkImageSwapchainCreateInfoKHR
Each sType member in the pNext chain must be unique
flags must be a valid combination of VkImageCreateFlagBits values
imageType must be a valid VkImageType value
format must be a valid VkFormat value
samples must be a valid VkSampleCountFlagBits value
tiling must be a valid VkImageTiling value
usage must be a valid combination of VkImageUsageFlagBits values
usage must not be 0
sharingMode must be a valid VkSharingMode value
initialLayout must be a valid VkImageLayout value
See Also
VkExtent3D, VkFormat, VkImageCreateFlags, VkImageLayout, VkImageTiling, VkImageType, VkImageUsageFlags, VkSampleCountFlagBits, VkSharingMode, VkStructureType, vkCreateImage

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageDrmFormatModifierExplicitCreateInfoEXT(3)
Name
VkImageDrmFormatModifierExplicitCreateInfoEXT - Specify that an image be created with the provided DRM format modifier and explicit memory layout

C Specification
If the pNext chain of VkImageCreateInfo contains VkImageDrmFormatModifierExplicitCreateInfoEXT, then the image will be created with the Linux DRM format modifier and memory layout defined by the structure.

The VkImageDrmFormatModifierExplicitCreateInfoEXT structure is defined as:

typedef struct VkImageDrmFormatModifierExplicitCreateInfoEXT {
    VkStructureType               sType;
    const void*                   pNext;
    uint64_t                      drmFormatModifier;
    uint32_t                      drmFormatModifierPlaneCount;
    const VkSubresourceLayout*    pPlaneLayouts;
} VkImageDrmFormatModifierExplicitCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
drmFormatModifier is the Linux DRM format modifier with which the image will be created.
drmFormatModifierPlaneCount is the number of memory planes in the image (as reported by VkDrmFormatModifierPropertiesEXT) as well as the length of the pPlaneLayouts array.
pPlaneLayouts is an array of VkSubresourceLayout structures that describe the image’s memory planes.
Description
The ith member of pPlaneLayouts describes the layout of the image’s ith memory plane (that is, VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT). In each element of pPlaneLayouts, the implementation must ignore size. The implementation calculates the size of each plane, which the application can query with vkGetImageSubresourceLayout.

When creating an image with VkImageDrmFormatModifierExplicitCreateInfoEXT, it is the application’s responsibility to satisfy all Valid Usage requirements. However, the implementation must validate that the provided pPlaneLayouts, when combined with the provided drmFormatModifier and other creation parameters in VkImageCreateInfo and its pNext chain, produce a valid image. (This validation is necessarily implementation-dependent and outside the scope of Vulkan, and therefore not described by Valid Usage requirements). If this validation fails, then vkCreateImage returns VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT.

Valid Usage
drmFormatModifier must be compatible with the parameters in VkImageCreateInfo and its pNext chain, as determined by querying VkPhysicalDeviceImageFormatInfo2KHR extended with VkPhysicalDeviceImageDrmFormatModifierInfoEXT.
drmFormatModifierPlaneCount must be equal to the VkDrmFormatModifierPropertiesEXT::drmFormatModifierPlaneCount associated with VkImageCreateInfo::format and drmFormatModifier, as found by querying VkDrmFormatModifierPropertiesListEXT.
For each element of pPlaneLayouts, size must be 0
For each element of pPlaneLayouts, arrayPitch must be 0 if VkImageCreateInfo::arrayLayers is 1.
For each element of pPlaneLayouts, depthPitch must be 0 if VkImageCreateInfo::extent::depth is 1.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT
If drmFormatModifierPlaneCount is not 0, pPlaneLayouts must be a valid pointer to an array of drmFormatModifierPlaneCount VkSubresourceLayout structures
See Also
VkStructureType, VkSubresourceLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageDrmFormatModifierExplicitCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageDrmFormatModifierListCreateInfoEXT(3)
Name
VkImageDrmFormatModifierListCreateInfoEXT - Specify that an image must be created with a DRM format modifier from the provided list

C Specification
If the pNext chain of VkImageCreateInfo contains VkImageDrmFormatModifierListCreateInfoEXT, then the image will be created with one of the Linux DRM format modifiers listed in the structure. The choice of modifier is implementation-dependent.

The VkImageDrmFormatModifierListCreateInfoEXT structure is defined as:

typedef struct VkImageDrmFormatModifierListCreateInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           drmFormatModifierCount;
    const uint64_t*    pDrmFormatModifiers;
} VkImageDrmFormatModifierListCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
drmFormatModifierCount is the length of the pDrmFormatModifiers array.
pDrmFormatModifiers is an array of Linux DRM format modifiers.
Description
Valid Usage
Each modifier in pDrmFormatModifiers must be compatible with the parameters in VkImageCreateInfo and its pNext chain, as determined by querying VkPhysicalDeviceImageFormatInfo2 extended with VkPhysicalDeviceImageDrmFormatModifierInfoEXT.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT
pDrmFormatModifiers must be a valid pointer to an array of drmFormatModifierCount uint64_t values
drmFormatModifierCount must be greater than 0
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageDrmFormatModifierListCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageDrmFormatModifierPropertiesEXT(3)
Name
VkImageDrmFormatModifierPropertiesEXT - Properties of an image’s Linux DRM format modifier

C Specification
The VkImageDrmFormatModifierPropertiesEXT structure is defined as:

typedef struct VkImageDrmFormatModifierPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    uint64_t           drmFormatModifier;
} VkImageDrmFormatModifierPropertiesEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
drmFormatModifier returns the image’s Linux DRM format modifier.
Description
If the image was created with VkImageDrmFormatModifierListCreateInfoEXT, then the returned drmFormatModifier must belong to the list of modifiers provided at time of image creation in VkImageDrmFormatModifierListCreateInfoEXT::pDrmFormatModifiers. If the image was created with VkImageDrmFormatModifierExplicitCreateInfoEXT, then the returned drmFormatModifier must be the modifier provided at time of image creation in VkImageDrmFormatModifierExplicitCreateInfoEXT::drmFormatModifier.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT
pNext must be NULL
See Also
VkStructureType, vkGetImageDrmFormatModifierPropertiesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageDrmFormatModifierPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageFormatListCreateInfoKHR(3)
Name
VkImageFormatListCreateInfoKHR - Specify that an image can be used with a particular set of formats

C Specification
If the pNext list of VkImageCreateInfo includes a VkImageFormatListCreateInfoKHR structure, then that structure contains a list of all formats that can be used when creating views of this image.

The VkImageFormatListCreateInfoKHR structure is defined as:

typedef struct VkImageFormatListCreateInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           viewFormatCount;
    const VkFormat*    pViewFormats;
} VkImageFormatListCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
viewFormatCount is the number of entries in the pViewFormats array.
pViewFormats is an array which lists of all formats which can be used when creating views of this image.
Description
If viewFormatCount is zero, pViewFormats is ignored and the image is created as if the VkImageFormatListCreateInfoKHR structure were not included in the pNext list of VkImageCreateInfo.

Valid Usage
If viewFormatCount is not 0, all of the formats in the pViewFormats array must be compatible with the format specified in the format field of VkImageCreateInfo, as described in the compatibility table.
If VkImageCreateInfo::flags does not contain VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, viewFormatCount must be 0 or 1.
If viewFormatCount is not 0, VkImageCreateInfo::format must be in pViewFormats.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR
If viewFormatCount is not 0, pViewFormats must be a valid pointer to an array of viewFormatCount valid VkFormat values
See Also
VkFormat, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageFormatListCreateInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageFormatProperties(3)
Name
VkImageFormatProperties - Structure specifying an image format properties

C Specification
The VkImageFormatProperties structure is defined as:

typedef struct VkImageFormatProperties {
    VkExtent3D            maxExtent;
    uint32_t              maxMipLevels;
    uint32_t              maxArrayLayers;
    VkSampleCountFlags    sampleCounts;
    VkDeviceSize          maxResourceSize;
} VkImageFormatProperties;
Members
maxExtent are the maximum image dimensions. See the Allowed Extent Values section below for how these values are constrained by type.
maxMipLevels is the maximum number of mipmap levels. maxMipLevels must be equal to the number of levels in the complete mipmap chain based on the maxExtent.width, maxExtent.height, and maxExtent.depth, except when one of the following conditions is true, in which case it may instead be 1:
vkGetPhysicalDeviceImageFormatProperties::tiling was VK_IMAGE_TILING_LINEAR
VkPhysicalDeviceImageFormatInfo2::tiling was VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT
the VkPhysicalDeviceImageFormatInfo2::pNext chain included an instance of VkPhysicalDeviceExternalImageFormatInfo with a handle type included in the handleTypes member for which mipmap image support is not required
image format is one of those listed in html/vkspec.html#formats-requiring-sampler-ycbcr-conversion
flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT
maxArrayLayers is the maximum number of array layers. maxArrayLayers must be no less than VkPhysicalDeviceLimits::maxImageArrayLayers, except when one of the following conditions is true, in which case it may instead be 1:
tiling is VK_IMAGE_TILING_LINEAR
tiling is VK_IMAGE_TILING_OPTIMAL and type is VK_IMAGE_TYPE_3D
format is one of those listed in html/vkspec.html#formats-requiring-sampler-ycbcr-conversion
If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then maxArrayLayers must not be 0.
sampleCounts is a bitmask of VkSampleCountFlagBits specifying all the supported sample counts for this image as described below.
maxResourceSize is an upper bound on the total image size in bytes, inclusive of all image subresources. Implementations may have an address space limit on total size of a resource, which is advertised by this property. maxResourceSize must be at least 231.
Description
Note
There is no mechanism to query the size of an image before creating it, to compare that size against maxResourceSize. If an application attempts to create an image that exceeds this limit, the creation will fail and vkCreateImage will return VK_ERROR_OUT_OF_DEVICE_MEMORY. While the advertised limit must be at least 231, it may not be possible to create an image that approaches that size, particularly for VK_IMAGE_TYPE_1D.
If the combination of parameters to vkGetPhysicalDeviceImageFormatProperties is not supported by the implementation for use in vkCreateImage, then all members of VkImageFormatProperties will be filled with zero.

Note
Filling VkImageFormatProperties with zero for unsupported formats is an exception to the usual rule that output structures have undefined contents on error. This exception was unintentional, but is preserved for backwards compatibility.
See Also
VkDeviceSize, VkExtent3D, VkExternalImageFormatPropertiesNV, VkImageFormatProperties2, VkSampleCountFlags, vkGetPhysicalDeviceImageFormatProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageFormatProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageFormatProperties2(3)
Name
VkImageFormatProperties2 - Structure specifying an image format properties

C Specification
The VkImageFormatProperties2 structure is defined as:

typedef struct VkImageFormatProperties2 {
    VkStructureType            sType;
    void*                      pNext;
    VkImageFormatProperties    imageFormatProperties;
} VkImageFormatProperties2;
or the equivalent

typedef VkImageFormatProperties2 VkImageFormatProperties2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure. The pNext chain of VkImageFormatProperties2 is used to allow the specification of additional capabilities to be returned from vkGetPhysicalDeviceImageFormatProperties2.
imageFormatProperties is an instance of a VkImageFormatProperties structure in which capabilities are returned.
Description
If the combination of parameters to vkGetPhysicalDeviceImageFormatProperties2 is not supported by the implementation for use in vkCreateImage, then all members of imageFormatProperties will be filled with zero.

Note
Filling imageFormatProperties with zero for unsupported formats is an exception to the usual rule that output structures have undefined contents on error. This exception was unintentional, but is preserved for backwards compatibility. This exeption only applies to imageFormatProperties, not sType, pNext, or any structures chained from pNext.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkAndroidHardwareBufferUsageANDROID, VkExternalImageFormatProperties, VkFilterCubicImageViewImageFormatPropertiesEXT, VkSamplerYcbcrConversionImageFormatProperties, or VkTextureLODGatherFormatPropertiesAMD
Each sType member in the pNext chain must be unique
See Also
VkImageFormatProperties, VkStructureType, vkGetPhysicalDeviceImageFormatProperties2, vkGetPhysicalDeviceImageFormatProperties2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageFormatProperties2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageMemoryBarrier(3)
Name
VkImageMemoryBarrier - Structure specifying the parameters of an image memory barrier

C Specification
The VkImageMemoryBarrier structure is defined as:

typedef struct VkImageMemoryBarrier {
    VkStructureType            sType;
    const void*                pNext;
    VkAccessFlags              srcAccessMask;
    VkAccessFlags              dstAccessMask;
    VkImageLayout              oldLayout;
    VkImageLayout              newLayout;
    uint32_t                   srcQueueFamilyIndex;
    uint32_t                   dstQueueFamilyIndex;
    VkImage                    image;
    VkImageSubresourceRange    subresourceRange;
} VkImageMemoryBarrier;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
srcAccessMask is a bitmask of VkAccessFlagBits specifying a source access mask.
dstAccessMask is a bitmask of VkAccessFlagBits specifying a destination access mask.
oldLayout is the old layout in an image layout transition.
newLayout is the new layout in an image layout transition.
srcQueueFamilyIndex is the source queue family for a queue family ownership transfer.
dstQueueFamilyIndex is the destination queue family for a queue family ownership transfer.
image is a handle to the image affected by this barrier.
subresourceRange describes the image subresource range within image that is affected by this barrier.
Description
The first access scope is limited to access to memory through the specified image subresource range, via access types in the source access mask specified by srcAccessMask. If srcAccessMask includes VK_ACCESS_HOST_WRITE_BIT, memory writes performed by that access type are also made visible, as that access type is not performed through a resource.

The second access scope is limited to access to memory through the specified image subresource range, via access types in the destination access mask specified by dstAccessMask. If dstAccessMask includes VK_ACCESS_HOST_WRITE_BIT or VK_ACCESS_HOST_READ_BIT, available memory writes are also made visible to accesses of those types, as those access types are not performed through a resource.

If srcQueueFamilyIndex is not equal to dstQueueFamilyIndex, and srcQueueFamilyIndex is equal to the current queue family, then the memory barrier defines a queue family release operation for the specified image subresource range, and the second access scope includes no access, as if dstAccessMask was 0.

If dstQueueFamilyIndex is not equal to srcQueueFamilyIndex, and dstQueueFamilyIndex is equal to the current queue family, then the memory barrier defines a queue family acquire operation for the specified image subresource range, and the first access scope includes no access, as if srcAccessMask was 0.

If oldLayout is not equal to newLayout, then the memory barrier defines an image layout transition for the specified image subresource range.

Layout transitions that are performed via image memory barriers execute in their entirety in submission order, relative to other image layout transitions submitted to the same queue, including those performed by render passes. In effect there is an implicit execution dependency from each such layout transition to all layout transitions previously submitted to the same queue.

The image layout of each image subresource of a depth/stencil image created with VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT is dependent on the last sample locations used to render to the image subresource as a depth/stencil attachment, thus when the image member of an VkImageMemoryBarrier is an image created with this flag the application can chain a VkSampleLocationsInfoEXT structure to the pNext chain of VkImageMemoryBarrier to specify the sample locations to use during the image layout transition.

If the VkSampleLocationsInfoEXT structure in the pNext chain of VkImageMemoryBarrier does not match the sample location state last used to render to the image subresource range specified by subresourceRange or if no VkSampleLocationsInfoEXT structure is in the pNext chain of VkImageMemoryBarrier then the contents of the given image subresource range becomes undefined as if oldLayout would equal VK_IMAGE_LAYOUT_UNDEFINED.

If image has a multi-planar format and the image is disjoint, then including VK_IMAGE_ASPECT_COLOR_BIT in the aspectMask member of subresourceRange is equivalent to including VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, and (for three-plane formats only) VK_IMAGE_ASPECT_PLANE_2_BIT.

Valid Usage
oldLayout must be VK_IMAGE_LAYOUT_UNDEFINED or the current layout of the image subresources affected by the barrier
newLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED
If image was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, at least one of srcQueueFamilyIndex and dstQueueFamilyIndex must be VK_QUEUE_FAMILY_IGNORED
If image was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, and one of srcQueueFamilyIndex and dstQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, the other must be VK_QUEUE_FAMILY_IGNORED or a special queue family reserved for external memory transfers, as described in html/vkspec.html#synchronization-queue-transfers.
If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is VK_QUEUE_FAMILY_IGNORED, dstQueueFamilyIndex must also be VK_QUEUE_FAMILY_IGNORED.
If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and srcQueueFamilyIndex is not VK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or a special queue family reserved for external memory transfers, as described in html/vkspec.html#synchronization-queue-transfers.
If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE and dstQueueFamilyIndex is not VK_QUEUE_FAMILY_IGNORED, it must be a valid queue family or a special queue family reserved for external memory transfers, as described in html/vkspec.html#synchronization-queue-transfers.
If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not VK_QUEUE_FAMILY_IGNORED, at least one of them must be the same as the family of the queue that will execute this barrier
subresourceRange.baseMipLevel must be less than the mipLevels specified in VkImageCreateInfo when image was created
If subresourceRange.levelCount is not VK_REMAINING_MIP_LEVELS, subresourceRange.baseMipLevel + subresourceRange.levelCount must be less than or equal to the mipLevels specified in VkImageCreateInfo when image was created
subresourceRange.baseArrayLayer must be less than the arrayLayers specified in VkImageCreateInfo when image was created
If subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, subresourceRange.baseArrayLayer + subresourceRange.layerCount must be less than or equal to the arrayLayers specified in VkImageCreateInfo when image was created
If image has a depth/stencil format with both depth and stencil components, then the aspectMask member of subresourceRange must include both VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT
If image has a single-plane color format or is not disjoint, then the aspectMask member of subresourceRange must be VK_IMAGE_ASPECT_COLOR_BIT
If image has a multi-planar format and the image is disjoint, then the aspectMask member of subresourceRange must include either at least one of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, and VK_IMAGE_ASPECT_PLANE_2_BIT; or must include VK_IMAGE_ASPECT_COLOR_BIT
If image has a multi-planar format with only two planes, then the aspectMask member of subresourceRange must not include VK_IMAGE_ASPECT_PLANE_2_BIT
If either oldLayout or newLayout is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT set
If either oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set
If either oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set
If either oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set
If either oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set
If either oldLayout or newLayout is VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set
If either oldLayout or newLayout is VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then image must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT set
If either oldLayout or newLayout is VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then image must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT set
If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
If either oldLayout or newLayout is VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV then image must have been created with VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV set
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
pNext must be NULL or a pointer to a valid instance of VkSampleLocationsInfoEXT
srcAccessMask must be a valid combination of VkAccessFlagBits values
dstAccessMask must be a valid combination of VkAccessFlagBits values
oldLayout must be a valid VkImageLayout value
newLayout must be a valid VkImageLayout value
image must be a valid VkImage handle
subresourceRange must be a valid VkImageSubresourceRange structure
See Also
VkAccessFlags, VkImage, VkImageLayout, VkImageSubresourceRange, VkStructureType, vkCmdPipelineBarrier, vkCmdWaitEvents

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageMemoryBarrier

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageMemoryRequirementsInfo2(3)
Name
VkImageMemoryRequirementsInfo2 - (None)

C Specification
The VkImageMemoryRequirementsInfo2 structure is defined as:

typedef struct VkImageMemoryRequirementsInfo2 {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
} VkImageMemoryRequirementsInfo2;
or the equivalent

typedef VkImageMemoryRequirementsInfo2 VkImageMemoryRequirementsInfo2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
image is the image to query.
Description
Valid Usage
If image was created with a multi-planar format and the VK_IMAGE_CREATE_DISJOINT_BIT flag, there must be a VkImagePlaneMemoryRequirementsInfo in the pNext chain of the VkImageMemoryRequirementsInfo2 structure
If image was created with VK_IMAGE_CREATE_DISJOINT_BIT and with VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then there must be a VkImagePlaneMemoryRequirementsInfo in the pNext chain of the VkImageMemoryRequirementsInfo2 structure
If image was not created with the VK_IMAGE_CREATE_DISJOINT_BIT flag, there must not be a VkImagePlaneMemoryRequirementsInfo in the pNext chain of the VkImageMemoryRequirementsInfo2 structure
If image was created with a single-plane format and with any tiling other than VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then there must not be a VkImagePlaneMemoryRequirementsInfo in the pNext chain of the VkImageMemoryRequirementsInfo2 structure
If image was created with the VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID external memory handle type, then image must be bound to memory.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2
pNext must be NULL or a pointer to a valid instance of VkImagePlaneMemoryRequirementsInfo
image must be a valid VkImage handle
See Also
VkImage, VkStructureType, vkGetImageMemoryRequirements2, vkGetImageMemoryRequirements2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageMemoryRequirementsInfo2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImagePipeSurfaceCreateInfoFUCHSIA(3)
Name
VkImagePipeSurfaceCreateInfoFUCHSIA - Structure specifying parameters of a newly created ImagePipe surface object

C Specification
The VkImagePipeSurfaceCreateInfoFUCHSIA structure is defined as:

typedef struct VkImagePipeSurfaceCreateInfoFUCHSIA {
    VkStructureType                         sType;
    const void*                             pNext;
    VkImagePipeSurfaceCreateFlagsFUCHSIA    flags;
    zx_handle_t                             imagePipeHandle;
} VkImagePipeSurfaceCreateInfoFUCHSIA;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
imagePipeHandle is a zx_handle_t referring to the ImagePipe to associate with the surface.
Description
Valid Usage
imagePipeHandle must be a valid zx_handle_t
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA
pNext must be NULL
flags must be 0
See Also
VkImagePipeSurfaceCreateFlagsFUCHSIA, VkStructureType, vkCreateImagePipeSurfaceFUCHSIA

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImagePipeSurfaceCreateInfoFUCHSIA

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImagePlaneMemoryRequirementsInfo(3)
Name
VkImagePlaneMemoryRequirementsInfo - Structure specifying image plane for memory requirements

C Specification
To determine the memory requirements for a plane of a disjoint image, add a VkImagePlaneMemoryRequirementsInfo to the pNext chain of the VkImageMemoryRequirementsInfo2 structure.

The VkImagePlaneMemoryRequirementsInfo structure is defined as:

typedef struct VkImagePlaneMemoryRequirementsInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkImageAspectFlagBits    planeAspect;
} VkImagePlaneMemoryRequirementsInfo;
or the equivalent

typedef VkImagePlaneMemoryRequirementsInfo VkImagePlaneMemoryRequirementsInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
planeAspect is the aspect corresponding to the image plane to query.
Description
Valid Usage
If the image’s tiling is VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_OPTIMAL, then planeAspect must be a single valid format plane for the image. (That is, for a two-plane image planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT, and for a three-plane image planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or VK_IMAGE_ASPECT_PLANE_2_BIT).
If the image’s tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then planeAspect must be a single valid memory plane for the image. (That is, aspectMask must specify a plane index that is less than the drmFormatModifierPlaneCount associated with the image’s format and drmFormatModifier.)
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO
planeAspect must be a valid VkImageAspectFlagBits value
See Also
VkImageAspectFlagBits, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImagePlaneMemoryRequirementsInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageResolve(3)
Name
VkImageResolve - Structure specifying an image resolve operation

C Specification
The VkImageResolve structure is defined as:

typedef struct VkImageResolve {
    VkImageSubresourceLayers    srcSubresource;
    VkOffset3D                  srcOffset;
    VkImageSubresourceLayers    dstSubresource;
    VkOffset3D                  dstOffset;
    VkExtent3D                  extent;
} VkImageResolve;
Members
srcSubresource and dstSubresource are VkImageSubresourceLayers structures specifying the image subresources of the images used for the source and destination image data, respectively. Resolve of depth/stencil images is not supported.
srcOffset and dstOffset select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data.
extent is the size in texels of the source image to resolve in width, height and depth.
Description
Valid Usage
The aspectMask member of srcSubresource and dstSubresource must only contain VK_IMAGE_ASPECT_COLOR_BIT
The layerCount member of srcSubresource and dstSubresource must match
If either of the calling command’s srcImage or dstImage parameters are of VkImageType VK_IMAGE_TYPE_3D, the baseArrayLayer and layerCount members of both srcSubresource and dstSubresource must be 0 and 1, respectively
srcOffset.x and (extent.width + srcOffset.x) must both be greater than or equal to 0 and less than or equal to the source image subresource width
srcOffset.y and (extent.height + srcOffset.y) must both be greater than or equal to 0 and less than or equal to the source image subresource height
If the calling command’s srcImage is of type VK_IMAGE_TYPE_1D, then srcOffset.y must be 0 and extent.height must be 1.
srcOffset.z and (extent.depth + srcOffset.z) must both be greater than or equal to 0 and less than or equal to the source image subresource depth
If the calling command’s srcImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then srcOffset.z must be 0 and extent.depth must be 1.
dstOffset.x and (extent.width + dstOffset.x) must both be greater than or equal to 0 and less than or equal to the destination image subresource width
dstOffset.y and (extent.height + dstOffset.y) must both be greater than or equal to 0 and less than or equal to the destination image subresource height
If the calling command’s dstImage is of type VK_IMAGE_TYPE_1D, then dstOffset.y must be 0 and extent.height must be 1.
dstOffset.z and (extent.depth + dstOffset.z) must both be greater than or equal to 0 and less than or equal to the destination image subresource depth
If the calling command’s dstImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then dstOffset.z must be 0 and extent.depth must be 1.
Valid Usage (Implicit)
srcSubresource must be a valid VkImageSubresourceLayers structure
dstSubresource must be a valid VkImageSubresourceLayers structure
See Also
VkExtent3D, VkImageSubresourceLayers, VkOffset3D, vkCmdResolveImage

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageResolve

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageSparseMemoryRequirementsInfo2(3)
Name
VkImageSparseMemoryRequirementsInfo2 - (None)

C Specification
The VkImageSparseMemoryRequirementsInfo2 structure is defined as:

typedef struct VkImageSparseMemoryRequirementsInfo2 {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
} VkImageSparseMemoryRequirementsInfo2;
or the equivalent

typedef VkImageSparseMemoryRequirementsInfo2 VkImageSparseMemoryRequirementsInfo2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
image is the image to query.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2
pNext must be NULL
image must be a valid VkImage handle
See Also
VkImage, VkStructureType, vkGetImageSparseMemoryRequirements2, vkGetImageSparseMemoryRequirements2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageSparseMemoryRequirementsInfo2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageStencilUsageCreateInfoEXT(3)
Name
VkImageStencilUsageCreateInfoEXT - Specify separate usage flags for the stencil aspect of a depth-stencil image

C Specification
If the pNext chain of VkImageCreateInfo includes a VkImageStencilUsageCreateInfoEXT structure, then that structure includes the usage flags specific to the stencil aspect of the image for an image with a depth-stencil format.

The VkImageStencilUsageCreateInfoEXT structure is defined as:

typedef struct VkImageStencilUsageCreateInfoEXT {
    VkStructureType      sType;
    const void*          pNext;
    VkImageUsageFlags    stencilUsage;
} VkImageStencilUsageCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
stencilUsage is a bitmask of VkImageUsageFlagBits describing the intended usage of the stencil aspect of the image.
Description
This structure specifies image usages which only apply to the stencil aspect of a depth/stencil format image. When this structure is included in the pNext chain of VkImageCreateInfo, the stencil aspect of the image must only be used as specified by stencilUsage. When this structure is not included in the pNext chain of VkImageCreateInfo, the stencil aspect of an image must only be used as specified VkImageCreateInfo::usage. Use of other aspects of an image are unaffected by this structure.

This structure can also be included in the pNext chain of VkPhysicalDeviceImageFormatInfo2 to query additional capabilities specific to image creation parameter combinations including a separate set of usage flags for the stencil aspect of the image using vkGetPhysicalDeviceImageFormatProperties2. When this structure is not present in the pNext chain of VkPhysicalDeviceImageFormatInfo2 then the implicit value of stencilUsage matches that of VkPhysicalDeviceImageFormatInfo2::usage.

Valid Usage
If stencilUsage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, then bits other than VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT must not be set
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT
stencilUsage must be a valid combination of VkImageUsageFlagBits values
stencilUsage must not be 0
See Also
VkImageUsageFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageStencilUsageCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageSubresource(3)
Name
VkImageSubresource - Structure specifying an image subresource

C Specification
The VkImageSubresource structure is defined as:

typedef struct VkImageSubresource {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              arrayLayer;
} VkImageSubresource;
Members
aspectMask is a VkImageAspectFlags selecting the image aspect.
mipLevel selects the mipmap level.
arrayLayer selects the array layer.
Description
Valid Usage (Implicit)
aspectMask must be a valid combination of VkImageAspectFlagBits values
aspectMask must not be 0
See Also
VkImageAspectFlags, VkSparseImageMemoryBind, vkGetImageSubresourceLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageSubresource

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageSubresourceLayers(3)
Name
VkImageSubresourceLayers - Structure specifying an image subresource layers

C Specification
The VkImageSubresourceLayers structure is defined as:

typedef struct VkImageSubresourceLayers {
    VkImageAspectFlags    aspectMask;
    uint32_t              mipLevel;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceLayers;
Members
aspectMask is a combination of VkImageAspectFlagBits, selecting the color, depth and/or stencil aspects to be copied.
mipLevel is the mipmap level to copy from.
baseArrayLayer and layerCount are the starting layer and number of layers to copy.
Description
Valid Usage
If aspectMask contains VK_IMAGE_ASPECT_COLOR_BIT, it must not contain either of VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT
aspectMask must not contain VK_IMAGE_ASPECT_METADATA_BIT
aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i.
layerCount must be greater than 0
Valid Usage (Implicit)
aspectMask must be a valid combination of VkImageAspectFlagBits values
aspectMask must not be 0
See Also
VkBufferImageCopy, VkImageAspectFlags, VkImageBlit, VkImageCopy, VkImageResolve

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageSubresourceLayers

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageSubresourceRange(3)
Name
VkImageSubresourceRange - Structure specifying an image subresource range

C Specification
The VkImageSubresourceRange structure is defined as:

typedef struct VkImageSubresourceRange {
    VkImageAspectFlags    aspectMask;
    uint32_t              baseMipLevel;
    uint32_t              levelCount;
    uint32_t              baseArrayLayer;
    uint32_t              layerCount;
} VkImageSubresourceRange;
Members
aspectMask is a bitmask of VkImageAspectFlagBits specifying which aspect(s) of the image are included in the view.
baseMipLevel is the first mipmap level accessible to the view.
levelCount is the number of mipmap levels (starting from baseMipLevel) accessible to the view.
baseArrayLayer is the first array layer accessible to the view.
layerCount is the number of array layers (starting from baseArrayLayer) accessible to the view.
Description
The number of mipmap levels and array layers must be a subset of the image subresources in the image. If an application wants to use all mip levels or layers in an image after the baseMipLevel or baseArrayLayer, it can set levelCount and layerCount to the special values VK_REMAINING_MIP_LEVELS and VK_REMAINING_ARRAY_LAYERS without knowing the exact number of mip levels or layers.

For cube and cube array image views, the layers of the image view starting at baseArrayLayer correspond to faces in the order +X, -X, +Y, -Y, +Z, -Z. For cube arrays, each set of six sequential layers is a single cube, so the number of cube maps in a cube map array view is layerCount / 6, and image array layer (baseArrayLayer + i) is face index (i mod 6) of cube i / 6. If the number of layers in the view, whether set explicitly in layerCount or implied by VK_REMAINING_ARRAY_LAYERS, is not a multiple of 6, the last cube map in the array must not be accessed.

aspectMask must be only VK_IMAGE_ASPECT_COLOR_BIT, VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT if format is a color, depth-only or stencil-only format, respectively, except if format is a multi-planar format. If using a depth/stencil format with both depth and stencil components, aspectMask must include at least one of VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT, and can include both.

When the VkImageSubresourceRange structure is used to select a subset of the slices of a 3D image’s mip level in order to create a 2D or 2D array image view of a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT, baseArrayLayer and layerCount specify the first slice index and the number of slices to include in the created image view. Such an image view can be used as a framebuffer attachment that refers only to the specified range of slices of the selected mip level. However, any layout transitions performed on such an attachment view during a render pass instance still apply to the entire subresource referenced which includes all the slices of the selected mip level.

When using an image view of a depth/stencil image to populate a descriptor set (e.g. for sampling in the shader, or for use as an input attachment), the aspectMask must only include one bit and selects whether the image view is used for depth reads (i.e. using a floating-point sampler or input attachment in the shader) or stencil reads (i.e. using an unsigned integer sampler or input attachment in the shader). When an image view of a depth/stencil image is used as a depth/stencil framebuffer attachment, the aspectMask is ignored and both depth and stencil image subresources are used.

The components member is of type VkComponentMapping, and describes a remapping from components of the image to components of the vector returned by shader image instructions. This remapping must be identity for storage image descriptors, input attachment descriptors, framebuffer attachments, and any VkImageView used with a combined image sampler that enables sampler Y’CBCR conversion.

When creating a VkImageView, if sampler Y’CBCR conversion is enabled in the sampler, the aspectMask of a subresourceRange used by the VkImageView must be VK_IMAGE_ASPECT_COLOR_BIT.

When creating a VkImageView, if sampler Y’CBCR conversion is not enabled in the sampler and the image format is multi-planar, the image must have been created with VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, and the aspectMask of the VkImageView’s subresourceRange must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or VK_IMAGE_ASPECT_PLANE_2_BIT.

Valid Usage
If levelCount is not VK_REMAINING_MIP_LEVELS, it must be greater than 0
If layerCount is not VK_REMAINING_ARRAY_LAYERS, it must be greater than 0
If aspectMask includes VK_IMAGE_ASPECT_COLOR_BIT, then it must not include any of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT
aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i.
Valid Usage (Implicit)
aspectMask must be a valid combination of VkImageAspectFlagBits values
aspectMask must not be 0
See Also
VkImageAspectFlags, VkImageMemoryBarrier, VkImageViewCreateInfo, vkCmdClearColorImage, vkCmdClearDepthStencilImage

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageSubresourceRange

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageSwapchainCreateInfoKHR(3)
Name
VkImageSwapchainCreateInfoKHR - Specify that an image will be bound to swapchain memory

C Specification
If the pNext chain of VkImageCreateInfo includes a VkImageSwapchainCreateInfoKHR structure, then that structure includes a swapchain handle indicating that the image will be bound to memory from that swapchain.

The VkImageSwapchainCreateInfoKHR structure is defined as:

typedef struct VkImageSwapchainCreateInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkSwapchainKHR     swapchain;
} VkImageSwapchainCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
swapchain is VK_NULL_HANDLE or a handle of a swapchain that the image will be bound to.
Description
Valid Usage
If swapchain is not VK_NULL_HANDLE, the fields of VkImageCreateInfo must match the implied image creation parameters of the swapchain
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR
If swapchain is not VK_NULL_HANDLE, swapchain must be a valid VkSwapchainKHR handle
See Also
VkStructureType, VkSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageSwapchainCreateInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageViewASTCDecodeModeEXT(3)
Name
VkImageViewASTCDecodeModeEXT - Structure describing the ASTC decode mode for an image view

C Specification
If the pNext list includes a VkImageViewASTCDecodeModeEXT structure, then that structure includes a parameter that specifies the decode mode for image views using ASTC compressed formats.

The VkImageViewASTCDecodeModeEXT structure is defined as:

typedef struct VkImageViewASTCDecodeModeEXT {
    VkStructureType    sType;
    const void*        pNext;
    VkFormat           decodeMode;
} VkImageViewASTCDecodeModeEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
decodeMode is the intermediate format used to decode ASTC compressed formats.
Description
Valid Usage
decodeMode must be one of VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R8G8B8A8_UNORM, or VK_FORMAT_E5B9G9R9_UFLOAT_PACK32
If the decodeModeSharedExponent feature is not enabled, decodeMode must not be VK_FORMAT_E5B9G9R9_UFLOAT_PACK32
If decodeMode is VK_FORMAT_R8G8B8A8_UNORM the image view must not include blocks using any of the ASTC HDR modes
format of the image view must be one of VK_FORMAT_ASTC_4x4_UNORM_BLOCK, VK_FORMAT_ASTC_4x4_SRGB_BLOCK, VK_FORMAT_ASTC_5x4_UNORM_BLOCK, VK_FORMAT_ASTC_5x4_SRGB_BLOCK, VK_FORMAT_ASTC_5x5_UNORM_BLOCK, VK_FORMAT_ASTC_5x5_SRGB_BLOCK, VK_FORMAT_ASTC_6x5_UNORM_BLOCK, VK_FORMAT_ASTC_6x5_SRGB_BLOCK, VK_FORMAT_ASTC_6x6_UNORM_BLOCK, VK_FORMAT_ASTC_6x6_SRGB_BLOCK, VK_FORMAT_ASTC_8x5_UNORM_BLOCK, VK_FORMAT_ASTC_8x5_SRGB_BLOCK, VK_FORMAT_ASTC_8x6_UNORM_BLOCK, VK_FORMAT_ASTC_8x6_SRGB_BLOCK, VK_FORMAT_ASTC_8x8_UNORM_BLOCK, VK_FORMAT_ASTC_8x8_SRGB_BLOCK, VK_FORMAT_ASTC_10x5_UNORM_BLOCK, VK_FORMAT_ASTC_10x5_SRGB_BLOCK, VK_FORMAT_ASTC_10x6_UNORM_BLOCK, VK_FORMAT_ASTC_10x6_SRGB_BLOCK, VK_FORMAT_ASTC_10x8_UNORM_BLOCK, VK_FORMAT_ASTC_10x8_SRGB_BLOCK, VK_FORMAT_ASTC_10x10_UNORM_BLOCK, VK_FORMAT_ASTC_10x10_SRGB_BLOCK, VK_FORMAT_ASTC_12x10_UNORM_BLOCK, VK_FORMAT_ASTC_12x10_SRGB_BLOCK, VK_FORMAT_ASTC_12x12_UNORM_BLOCK, or VK_FORMAT_ASTC_12x12_SRGB_BLOCK
If format uses sRGB encoding then the decodeMode has no effect.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT
decodeMode must be a valid VkFormat value
See Also
VkFormat, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageViewASTCDecodeModeEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageViewCreateInfo(3)
Name
VkImageViewCreateInfo - Structure specifying parameters of a newly created image view

C Specification
The VkImageViewCreateInfo structure is defined as:

typedef struct VkImageViewCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    VkImageViewCreateFlags     flags;
    VkImage                    image;
    VkImageViewType            viewType;
    VkFormat                   format;
    VkComponentMapping         components;
    VkImageSubresourceRange    subresourceRange;
} VkImageViewCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkImageViewCreateFlagBits describing additional parameters of the image view.
image is a VkImage on which the view will be created.
viewType is a VkImageViewType value specifying the type of the image view.
format is a VkFormat describing the format and type used to interpret texel blocks in the image.
components is a VkComponentMapping specifies a remapping of color components (or of depth or stencil components after they have been converted into color components).
subresourceRange is a VkImageSubresourceRange selecting the set of mipmap levels and array layers to be accessible to the view.
Description
Some of the image creation parameters are inherited by the view. In particular, image view creation inherits the implicit parameter usage specifying the allowed usages of the image view that, by default, takes the value of the corresponding usage parameter specified in VkImageCreateInfo at image creation time. If the image was has a depth-stencil format and was created with an instance of VkImageStencilUsageCreateInfoEXT in the pNext chain of VkImageCreateInfo, the usage is calculated based on the subresource.aspectMask provided: * If aspectMask includes only VK_IMAGE_ASPECT_STENCIL_BIT, the implicit usage is equal to VkImageStencilUsageCreateInfoEXT::stencilUsage. * If aspectMask includes only VK_IMAGE_ASPECT_DEPTH_BIT, the implicit usage is equal to VkImageCreateInfo::stencilUsage. * If both aspects are included in aspectMask, the implicit usage is equal to the intersection of slinkVkImageCreateInfo::usage and VkImageStencilUsageCreateInfoEXT::stencilUsage. The implicit usage can be overriden by including an instance of VkImageViewUsageCreateInfo structure in the pNext chain.

If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, and if the format of the image is not multi-planar, format can be different from the image’s format, but if image was created without the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag and they are not equal they must be compatible. Image format compatibility is defined in the Format Compatibility Classes section. Views of compatible formats will have the same mapping between texel coordinates and memory locations irrespective of the format, with only the interpretation of the bit pattern changing.

Note
Values intended to be used with one view format may not be exactly preserved when written or read through a different format. For example, an integer value that happens to have the bit pattern of a floating point denorm or NaN may be flushed or canonicalized when written or read through a view with a floating point format. Similarly, a value written through a signed normalized format that has a bit pattern exactly equal to -2b may be changed to -2b + 1 as described in Conversion from Normalized Fixed-Point to Floating-Point.
If image was created with the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, format must be compatible with the image’s format as described above, or must be an uncompressed format in which case it must be size-compatible with the image’s format, as defined for copying data between images In this case the resulting image view’s texel dimensions equal the dimensions of the selected mip level divided by the compressed texel block size and rounded up.

If the image view is to be used with a sampler which supports sampler Y’CBCR conversion, an identically defined object of type VkSamplerYcbcrConversion to that used to create the sampler must be passed to vkCreateImageView in a VkSamplerYcbcrConversionInfo added to the pNext chain of VkImageViewCreateInfo.

If the image has a multi-planar format and subresourceRange.aspectMask is VK_IMAGE_ASPECT_COLOR_BIT, format must be identical to the image format, and the sampler to be used with the image view must enable sampler Y’CBCR conversion.

If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT and the image has a multi-planar format, and if subresourceRange.aspectMask is VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT, format must be compatible with the corresponding plane of the image, and the sampler to be used with the image view must not enable sampler Y’CBCR conversion. The width and height of the single-plane image view must be derived from the multi-planar image’s dimensions in the manner listed for plane compatibility for the plane.

Any view of an image plane will have the same mapping between texel coordinates and memory locations as used by the channels of the color aspect, subject to the formulae relating texel coordinates to lower-resolution planes as described in Chroma Reconstruction. That is, if an R or B plane has a reduced resolution relative to the G plane of the multi-planar image, the image view operates using the (uplane, vplane) unnormalized coordinates of the reduced-resolution plane, and these coordinates access the same memory locations as the (ucolor, vcolor) unnormalized coordinates of the color aspect for which chroma reconstruction operations operate on the same (uplane, vplane) or (iplane, jplane) coordinates.

Table 7. Image and image view parameter compatibility requirements
Dim, Arrayed, MS	Image parameters	View parameters
imageType = ci.imageType
width = ci.extent.width
height = ci.extent.height
depth = ci.extent.depth
arrayLayers = ci.arrayLayers
samples = ci.samples
flags = ci.flags
where ci is the VkImageCreateInfo used to create image.
baseArrayLayer, layerCount, and levelCount are members of the subresourceRange member.
1D, 0, 0
imageType = VK_IMAGE_TYPE_1D
width ≥ 1
height = 1
depth = 1
arrayLayers ≥ 1
samples = 1
viewType = VK_IMAGE_VIEW_TYPE_1D
baseArrayLayer ≥ 0
layerCount = 1
1D, 1, 0
imageType = VK_IMAGE_TYPE_1D
width ≥ 1
height = 1
depth = 1
arrayLayers ≥ 1
samples = 1
viewType = VK_IMAGE_VIEW_TYPE_1D_ARRAY
baseArrayLayer ≥ 0
layerCount ≥ 1
2D, 0, 0
imageType = VK_IMAGE_TYPE_2D
width ≥ 1
height ≥ 1
depth = 1
arrayLayers ≥ 1
samples = 1
viewType = VK_IMAGE_VIEW_TYPE_2D
baseArrayLayer ≥ 0
layerCount = 1
2D, 1, 0
imageType = VK_IMAGE_TYPE_2D
width ≥ 1
height ≥ 1
depth = 1
arrayLayers ≥ 1
samples = 1
viewType = VK_IMAGE_VIEW_TYPE_2D_ARRAY
baseArrayLayer ≥ 0
layerCount ≥ 1
2D, 0, 1
imageType = VK_IMAGE_TYPE_2D
width ≥ 1
height ≥ 1
depth = 1
arrayLayers ≥ 1
samples > 1
viewType = VK_IMAGE_VIEW_TYPE_2D
baseArrayLayer ≥ 0
layerCount = 1
2D, 1, 1
imageType = VK_IMAGE_TYPE_2D
width ≥ 1
height ≥ 1
depth = 1
arrayLayers ≥ 1
samples > 1
viewType = VK_IMAGE_VIEW_TYPE_2D_ARRAY
baseArrayLayer ≥ 0
layerCount ≥ 1
CUBE, 0, 0
imageType = VK_IMAGE_TYPE_2D
width ≥ 1
height = width
depth = 1
arrayLayers ≥ 6
samples = 1
flags includes VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT
viewType = VK_IMAGE_VIEW_TYPE_CUBE
baseArrayLayer ≥ 0
layerCount = 6
CUBE, 1, 0
imageType = VK_IMAGE_TYPE_2D
width ≥ 1
height = width
depth = 1
N ≥ 1
arrayLayers ≥ 6 × N
samples = 1
flags includes VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT
viewType = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
baseArrayLayer ≥ 0
layerCount = 6 × N, N ≥ 1
3D, 0, 0
imageType = VK_IMAGE_TYPE_3D
width ≥ 1
height ≥ 1
depth ≥ 1
arrayLayers = 1
samples = 1
viewType = VK_IMAGE_VIEW_TYPE_3D
baseArrayLayer = 0
layerCount = 1
3D, 0, 0
imageType = VK_IMAGE_TYPE_3D
width ≥ 1
height ≥ 1
depth ≥ 1
arrayLayers = 1
samples = 1
flags includes VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT
flags does not include VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, and VK_IMAGE_CREATE_SPARSE_ALIASED_BIT
viewType = VK_IMAGE_VIEW_TYPE_2D
levelCount = 1
baseArrayLayer ≥ 0
layerCount = 1
3D, 0, 0
imageType = VK_IMAGE_TYPE_3D
width ≥ 1
height ≥ 1
depth ≥ 1
arrayLayers = 1
samples = 1
flags includes VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT
flags does not include VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, and VK_IMAGE_CREATE_SPARSE_ALIASED_BIT
viewType = VK_IMAGE_VIEW_TYPE_2D_ARRAY
levelCount = 1
baseArrayLayer ≥ 0
layerCount ≥ 1
Valid Usage
If image was not created with VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT then viewType must not be VK_IMAGE_VIEW_TYPE_CUBE or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
If the image cubemap arrays feature is not enabled, viewType must not be VK_IMAGE_VIEW_TYPE_CUBE_ARRAY
If image was created with VK_IMAGE_TYPE_3D but without VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set then viewType must not be VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY
image must have been created with a usage value containing at least one of VK_IMAGE_USAGE_SAMPLED_BIT, VK_IMAGE_USAGE_STORAGE_BIT, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, or VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT
The format features of the resultant image view must contain at least one bit.
If usage contains VK_IMAGE_USAGE_SAMPLED_BIT, then the format features of the resultant image view must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT.
If usage contains VK_IMAGE_USAGE_STORAGE_BIT, then the image view’s format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT.
If usage contains VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, then the image view’s format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT.
If usage contains VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, then the image view’s format features must contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT.
If usage contains VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, then the image view’s format features must contain at least one of VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT.
subresourceRange.baseMipLevel must be less than the mipLevels specified in VkImageCreateInfo when image was created
If subresourceRange.levelCount is not VK_REMAINING_MIP_LEVELS, subresourceRange.baseMipLevel + subresourceRange.levelCount must be less than or equal to the mipLevels specified in VkImageCreateInfo when image was created
If image was created with usage containing VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, subresourceRange.levelCount must be 1
If image is not a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, or viewType is not VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange::baseArrayLayer must be less than the arrayLayers specified in VkImageCreateInfo when image was created
If subresourceRange::layerCount is not VK_REMAINING_ARRAY_LAYERS, image is not a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, or viewType is not VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange::layerCount must be non-zero and subresourceRange::baseArrayLayer + subresourceRange::layerCount must be less than or equal to the arrayLayers specified in VkImageCreateInfo when image was created
If image is a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, and viewType is VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange::baseArrayLayer must be less than the extent.depth specified in VkImageCreateInfo when image was created
If subresourceRange::layerCount is not VK_REMAINING_ARRAY_LAYERS, image is a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, and viewType is VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange::layerCount must be non-zero and subresourceRange::baseArrayLayer + subresourceRange::layerCount must be less than or equal to the extent.depth specified in VkImageCreateInfo when image was created
If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, format must be compatible with the format used to create image, as defined in Format Compatibility Classes
If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, but without the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, and if the format of the image is not a multi-planar format, format must be compatible with the format used to create image, as defined in Format Compatibility Classes
If image was created with the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, format must be compatible with, or must be an uncompressed format that is size-compatible with, the format used to create image.
If image was created with the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, the levelCount and layerCount members of subresourceRange must both be 1.
If a VkImageFormatListCreateInfoKHR structure was included in the pNext chain of the VkImageCreateInfo struct used when creating image and the viewFormatCount field of VkImageFormatListCreateInfoKHR is not zero then format must be one of the formats in VkImageFormatListCreateInfoKHR::pViewFormats.
If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, if the format of the image is a multi-planar format, and if subresourceRange.aspectMask is one of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT, then format must be compatible with the VkFormat for the plane of the image format indicated by subresourceRange.aspectMask, as defined in html/vkspec.html#formats-compatible-planes
If image was not created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, or if the format of the image is a multi-planar format and if subresourceRange.aspectMask is VK_IMAGE_ASPECT_COLOR_BIT, format must be identical to the format used to create image
If the pNext chain contains an instance of VkSamplerYcbcrConversionInfo with a conversion value other than VK_NULL_HANDLE, all members of components must have the value VK_COMPONENT_SWIZZLE_IDENTITY.
If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object
subresourceRange and viewType must be compatible with the image, as described in the compatibility table
If image has an external format, format must be VK_FORMAT_UNDEFINED.
If image has an external format, the pNext chain must contain an instance of VkSamplerYcbcrConversionInfo with a conversion object created with the same external format as image.
If image has an external format, all members of components must be VK_COMPONENT_SWIZZLE_IDENTITY.
If image was created with usage containing VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, viewType must be VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY
If image was created with usage containing VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, format must be VK_FORMAT_R8_UINT
If dynamic fragment density map feature is not enabled, flags must not contain VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT
If dynamic fragment density map feature is not enabled and image was created with usage containing VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, flags must not contain any of VK_IMAGE_CREATE_PROTECTED_BIT, VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT ifdef::VK_VERSION_1_1,VK_KHR_maintenance2
If the pNext chain includes an instance of VkImageViewUsageCreateInfo, and image was not created with an instance of VkImageStencilUsageCreateInfoEXT in the pNext chain of VkImageCreateInfo, its usage member must not include any bits that were not set in the usage member of the VkImageCreateInfo structure used to create image
If the pNext chain includes an instance of VkImageViewUsageCreateInfo, image was created with an instance of VkImageStencilUsageCreateInfoEXT in the pNext chain of VkImageCreateInfo, and subResourceRange.aspectMask includes VK_IMAGE_ASPECT_STENCIL_BIT, the usage member of the VkImageViewUsageCreateInfo instance must not include any bits that were not set in the usage member of the VkImageStencilUsageCreateInfoEXT structure used to create image
If the pNext chain includes an instance of VkImageViewUsageCreateInfo, image was created with an instance of VkImageStencilUsageCreateInfoEXT in the pNext chain of VkImageCreateInfo, and subResourceRange.aspectMask includes bits other than VK_IMAGE_ASPECT_STENCIL_BIT, the usage member of the VkImageViewUsageCreateInfo instance must not include any bits that were not set in the usage member of the VkImageCreateInfo structure used to create image endif::VK_VERSION_1_1,VK_KHR_maintenance2
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkImageViewASTCDecodeModeEXT, VkImageViewUsageCreateInfo, or VkSamplerYcbcrConversionInfo
Each sType member in the pNext chain must be unique
flags must be a valid combination of VkImageViewCreateFlagBits values
image must be a valid VkImage handle
viewType must be a valid VkImageViewType value
format must be a valid VkFormat value
components must be a valid VkComponentMapping structure
subresourceRange must be a valid VkImageSubresourceRange structure
See Also
VkComponentMapping, VkFormat, VkImage, VkImageSubresourceRange, VkImageViewCreateFlags, VkImageViewType, VkStructureType, vkCreateImageView

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageViewCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageViewHandleInfoNVX(3)
Name
VkImageViewHandleInfoNVX - Structure specifying the image view for handle queries

C Specification
The VkImageViewHandleInfoNVX structure is defined as:

typedef struct VkImageViewHandleInfoNVX {
    VkStructureType     sType;
    const void*         pNext;
    VkImageView         imageView;
    VkDescriptorType    descriptorType;
    VkSampler           sampler;
} VkImageViewHandleInfoNVX;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
imageView is the image view to query.
descriptorType is the type of descriptor for which to query a handle.
sampler is the sampler to combine with the image view when generating the handle.
Description
Valid Usage
descriptorType must be VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
sampler must be a valid VkSampler if descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the image that imageView was created from must have been created with the VK_IMAGE_USAGE_SAMPLED_BIT usage bit set
If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, the image that imageView was created from must have been created with the VK_IMAGE_USAGE_STORAGE_BIT usage bit set
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX
pNext must be NULL
imageView must be a valid VkImageView handle
descriptorType must be a valid VkDescriptorType value
If sampler is not VK_NULL_HANDLE, sampler must be a valid VkSampler handle
Both of imageView, and sampler that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkDescriptorType, VkImageView, VkSampler, VkStructureType, vkGetImageViewHandleNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageViewHandleInfoNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageViewUsageCreateInfo(3)
Name
VkImageViewUsageCreateInfo - Specify the intended usage of an image view

C Specification
The set of usages for the created image view can be restricted compared to the parent image’s usage flags by chaining a VkImageViewUsageCreateInfo structure through the pNext member to VkImageViewCreateInfo.

The VkImageViewUsageCreateInfo structure is defined as:

typedef struct VkImageViewUsageCreateInfo {
    VkStructureType      sType;
    const void*          pNext;
    VkImageUsageFlags    usage;
} VkImageViewUsageCreateInfo;
or the equivalent

typedef VkImageViewUsageCreateInfo VkImageViewUsageCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
usage is a bitmask describing the allowed usages of the image view. See VkImageUsageFlagBits for a description of the supported bits.
Description
When this structure is chained to VkImageViewCreateInfo the usage field overrides the implicit usage parameter inherited from image creation time and its value is used instead for the purposes of determining the valid usage conditions of VkImageViewCreateInfo.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO
usage must be a valid combination of VkImageUsageFlagBits values
usage must not be 0
See Also
VkImageUsageFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageViewUsageCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImportAndroidHardwareBufferInfoANDROID(3)
Name
VkImportAndroidHardwareBufferInfoANDROID - Import memory from an Android hardware buffer

C Specification
To import memory created outside of the current Vulkan instance from an Android hardware buffer, add a VkImportAndroidHardwareBufferInfoANDROID structure to the pNext chain of the VkMemoryAllocateInfo structure. The VkImportAndroidHardwareBufferInfoANDROID structure is defined as:

typedef struct VkImportAndroidHardwareBufferInfoANDROID {
    VkStructureType            sType;
    const void*                pNext;
    struct AHardwareBuffer*    buffer;
} VkImportAndroidHardwareBufferInfoANDROID;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
buffer is the Android hardware buffer to import.
Description
If the vkAllocateMemory command succeeds, the implementation must acquire a reference to the imported hardware buffer, which it must release when the device memory object is freed. If the command fails, the implementation must not retain a reference.

Valid Usage
If buffer is not NULL, Android hardware buffers must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties.
If buffer is not NULL, it must be a valid Android hardware buffer object with AHardwareBuffer_Desc::format and AHardwareBuffer_Desc::usage compatible with Vulkan as described in Android Hardware Buffers.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID
buffer must be a valid pointer to a AHardwareBuffer value
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImportAndroidHardwareBufferInfoANDROID

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImportFenceFdInfoKHR(3)
Name
VkImportFenceFdInfoKHR - (None)

C Specification
The VkImportFenceFdInfoKHR structure is defined as:

typedef struct VkImportFenceFdInfoKHR {
    VkStructureType                      sType;
    const void*                          pNext;
    VkFence                              fence;
    VkFenceImportFlags                   flags;
    VkExternalFenceHandleTypeFlagBits    handleType;
    int                                  fd;
} VkImportFenceFdInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
fence is the fence into which the payload will be imported.
flags is a bitmask of VkFenceImportFlagBits specifying additional parameters for the fence payload import operation.
handleType specifies the type of fd.
fd is the external handle to import.
Description
The handle types supported by handleType are:

Table 8. Handle Types Supported by VkImportFenceFdInfoKHR
Handle Type	Transference	Permanence Supported
VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT
Reference
Temporary,Permanent
VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT
Copy
Temporary
Valid Usage
handleType must be a value included in the Handle Types Supported by VkImportFenceFdInfoKHR table.
fd must obey any requirements listed for handleType in external fence handle types compatibility.
If handleType is VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT, the special value -1 for fd is treated like a valid sync file descriptor referring to an object that has already signaled. The import operation will succeed and the VkFence will have a temporarily imported payload as if a valid file descriptor had been provided.

Note
This special behavior for importing an invalid sync file descriptor allows easier interoperability with other system APIs which use the convention that an invalid sync file descriptor represents work that has already completed and does not need to be waited for. It is consistent with the option for implementations to return a -1 file descriptor when exporting a VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT from a VkFence which is signaled.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR
pNext must be NULL
fence must be a valid VkFence handle
flags must be a valid combination of VkFenceImportFlagBits values
handleType must be a valid VkExternalFenceHandleTypeFlagBits value
Host Synchronization
Host access to fence must be externally synchronized
See Also
VkExternalFenceHandleTypeFlagBits, VkFence, VkFenceImportFlags, VkStructureType, vkImportFenceFdKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImportFenceFdInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImportFenceWin32HandleInfoKHR(3)
Name
VkImportFenceWin32HandleInfoKHR - (None)

C Specification
The VkImportFenceWin32HandleInfoKHR structure is defined as:

typedef struct VkImportFenceWin32HandleInfoKHR {
    VkStructureType                      sType;
    const void*                          pNext;
    VkFence                              fence;
    VkFenceImportFlags                   flags;
    VkExternalFenceHandleTypeFlagBits    handleType;
    HANDLE                               handle;
    LPCWSTR                              name;
} VkImportFenceWin32HandleInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
fence is the fence into which the state will be imported.
flags is a bitmask of VkFenceImportFlagBits specifying additional parameters for the fence payload import operation.
handleType specifies the type of handle.
handle is the external handle to import, or NULL.
name is the NULL-terminated UTF-16 string naming the underlying synchronization primitive to import, or NULL.
Description
The handle types supported by handleType are:

Table 9. Handle Types Supported by VkImportFenceWin32HandleInfoKHR
Handle Type	Transference	Permanence Supported
VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT
Reference
Temporary,Permanent
VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
Reference
Temporary,Permanent
Valid Usage
handleType must be a value included in the Handle Types Supported by VkImportFenceWin32HandleInfoKHR table.
If handleType is not VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT, name must be NULL.
If handleType is not 0 and handle is NULL, name must name a valid synchronization primitive of the type specified by handleType.
If handleType is not 0 and name is NULL, handle must be a valid handle of the type specified by handleType.
If handle is not NULL, name must be NULL.
If handle is not NULL, it must obey any requirements listed for handleType in external fence handle types compatibility.
If name is not NULL, it must obey any requirements listed for handleType in external fence handle types compatibility.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR
pNext must be NULL
fence must be a valid VkFence handle
flags must be a valid combination of VkFenceImportFlagBits values
If handleType is not 0, handleType must be a valid VkExternalFenceHandleTypeFlagBits value
Host Synchronization
Host access to fence must be externally synchronized
See Also
VkExternalFenceHandleTypeFlagBits, VkFence, VkFenceImportFlags, VkStructureType, vkImportFenceWin32HandleKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImportFenceWin32HandleInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImportMemoryFdInfoKHR(3)
Name
VkImportMemoryFdInfoKHR - import memory created on the same physical device from a file descriptor

C Specification
To import memory from a POSIX file descriptor handle, add a VkImportMemoryFdInfoKHR structure to the pNext chain of the VkMemoryAllocateInfo structure. The VkImportMemoryFdInfoKHR structure is defined as:

typedef struct VkImportMemoryFdInfoKHR {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalMemoryHandleTypeFlagBits    handleType;
    int                                   fd;
} VkImportMemoryFdInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
handleType specifies the handle type of fd.
fd is the external handle to import.
Description
Importing memory from a file descriptor transfers ownership of the file descriptor from the application to the Vulkan implementation. The application must not perform any operations on the file descriptor after a successful import.

Applications can import the same underlying memory into multiple instances of Vulkan, into the same instance from which it was exported, and multiple times into a given Vulkan instance. In all cases, each import operation must create a distinct VkDeviceMemory object.

Valid Usage
If handleType is not 0, it must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties.
The memory from which fd was exported must have been created on the same underlying physical device as device.
If handleType is not 0, it must be defined as a POSIX file descriptor handle.
If handleType is not 0, fd must be a valid handle of the type specified by handleType.
The memory represented by fd must have been created from a physical device and driver that is compatible with device and handleType, as described in html/vkspec.html#external-memory-handle-types-compatibility.
fd must obey any requirements listed for handleType in external memory handle types compatibility.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR
If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
See Also
VkExternalMemoryHandleTypeFlagBits, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImportMemoryFdInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImportMemoryHostPointerInfoEXT(3)
Name
VkImportMemoryHostPointerInfoEXT - import memory from a host pointer

C Specification
To import memory from a host pointer, add a VkImportMemoryHostPointerInfoEXT structure to the pNext chain of the VkMemoryAllocateInfo structure. The VkImportMemoryHostPointerInfoEXT structure is defined as:

typedef struct VkImportMemoryHostPointerInfoEXT {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalMemoryHandleTypeFlagBits    handleType;
    void*                                 pHostPointer;
} VkImportMemoryHostPointerInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
handleType specifies the handle type.
pHostPointer is the host pointer to import from.
Description
Importing memory from a host pointer shares ownership of the memory between the host and the Vulkan implementation. The application can continue to access the memory through the host pointer but it is the application’s responsibility to synchronize device and non-device access to the underlying memory as defined in Host Access to Device Memory Objects.

Applications can import the same underlying memory into multiple instances of Vulkan and multiple times into a given Vulkan instance. However, implementations may fail to import the same underlying memory multiple times into a given physical device due to platform constraints.

Importing memory from a particular host pointer may not be possible due to additional platform-specific restrictions beyond the scope of this specification in which case the implementation must fail the memory import operation with the error code VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR.

The application must ensure that the imported memory range remains valid and accessible for the lifetime of the imported memory object.

Valid Usage
If handleType is not 0, it must be supported for import, as reported in VkExternalMemoryPropertiesKHR
If handleType is not 0, it must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT
pHostPointer must be a pointer aligned to an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment
If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT, pHostPointer must be a pointer to allocationSize number of bytes of host memory, where allocationSize is the member of the VkMemoryAllocateInfo structure this structure is chained to
If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT, pHostPointer must be a pointer to allocationSize number of bytes of host mapped foreign memory, where allocationSize is the member of the VkMemoryAllocateInfo structure this structure is chained to
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT
handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
See Also
VkExternalMemoryHandleTypeFlagBits, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImportMemoryHostPointerInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImportMemoryWin32HandleInfoKHR(3)
Name
VkImportMemoryWin32HandleInfoKHR - import Win32 memory created on the same physical device

C Specification
To import memory from a Windows handle, add a VkImportMemoryWin32HandleInfoKHR structure to the pNext chain of the VkMemoryAllocateInfo structure.

The VkImportMemoryWin32HandleInfoKHR structure is defined as:

typedef struct VkImportMemoryWin32HandleInfoKHR {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalMemoryHandleTypeFlagBits    handleType;
    HANDLE                                handle;
    LPCWSTR                               name;
} VkImportMemoryWin32HandleInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
handleType specifies the type of handle or name.
handle is the external handle to import, or NULL.
name is a NULL-terminated UTF-16 string naming the underlying memory resource to import, or NULL.
Description
Importing memory objects from Windows handles does not transfer ownership of the handle to the Vulkan implementation. For handle types defined as NT handles, the application must release ownership using the CloseHandle system call when the handle is no longer needed.

Applications can import the same underlying memory into multiple instances of Vulkan, into the same instance from which it was exported, and multiple times into a given Vulkan instance. In all cases, each import operation must create a distinct VkDeviceMemory object.

Valid Usage
If handleType is not 0, it must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties.
The memory from which handle was exported, or the memory named by name must have been created on the same underlying physical device as device.
If handleType is not 0, it must be defined as an NT handle or a global share handle.
If handleType is not VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, name must be NULL.
If handleType is not 0 and handle is NULL, name must name a valid memory resource of the type specified by handleType.
If handleType is not 0 and name is NULL, handle must be a valid handle of the type specified by handleType.
if handle is not NULL, name must be NULL.
If handle is not NULL, it must obey any requirements listed for handleType in external memory handle types compatibility.
If name is not NULL, it must obey any requirements listed for handleType in external memory handle types compatibility.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR
If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
See Also
VkExternalMemoryHandleTypeFlagBits, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImportMemoryWin32HandleInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImportMemoryWin32HandleInfoNV(3)
Name
VkImportMemoryWin32HandleInfoNV - import Win32 memory created on the same physical device

C Specification
To import memory created on the same physical device but outside of the current Vulkan instance, add a VkImportMemoryWin32HandleInfoNV structure to the pNext chain of the VkMemoryAllocateInfo structure, specifying a handle to and the type of the memory.

The VkImportMemoryWin32HandleInfoNV structure is defined as:

typedef struct VkImportMemoryWin32HandleInfoNV {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalMemoryHandleTypeFlagsNV    handleType;
    HANDLE                               handle;
} VkImportMemoryWin32HandleInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
handleType is 0 or a VkExternalMemoryHandleTypeFlagBitsNV value specifying the type of memory handle in handle.
handle is a Windows HANDLE referring to the memory.
Description
If handleType is 0, this structure is ignored by consumers of the VkMemoryAllocateInfo structure it is chained from.

Valid Usage
handleType must not have more than one bit set.
handle must be a valid handle to memory, obtained as specified by handleType.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV
handleType must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values
See Also
VkExternalMemoryHandleTypeFlagsNV, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImportMemoryWin32HandleInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImportSemaphoreFdInfoKHR(3)
Name
VkImportSemaphoreFdInfoKHR - Structure specifying POSIX file descriptor to import to a semaphore

C Specification
The VkImportSemaphoreFdInfoKHR structure is defined as:

typedef struct VkImportSemaphoreFdInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkSemaphore                              semaphore;
    VkSemaphoreImportFlags                   flags;
    VkExternalSemaphoreHandleTypeFlagBits    handleType;
    int                                      fd;
} VkImportSemaphoreFdInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
semaphore is the semaphore into which the payload will be imported.
flags is a bitmask of VkSemaphoreImportFlagBits specifying additional parameters for the semaphore payload import operation.
handleType specifies the type of fd.
fd is the external handle to import.
Description
The handle types supported by handleType are:

Table 10. Handle Types Supported by VkImportSemaphoreFdInfoKHR
Handle Type	Transference	Permanence Supported
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT
Reference
Temporary,Permanent
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT
Copy
Temporary
Valid Usage
handleType must be a value included in the Handle Types Supported by VkImportSemaphoreFdInfoKHR table.
fd must obey any requirements listed for handleType in external semaphore handle types compatibility.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR
pNext must be NULL
semaphore must be a valid VkSemaphore handle
flags must be a valid combination of VkSemaphoreImportFlagBits values
handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value
Host Synchronization
Host access to semaphore must be externally synchronized
See Also
VkExternalSemaphoreHandleTypeFlagBits, VkSemaphore, VkSemaphoreImportFlags, VkStructureType, vkImportSemaphoreFdKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImportSemaphoreFdInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImportSemaphoreWin32HandleInfoKHR(3)
Name
VkImportSemaphoreWin32HandleInfoKHR - Structure specifying Windows handle to import to a semaphore

C Specification
The VkImportSemaphoreWin32HandleInfoKHR structure is defined as:

typedef struct VkImportSemaphoreWin32HandleInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkSemaphore                              semaphore;
    VkSemaphoreImportFlags                   flags;
    VkExternalSemaphoreHandleTypeFlagBits    handleType;
    HANDLE                                   handle;
    LPCWSTR                                  name;
} VkImportSemaphoreWin32HandleInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
semaphore is the semaphore into which the payload will be imported.
flags is a bitmask of VkSemaphoreImportFlagBits specifying additional parameters for the semaphore payload import operation.
handleType specifies the type of handle.
handle is the external handle to import, or NULL.
name is a NULL-terminated UTF-16 string naming the underlying synchronization primitive to import, or NULL.
Description
The handle types supported by handleType are:

Table 11. Handle Types Supported by VkImportSemaphoreWin32HandleInfoKHR
Handle Type	Transference	Permanence Supported
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT
Reference
Temporary,Permanent
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
Reference
Temporary,Permanent
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT
Reference
Temporary,Permanent
Valid Usage
handleType must be a value included in the Handle Types Supported by VkImportSemaphoreWin32HandleInfoKHR table.
If handleType is not VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT, name must be NULL.
If handleType is not 0 and handle is NULL, name must name a valid synchronization primitive of the type specified by handleType.
If handleType is not 0 and name is NULL, handle must be a valid handle of the type specified by handleType.
If handle is not NULL, name must be NULL.
If handle is not NULL, it must obey any requirements listed for handleType in external semaphore handle types compatibility.
If name is not NULL, it must obey any requirements listed for handleType in external semaphore handle types compatibility.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR
pNext must be NULL
semaphore must be a valid VkSemaphore handle
flags must be a valid combination of VkSemaphoreImportFlagBits values
If handleType is not 0, handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value
Host Synchronization
Host access to semaphore must be externally synchronized
See Also
VkExternalSemaphoreHandleTypeFlagBits, VkSemaphore, VkSemaphoreImportFlags, VkStructureType, vkImportSemaphoreWin32HandleKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImportSemaphoreWin32HandleInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkIndirectCommandsLayoutCreateInfoNVX(3)
Name
VkIndirectCommandsLayoutCreateInfoNVX - Structure specifying the parameters of a newly created indirect commands layout object

C Specification
The VkIndirectCommandsLayoutCreateInfoNVX structure is defined as:

typedef struct VkIndirectCommandsLayoutCreateInfoNVX {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineBindPoint                        pipelineBindPoint;
    VkIndirectCommandsLayoutUsageFlagsNVX      flags;
    uint32_t                                   tokenCount;
    const VkIndirectCommandsLayoutTokenNVX*    pTokens;
} VkIndirectCommandsLayoutCreateInfoNVX;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
pipelineBindPoint is the VkPipelineBindPoint that this layout targets.
flags is a bitmask of VkIndirectCommandsLayoutUsageFlagBitsNVX specifying usage hints of this layout.
tokenCount is the length of the individual command sequnce.
pTokens is an array describing each command token in detail. See VkIndirectCommandsTokenTypeNVX and VkIndirectCommandsLayoutTokenNVX below for details.
Description
The following code illustrates some of the key flags:

void cmdProcessAllSequences(cmd, objectTable, indirectCommandsLayout, pIndirectCommandsTokens, sequencesCount, indexbuffer, indexbufferoffset)
{
  for (s = 0; s < sequencesCount; s++)
  {
    sequence = s;

    if (indirectCommandsLayout.flags & VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX) {
      sequence = incoherent_implementation_dependent_permutation[ sequence ];
    }
    if (indirectCommandsLayout.flags & VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX) {
      sequence = indexbuffer.load_uint32( sequence * sizeof(uint32_t) + indexbufferoffset);
    }

    cmdProcessSequence( cmd, objectTable, indirectCommandsLayout, pIndirectCommandsTokens, sequence );
  }
}
Valid Usage
tokenCount must be greater than 0 and below VkDeviceGeneratedCommandsLimitsNVX::maxIndirectCommandsLayoutTokenCount
If the VkDeviceGeneratedCommandsFeaturesNVX::computeBindingPointSupport feature is not enabled, then pipelineBindPoint must not be VK_PIPELINE_BIND_POINT_COMPUTE
If pTokens contains an entry of VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX it must be the first element of the array and there must be only a single element of such token type.
All state binding tokens in pTokens must occur prior work provoking tokens (VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX, VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX, VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX).
The content of pTokens must include one single work provoking token that is compatible with the pipelineBindPoint.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX
pNext must be NULL
pipelineBindPoint must be a valid VkPipelineBindPoint value
flags must be a valid combination of VkIndirectCommandsLayoutUsageFlagBitsNVX values
flags must not be 0
pTokens must be a valid pointer to an array of tokenCount valid VkIndirectCommandsLayoutTokenNVX structures
tokenCount must be greater than 0
See Also
VkIndirectCommandsLayoutTokenNVX, VkIndirectCommandsLayoutUsageFlagsNVX, VkPipelineBindPoint, VkStructureType, vkCreateIndirectCommandsLayoutNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkIndirectCommandsLayoutCreateInfoNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkIndirectCommandsLayoutTokenNVX(3)
Name
VkIndirectCommandsLayoutTokenNVX - Struct specifying the details of an indirect command layout token

C Specification
The VkIndirectCommandsLayoutTokenNVX structure specifies details to the function arguments that need to be known at layout creation time:

typedef struct VkIndirectCommandsLayoutTokenNVX {
    VkIndirectCommandsTokenTypeNVX    tokenType;
    uint32_t                          bindingUnit;
    uint32_t                          dynamicCount;
    uint32_t                          divisor;
} VkIndirectCommandsLayoutTokenNVX;
Members
type specifies the token command type.
bindingUnit has a different meaning depending on the type, please refer pseudo code further down for details.
dynamicCount has a different meaning depending on the type, please refer pseudo code further down for details.
divisor defines the rate at which the input data buffers are accessed.
Description
Valid Usage
bindingUnit must stay within device supported limits for the appropriate commands.
dynamicCount must stay within device supported limits for the appropriate commands.
divisor must be greater than 0 and a power of two.
Valid Usage (Implicit)
tokenType must be a valid VkIndirectCommandsTokenTypeNVX value
See Also
VkIndirectCommandsLayoutCreateInfoNVX, VkIndirectCommandsTokenTypeNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkIndirectCommandsLayoutTokenNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkIndirectCommandsTokenNVX(3)
Name
VkIndirectCommandsTokenNVX - Structure specifying parameters for the reservation of command buffer space

C Specification
The VkIndirectCommandsTokenNVX structure specifies the input data for a token at processing time.

typedef struct VkIndirectCommandsTokenNVX {
    VkIndirectCommandsTokenTypeNVX    tokenType;
    VkBuffer                          buffer;
    VkDeviceSize                      offset;
} VkIndirectCommandsTokenNVX;
Members
tokenType specifies the token command type.
buffer specifies the VkBuffer storing the functional arguments for each squence. These argumetns can be written by the device.
offset specified an offset into buffer where the arguments start.
Description
Valid Usage
The buffer’s usage flag must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set.
The offset must be aligned to VkDeviceGeneratedCommandsLimitsNVX::minCommandsTokenBufferOffsetAlignment.
Valid Usage (Implicit)
tokenType must be a valid VkIndirectCommandsTokenTypeNVX value
buffer must be a valid VkBuffer handle
See Also
VkBuffer, VkCmdProcessCommandsInfoNVX, VkDeviceSize, VkIndirectCommandsTokenTypeNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkIndirectCommandsTokenNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkInputAttachmentAspectReference(3)
Name
VkInputAttachmentAspectReference - Structure specifying a subpass/input attachment pair and an aspect mask that can be read.

C Specification
The VkInputAttachmentAspectReference structure specifies an aspect mask for a specific input attachment of a specific subpass in the render pass.

subpass and inputAttachmentIndex index into the render pass as:

pCreateInfo::pSubpasses[subpass].pInputAttachments[inputAttachmentIndex]

typedef struct VkInputAttachmentAspectReference {
    uint32_t              subpass;
    uint32_t              inputAttachmentIndex;
    VkImageAspectFlags    aspectMask;
} VkInputAttachmentAspectReference;
or the equivalent

typedef VkInputAttachmentAspectReference VkInputAttachmentAspectReferenceKHR;
Members
subpass is an index into the pSubpasses array of the parent VkRenderPassCreateInfo structure.
inputAttachmentIndex is an index into the pInputAttachments of the specified subpass.
aspectMask is a mask of which aspect(s) can be accessed within the specified subpass.
Description
Valid Usage
aspectMask must not include VK_IMAGE_ASPECT_METADATA_BIT
aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i.
Valid Usage (Implicit)
aspectMask must be a valid combination of VkImageAspectFlagBits values
aspectMask must not be 0
See Also
VkImageAspectFlags, VkRenderPassInputAttachmentAspectCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkInputAttachmentAspectReference

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkInstanceCreateInfo(3)
Name
VkInstanceCreateInfo - Structure specifying parameters of a newly created instance

C Specification
The VkInstanceCreateInfo structure is defined as:

typedef struct VkInstanceCreateInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkInstanceCreateFlags       flags;
    const VkApplicationInfo*    pApplicationInfo;
    uint32_t                    enabledLayerCount;
    const char* const*          ppEnabledLayerNames;
    uint32_t                    enabledExtensionCount;
    const char* const*          ppEnabledExtensionNames;
} VkInstanceCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
pApplicationInfo is NULL or a pointer to an instance of VkApplicationInfo. If not NULL, this information helps implementations recognize behavior inherent to classes of applications. VkApplicationInfo is defined in detail below.
enabledLayerCount is the number of global layers to enable.
ppEnabledLayerNames is a pointer to an array of enabledLayerCount null-terminated UTF-8 strings containing the names of layers to enable for the created instance. See the html/vkspec.html#extendingvulkan-layers section for further details.
enabledExtensionCount is the number of global extensions to enable.
ppEnabledExtensionNames is a pointer to an array of enabledExtensionCount null-terminated UTF-8 strings containing the names of extensions to enable.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDebugReportCallbackCreateInfoEXT, VkDebugUtilsMessengerCreateInfoEXT, VkValidationFeaturesEXT, or VkValidationFlagsEXT
Each sType member in the pNext chain must be unique
flags must be 0
If pApplicationInfo is not NULL, pApplicationInfo must be a valid pointer to a valid VkApplicationInfo structure
If enabledLayerCount is not 0, ppEnabledLayerNames must be a valid pointer to an array of enabledLayerCount null-terminated UTF-8 strings
If enabledExtensionCount is not 0, ppEnabledExtensionNames must be a valid pointer to an array of enabledExtensionCount null-terminated UTF-8 strings
See Also
VkApplicationInfo, VkInstanceCreateFlags, VkStructureType, vkCreateInstance

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkInstanceCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkLayerProperties(3)
Name
VkLayerProperties - Structure specifying layer properties

C Specification
The VkLayerProperties structure is defined as:

typedef struct VkLayerProperties {
    char        layerName[VK_MAX_EXTENSION_NAME_SIZE];
    uint32_t    specVersion;
    uint32_t    implementationVersion;
    char        description[VK_MAX_DESCRIPTION_SIZE];
} VkLayerProperties;
Members
layerName is a null-terminated UTF-8 string specifying the name of the layer. Use this name in the ppEnabledLayerNames array passed in the VkInstanceCreateInfo structure to enable this layer for an instance.
specVersion is the Vulkan version the layer was written to, encoded as described in html/vkspec.html#extendingvulkan-coreversions-versionnumbers.
implementationVersion is the version of this layer. It is an integer, increasing with backward compatible changes.
description is a null-terminated UTF-8 string providing additional details that can be used by the application to identify the layer.
Description
See Also
vkEnumerateDeviceLayerProperties, vkEnumerateInstanceLayerProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkLayerProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMacOSSurfaceCreateInfoMVK(3)
Name
VkMacOSSurfaceCreateInfoMVK - Structure specifying parameters of a newly created macOS surface object

C Specification
The VkMacOSSurfaceCreateInfoMVK structure is defined as:

typedef struct VkMacOSSurfaceCreateInfoMVK {
    VkStructureType                 sType;
    const void*                     pNext;
    VkMacOSSurfaceCreateFlagsMVK    flags;
    const void*                     pView;
} VkMacOSSurfaceCreateInfoMVK;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
pView is a reference to a NSView object which will display this surface. This NSView must be backed by a CALayer instance of type CAMetalLayer.
Description
Valid Usage
pView must be a valid NSView and must be backed by a CALayer instance of type CAMetalLayer.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK
pNext must be NULL
flags must be 0
See Also
VkMacOSSurfaceCreateFlagsMVK, VkStructureType, vkCreateMacOSSurfaceMVK

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMacOSSurfaceCreateInfoMVK

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMappedMemoryRange(3)
Name
VkMappedMemoryRange - Structure specifying a mapped memory range

C Specification
The VkMappedMemoryRange structure is defined as:

typedef struct VkMappedMemoryRange {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceMemory     memory;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkMappedMemoryRange;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
memory is the memory object to which this range belongs.
offset is the zero-based byte offset from the beginning of the memory object.
size is either the size of range, or VK_WHOLE_SIZE to affect the range from offset to the end of the current mapping of the allocation.
Description
Valid Usage
memory must be currently host mapped
If size is not equal to VK_WHOLE_SIZE, offset and size must specify a range contained within the currently mapped range of memory
If size is equal to VK_WHOLE_SIZE, offset must be within the currently mapped range of memory
If size is equal to VK_WHOLE_SIZE, the end of the current mapping of memory must be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize bytes from the beginning of the memory object.
offset must be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize
If size is not equal to VK_WHOLE_SIZE, size must either be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize, or offset plus size must equal the size of memory.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE
pNext must be NULL
memory must be a valid VkDeviceMemory handle
See Also
VkDeviceMemory, VkDeviceSize, VkStructureType, vkFlushMappedMemoryRanges, vkInvalidateMappedMemoryRanges

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMappedMemoryRange

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryAllocateFlagsInfo(3)
Name
VkMemoryAllocateFlagsInfo - Structure controlling how many instances of memory will be allocated

C Specification
If the pNext chain of VkMemoryAllocateInfo includes a VkMemoryAllocateFlagsInfo structure, then that structure includes flags and a device mask controlling how many instances of the memory will be allocated.

The VkMemoryAllocateFlagsInfo structure is defined as:

typedef struct VkMemoryAllocateFlagsInfo {
    VkStructureType          sType;
    const void*              pNext;
    VkMemoryAllocateFlags    flags;
    uint32_t                 deviceMask;
} VkMemoryAllocateFlagsInfo;
or the equivalent

typedef VkMemoryAllocateFlagsInfo VkMemoryAllocateFlagsInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkMemoryAllocateFlagBits controlling the allocation.
deviceMask is a mask of physical devices in the logical device, indicating that memory must be allocated on each device in the mask, if VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is set in flags.
Description
If VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is not set, the number of instances allocated depends on whether VK_MEMORY_HEAP_MULTI_INSTANCE_BIT is set in the memory heap. If VK_MEMORY_HEAP_MULTI_INSTANCE_BIT is set, then memory is allocated for every physical device in the logical device (as if deviceMask has bits set for all device indices). If VK_MEMORY_HEAP_MULTI_INSTANCE_BIT is not set, then a single instance of memory is allocated (as if deviceMask is set to one).

On some implementations, allocations from a multi-instance heap may consume memory on all physical devices even if the deviceMask excludes some devices. If VkPhysicalDeviceGroupProperties::subsetAllocation is VK_TRUE, then memory is only consumed for the devices in the device mask.

Note
In practice, most allocations on a multi-instance heap will be allocated across all physical devices. Unicast allocation support is an optional optimization for a minority of allocations.
Valid Usage
If VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is set, deviceMask must be a valid device mask.
If VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is set, deviceMask must not be zero
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO
flags must be a valid combination of VkMemoryAllocateFlagBits values
See Also
VkMemoryAllocateFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryAllocateFlagsInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryAllocateInfo(3)
Name
VkMemoryAllocateInfo - Structure containing parameters of a memory allocation

C Specification
The VkMemoryAllocateInfo structure is defined as:

typedef struct VkMemoryAllocateInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceSize       allocationSize;
    uint32_t           memoryTypeIndex;
} VkMemoryAllocateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
allocationSize is the size of the allocation in bytes
memoryTypeIndex is an index identifying a memory type from the memoryTypes array of the VkPhysicalDeviceMemoryProperties structure
Description
An instance of the VkMemoryAllocateInfo structure defines a memory import operation if the pNext chain contains an instance of one of the following structures:

VkImportMemoryWin32HandleInfoKHR with non-zero handleType value
VkImportMemoryFdInfoKHR with a non-zero handleType value
VkImportMemoryHostPointerInfoEXT with a non-zero handleType value
VkImportAndroidHardwareBufferInfoANDROID with a non-NULL buffer value
Importing memory must not modify the content of the memory. Implementations must ensure that importing memory does not enable the importing Vulkan instance to access any memory or resources in other Vulkan instances other than that corresponding to the memory object imported. Implementations must also ensure accessing imported memory which has not been initialized does not allow the importing Vulkan instance to obtain data from the exporting Vulkan instance or vice-versa.

Note
How exported and imported memory is isolated is left to the implementation, but applications should be aware that such isolation may prevent implementations from placing multiple exportable memory objects in the same physical or virtual page. Hence, applications should avoid creating many small external memory objects whenever possible.
When performing a memory import operation, it is the responsibility of the application to ensure the external handles meet all valid usage requirements. However, implementations must perform sufficient validation of external handles to ensure that the operation results in a valid memory object which will not cause program termination, device loss, queue stalls, or corruption of other resources when used as allowed according to its allocation parameters. If the external handle provided does not meet these requirements, the implementation must fail the memory import operation with the error code VK_ERROR_INVALID_EXTERNAL_HANDLE.

Valid Usage
If the pNext chain contains an instance of VkExportMemoryAllocateInfo, and any of the handle types specified in VkExportMemoryAllocateInfo::handleTypes require a dedicated allocation, as reported by vkGetPhysicalDeviceImageFormatProperties2 in VkExternalImageFormatProperties::externalMemoryProperties::externalMemoryFeatures or VkExternalBufferProperties::externalMemoryProperties::externalMemoryFeatures, the pNext chain must contain an instance of VkMemoryDedicatedAllocateInfo or VkDedicatedAllocationMemoryAllocateInfoNV with either its image or buffer field set to a value other than VK_NULL_HANDLE.
If the pNext chain contains an instance of VkExportMemoryAllocateInfo, it must not contain an instance of VkExportMemoryAllocateInfoNV or VkExportMemoryWin32HandleInfoNV.
If the pNext chain contains an instance of VkImportMemoryWin32HandleInfoKHR, it must not contain an instance of VkImportMemoryWin32HandleInfoNV.
If the parameters define an import operation, the external handle specified was created by the Vulkan API, and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR, then the values of allocationSize and memoryTypeIndex must match those specified when the memory object being imported was created.
If the parameters define an import operation and the external handle specified was created by the Vulkan API, the device mask specified by VkMemoryAllocateFlagsInfo must match that specified when the memory object being imported was allocated.
If the parameters define an import operation and the external handle specified was created by the Vulkan API, the list of physical devices that comprise the logical device passed to vkAllocateMemory must match the list of physical devices that comprise the logical device on which the memory was originally allocated.
If the parameters define an import operation and the external handle is an NT handle or a global share handle created outside of the Vulkan API, the value of memoryTypeIndex must be one of those returned by vkGetMemoryWin32HandlePropertiesKHR.
If the parameters define an import operation, the external handle was created by the Vulkan API, and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR or VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR, then the values of allocationSize and memoryTypeIndex must match those specified when the memory object being imported was created.
If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, allocationSize must match the size reported in the memory requirements of the image or buffer member of the instance of VkDedicatedAllocationMemoryAllocateInfoNV included in the pNext chain.
If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, allocationSize must match the size specified when creating the Direct3D 12 heap from which the external handle was extracted.
If the parameters define an import operation and the external handle is a POSIX file descriptor created outside of the Vulkan API, the value of memoryTypeIndex must be one of those returned by vkGetMemoryFdPropertiesKHR.
If the protected memory feature is not enabled, the VkMemoryAllocateInfo::memoryTypeIndex must not indicate a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT.
If the parameters define an import operation and the external handle is a host pointer, the value of memoryTypeIndex must be one of those returned by vkGetMemoryHostPointerPropertiesEXT
If the parameters define an import operation and the external handle is a host pointer, allocationSize must be an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment
If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, allocationSize must be the size returned by vkGetAndroidHardwareBufferPropertiesANDROID for the Android hardware buffer.
If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, and the pNext chain does not contain an instance of VkMemoryDedicatedAllocateInfo or VkMemoryDedicatedAllocateInfo::image is VK_NULL_HANDLE, the Android hardware buffer must have a AHardwareBuffer_Desc::format of AHARDWAREBUFFER_FORMAT_BLOB and a AHardwareBuffer_Desc::usage that includes AHARDWAREBUFFER_USAGE_GPU_DATA_BUFFER.
If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, memoryTypeIndex must be one of those returned by vkGetAndroidHardwareBufferPropertiesANDROID for the Android hardware buffer.
If the parameters do not define an import operation, and the pNext chain contains an instance of VkExportMemoryAllocateInfo with VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID included in its handleTypes member, and the pNext contains an instance of VkMemoryDedicatedAllocateInfo with image not equal to VK_NULL_HANDLE, then allocationSize must be 0, otherwise allocationSize must be greater than 0.
If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes an instance of VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, the Android hardware buffer’s AHardwareBuffer::usage must include at least one of AHARDWAREBUFFER_USAGE_GPU_COLOR_OUTPUT or AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE.
If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes an instance of VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, the format of image must be VK_FORMAT_UNDEFINED or the format returned by vkGetAndroidHardwareBufferPropertiesANDROID in VkAndroidHardwareBufferFormatPropertiesANDROID::format for the Android hardware buffer.
If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes an instance of VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, the width, height, and array layer dimensions of image and the Android hardware buffer’s AHardwareBuffer_Desc must be identical.
If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes an instance of VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, and the Android hardware buffer’s AHardwareBuffer::usage includes AHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE, the image must have a complete mipmap chain.
If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes an instance of VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, and the Android hardware buffer’s AHardwareBuffer::usage does not include AHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE, the image must have exactly one mipmap level.
If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes an instance of VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, each bit set in the usage of image must be listed in AHardwareBuffer Usage Equivalence, and if there is a corresponding AHARDWAREBUFFER_USAGE bit listed that bit must be included in the Android hardware buffer’s AHardwareBuffer_Desc::usage.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDedicatedAllocationMemoryAllocateInfoNV, VkExportMemoryAllocateInfo, VkExportMemoryAllocateInfoNV, VkExportMemoryWin32HandleInfoKHR, VkExportMemoryWin32HandleInfoNV, VkImportAndroidHardwareBufferInfoANDROID, VkImportMemoryFdInfoKHR, VkImportMemoryHostPointerInfoEXT, VkImportMemoryWin32HandleInfoKHR, VkImportMemoryWin32HandleInfoNV, VkMemoryAllocateFlagsInfo, VkMemoryDedicatedAllocateInfo, or VkMemoryPriorityAllocateInfoEXT
Each sType member in the pNext chain must be unique
See Also
VkDeviceSize, VkStructureType, vkAllocateMemory

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryAllocateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryBarrier(3)
Name
VkMemoryBarrier - Structure specifying a global memory barrier

C Specification
The VkMemoryBarrier structure is defined as:

typedef struct VkMemoryBarrier {
    VkStructureType    sType;
    const void*        pNext;
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
} VkMemoryBarrier;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
srcAccessMask is a bitmask of VkAccessFlagBits specifying a source access mask.
dstAccessMask is a bitmask of VkAccessFlagBits specifying a destination access mask.
Description
The first access scope is limited to access types in the source access mask specified by srcAccessMask.

The second access scope is limited to access types in the destination access mask specified by dstAccessMask.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MEMORY_BARRIER
pNext must be NULL
srcAccessMask must be a valid combination of VkAccessFlagBits values
dstAccessMask must be a valid combination of VkAccessFlagBits values
See Also
VkAccessFlags, VkStructureType, vkCmdPipelineBarrier, vkCmdWaitEvents

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryBarrier

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryDedicatedAllocateInfo(3)
Name
VkMemoryDedicatedAllocateInfo - Specify a dedicated memory allocation resource

C Specification
If the pNext chain includes a VkMemoryDedicatedAllocateInfo structure, then that structure includes a handle of the sole buffer or image resource that the memory can be bound to.

The VkMemoryDedicatedAllocateInfo structure is defined as:

typedef struct VkMemoryDedicatedAllocateInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkImage            image;
    VkBuffer           buffer;
} VkMemoryDedicatedAllocateInfo;
or the equivalent

typedef VkMemoryDedicatedAllocateInfo VkMemoryDedicatedAllocateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
image is VK_NULL_HANDLE or a handle of an image which this memory will be bound to.
buffer is VK_NULL_HANDLE or a handle of a buffer which this memory will be bound to.
Description
Valid Usage
At least one of image and buffer must be VK_NULL_HANDLE
If image is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the image
If image is not VK_NULL_HANDLE, image must have been created without VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in VkImageCreateInfo::flags
If buffer is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the buffer
If buffer is not VK_NULL_HANDLE, buffer must have been created without VK_BUFFER_CREATE_SPARSE_BINDING_BIT set in VkBufferCreateInfo::flags
If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, and the external handle was created by the Vulkan API, then the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory.
If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, and the external handle was created by the Vulkan API, then the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory.
If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory.
If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory.
If image is not VK_NULL_HANDLE, image must not have been created with VK_IMAGE_CREATE_DISJOINT_BIT set in VkImageCreateInfo::flags
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO
If image is not VK_NULL_HANDLE, image must be a valid VkImage handle
If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle
Both of buffer, and image that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkBuffer, VkImage, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryDedicatedAllocateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryDedicatedRequirements(3)
Name
VkMemoryDedicatedRequirements - Structure describing dedicated allocation requirements of buffer and image resources

C Specification
To determine the dedicated allocation requirements of a buffer or image resource, add a VkMemoryDedicatedRequirements structure to the pNext chain of the VkMemoryRequirements2 structure passed as the pMemoryRequirements parameter of vkGetBufferMemoryRequirements2 or vkGetImageMemoryRequirements2.

The VkMemoryDedicatedRequirements structure is defined as:

typedef struct VkMemoryDedicatedRequirements {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           prefersDedicatedAllocation;
    VkBool32           requiresDedicatedAllocation;
} VkMemoryDedicatedRequirements;
or the equivalent

typedef VkMemoryDedicatedRequirements VkMemoryDedicatedRequirementsKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
prefersDedicatedAllocation specifies that the implementation would prefer a dedicated allocation for this resource. The application is still free to suballocate the resource but it may get better performance if a dedicated allocation is used.
requiresDedicatedAllocation specifies that a dedicated allocation is required for this resource.
Description
When the implementation sets requiresDedicatedAllocation to VK_TRUE, it must also set prefersDedicatedAllocation to VK_TRUE.

If the VkMemoryDedicatedRequirements structure is included in the pNext chain of the VkMemoryRequirements2 structure passed as the pMemoryRequirements parameter of a vkGetBufferMemoryRequirements2 call, requiresDedicatedAllocation may be VK_TRUE under one of the following conditions:

The pNext chain of VkBufferCreateInfo for the call to vkCreateBuffer used to create the buffer being queried contained an instance of VkExternalMemoryBufferCreateInfo, and any of the handle types specified in VkExternalMemoryBufferCreateInfo::handleTypes requires dedicated allocation, as reported by vkGetPhysicalDeviceExternalBufferProperties in VkExternalBufferProperties::externalMemoryProperties::externalMemoryFeatures, the requiresDedicatedAllocation field will be set to VK_TRUE.
In all other cases, requiresDedicatedAllocation must be set to VK_FALSE by the implementation whenever a VkMemoryDedicatedRequirements structure is included in the pNext chain of the VkMemoryRequirements2 structure passed to a call to vkGetBufferMemoryRequirements2.

If the VkMemoryDedicatedRequirements structure is included in the pNext chain of the VkMemoryRequirements2 structure passed as the pMemoryRequirements parameter of a vkGetBufferMemoryRequirements2 call and VK_BUFFER_CREATE_SPARSE_BINDING_BIT was set in VkBufferCreateInfo::flags when buffer was created then the implementation must set both prefersDedicatedAllocation and requiresDedicatedAllocation to VK_FALSE.

If the VkMemoryDedicatedRequirements structure is included in the pNext chain of the VkMemoryRequirements2 structure passed as the pMemoryRequirements parameter of a vkGetImageMemoryRequirements2 call, requiresDedicatedAllocation may be VK_TRUE under one of the following conditions:

The pNext chain of VkImageCreateInfo for the call to vkCreateImage used to create the image being queried contained an instance of VkExternalMemoryImageCreateInfo, and any of the handle types specified in VkExternalMemoryImageCreateInfo::handleTypes requires dedicated allocation, as reported by vkGetPhysicalDeviceImageFormatProperties2 in VkExternalImageFormatProperties::externalMemoryProperties::externalMemoryFeatures, the requiresDedicatedAllocation field will be set to VK_TRUE.
In all other cases, requiresDedicatedAllocation must be set to VK_FALSE by the implementation whenever a VkMemoryDedicatedRequirements structure is included in the pNext chain of the VkMemoryRequirements2 structure passed to a call to vkGetImageMemoryRequirements2.

If the VkMemoryDedicatedRequirements structure is included in the pNext chain of the VkMemoryRequirements2 structure passed as the pMemoryRequirements parameter of a vkGetImageMemoryRequirements2 call and VK_IMAGE_CREATE_SPARSE_BINDING_BIT was set in VkImageCreateInfo::flags when image was created then the implementation must set both prefersDedicatedAllocation and requiresDedicatedAllocation to VK_FALSE.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryDedicatedRequirements

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryFdPropertiesKHR(3)
Name
VkMemoryFdPropertiesKHR - Properties of External Memory File Descriptors

C Specification
The VkMemoryFdPropertiesKHR structure returned is defined as:

typedef struct VkMemoryFdPropertiesKHR {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           memoryTypeBits;
} VkMemoryFdPropertiesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
memoryTypeBits is a bitmask containing one bit set for every memory type which the specified file descriptor can be imported as.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR
pNext must be NULL
See Also
VkStructureType, vkGetMemoryFdPropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryFdPropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryGetAndroidHardwareBufferInfoANDROID(3)
Name
VkMemoryGetAndroidHardwareBufferInfoANDROID - Structure describing an Android hardware buffer memory export operation

C Specification
The VkMemoryGetAndroidHardwareBufferInfoANDROID structure is defined as:

typedef struct VkMemoryGetAndroidHardwareBufferInfoANDROID {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceMemory     memory;
} VkMemoryGetAndroidHardwareBufferInfoANDROID;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
memory is the memory object from which the Android hardware buffer will be exported.
Description
Valid Usage
VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID must have been included in VkExportMemoryAllocateInfoKHR::handleTypes when memory was created.
If the pNext chain of the VkMemoryAllocateInfo used to allocate memory included a VkMemoryDedicatedAllocateInfo with non-NULL image member, then that image must already be bound to memory.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID
pNext must be NULL
memory must be a valid VkDeviceMemory handle
See Also
VkDeviceMemory, VkStructureType, vkGetMemoryAndroidHardwareBufferANDROID

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryGetAndroidHardwareBufferInfoANDROID

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryGetFdInfoKHR(3)
Name
VkMemoryGetFdInfoKHR - Structure describing a POSIX FD semaphore export operation

C Specification
The VkMemoryGetFdInfoKHR structure is defined as:

typedef struct VkMemoryGetFdInfoKHR {
    VkStructureType                       sType;
    const void*                           pNext;
    VkDeviceMemory                        memory;
    VkExternalMemoryHandleTypeFlagBits    handleType;
} VkMemoryGetFdInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
memory is the memory object from which the handle will be exported.
handleType is the type of handle requested.
Description
The properties of the file descriptor exported depend on the value of handleType. See VkExternalMemoryHandleTypeFlagBits for a description of the properties of the defined external memory handle types.

Note
The size of the exported file may be larger than the size requested by VkMemoryAllocateInfo::allocationSize. If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT, then the application can query the file’s actual size with lseek(2).
Valid Usage
handleType must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created.
handleType must be defined as a POSIX file descriptor handle.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR
pNext must be NULL
memory must be a valid VkDeviceMemory handle
handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
See Also
VkDeviceMemory, VkExternalMemoryHandleTypeFlagBits, VkStructureType, vkGetMemoryFdKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryGetFdInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryGetWin32HandleInfoKHR(3)
Name
VkMemoryGetWin32HandleInfoKHR - Structure describing a Win32 handle semaphore export operation

C Specification
The VkMemoryGetWin32HandleInfoKHR structure is defined as:

typedef struct VkMemoryGetWin32HandleInfoKHR {
    VkStructureType                       sType;
    const void*                           pNext;
    VkDeviceMemory                        memory;
    VkExternalMemoryHandleTypeFlagBits    handleType;
} VkMemoryGetWin32HandleInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
memory is the memory object from which the handle will be exported.
handleType is the type of handle requested.
Description
The properties of the handle returned depend on the value of handleType. See VkExternalMemoryHandleTypeFlagBits for a description of the properties of the defined external memory handle types.

Valid Usage
handleType must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created.
If handleType is defined as an NT handle, vkGetMemoryWin32HandleKHR must be called no more than once for each valid unique combination of memory and handleType.
handleType must be defined as an NT handle or a global share handle.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR
pNext must be NULL
memory must be a valid VkDeviceMemory handle
handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
See Also
VkDeviceMemory, VkExternalMemoryHandleTypeFlagBits, VkStructureType, vkGetMemoryWin32HandleKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryGetWin32HandleInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryHeap(3)
Name
VkMemoryHeap - Structure specifying a memory heap

C Specification
The VkMemoryHeap structure is defined as:

typedef struct VkMemoryHeap {
    VkDeviceSize         size;
    VkMemoryHeapFlags    flags;
} VkMemoryHeap;
Members
size is the total memory size in bytes in the heap.
flags is a bitmask of VkMemoryHeapFlagBits specifying attribute flags for the heap.
Description
See Also
VkDeviceSize, VkMemoryHeapFlags, VkPhysicalDeviceMemoryProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryHeap

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryHostPointerPropertiesEXT(3)
Name
VkMemoryHostPointerPropertiesEXT - Properties of external memory host pointer

C Specification
The VkMemoryHostPointerPropertiesEXT structure is defined as:

typedef struct VkMemoryHostPointerPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           memoryTypeBits;
} VkMemoryHostPointerPropertiesEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
memoryTypeBits is a bitmask containing one bit set for every memory type which the specified host pointer can be imported as.
Description
The value returned by memoryTypeBits must only include bits that identify memory types which are host visible.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT
pNext must be NULL
See Also
VkStructureType, vkGetMemoryHostPointerPropertiesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryHostPointerPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryPriorityAllocateInfoEXT(3)
Name
VkMemoryPriorityAllocateInfoEXT - Specify a memory allocation priority

C Specification
If the pNext chain includes a VkMemoryPriorityAllocateInfoEXT structure, then that structure includes a priority for the memory.

The VkMemoryPriorityAllocateInfoEXT structure is defined as:

typedef struct VkMemoryPriorityAllocateInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    float              priority;
} VkMemoryPriorityAllocateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
priority is a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations. Larger values are higher priority. The granularity of the priorities is implementation-dependent.
Description
Memory allocations with higher priority may be more likely to stay in device-local memory when the system is under memory pressure.

If this structure is not included, it is as if the priority value were 0.5.

Valid Usage
priority must be between 0 and 1, inclusive
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryPriorityAllocateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryRequirements(3)
Name
VkMemoryRequirements - Structure specifying memory requirements

C Specification
The VkMemoryRequirements structure is defined as:

typedef struct VkMemoryRequirements {
    VkDeviceSize    size;
    VkDeviceSize    alignment;
    uint32_t        memoryTypeBits;
} VkMemoryRequirements;
Members
size is the size, in bytes, of the memory allocation required for the resource.
alignment is the alignment, in bytes, of the offset within the allocation required for the resource.
memoryTypeBits is a bitmask and contains one bit set for every supported memory type for the resource. Bit i is set if and only if the memory type i in the VkPhysicalDeviceMemoryProperties structure for the physical device is supported for the resource.
Description
See Also
VkDeviceSize, VkMemoryRequirements2, vkGetBufferMemoryRequirements, vkGetImageMemoryRequirements

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryRequirements

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryRequirements2(3)
Name
VkMemoryRequirements2 - Structure specifying memory requirements

C Specification
The VkMemoryRequirements2 structure is defined as:

typedef struct VkMemoryRequirements2 {
    VkStructureType         sType;
    void*                   pNext;
    VkMemoryRequirements    memoryRequirements;
} VkMemoryRequirements2;
or the equivalent

typedef VkMemoryRequirements2 VkMemoryRequirements2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
memoryRequirements is a structure of type VkMemoryRequirements describing the memory requirements of the resource.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2
pNext must be NULL or a pointer to a valid instance of VkMemoryDedicatedRequirements
See Also
VkMemoryRequirements, VkStructureType, vkGetBufferMemoryRequirements2, vkGetBufferMemoryRequirements2KHR, vkGetImageMemoryRequirements2, vkGetImageMemoryRequirements2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryRequirements2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryType(3)
Name
VkMemoryType - Structure specifying memory type

C Specification
The VkMemoryType structure is defined as:

typedef struct VkMemoryType {
    VkMemoryPropertyFlags    propertyFlags;
    uint32_t                 heapIndex;
} VkMemoryType;
Members
heapIndex describes which memory heap this memory type corresponds to, and must be less than memoryHeapCount from the VkPhysicalDeviceMemoryProperties structure.
propertyFlags is a bitmask of VkMemoryPropertyFlagBits of properties for this memory type.
Description
See Also
VkMemoryPropertyFlags, VkPhysicalDeviceMemoryProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryType

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryWin32HandlePropertiesKHR(3)
Name
VkMemoryWin32HandlePropertiesKHR - Properties of External Memory Windows Handles

C Specification
The VkMemoryWin32HandlePropertiesKHR structure returned is defined as:

typedef struct VkMemoryWin32HandlePropertiesKHR {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           memoryTypeBits;
} VkMemoryWin32HandlePropertiesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
memoryTypeBits is a bitmask containing one bit set for every memory type which the specified windows handle can be imported as.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR
pNext must be NULL
See Also
VkStructureType, vkGetMemoryWin32HandlePropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryWin32HandlePropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMetalSurfaceCreateInfoEXT(3)
Name
VkMetalSurfaceCreateInfoEXT - Structure specifying parameters of a newly created Metal surface object

C Specification
The VkMetalSurfaceCreateInfoEXT structure is defined as:

typedef struct VkMetalSurfaceCreateInfoEXT {
    VkStructureType                 sType;
    const void*                     pNext;
    VkMetalSurfaceCreateFlagsEXT    flags;
    const CAMetalLayer*             pLayer;
} VkMetalSurfaceCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
pLayer is a reference to a CAMetalLayer object that represents a renderable surface.
Description
Valid Usage
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT
pNext must be NULL
flags must be 0
See Also
VkMetalSurfaceCreateFlagsEXT, VkStructureType, vkCreateMetalSurfaceEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMetalSurfaceCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMultisamplePropertiesEXT(3)
Name
VkMultisamplePropertiesEXT - Structure returning information about sample count specific additional multisampling capabilities

C Specification
The VkMultisamplePropertiesEXT structure is defined as

typedef struct VkMultisamplePropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkExtent2D         maxSampleLocationGridSize;
} VkMultisamplePropertiesEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
maxSampleLocationGridSize is the maximum size of the pixel grid in which sample locations can vary.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT
pNext must be NULL
See Also
VkExtent2D, VkStructureType, vkGetPhysicalDeviceMultisamplePropertiesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMultisamplePropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkObjectTableCreateInfoNVX(3)
Name
VkObjectTableCreateInfoNVX - Structure specifying the parameters of a newly created object table

C Specification
The VkObjectTableCreateInfoNVX structure is defined as:

typedef struct VkObjectTableCreateInfoNVX {
    VkStructureType                      sType;
    const void*                          pNext;
    uint32_t                             objectCount;
    const VkObjectEntryTypeNVX*          pObjectEntryTypes;
    const uint32_t*                      pObjectEntryCounts;
    const VkObjectEntryUsageFlagsNVX*    pObjectEntryUsageFlags;
    uint32_t                             maxUniformBuffersPerDescriptor;
    uint32_t                             maxStorageBuffersPerDescriptor;
    uint32_t                             maxStorageImagesPerDescriptor;
    uint32_t                             maxSampledImagesPerDescriptor;
    uint32_t                             maxPipelineLayouts;
} VkObjectTableCreateInfoNVX;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
objectCount is the number of entry configurations that the object table supports.
pObjectEntryTypes is an array of VkObjectEntryTypeNVX values providing the entry type of a given configuration.
pObjectEntryCounts is an array of counts of how many objects can be registered in the table.
pObjectEntryUsageFlags is an array of bitmasks of VkObjectEntryUsageFlagBitsNVX specifying the binding usage of the entry.
maxUniformBuffersPerDescriptor is the maximum number of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC used by any single registered VkDescriptorSet in this table.
maxStorageBuffersPerDescriptor is the maximum number of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC used by any single registered VkDescriptorSet in this table.
maxStorageImagesPerDescriptor is the maximum number of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER used by any single registered VkDescriptorSet in this table.
maxSampledImagesPerDescriptor is the maximum number of VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT used by any single registered VkDescriptorSet in this table.
maxPipelineLayouts is the maximum number of unique VkPipelineLayout used by any registered VkDescriptorSet or VkPipeline in this table.
Description
Valid Usage
If the VkDeviceGeneratedCommandsFeaturesNVX::computeBindingPointSupport feature is not enabled, pObjectEntryUsageFlags must not contain VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX
Any value within pObjectEntryCounts must not exceed VkDeviceGeneratedCommandsLimitsNVX::maxObjectEntryCounts
maxUniformBuffersPerDescriptor must be within the limits supported by the device.
maxStorageBuffersPerDescriptor must be within the limits supported by the device.
maxStorageImagesPerDescriptor must be within the limits supported by the device.
maxSampledImagesPerDescriptor must be within the limits supported by the device.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX
pNext must be NULL
pObjectEntryTypes must be a valid pointer to an array of objectCount valid VkObjectEntryTypeNVX values
pObjectEntryCounts must be a valid pointer to an array of objectCount uint32_t values
pObjectEntryUsageFlags must be a valid pointer to an array of objectCount valid combinations of VkObjectEntryUsageFlagBitsNVX values
Each element of pObjectEntryUsageFlags must not be 0
objectCount must be greater than 0
See Also
VkObjectEntryTypeNVX, VkObjectEntryUsageFlagsNVX, VkStructureType, vkCreateObjectTableNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkObjectTableCreateInfoNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkObjectTableDescriptorSetEntryNVX(3)
Name
VkObjectTableDescriptorSetEntryNVX - Parameters of an object table descriptor set entry

C Specification
typedef struct VkObjectTableDescriptorSetEntryNVX {
    VkObjectEntryTypeNVX          type;
    VkObjectEntryUsageFlagsNVX    flags;
    VkPipelineLayout              pipelineLayout;
    VkDescriptorSet               descriptorSet;
} VkObjectTableDescriptorSetEntryNVX;
Members
pipelineLayout specifies the VkPipelineLayout that the descriptorSet is used with.
descriptorSet specifies the VkDescriptorSet that can be bound with this entry.
Description
Valid Usage
type must be VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX
Valid Usage (Implicit)
type must be a valid VkObjectEntryTypeNVX value
flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values
flags must not be 0
pipelineLayout must be a valid VkPipelineLayout handle
descriptorSet must be a valid VkDescriptorSet handle
Both of descriptorSet, and pipelineLayout must have been created, allocated, or retrieved from the same VkDevice
See Also
VkDescriptorSet, VkObjectEntryTypeNVX, VkObjectEntryUsageFlagsNVX, VkPipelineLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkObjectTableDescriptorSetEntryNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkObjectTableEntryNVX(3)
Name
VkObjectTableEntryNVX - Common parameters of an object table resource entry

C Specification
Common to all resource entries are:

typedef struct VkObjectTableEntryNVX {
    VkObjectEntryTypeNVX          type;
    VkObjectEntryUsageFlagsNVX    flags;
} VkObjectTableEntryNVX;
Members
type defines the entry type
flags defines which VkPipelineBindPoint the resource can be used with. Some entry types allow only a single flag to be set.
Description
Valid Usage
If the VkDeviceGeneratedCommandsFeaturesNVX::computeBindingPointSupport feature is not enabled, flags must not contain VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX
Valid Usage (Implicit)
type must be a valid VkObjectEntryTypeNVX value
flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values
flags must not be 0
See Also
VkObjectEntryTypeNVX, VkObjectEntryUsageFlagsNVX, vkRegisterObjectsNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkObjectTableEntryNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkObjectTableIndexBufferEntryNVX(3)
Name
VkObjectTableIndexBufferEntryNVX - Parameters of an object table index buffer entry

C Specification
typedef struct VkObjectTableIndexBufferEntryNVX {
    VkObjectEntryTypeNVX          type;
    VkObjectEntryUsageFlagsNVX    flags;
    VkBuffer                      buffer;
    VkIndexType                   indexType;
} VkObjectTableIndexBufferEntryNVX;
Members
buffer specifies the VkBuffer that can be bound as index buffer
indexType specifies the VkIndexType used with this index buffer
Description
Valid Usage
type must be VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX
Valid Usage (Implicit)
type must be a valid VkObjectEntryTypeNVX value
flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values
flags must not be 0
buffer must be a valid VkBuffer handle
indexType must be a valid VkIndexType value
See Also
VkBuffer, VkIndexType, VkObjectEntryTypeNVX, VkObjectEntryUsageFlagsNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkObjectTableIndexBufferEntryNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkObjectTablePipelineEntryNVX(3)
Name
VkObjectTablePipelineEntryNVX - Parameters of an object table pipeline entry

C Specification
typedef struct VkObjectTablePipelineEntryNVX {
    VkObjectEntryTypeNVX          type;
    VkObjectEntryUsageFlagsNVX    flags;
    VkPipeline                    pipeline;
} VkObjectTablePipelineEntryNVX;
Members
pipeline specifies the VkPipeline that this resource entry references.
Description
Valid Usage
type must be VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX
Valid Usage (Implicit)
type must be a valid VkObjectEntryTypeNVX value
flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values
flags must not be 0
pipeline must be a valid VkPipeline handle
See Also
VkObjectEntryTypeNVX, VkObjectEntryUsageFlagsNVX, VkPipeline

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkObjectTablePipelineEntryNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkObjectTablePushConstantEntryNVX(3)
Name
VkObjectTablePushConstantEntryNVX - Parameters of an object table push constant entry

C Specification
typedef struct VkObjectTablePushConstantEntryNVX {
    VkObjectEntryTypeNVX          type;
    VkObjectEntryUsageFlagsNVX    flags;
    VkPipelineLayout              pipelineLayout;
    VkShaderStageFlags            stageFlags;
} VkObjectTablePushConstantEntryNVX;
Members
pipelineLayout specifies the VkPipelineLayout that the pushconstants are used with
stageFlags specifies the VkShaderStageFlags that the pushconstants are used with
Description
Valid Usage
type must be VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX
Valid Usage (Implicit)
type must be a valid VkObjectEntryTypeNVX value
flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values
flags must not be 0
pipelineLayout must be a valid VkPipelineLayout handle
stageFlags must be a valid combination of VkShaderStageFlagBits values
stageFlags must not be 0
See Also
VkObjectEntryTypeNVX, VkObjectEntryUsageFlagsNVX, VkPipelineLayout, VkShaderStageFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkObjectTablePushConstantEntryNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkObjectTableVertexBufferEntryNVX(3)
Name
VkObjectTableVertexBufferEntryNVX - Parameters of an object table vertex buffer entry

C Specification
typedef struct VkObjectTableVertexBufferEntryNVX {
    VkObjectEntryTypeNVX          type;
    VkObjectEntryUsageFlagsNVX    flags;
    VkBuffer                      buffer;
} VkObjectTableVertexBufferEntryNVX;
Members
buffer specifies the VkBuffer that can be bound as vertex bufer
Description
Valid Usage
type must be VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX
Valid Usage (Implicit)
type must be a valid VkObjectEntryTypeNVX value
flags must be a valid combination of VkObjectEntryUsageFlagBitsNVX values
flags must not be 0
buffer must be a valid VkBuffer handle
See Also
VkBuffer, VkObjectEntryTypeNVX, VkObjectEntryUsageFlagsNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkObjectTableVertexBufferEntryNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkOffset2D(3)
Name
VkOffset2D - Structure specifying a two-dimensional offset

C Specification
A two-dimensional offsets is defined by the structure:

typedef struct VkOffset2D {
    int32_t    x;
    int32_t    y;
} VkOffset2D;
Members
x is the x offset.
y is the y offset.
Description
See Also
VkDisplayPlaneCapabilitiesKHR, VkRect2D, VkRectLayerKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkOffset2D

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkOffset3D(3)
Name
VkOffset3D - Structure specifying a three-dimensional offset

C Specification
A three-dimensional offset is defined by the structure:

typedef struct VkOffset3D {
    int32_t    x;
    int32_t    y;
    int32_t    z;
} VkOffset3D;
Members
x is the x offset.
y is the y offset.
z is the z offset.
Description
See Also
VkBufferImageCopy, VkImageBlit, VkImageCopy, VkImageResolve, VkSparseImageMemoryBind

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkOffset3D

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPastPresentationTimingGOOGLE(3)
Name
VkPastPresentationTimingGOOGLE - Structure containing timing information about a previously-presented image

C Specification
The VkPastPresentationTimingGOOGLE structure is defined as:

typedef struct VkPastPresentationTimingGOOGLE {
    uint32_t    presentID;
    uint64_t    desiredPresentTime;
    uint64_t    actualPresentTime;
    uint64_t    earliestPresentTime;
    uint64_t    presentMargin;
} VkPastPresentationTimingGOOGLE;
Members
presentID is an application-provided value that was given to a previous vkQueuePresentKHR command via VkPresentTimeGOOGLE::presentID (see below). It can be used to uniquely identify a previous present with the vkQueuePresentKHR command.
desiredPresentTime is an application-provided value that was given to a previous vkQueuePresentKHR command via VkPresentTimeGOOGLE::desiredPresentTime. If non-zero, it was used by the application to indicate that an image not be presented any sooner than desiredPresentTime.
actualPresentTime is the time when the image of the swapchain was actually displayed.
earliestPresentTime is the time when the image of the swapchain could have been displayed. This may differ from actualPresentTime if the application requested that the image be presented no sooner than VkPresentTimeGOOGLE::desiredPresentTime.
presentMargin is an indication of how early the vkQueuePresentKHR command was processed compared to how soon it needed to be processed, and still be presented at earliestPresentTime.
Description
The results for a given swapchain and presentID are only returned once from vkGetPastPresentationTimingGOOGLE.

The application can use the VkPastPresentationTimingGOOGLE values to occasionally adjust its timing. For example, if actualPresentTime is later than expected (e.g. one refreshDuration late), the application may increase its target IPD to a higher multiple of refreshDuration (e.g. decrease its frame rate from 60Hz to 30Hz). If actualPresentTime and earliestPresentTime are consistently different, and if presentMargin is consistently large enough, the application may decrease its target IPD to a smaller multiple of refreshDuration (e.g. increase its frame rate from 30Hz to 60Hz). If actualPresentTime and earliestPresentTime are same, and if presentMargin is consistently high, the application may delay the start of its input-render-present loop in order to decrease the latency between user input and the corresponding present (always leaving some margin in case a new image takes longer to render than the previous image). An application that desires its target IPD to always be the same as refreshDuration, can also adjust features until actualPresentTime is never late and presentMargin is satisfactory.

See Also
vkGetPastPresentationTimingGOOGLE

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPastPresentationTimingGOOGLE

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDevice16BitStorageFeatures(3)
Name
VkPhysicalDevice16BitStorageFeatures - Structure describing features supported by VK_KHR_16bit_storage

C Specification
To query 16-bit storage features additionally supported call vkGetPhysicalDeviceFeatures2 with a VkPhysicalDevice16BitStorageFeatures structure included in the pNext chain of its pFeatures parameter. The VkPhysicalDevice16BitStorageFeatures structure can also be in the pNext chain of a VkDeviceCreateInfo structure, in which case it controls which additional features are enabled in the device.

The VkPhysicalDevice16BitStorageFeatures structure is defined as:

typedef struct VkPhysicalDevice16BitStorageFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           storageBuffer16BitAccess;
    VkBool32           uniformAndStorageBuffer16BitAccess;
    VkBool32           storagePushConstant16;
    VkBool32           storageInputOutput16;
} VkPhysicalDevice16BitStorageFeatures;
or the equivalent

typedef VkPhysicalDevice16BitStorageFeatures VkPhysicalDevice16BitStorageFeaturesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
storageBuffer16BitAccess specifies whether objects in the StorageBuffer or PhysicalStorageBufferEXT storage class with the Block decoration can have 16-bit integer and 16-bit floating-point members. If this feature is not enabled, 16-bit integer or 16-bit floating-point members must not be used in such objects. This also specifies whether shader modules can declare the StorageBuffer16BitAccess capability.
uniformAndStorageBuffer16BitAccess specifies whether objects in the Uniform storage class with the Block decoration and in the StorageBuffer or PhysicalStorageBufferEXT storage class with the same decoration can have 16-bit integer and 16-bit floating-point members. If this feature is not enabled, 16-bit integer or 16-bit floating-point members must not be used in such objects. This also specifies whether shader modules can declare the UniformAndStorageBuffer16BitAccess capability.
storagePushConstant16 specifies whether objects in the PushConstant storage class can have 16-bit integer and 16-bit floating-point members. If this feature is not enabled, 16-bit integer or floating-point members must not be used in such objects. This also specifies whether shader modules can declare the StoragePushConstant16 capability.
storageInputOutput16 specifies whether objects in the Input and Output storage classes can have 16-bit integer and 16-bit floating-point members. If this feature is not enabled, 16-bit integer or 16-bit floating-point members must not be used in such objects. This also specifies whether shader modules can declare the StorageInputOutput16 capability.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDevice16BitStorageFeatures

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDevice8BitStorageFeaturesKHR(3)
Name
VkPhysicalDevice8BitStorageFeaturesKHR - Structure describing features supported by VK_KHR_8bit_storage

C Specification
To query 8-bit storage features additionally supported call vkGetPhysicalDeviceFeatures2 with a VkPhysicalDevice8BitStorageFeaturesKHR structure included in the pNext chain of its pFeatures parameter. The VkPhysicalDevice8BitStorageFeaturesKHR structure can also be in the pNext chain of a VkDeviceCreateInfo structure, in which case it controls which additional features are enabled in the device.

The VkPhysicalDevice8BitStorageFeaturesKHR structure is defined as:

typedef struct VkPhysicalDevice8BitStorageFeaturesKHR {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           storageBuffer8BitAccess;
    VkBool32           uniformAndStorageBuffer8BitAccess;
    VkBool32           storagePushConstant8;
} VkPhysicalDevice8BitStorageFeaturesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
storageBuffer8BitAccess indicates whether objects in the StorageBuffer or PhysicalStorageBufferEXT storage class with the Block decoration can have 8-bit integer members. If this feature is not enabled, 8-bit integer members must not be used in such objects. This also indicates whether shader modules can declare the StorageBuffer8BitAccess capability.
uniformAndStorageBuffer8BitAccess indicates whether objects in the Uniform storage class with the Block decoration and in the StorageBuffer or PhysicalStorageBufferEXT storage class with the same decoration can have 8-bit integer members. If this feature is not enabled, 8-bit integer members must not be used in such objects. This also indicates whether shader modules can declare the UniformAndStorageBuffer8BitAccess capability.
storagePushConstant8 indicates whether objects in the PushConstant storage class can have 8-bit integer members. If this feature is not enabled, 8-bit integer members must not be used in such objects. This also indicates whether shader modules can declare the StoragePushConstant8 capability.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDevice8BitStorageFeaturesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceASTCDecodeFeaturesEXT(3)
Name
VkPhysicalDeviceASTCDecodeFeaturesEXT - Structure describing ASTC decode mode features

C Specification
The VkPhysicalDeviceASTCDecodeFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceASTCDecodeFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           decodeModeSharedExponent;
} VkPhysicalDeviceASTCDecodeFeaturesEXT;
Members
The members of the VkPhysicalDeviceASTCDecodeFeaturesEXT structure describe the following features:

Description
decodeModeSharedExponent indicates whether the implementation supports decoding ASTC compressed formats to VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 internal precision.
If the VkPhysicalDeviceASTCDecodeFeaturesEXT structure is included in the pNext chain of vkGetPhysicalDeviceFeatures2KHR, it is filled with values indicating whether each feature is supported. VkPhysicalDeviceASTCDecodeFeaturesEXT can also be used in the pNext chain of vkCreateDevice to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceASTCDecodeFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(3)
Name
VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT - Structure describing advanced blending features that can be supported by an implementation

C Specification
The VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           advancedBlendCoherentOperations;
} VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT;
Members
The members of the VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure describe the following features:

Description
advancedBlendCoherentOperations specifies whether blending using advanced blend operations is guaranteed to execute atomically and in primitive order. If this is VK_TRUE, VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT is treated the same as VK_ACCESS_COLOR_ATTACHMENT_READ_BIT, and advanced blending needs no additional synchronization over basic blending. If this is VK_FALSE, then memory dependencies are required to guarantee order between two advanced blending operations that occur on the same sample.
If the VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure is included in the pNext chain of VkPhysicalDeviceFeatures2, it is filled with values indicating whether each feature is supported. VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT can also be used in pNext chain of VkDeviceCreateInfo to enable the features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(3)
Name
VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT - Structure describing advanced blending limits that can be supported by an implementation

C Specification
The VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT structure is defined as:

typedef struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           advancedBlendMaxColorAttachments;
    VkBool32           advancedBlendIndependentBlend;
    VkBool32           advancedBlendNonPremultipliedSrcColor;
    VkBool32           advancedBlendNonPremultipliedDstColor;
    VkBool32           advancedBlendCorrelatedOverlap;
    VkBool32           advancedBlendAllOperations;
} VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT;
Members
The members of the VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
advancedBlendMaxColorAttachments is one greater than the highest color attachment index that can be used in a subpass, for a pipeline that uses an advanced blend operation.
advancedBlendIndependentBlend specifies whether advanced blend operations can vary per-attachment.
advancedBlendNonPremultipliedSrcColor specifies whether the source color can be treated as non-premultiplied. If this is VK_FALSE, then VkPipelineColorBlendAdvancedStateCreateInfoEXT::srcPremultiplied must be VK_TRUE.
advancedBlendNonPremultipliedDstColor specifies whether the destination color can be treated as non-premultiplied. If this is VK_FALSE, then VkPipelineColorBlendAdvancedStateCreateInfoEXT::dstPremultiplied must be VK_TRUE.
advancedBlendCorrelatedOverlap specifies whether the overlap mode can be treated as correlated. If this is VK_FALSE, then VkPipelineColorBlendAdvancedStateCreateInfoEXT::blendOverlap must be VK_BLEND_OVERLAP_UNCORRELATED_EXT.
advancedBlendAllOperations specifies whether all advanced blend operation enums are supported. See the valid usage of VkPipelineColorBlendAttachmentState.
If the VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(3)
Name
VkPhysicalDeviceBufferDeviceAddressFeaturesEXT - Structure describing buffer address features that can be supported by an implementation

C Specification
The VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           bufferDeviceAddress;
    VkBool32           bufferDeviceAddressCaptureReplay;
    VkBool32           bufferDeviceAddressMultiDevice;
} VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
Members
The members of the VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure describe the following features:

Description
bufferDeviceAddress indicates that the implementation supports accessing buffer memory in shaders as storage buffers via an address queried from vkGetBufferDeviceAddressEXT.
bufferDeviceAddressCaptureReplay indicates that the implementation supports saving and reusing buffer addresses, e.g. for trace capture and replay.
bufferDeviceAddressMultiDevice indicates that the implementation supports the bufferDeviceAddress feature for logical devices created with multiple physical devices. If this feature is not supported, buffer addresses must not be queried on a logical device created with more than one physical device.
Note
bufferDeviceAddressMultiDevice exists to allow certain legacy platforms to be able to support bufferDeviceAddress without needing to support shared GPU virtual addresses for multi-device configurations.
See vkGetBufferDeviceAddressEXT for more information.

If the VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether the feature is supported. VkPhysicalDeviceBufferDeviceAddressFeaturesEXT can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceBufferDeviceAddressFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(3)
Name
VkPhysicalDeviceComputeShaderDerivativesFeaturesNV - Structure describing compute shader derivative features that can be supported by an implementation

C Specification
The VkPhysicalDeviceComputeShaderDerivativesFeaturesNV structure is defined as:

typedef struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNV {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           computeDerivativeGroupQuads;
    VkBool32           computeDerivativeGroupLinear;
} VkPhysicalDeviceComputeShaderDerivativesFeaturesNV;
Members
The members of the VkPhysicalDeviceComputeShaderDerivativesFeaturesNV structure describe the following features:

Description
computeDerivativeGroupQuads indicates that the implementation supports the ComputeDerivativeGroupQuadsNV SPIR-V capability.
computeDerivativeGroupLinear indicates that the implementation supports the ComputeDerivativeGroupLinearNV SPIR-V capability.
See Compute Shader Derivatives for more information.

If the VkPhysicalDeviceComputeShaderDerivativesFeaturesNV structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether each feature is supported. VkPhysicalDeviceComputeShaderDerivativesFeaturesNV can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceComputeShaderDerivativesFeaturesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceConditionalRenderingFeaturesEXT(3)
Name
VkPhysicalDeviceConditionalRenderingFeaturesEXT - Structure describing if a secondary command buffer can be executed if conditional rendering is active in the primary command buffer

C Specification
The VkPhysicalDeviceConditionalRenderingFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceConditionalRenderingFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           conditionalRendering;
    VkBool32           inheritedConditionalRendering;
} VkPhysicalDeviceConditionalRenderingFeaturesEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
conditionalRendering specifies whether conditional rendering is supported.
inheritedConditionalRendering specifies whether a secondary command buffer can be executed while conditional rendering is active in the primary command buffer.
Description
If the VkPhysicalDeviceConditionalRenderingFeaturesEXT structure is included in the pNext chain of VkPhysicalDeviceFeatures2, it is filled with values indicating the implementation-dependent behavior. VkPhysicalDeviceConditionalRenderingFeaturesEXT can also be used in pNext chain of VkDeviceCreateInfo to enable the features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceConditionalRenderingFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceConservativeRasterizationPropertiesEXT(3)
Name
VkPhysicalDeviceConservativeRasterizationPropertiesEXT - Structure describing conservative raster properties that can be supported by an implementation

C Specification
The VkPhysicalDeviceConservativeRasterizationPropertiesEXT structure is defined as:

typedef struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    float              primitiveOverestimationSize;
    float              maxExtraPrimitiveOverestimationSize;
    float              extraPrimitiveOverestimationSizeGranularity;
    VkBool32           primitiveUnderestimation;
    VkBool32           conservativePointAndLineRasterization;
    VkBool32           degenerateTrianglesRasterized;
    VkBool32           degenerateLinesRasterized;
    VkBool32           fullyCoveredFragmentShaderInputVariable;
    VkBool32           conservativeRasterizationPostDepthCoverage;
} VkPhysicalDeviceConservativeRasterizationPropertiesEXT;
Members
The members of the VkPhysicalDeviceConservativeRasterizationPropertiesEXT structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
primitiveOverestimationSize is the size in pixels the generating primitive is increased at each of its edges during conservative rasterization overestimation mode. Even with a size of 0.0, conservative rasterization overestimation rules still apply and if any part of the pixel rectangle is covered by the generating primitive, fragments are generated for the entire pixel. However implementations may make the pixel coverage area even more conservative by increasing the size of the generating primitive.
maxExtraPrimitiveOverestimationSize is the maximum size in pixels of extra overestimation the implementation supports in the pipeline state. A value of 0.0 means the implementation does not support any additional overestimation of the generating primitive during conservative rasterization. A value above 0.0 allows the application to further increase the size of the generating primitive during conservative rasterization overestimation.
extraPrimitiveOverestimationSizeGranularity is the granularity of extra overestimation that can be specified in the pipeline state between 0.0 and maxExtraPrimitiveOverestimationSize inclusive. A value of 0.0 means the implementation can use the smallest representable non-zero value in the screen space pixel fixed-point grid.
primitiveUnderestimation is true if the implementation supports the VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT conservative rasterization mode in addition to VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT. Otherwise the implementation only supports VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT.
conservativePointAndLineRasterization is true if the implementation supports conservative rasterization of point and line primitives as well as triangle primitives. Otherwise the implementation only supports triangle primitives.
degenerateTrianglesRasterized is false if the implementation culls primitives generated from triangles that become zero area after they are quantized to the fixed-point rasterization pixel grid. degenerateTrianglesRasterized is true if these primitives are not culled and the provoking vertex attributes and depth value are used for the fragments. The primitive area calculation is done on the primitive generated from the clipped triangle if applicable. Zero area primitives are backfacing and the application can enable backface culling if desired.
degenerateLinesRasterized is false if the implementation culls lines that become zero length after they are quantized to the fixed-point rasterization pixel grid. degenerateLinesRasterized is true if zero length lines are not culled and the provoking vertex attributes and depth value are used for the fragments.
fullyCoveredFragmentShaderInputVariable is true if the implementation supports the SPIR-V builtin fragment shader input variable FullyCoveredEXT which specifies that conservative rasterization is enabled and the fragment area is fully covered by the generating primitive.
conservativeRasterizationPostDepthCoverage is true if the implementation supports conservative rasterization with the PostDepthCoverage execution mode enabled. When supported the SampleMask built-in input variable will reflect the coverage after the early per-fragment depth and stencil tests are applied even when conservative rasterization is enabled. Otherwise PostDepthCoverage execution mode must not be used when conservative rasterization is enabled.
If the VkPhysicalDeviceConservativeRasterizationPropertiesEXT structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits and properties.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceConservativeRasterizationPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceCooperativeMatrixFeaturesNV(3)
Name
VkPhysicalDeviceCooperativeMatrixFeaturesNV - Structure describing cooperative matrix features that can be supported by an implementation

C Specification
The VkPhysicalDeviceCooperativeMatrixFeaturesNV structure is defined as:

typedef struct VkPhysicalDeviceCooperativeMatrixFeaturesNV {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           cooperativeMatrix;
    VkBool32           cooperativeMatrixRobustBufferAccess;
} VkPhysicalDeviceCooperativeMatrixFeaturesNV;
Members
The members of the VkPhysicalDeviceCooperativeMatrixFeaturesNV structure describe the following features:

Description
cooperativeMatrix indicates that the implementation supports the CooperativeMatrixNV SPIR-V capability.
cooperativeMatrixRobustBufferAccess indicates that the implementation supports robust buffer access for SPIR-V OpCooperativeMatrixLoadNV and OpCooperativeMatrixStoreNV instructions.
If the VkPhysicalDeviceCooperativeMatrixFeaturesNV structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether the feature is supported. VkPhysicalDeviceCooperativeMatrixFeaturesNV can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceCooperativeMatrixFeaturesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceCooperativeMatrixPropertiesNV(3)
Name
VkPhysicalDeviceCooperativeMatrixPropertiesNV - Structure describing cooperative matrix properties supported by an implementation

C Specification
The VkPhysicalDeviceCooperativeMatrixPropertiesNV structure is defined as:

typedef struct VkPhysicalDeviceCooperativeMatrixPropertiesNV {
    VkStructureType       sType;
    void*                 pNext;
    VkShaderStageFlags    cooperativeMatrixSupportedStages;
} VkPhysicalDeviceCooperativeMatrixPropertiesNV;
Members
The members of the VkPhysicalDeviceCooperativeMatrixPropertiesNV structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
cooperativeMatrixSupportedStages is a bitfield of VkShaderStageFlagBits describing the shader stages that cooperative matrix instructions are supported in. cooperativeMatrixSupportedStages will have the VK_SHADER_STAGE_COMPUTE_BIT bit set if any of the physical device’s queues support VK_QUEUE_COMPUTE_BIT.
If the VkPhysicalDeviceCooperativeMatrixPropertiesNV structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV
See Also
VkShaderStageFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceCooperativeMatrixPropertiesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceCornerSampledImageFeaturesNV(3)
Name
VkPhysicalDeviceCornerSampledImageFeaturesNV - Structure describing corner sampled image features that can be supported by an implementation

C Specification
The VkPhysicalDeviceCornerSampledImageFeaturesNV structure is defined as:

typedef struct VkPhysicalDeviceCornerSampledImageFeaturesNV {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           cornerSampledImage;
} VkPhysicalDeviceCornerSampledImageFeaturesNV;
Members
The members of the VkPhysicalDeviceCornerSampledImageFeaturesNV structure describe the following features:

Description
cornerSampledImage specifies whether images can be created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV. See Corner-Sampled Images.
If the VkPhysicalDeviceCornerSampledImageFeaturesNV structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether each feature is supported. VkPhysicalDeviceCornerSampledImageFeaturesNV can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceCornerSampledImageFeaturesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(3)
Name
VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV - Structure describing dedicated allocation image aliasing features that can be supported by an implementation

C Specification
The VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV structure is defined as:

typedef struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           dedicatedAllocationImageAliasing;
} VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
Members
The members of the VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV structure describe the following features:

Description
dedicatedAllocationImageAliasing indicates that the implementation supports aliasing of compatible image objects on a dedicated allocation.
If the VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether each feature is supported. VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceDepthClipEnableFeaturesEXT(3)
Name
VkPhysicalDeviceDepthClipEnableFeaturesEXT - Structure indicating support for explicit enable of depth clip

C Specification
The VkPhysicalDeviceDepthClipEnableFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceDepthClipEnableFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           depthClipEnable;
} VkPhysicalDeviceDepthClipEnableFeaturesEXT;
Members
The members of the VkPhysicalDeviceDepthClipEnableFeaturesEXT structure describe the following features:

Description
depthClipEnable indicates that the implementation supports setting the depth clipping operation explicitly via the VkPipelineRasterizationDepthClipStateCreateInfoEXT pipeline state. Otherwise depth clipping is only enabled when VkPipelineRasterizationStateCreateInfo::depthClampEnable is set to VK_FALSE.
If the VkPhysicalDeviceDepthClipEnableFeaturesEXT structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether the feature is supported. VkPhysicalDeviceDepthClipEnableFeaturesEXT can also be used in the pNext chain of VkDeviceCreateInfo to enable this feature.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceDepthClipEnableFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceDepthStencilResolvePropertiesKHR(3)
Name
VkPhysicalDeviceDepthStencilResolvePropertiesKHR - Structure describing depth/stencil resolve properties that can be supported by an implementation

C Specification
The VkPhysicalDeviceDepthStencilResolvePropertiesKHR structure is defined as:

typedef struct VkPhysicalDeviceDepthStencilResolvePropertiesKHR {
    VkStructureType          sType;
    void*                    pNext;
    VkResolveModeFlagsKHR    supportedDepthResolveModes;
    VkResolveModeFlagsKHR    supportedStencilResolveModes;
    VkBool32                 independentResolveNone;
    VkBool32                 independentResolve;
} VkPhysicalDeviceDepthStencilResolvePropertiesKHR;
Members
The members of the VkPhysicalDeviceDepthStencilResolvePropertiesKHR structure describe the following implementation-dependent limits:

Description
supportedDepthResolveModes is a bitmask of VkResolveModeFlagBitsKHR indicating the set of supported depth resolve modes. VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR must be included in the set but implementations may support additional modes.
supportedStencilResolveModes is a bitmask of VkResolveModeFlagBitsKHR indicating the set of supported stencil resolve modes. VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR must be included in the set but implementations may support additional modes. VK_RESOLVE_MODE_AVERAGE_BIT_KHR must not be included in the set.
independentResolveNone is VK_TRUE if the implementation supports setting the depth and stencil resolve modes to different values when one of those modes is VK_RESOLVE_MODE_NONE_KHR. Otherwise the implementation only supports setting both modes to the same value.
independentResolve is VK_TRUE if the implementation supports all combinations of the supported depth and stencil resolve modes.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR
See Also
VkBool32, VkResolveModeFlagsKHR, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceDepthStencilResolvePropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceDescriptorIndexingFeaturesEXT(3)
Name
VkPhysicalDeviceDescriptorIndexingFeaturesEXT - Structure describing descriptor indexing features that can be supported by an implementation

C Specification
The VkPhysicalDeviceDescriptorIndexingFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceDescriptorIndexingFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           shaderInputAttachmentArrayDynamicIndexing;
    VkBool32           shaderUniformTexelBufferArrayDynamicIndexing;
    VkBool32           shaderStorageTexelBufferArrayDynamicIndexing;
    VkBool32           shaderUniformBufferArrayNonUniformIndexing;
    VkBool32           shaderSampledImageArrayNonUniformIndexing;
    VkBool32           shaderStorageBufferArrayNonUniformIndexing;
    VkBool32           shaderStorageImageArrayNonUniformIndexing;
    VkBool32           shaderInputAttachmentArrayNonUniformIndexing;
    VkBool32           shaderUniformTexelBufferArrayNonUniformIndexing;
    VkBool32           shaderStorageTexelBufferArrayNonUniformIndexing;
    VkBool32           descriptorBindingUniformBufferUpdateAfterBind;
    VkBool32           descriptorBindingSampledImageUpdateAfterBind;
    VkBool32           descriptorBindingStorageImageUpdateAfterBind;
    VkBool32           descriptorBindingStorageBufferUpdateAfterBind;
    VkBool32           descriptorBindingUniformTexelBufferUpdateAfterBind;
    VkBool32           descriptorBindingStorageTexelBufferUpdateAfterBind;
    VkBool32           descriptorBindingUpdateUnusedWhilePending;
    VkBool32           descriptorBindingPartiallyBound;
    VkBool32           descriptorBindingVariableDescriptorCount;
    VkBool32           runtimeDescriptorArray;
} VkPhysicalDeviceDescriptorIndexingFeaturesEXT;
Members
The members of the VkPhysicalDeviceDescriptorIndexingFeaturesEXT structure describe the following features:

Description
shaderInputAttachmentArrayDynamicIndexing indicates whether arrays of input attachments can be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules can declare the InputAttachmentArrayDynamicIndexingEXT capability.
shaderUniformTexelBufferArrayDynamicIndexing indicates whether arrays of uniform texel buffers can be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules can declare the UniformTexelBufferArrayDynamicIndexingEXT capability.
shaderStorageTexelBufferArrayDynamicIndexing indicates whether arrays of storage texel buffers can be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must be indexed only by constant integral expressions when aggregated into arrays in shader code. This also indicates whether shader modules can declare the StorageTexelBufferArrayDynamicIndexingEXT capability.
shaderUniformBufferArrayNonUniformIndexing indicates whether arrays of uniform buffers can be indexed by non-uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must not be indexed by non-uniform integer expressions when aggregated into arrays in shader code. This also indicates whether shader modules can declare the UniformBufferArrayNonUniformIndexingEXT capability.
shaderSampledImageArrayNonUniformIndexing indicates whether arrays of samplers or sampled images can be indexed by non-uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must not be indexed by non-uniform integer expressions when aggregated into arrays in shader code. This also indicates whether shader modules can declare the SampledImageArrayNonUniformIndexingEXT capability.
shaderStorageBufferArrayNonUniformIndexing indicates whether arrays of storage buffers can be indexed by non-uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must not be indexed by non-uniform integer expressions when aggregated into arrays in shader code. This also indicates whether shader modules can declare the StorageBufferArrayNonUniformIndexingEXT capability.
shaderStorageImageArrayNonUniformIndexing indicates whether arrays of storage images can be indexed by non-uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must not be indexed by non-uniform integer expressions when aggregated into arrays in shader code. This also indicates whether shader modules can declare the StorageImageArrayNonUniformIndexingEXT capability.
shaderInputAttachmentArrayNonUniformIndexing indicates whether arrays of input attachments can be indexed by non-uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT must not be indexed by non-uniform integer expressions when aggregated into arrays in shader code. This also indicates whether shader modules can declare the InputAttachmentArrayNonUniformIndexingEXT capability.
shaderUniformTexelBufferArrayNonUniformIndexing indicates whether arrays of uniform texel buffers can be indexed by non-uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must not be indexed by non-uniform integer expressions when aggregated into arrays in shader code. This also indicates whether shader modules can declare the UniformTexelBufferArrayNonUniformIndexingEXT capability.
shaderStorageTexelBufferArrayNonUniformIndexing indicates whether arrays of storage texel buffers can be indexed by non-uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must not be indexed by non-uniform integer expressions when aggregated into arrays in shader code. This also indicates whether shader modules can declare the StorageTexelBufferArrayNonUniformIndexingEXT capability.
descriptorBindingUniformBufferUpdateAfterBind indicates whether the implementation supports updating uniform buffer descriptors after a set is bound. If this feature is not enabled, VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be used with VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER.
descriptorBindingSampledImageUpdateAfterBind indicates whether the implementation supports updating sampled image descriptors after a set is bound. If this feature is not enabled, VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be used with VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE.
descriptorBindingStorageImageUpdateAfterBind indicates whether the implementation supports updating storage image descriptors after a set is bound. If this feature is not enabled, VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be used with VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.
descriptorBindingStorageBufferUpdateAfterBind indicates whether the implementation supports updating storage buffer descriptors after a set is bound. If this feature is not enabled, VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be used with VK_DESCRIPTOR_TYPE_STORAGE_BUFFER.
descriptorBindingUniformTexelBufferUpdateAfterBind indicates whether the implementation supports updating uniform texel buffer descriptors after a set is bound. If this feature is not enabled, VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be used with VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.
descriptorBindingStorageTexelBufferUpdateAfterBind indicates whether the implementation supports updating storage texel buffer descriptors after a set is bound. If this feature is not enabled, VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be used with VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.
descriptorBindingUpdateUnusedWhilePending indicates whether the implementation supports updating descriptors while the set is in use. If this feature is not enabled, VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT must not be used.
descriptorBindingPartiallyBound indicates whether the implementation supports statically using a descriptor set binding in which some descriptors are not valid. If this feature is not enabled, VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT must not be used.
descriptorBindingVariableDescriptorCount indicates whether the implementation supports descriptor sets with a variable-sized last binding. If this feature is not enabled, VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT must not be used.
runtimeDescriptorArray indicates whether the implementation supports the SPIR-V RuntimeDescriptorArrayEXT capability. If this feature is not enabled, descriptors must not be declared in runtime arrays.
If the VkPhysicalDeviceDescriptorIndexingFeaturesEXT structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether each feature is supported. VkPhysicalDeviceDescriptorIndexingFeaturesEXT can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceDescriptorIndexingFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceDescriptorIndexingPropertiesEXT(3)
Name
VkPhysicalDeviceDescriptorIndexingPropertiesEXT - Structure describing descriptor indexing properties that can be supported by an implementation

C Specification
The VkPhysicalDeviceDescriptorIndexingPropertiesEXT structure is defined as:

typedef struct VkPhysicalDeviceDescriptorIndexingPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxUpdateAfterBindDescriptorsInAllPools;
    VkBool32           shaderUniformBufferArrayNonUniformIndexingNative;
    VkBool32           shaderSampledImageArrayNonUniformIndexingNative;
    VkBool32           shaderStorageBufferArrayNonUniformIndexingNative;
    VkBool32           shaderStorageImageArrayNonUniformIndexingNative;
    VkBool32           shaderInputAttachmentArrayNonUniformIndexingNative;
    VkBool32           robustBufferAccessUpdateAfterBind;
    VkBool32           quadDivergentImplicitLod;
    uint32_t           maxPerStageDescriptorUpdateAfterBindSamplers;
    uint32_t           maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    uint32_t           maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    uint32_t           maxPerStageDescriptorUpdateAfterBindSampledImages;
    uint32_t           maxPerStageDescriptorUpdateAfterBindStorageImages;
    uint32_t           maxPerStageDescriptorUpdateAfterBindInputAttachments;
    uint32_t           maxPerStageUpdateAfterBindResources;
    uint32_t           maxDescriptorSetUpdateAfterBindSamplers;
    uint32_t           maxDescriptorSetUpdateAfterBindUniformBuffers;
    uint32_t           maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    uint32_t           maxDescriptorSetUpdateAfterBindStorageBuffers;
    uint32_t           maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    uint32_t           maxDescriptorSetUpdateAfterBindSampledImages;
    uint32_t           maxDescriptorSetUpdateAfterBindStorageImages;
    uint32_t           maxDescriptorSetUpdateAfterBindInputAttachments;
} VkPhysicalDeviceDescriptorIndexingPropertiesEXT;
Members
The members of the VkPhysicalDeviceDescriptorIndexingPropertiesEXT structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
maxUpdateAfterBindDescriptorsInAllPools is the maximum number of descriptors (summed over all descriptor types) that can be created across all pools that are created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT bit set. Pool creation may fail when this limit is exceeded, or when the space this limit represents is unable to satisfy a pool creation due to fragmentation.
shaderUniformBufferArrayNonUniformIndexingNative is a boolean value indicating whether uniform buffer descriptors natively support nonuniform indexing. If this is VK_FALSE, then a single dynamic instance of an instruction that nonuniformly indexes an array of uniform buffers may execute multiple times in order to access all the descriptors.
shaderSampledImageArrayNonUniformIndexingNative is a boolean value indicating whether sampler and image descriptors natively support nonuniform indexing. If this is VK_FALSE, then a single dynamic instance of an instruction that nonuniformly indexes an array of samplers or images may execute multiple times in order to access all the descriptors.
shaderStorageBufferArrayNonUniformIndexingNative is a boolean value indicating whether storage buffer descriptors natively support nonuniform indexing. If this is VK_FALSE, then a single dynamic instance of an instruction that nonuniformly indexes an array of storage buffers may execute multiple times in order to access all the descriptors.
shaderStorageImageArrayNonUniformIndexingNative is a boolean value indicating whether storage image descriptors natively support nonuniform indexing. If this is VK_FALSE, then a single dynamic instance of an instruction that nonuniformly indexes an array of storage images may execute multiple times in order to access all the descriptors.
shaderInputAttachmentArrayNonUniformIndexingNative is a boolean value indicating whether input attachment descriptors natively support nonuniform indexing. If this is VK_FALSE, then a single dynamic instance of an instruction that nonuniformly indexes an array of input attachments may execute multiple times in order to access all the descriptors.
robustBufferAccessUpdateAfterBind is a boolean value indicating whether robustBufferAccess can be enabled in a device simultaneously with descriptorBindingUniformBufferUpdateAfterBind, descriptorBindingStorageBufferUpdateAfterBind, descriptorBindingUniformTexelBufferUpdateAfterBind, and/or descriptorBindingStorageTexelBufferUpdateAfterBind. If this is VK_FALSE, then either robustBufferAccess must be disabled or all of these update-after-bind features must be disabled.
quadDivergentImplicitLod is a boolean value indicating whether implicit level of detail calculations for image operations have well-defined results when the image and/or sampler objects used for the instruction are not uniform within a quad. See Derivative Image Operations.
maxPerStageDescriptorUpdateAfterBindSamplers is similar to maxPerStageDescriptorSamplers but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxPerStageDescriptorUpdateAfterBindUniformBuffers is similar to maxPerStageDescriptorUniformBuffers but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxPerStageDescriptorUpdateAfterBindStorageBuffers is similar to maxPerStageDescriptorStorageBuffers but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxPerStageDescriptorUpdateAfterBindSampledImages is similar to maxPerStageDescriptorSampledImages but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxPerStageDescriptorUpdateAfterBindStorageImages is similar to maxPerStageDescriptorStorageImages but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxPerStageDescriptorUpdateAfterBindInputAttachments is similar to maxPerStageDescriptorInputAttachments but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxPerStageUpdateAfterBindResources is similar to maxPerStageResources but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxDescriptorSetUpdateAfterBindSamplers is similar to maxDescriptorSetSamplers but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxDescriptorSetUpdateAfterBindUniformBuffers is similar to maxDescriptorSetUniformBuffers but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxDescriptorSetUpdateAfterBindUniformBuffersDynamic is similar to maxDescriptorSetUniformBuffersDynamic but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxDescriptorSetUpdateAfterBindStorageBuffers is similar to maxDescriptorSetStorageBuffers but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxDescriptorSetUpdateAfterBindStorageBuffersDynamic is similar to maxDescriptorSetStorageBuffersDynamic but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxDescriptorSetUpdateAfterBindSampledImages is similar to maxDescriptorSetSampledImages but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxDescriptorSetUpdateAfterBindStorageImages is similar to maxDescriptorSetStorageImages but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxDescriptorSetUpdateAfterBindInputAttachments is similar to maxDescriptorSetInputAttachments but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
If the VkPhysicalDeviceDescriptorIndexingPropertiesEXT structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceDescriptorIndexingPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceDiscardRectanglePropertiesEXT(3)
Name
VkPhysicalDeviceDiscardRectanglePropertiesEXT - Structure describing discard rectangle limits that can be supported by an implementation

C Specification
The VkPhysicalDeviceDiscardRectanglePropertiesEXT structure is defined as:

typedef struct VkPhysicalDeviceDiscardRectanglePropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxDiscardRectangles;
} VkPhysicalDeviceDiscardRectanglePropertiesEXT;
Members
The members of the VkPhysicalDeviceDiscardRectanglePropertiesEXT structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
maxDiscardRectangles is the maximum number of active discard rectangles that can be specified.
If the VkPhysicalDeviceDiscardRectanglePropertiesEXT structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceDiscardRectanglePropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceDriverPropertiesKHR(3)
Name
VkPhysicalDeviceDriverPropertiesKHR - Structure containing driver identification information

C Specification
To query the properties of the driver corresponding to a physical device, add VkPhysicalDeviceDriverPropertiesKHR to the pNext chain of the VkPhysicalDeviceProperties2 structure. The VkPhysicalDeviceDriverPropertiesKHR structure is defined as:

typedef struct VkPhysicalDeviceDriverPropertiesKHR {
    VkStructureType            sType;
    void*                      pNext;
    VkDriverIdKHR              driverID;
    char                       driverName[VK_MAX_DRIVER_NAME_SIZE_KHR];
    char                       driverInfo[VK_MAX_DRIVER_INFO_SIZE_KHR];
    VkConformanceVersionKHR    conformanceVersion;
} VkPhysicalDeviceDriverPropertiesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension specific structure.
driverID is a unique identifier for the driver of the physical device.
driverName is a null-terminated UTF-8 string containing the name of the driver.
driverInfo is a null-terminated UTF-8 string containing additional information about the driver.
conformanceVersion is the version of the Vulkan conformance test this driver is conformant against (see VkConformanceVersionKHR).
Description
driverID must be immutable for a given driver across instances, processes, driver versions, and system reboots.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR
See Also
VkConformanceVersionKHR, VkDriverIdKHR, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceDriverPropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceExclusiveScissorFeaturesNV(3)
Name
VkPhysicalDeviceExclusiveScissorFeaturesNV - Structure describing exclusive scissor features that can be supported by an implementation

C Specification
The VkPhysicalDeviceExclusiveScissorFeaturesNV structure is defined as:

typedef struct VkPhysicalDeviceExclusiveScissorFeaturesNV {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           exclusiveScissor;
} VkPhysicalDeviceExclusiveScissorFeaturesNV;
Members
The members of the VkPhysicalDeviceExclusiveScissorFeaturesNV structure describe the following features:

Description
exclusiveScissor indicates that the implementation supports the exclusive scissor test.
See Exclusive Scissor Test for more information.

If the VkPhysicalDeviceExclusiveScissorFeaturesNV structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether the feature is supported. VkPhysicalDeviceExclusiveScissorFeaturesNV can also be used in the pNext chain of VkDeviceCreateInfo to enable the feature.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceExclusiveScissorFeaturesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceExternalBufferInfo(3)
Name
VkPhysicalDeviceExternalBufferInfo - Structure specifying buffer creation parameters

C Specification
The VkPhysicalDeviceExternalBufferInfo structure is defined as:

typedef struct VkPhysicalDeviceExternalBufferInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkBufferCreateFlags                   flags;
    VkBufferUsageFlags                    usage;
    VkExternalMemoryHandleTypeFlagBits    handleType;
} VkPhysicalDeviceExternalBufferInfo;
or the equivalent

typedef VkPhysicalDeviceExternalBufferInfo VkPhysicalDeviceExternalBufferInfoKHR;
Members
sType is the type of this structure
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkBufferCreateFlagBits describing additional parameters of the buffer, corresponding to VkBufferCreateInfo::flags.
usage is a bitmask of VkBufferUsageFlagBits describing the intended usage of the buffer, corresponding to VkBufferCreateInfo::usage.
handleType is a VkExternalMemoryHandleTypeFlagBits value specifying the memory handle type that will be used with the memory associated with the buffer.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO
pNext must be NULL
flags must be a valid combination of VkBufferCreateFlagBits values
usage must be a valid combination of VkBufferUsageFlagBits values
usage must not be 0
handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
See Also
VkBufferCreateFlags, VkBufferUsageFlags, VkExternalMemoryHandleTypeFlagBits, VkStructureType, vkGetPhysicalDeviceExternalBufferProperties, vkGetPhysicalDeviceExternalBufferPropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceExternalBufferInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceExternalFenceInfo(3)
Name
VkPhysicalDeviceExternalFenceInfo - Structure specifying fence creation parameters.

C Specification
The VkPhysicalDeviceExternalFenceInfo structure is defined as:

typedef struct VkPhysicalDeviceExternalFenceInfo {
    VkStructureType                      sType;
    const void*                          pNext;
    VkExternalFenceHandleTypeFlagBits    handleType;
} VkPhysicalDeviceExternalFenceInfo;
or the equivalent

typedef VkPhysicalDeviceExternalFenceInfo VkPhysicalDeviceExternalFenceInfoKHR;
Members
sType is the type of this structure
pNext is NULL or a pointer to an extension-specific structure.
handleType is a VkExternalFenceHandleTypeFlagBits value indicating an external fence handle type for which capabilities will be returned.
Description
Note
Handles of type VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT generated by the implementation may represent either Linux Sync Files or Android Fences at the implementation’s discretion. Applications should only use operations defined for both types of file descriptors, unless they know via means external to Vulkan the type of the file descriptor, or are prepared to deal with the system-defined operation failures resulting from using the wrong type.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO
pNext must be NULL
handleType must be a valid VkExternalFenceHandleTypeFlagBits value
See Also
VkExternalFenceHandleTypeFlagBits, VkStructureType, vkGetPhysicalDeviceExternalFenceProperties, vkGetPhysicalDeviceExternalFencePropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceExternalFenceInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceExternalImageFormatInfo(3)
Name
VkPhysicalDeviceExternalImageFormatInfo - Structure specifying external image creation parameters

C Specification
To determine the image capabilities compatible with an external memory handle type, add VkPhysicalDeviceExternalImageFormatInfo to the pNext chain of the VkPhysicalDeviceImageFormatInfo2 structure and VkExternalImageFormatProperties to the pNext chain of the VkImageFormatProperties2 structure.

The VkPhysicalDeviceExternalImageFormatInfo structure is defined as:

typedef struct VkPhysicalDeviceExternalImageFormatInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkExternalMemoryHandleTypeFlagBits    handleType;
} VkPhysicalDeviceExternalImageFormatInfo;
or the equivalent

typedef VkPhysicalDeviceExternalImageFormatInfo VkPhysicalDeviceExternalImageFormatInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
handleType is a VkExternalMemoryHandleTypeFlagBits value specifying the memory handle type that will be used with the memory associated with the image.
Description
If handleType is 0, vkGetPhysicalDeviceImageFormatProperties2 will behave as if VkPhysicalDeviceExternalImageFormatInfo was not present, and VkExternalImageFormatProperties will be ignored.

If handleType is not compatible with the format, type, tiling, usage, and flags specified in VkPhysicalDeviceImageFormatInfo2, then vkGetPhysicalDeviceImageFormatProperties2 returns VK_ERROR_FORMAT_NOT_SUPPORTED.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO
If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value
See Also
VkExternalMemoryHandleTypeFlagBits, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceExternalImageFormatInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceExternalMemoryHostPropertiesEXT(3)
Name
VkPhysicalDeviceExternalMemoryHostPropertiesEXT - Structure describing external memory host pointer limits that can be supported by an implementation

C Specification
The VkPhysicalDeviceExternalMemoryHostPropertiesEXT structure is defined as:

typedef struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkDeviceSize       minImportedHostPointerAlignment;
} VkPhysicalDeviceExternalMemoryHostPropertiesEXT;
Members
The members of the VkPhysicalDeviceExternalMemoryHostPropertiesEXT structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
minImportedHostPointerAlignment is the minimum required alignment, in bytes, for the base address and size of host pointers that can be imported to a Vulkan memory object.
If the VkPhysicalDeviceExternalMemoryHostPropertiesEXT structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT
See Also
VkDeviceSize, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceExternalMemoryHostPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceExternalSemaphoreInfo(3)
Name
VkPhysicalDeviceExternalSemaphoreInfo - Structure specifying semaphore creation parameters.

C Specification
The VkPhysicalDeviceExternalSemaphoreInfo structure is defined as:

typedef struct VkPhysicalDeviceExternalSemaphoreInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkExternalSemaphoreHandleTypeFlagBits    handleType;
} VkPhysicalDeviceExternalSemaphoreInfo;
or the equivalent

typedef VkPhysicalDeviceExternalSemaphoreInfo VkPhysicalDeviceExternalSemaphoreInfoKHR;
Members
sType is the type of this structure
pNext is NULL or a pointer to an extension-specific structure.
handleType is a VkExternalSemaphoreHandleTypeFlagBits value specifying the external semaphore handle type for which capabilities will be returned.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO
pNext must be NULL
handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value
See Also
VkExternalSemaphoreHandleTypeFlagBits, VkStructureType, vkGetPhysicalDeviceExternalSemaphoreProperties, vkGetPhysicalDeviceExternalSemaphorePropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceExternalSemaphoreInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceFeatures(3)
Name
VkPhysicalDeviceFeatures - Structure describing the fine-grained features that can be supported by an implementation

C Specification
The VkPhysicalDeviceFeatures structure is defined as:

typedef struct VkPhysicalDeviceFeatures {
    VkBool32    robustBufferAccess;
    VkBool32    fullDrawIndexUint32;
    VkBool32    imageCubeArray;
    VkBool32    independentBlend;
    VkBool32    geometryShader;
    VkBool32    tessellationShader;
    VkBool32    sampleRateShading;
    VkBool32    dualSrcBlend;
    VkBool32    logicOp;
    VkBool32    multiDrawIndirect;
    VkBool32    drawIndirectFirstInstance;
    VkBool32    depthClamp;
    VkBool32    depthBiasClamp;
    VkBool32    fillModeNonSolid;
    VkBool32    depthBounds;
    VkBool32    wideLines;
    VkBool32    largePoints;
    VkBool32    alphaToOne;
    VkBool32    multiViewport;
    VkBool32    samplerAnisotropy;
    VkBool32    textureCompressionETC2;
    VkBool32    textureCompressionASTC_LDR;
    VkBool32    textureCompressionBC;
    VkBool32    occlusionQueryPrecise;
    VkBool32    pipelineStatisticsQuery;
    VkBool32    vertexPipelineStoresAndAtomics;
    VkBool32    fragmentStoresAndAtomics;
    VkBool32    shaderTessellationAndGeometryPointSize;
    VkBool32    shaderImageGatherExtended;
    VkBool32    shaderStorageImageExtendedFormats;
    VkBool32    shaderStorageImageMultisample;
    VkBool32    shaderStorageImageReadWithoutFormat;
    VkBool32    shaderStorageImageWriteWithoutFormat;
    VkBool32    shaderUniformBufferArrayDynamicIndexing;
    VkBool32    shaderSampledImageArrayDynamicIndexing;
    VkBool32    shaderStorageBufferArrayDynamicIndexing;
    VkBool32    shaderStorageImageArrayDynamicIndexing;
    VkBool32    shaderClipDistance;
    VkBool32    shaderCullDistance;
    VkBool32    shaderFloat64;
    VkBool32    shaderInt64;
    VkBool32    shaderInt16;
    VkBool32    shaderResourceResidency;
    VkBool32    shaderResourceMinLod;
    VkBool32    sparseBinding;
    VkBool32    sparseResidencyBuffer;
    VkBool32    sparseResidencyImage2D;
    VkBool32    sparseResidencyImage3D;
    VkBool32    sparseResidency2Samples;
    VkBool32    sparseResidency4Samples;
    VkBool32    sparseResidency8Samples;
    VkBool32    sparseResidency16Samples;
    VkBool32    sparseResidencyAliased;
    VkBool32    variableMultisampleRate;
    VkBool32    inheritedQueries;
} VkPhysicalDeviceFeatures;
Members
The members of the VkPhysicalDeviceFeatures structure describe the following features:

Description
robustBufferAccess specifies that accesses to buffers are bounds-checked against the range of the buffer descriptor (as determined by VkDescriptorBufferInfo::range, VkBufferViewCreateInfo::range, or the size of the buffer). Out of bounds accesses must not cause application termination, and the effects of shader loads, stores, and atomics must conform to an implementation-dependent behavior as described below.
A buffer access is considered to be out of bounds if any of the following are true:
The pointer was formed by OpImageTexelPointer and the coordinate is less than zero or greater than or equal to the number of whole elements in the bound range.
The pointer was not formed by OpImageTexelPointer and the object pointed to is not wholly contained within the bound range. This includes accesses performed via variable pointers where the buffer descriptor being accessed cannot be statically determined. Uninitialized pointers and pointers equal to OpConstantNull are treated as pointing to a zero-sized object, so all accesses through such pointers are considered to be out of bounds. Buffer accesses through buffer device addresses are not bounds-checked. If the cooperativeMatrixRobustBufferAccess feature is not enabled, then accesses using OpCooperativeMatrixLoadNV and OpCooperativeMatrixStoreNV may not be bounds-checked.
Note
If a SPIR-V OpLoad instruction loads a structure and the tail end of the structure is out of bounds, then all members of the structure are considered out of bounds even if the members at the end are not statically used.
If any buffer access in a given SPIR-V block is determined to be out of bounds, then any other access of the same type (load, store, or atomic) in the same SPIR-V block that accesses an address less than 16 bytes away from the out of bounds address may also be considered out of bounds.
Out-of-bounds buffer loads will return any of the following values:
Values from anywhere within the memory range(s) bound to the buffer (possibly including bytes of memory past the end of the buffer, up to the end of the bound range).
Zero values, or (0,0,0,x) vectors for vector reads where x is a valid value represented in the type of the vector components and may be any of:
0, 1, or the maximum representable positive integer value, for signed or unsigned integer components
0.0 or 1.0, for floating-point components
Out-of-bounds writes may modify values within the memory range(s) bound to the buffer, but must not modify any other memory.
Out-of-bounds atomics may modify values within the memory range(s) bound to the buffer, but must not modify any other memory, and return an undefined value.
Vertex input attributes are considered out of bounds if the offset of the attribute in the bound vertex buffer range plus the size of the attribute is greater than either:
vertexBufferRangeSize, if bindingStride == 0; or
(vertexBufferRangeSize - (vertexBufferRangeSize % bindingStride))
where vertexBufferRangeSize is the byte size of the memory range bound to the vertex buffer binding and bindingStride is the byte stride of the corresponding vertex input binding. Further, if any vertex input attribute using a specific vertex input binding is out of bounds, then all vertex input attributes using that vertex input binding for that vertex shader invocation are considered out of bounds.
If a vertex input attribute is out of bounds, it will be assigned one of the following values:
Values from anywhere within the memory range(s) bound to the buffer, converted according to the format of the attribute.
Zero values, format converted according to the format of the attribute.
Zero values, or (0,0,0,x) vectors, as described above.
If robustBufferAccess is not enabled, applications must not perform out of bounds accesses.
fullDrawIndexUint32 specifies the full 32-bit range of indices is supported for indexed draw calls when using a VkIndexType of VK_INDEX_TYPE_UINT32. maxDrawIndexedIndexValue is the maximum index value that may be used (aside from the primitive restart index, which is always 232-1 when the VkIndexType is VK_INDEX_TYPE_UINT32). If this feature is supported, maxDrawIndexedIndexValue must be 232-1; otherwise it must be no smaller than 224-1. See maxDrawIndexedIndexValue.
imageCubeArray specifies whether image views with a VkImageViewType of VK_IMAGE_VIEW_TYPE_CUBE_ARRAY can be created, and that the corresponding SampledCubeArray and ImageCubeArray SPIR-V capabilities can be used in shader code.
independentBlend specifies whether the VkPipelineColorBlendAttachmentState settings are controlled independently per-attachment. If this feature is not enabled, the VkPipelineColorBlendAttachmentState settings for all color attachments must be identical. Otherwise, a different VkPipelineColorBlendAttachmentState can be provided for each bound color attachment.
geometryShader specifies whether geometry shaders are supported. If this feature is not enabled, the VK_SHADER_STAGE_GEOMETRY_BIT and VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT enum values must not be used. This also specifies whether shader modules can declare the Geometry capability.
tessellationShader specifies whether tessellation control and evaluation shaders are supported. If this feature is not enabled, the VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, and VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO enum values must not be used. This also specifies whether shader modules can declare the Tessellation capability.
sampleRateShading specifies whether Sample Shading and multisample interpolation are supported. If this feature is not enabled, the sampleShadingEnable member of the VkPipelineMultisampleStateCreateInfo structure must be set to VK_FALSE and the minSampleShading member is ignored. This also specifies whether shader modules can declare the SampleRateShading capability.
dualSrcBlend specifies whether blend operations which take two sources are supported. If this feature is not enabled, the VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, and VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA enum values must not be used as source or destination blending factors. See html/vkspec.html#framebuffer-dsb.
logicOp specifies whether logic operations are supported. If this feature is not enabled, the logicOpEnable member of the VkPipelineColorBlendStateCreateInfo structure must be set to VK_FALSE, and the logicOp member is ignored.
multiDrawIndirect specifies whether multiple draw indirect is supported. If this feature is not enabled, the drawCount parameter to the vkCmdDrawIndirect and vkCmdDrawIndexedIndirect commands must be 0 or 1. The maxDrawIndirectCount member of the VkPhysicalDeviceLimits structure must also be 1 if this feature is not supported. See maxDrawIndirectCount.
drawIndirectFirstInstance specifies whether indirect draw calls support the firstInstance parameter. If this feature is not enabled, the firstInstance member of all VkDrawIndirectCommand and VkDrawIndexedIndirectCommand structures that are provided to the vkCmdDrawIndirect and vkCmdDrawIndexedIndirect commands must be 0.
depthClamp specifies whether depth clamping is supported. If this feature is not enabled, the depthClampEnable member of the VkPipelineRasterizationStateCreateInfo structure must be set to VK_FALSE. Otherwise, setting depthClampEnable to VK_TRUE will enable depth clamping.
depthBiasClamp specifies whether depth bias clamping is supported. If this feature is not enabled, the depthBiasClamp member of the VkPipelineRasterizationStateCreateInfo structure must be set to 0.0 unless the VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state is enabled, and the depthBiasClamp parameter to vkCmdSetDepthBias must be set to 0.0.
fillModeNonSolid specifies whether point and wireframe fill modes are supported. If this feature is not enabled, the VK_POLYGON_MODE_POINT and VK_POLYGON_MODE_LINE enum values must not be used.
depthBounds specifies whether depth bounds tests are supported. If this feature is not enabled, the depthBoundsTestEnable member of the VkPipelineDepthStencilStateCreateInfo structure must be set to VK_FALSE. When depthBoundsTestEnable is set to VK_FALSE, the minDepthBounds and maxDepthBounds members of the VkPipelineDepthStencilStateCreateInfo structure are ignored.
wideLines specifies whether lines with width other than 1.0 are supported. If this feature is not enabled, the lineWidth member of the VkPipelineRasterizationStateCreateInfo structure must be set to 1.0 unless the VK_DYNAMIC_STATE_LINE_WIDTH dynamic state is enabled, and the lineWidth parameter to vkCmdSetLineWidth must be set to 1.0. When this feature is supported, the range and granularity of supported line widths are indicated by the lineWidthRange and lineWidthGranularity members of the VkPhysicalDeviceLimits structure, respectively.
largePoints specifies whether points with size greater than 1.0 are supported. If this feature is not enabled, only a point size of 1.0 written by a shader is supported. The range and granularity of supported point sizes are indicated by the pointSizeRange and pointSizeGranularity members of the VkPhysicalDeviceLimits structure, respectively.
alphaToOne specifies whether the implementation is able to replace the alpha value of the color fragment output from the fragment shader with the maximum representable alpha value for fixed-point colors or 1.0 for floating-point colors. If this feature is not enabled, then the alphaToOneEnable member of the VkPipelineMultisampleStateCreateInfo structure must be set to VK_FALSE. Otherwise setting alphaToOneEnable to VK_TRUE will enable alpha-to-one behavior.
multiViewport specifies whether more than one viewport is supported. If this feature is not enabled:
The viewportCount and scissorCount members of the VkPipelineViewportStateCreateInfo structure must be set to 1.
The firstViewport and viewportCount parameters to the vkCmdSetViewport command must be set to 0 and 1, respectively.
The firstScissor and scissorCount parameters to the vkCmdSetScissor command must be set to 0 and 1, respectively.
The exclusiveScissorCount member of the VkPipelineViewportExclusiveScissorStateCreateInfoNV structure must be set to 0 or 1.
The firstExclusiveScissor and exclusiveScissorCount parameters to the vkCmdSetExclusiveScissorNV command must be set to 0 and 1, respectively.
samplerAnisotropy specifies whether anisotropic filtering is supported. If this feature is not enabled, the anisotropyEnable member of the VkSamplerCreateInfo structure must be VK_FALSE.
textureCompressionETC2 specifies whether all of the ETC2 and EAC compressed texture formats are supported. If this feature is enabled, then the VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, VK_FORMAT_FEATURE_BLIT_SRC_BIT and VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must be supported in optimalTilingFeatures for the following formats:
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK
VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK
VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK
VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK
VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK
VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK
VK_FORMAT_EAC_R11_UNORM_BLOCK
VK_FORMAT_EAC_R11_SNORM_BLOCK
VK_FORMAT_EAC_R11G11_UNORM_BLOCK
VK_FORMAT_EAC_R11G11_SNORM_BLOCK
To query for additional properties, or if the feature is not enabled, vkGetPhysicalDeviceFormatProperties and vkGetPhysicalDeviceImageFormatProperties can be used to check for supported properties of individual formats as normal.
textureCompressionASTC_LDR specifies whether all of the ASTC LDR compressed texture formats are supported. If this feature is enabled, then the VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, VK_FORMAT_FEATURE_BLIT_SRC_BIT and VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must be supported in optimalTilingFeatures for the following formats:
VK_FORMAT_ASTC_4x4_UNORM_BLOCK
VK_FORMAT_ASTC_4x4_SRGB_BLOCK
VK_FORMAT_ASTC_5x4_UNORM_BLOCK
VK_FORMAT_ASTC_5x4_SRGB_BLOCK
VK_FORMAT_ASTC_5x5_UNORM_BLOCK
VK_FORMAT_ASTC_5x5_SRGB_BLOCK
VK_FORMAT_ASTC_6x5_UNORM_BLOCK
VK_FORMAT_ASTC_6x5_SRGB_BLOCK
VK_FORMAT_ASTC_6x6_UNORM_BLOCK
VK_FORMAT_ASTC_6x6_SRGB_BLOCK
VK_FORMAT_ASTC_8x5_UNORM_BLOCK
VK_FORMAT_ASTC_8x5_SRGB_BLOCK
VK_FORMAT_ASTC_8x6_UNORM_BLOCK
VK_FORMAT_ASTC_8x6_SRGB_BLOCK
VK_FORMAT_ASTC_8x8_UNORM_BLOCK
VK_FORMAT_ASTC_8x8_SRGB_BLOCK
VK_FORMAT_ASTC_10x5_UNORM_BLOCK
VK_FORMAT_ASTC_10x5_SRGB_BLOCK
VK_FORMAT_ASTC_10x6_UNORM_BLOCK
VK_FORMAT_ASTC_10x6_SRGB_BLOCK
VK_FORMAT_ASTC_10x8_UNORM_BLOCK
VK_FORMAT_ASTC_10x8_SRGB_BLOCK
VK_FORMAT_ASTC_10x10_UNORM_BLOCK
VK_FORMAT_ASTC_10x10_SRGB_BLOCK
VK_FORMAT_ASTC_12x10_UNORM_BLOCK
VK_FORMAT_ASTC_12x10_SRGB_BLOCK
VK_FORMAT_ASTC_12x12_UNORM_BLOCK
VK_FORMAT_ASTC_12x12_SRGB_BLOCK
To query for additional properties, or if the feature is not enabled, vkGetPhysicalDeviceFormatProperties and vkGetPhysicalDeviceImageFormatProperties can be used to check for supported properties of individual formats as normal.
textureCompressionBC specifies whether all of the BC compressed texture formats are supported. If this feature is enabled, then the VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT, VK_FORMAT_FEATURE_BLIT_SRC_BIT and VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT features must be supported in optimalTilingFeatures for the following formats:
VK_FORMAT_BC1_RGB_UNORM_BLOCK
VK_FORMAT_BC1_RGB_SRGB_BLOCK
VK_FORMAT_BC1_RGBA_UNORM_BLOCK
VK_FORMAT_BC1_RGBA_SRGB_BLOCK
VK_FORMAT_BC2_UNORM_BLOCK
VK_FORMAT_BC2_SRGB_BLOCK
VK_FORMAT_BC3_UNORM_BLOCK
VK_FORMAT_BC3_SRGB_BLOCK
VK_FORMAT_BC4_UNORM_BLOCK
VK_FORMAT_BC4_SNORM_BLOCK
VK_FORMAT_BC5_UNORM_BLOCK
VK_FORMAT_BC5_SNORM_BLOCK
VK_FORMAT_BC6H_UFLOAT_BLOCK
VK_FORMAT_BC6H_SFLOAT_BLOCK
VK_FORMAT_BC7_UNORM_BLOCK
VK_FORMAT_BC7_SRGB_BLOCK
To query for additional properties, or if the feature is not enabled, vkGetPhysicalDeviceFormatProperties and vkGetPhysicalDeviceImageFormatProperties can be used to check for supported properties of individual formats as normal.
occlusionQueryPrecise specifies whether occlusion queries returning actual sample counts are supported. Occlusion queries are created in a VkQueryPool by specifying the queryType of VK_QUERY_TYPE_OCCLUSION in the VkQueryPoolCreateInfo structure which is passed to vkCreateQueryPool. If this feature is enabled, queries of this type can enable VK_QUERY_CONTROL_PRECISE_BIT in the flags parameter to vkCmdBeginQuery. If this feature is not supported, the implementation supports only boolean occlusion queries. When any samples are passed, boolean queries will return a non-zero result value, otherwise a result value of zero is returned. When this feature is enabled and VK_QUERY_CONTROL_PRECISE_BIT is set, occlusion queries will report the actual number of samples passed.
pipelineStatisticsQuery specifies whether the pipeline statistics queries are supported. If this feature is not enabled, queries of type VK_QUERY_TYPE_PIPELINE_STATISTICS cannot be created, and none of the VkQueryPipelineStatisticFlagBits bits can be set in the pipelineStatistics member of the VkQueryPoolCreateInfo structure.
vertexPipelineStoresAndAtomics specifies whether storage buffers and images support stores and atomic operations in the vertex, tessellation, and geometry shader stages. If this feature is not enabled, all storage image, storage texel buffers, and storage buffer variables used by these stages in shader modules must be decorated with the NonWritable decoration (or the readonly memory qualifier in GLSL).
fragmentStoresAndAtomics specifies whether storage buffers and images support stores and atomic operations in the fragment shader stage. If this feature is not enabled, all storage image, storage texel buffers, and storage buffer variables used by the fragment stage in shader modules must be decorated with the NonWritable decoration (or the readonly memory qualifier in GLSL).
shaderTessellationAndGeometryPointSize specifies whether the PointSize built-in decoration is available in the tessellation control, tessellation evaluation, and geometry shader stages. If this feature is not enabled, members decorated with the PointSize built-in decoration must not be read from or written to and all points written from a tessellation or geometry shader will have a size of 1.0. This also specifies whether shader modules can declare the TessellationPointSize capability for tessellation control and evaluation shaders, or if the shader modules can declare the GeometryPointSize capability for geometry shaders. An implementation supporting this feature must also support one or both of the tessellationShader or geometryShader features.
shaderImageGatherExtended specifies whether the extended set of image gather instructions are available in shader code. If this feature is not enabled, the OpImage*Gather instructions do not support the Offset and ConstOffsets operands. This also specifies whether shader modules can declare the ImageGatherExtended capability.
shaderStorageImageExtendedFormats specifies whether all the extended storage image formats are available in shader code. If this feature is enabled then the VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT feature must be supported in optimalTilingFeatures for all of the extended formats. To query for additional properties, or if the feature is not enabled, vkGetPhysicalDeviceFormatProperties and vkGetPhysicalDeviceImageFormatProperties can be used to check for supported properties of individual formats as normal.
shaderStorageImageMultisample specifies whether multisampled storage images are supported. If this feature is not enabled, images that are created with a usage that includes VK_IMAGE_USAGE_STORAGE_BIT must be created with samples equal to VK_SAMPLE_COUNT_1_BIT. This also specifies whether shader modules can declare the StorageImageMultisample capability.
shaderStorageImageReadWithoutFormat specifies whether storage images require a format qualifier to be specified when reading from storage images. If this feature is not enabled, the OpImageRead instruction must not have an OpTypeImage of Unknown. This also specifies whether shader modules can declare the StorageImageReadWithoutFormat capability.
shaderStorageImageWriteWithoutFormat specifies whether storage images require a format qualifier to be specified when writing to storage images. If this feature is not enabled, the OpImageWrite instruction must not have an OpTypeImage of Unknown. This also specifies whether shader modules can declare the StorageImageWriteWithoutFormat capability.
shaderUniformBufferArrayDynamicIndexing specifies whether arrays of uniform buffers can be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must be indexed only by constant integral expressions when aggregated into arrays in shader code. This also specifies whether shader modules can declare the UniformBufferArrayDynamicIndexing capability.
shaderSampledImageArrayDynamicIndexing specifies whether arrays of samplers or sampled images can be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must be indexed only by constant integral expressions when aggregated into arrays in shader code. This also specifies whether shader modules can declare the SampledImageArrayDynamicIndexing capability.
shaderStorageBufferArrayDynamicIndexing specifies whether arrays of storage buffers can be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must be indexed only by constant integral expressions when aggregated into arrays in shader code. This also specifies whether shader modules can declare the StorageBufferArrayDynamicIndexing capability.
shaderStorageImageArrayDynamicIndexing specifies whether arrays of storage images can be indexed by dynamically uniform integer expressions in shader code. If this feature is not enabled, resources with a descriptor type of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must be indexed only by constant integral expressions when aggregated into arrays in shader code. This also specifies whether shader modules can declare the StorageImageArrayDynamicIndexing capability.
shaderClipDistance specifies whether clip distances are supported in shader code. If this feature is not enabled, any members decorated with the ClipDistance built-in decoration must not be read from or written to in shader modules. This also specifies whether shader modules can declare the ClipDistance capability.
shaderCullDistance specifies whether cull distances are supported in shader code. If this feature is not enabled, any members decorated with the CullDistance built-in decoration must not be read from or written to in shader modules. This also specifies whether shader modules can declare the CullDistance capability.
shaderFloat64 specifies whether 64-bit floats (doubles) are supported in shader code. If this feature is not enabled, 64-bit floating-point types must not be used in shader code. This also specifies whether shader modules can declare the Float64 capability.
shaderInt64 specifies whether 64-bit integers (signed and unsigned) are supported in shader code. If this feature is not enabled, 64-bit integer types must not be used in shader code. This also specifies whether shader modules can declare the Int64 capability.
shaderInt16 specifies whether 16-bit integers (signed and unsigned) are supported in shader code. If this feature is not enabled, 16-bit integer types must not be used in shader code. This also specifies whether shader modules can declare the Int16 capability.
shaderResourceResidency specifies whether image operations that return resource residency information are supported in shader code. If this feature is not enabled, the OpImageSparse* instructions must not be used in shader code. This also specifies whether shader modules can declare the SparseResidency capability. The feature requires at least one of the sparseResidency* features to be supported.
shaderResourceMinLod specifies whether image operations that specify the minimum resource LOD are supported in shader code. If this feature is not enabled, the MinLod image operand must not be used in shader code. This also specifies whether shader modules can declare the MinLod capability.
sparseBinding specifies whether resource memory can be managed at opaque sparse block level instead of at the object level. If this feature is not enabled, resource memory must be bound only on a per-object basis using the vkBindBufferMemory and vkBindImageMemory commands. In this case, buffers and images must not be created with VK_BUFFER_CREATE_SPARSE_BINDING_BIT and VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in the flags member of the VkBufferCreateInfo and VkImageCreateInfo structures, respectively. Otherwise resource memory can be managed as described in Sparse Resource Features.
sparseResidencyBuffer specifies whether the device can access partially resident buffers. If this feature is not enabled, buffers must not be created with VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkBufferCreateInfo structure.
sparseResidencyImage2D specifies whether the device can access partially resident 2D images with 1 sample per pixel. If this feature is not enabled, images with an imageType of VK_IMAGE_TYPE_2D and samples set to VK_SAMPLE_COUNT_1_BIT must not be created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkImageCreateInfo structure.
sparseResidencyImage3D specifies whether the device can access partially resident 3D images. If this feature is not enabled, images with an imageType of VK_IMAGE_TYPE_3D must not be created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkImageCreateInfo structure.
sparseResidency2Samples specifies whether the physical device can access partially resident 2D images with 2 samples per pixel. If this feature is not enabled, images with an imageType of VK_IMAGE_TYPE_2D and samples set to VK_SAMPLE_COUNT_2_BIT must not be created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkImageCreateInfo structure.
sparseResidency4Samples specifies whether the physical device can access partially resident 2D images with 4 samples per pixel. If this feature is not enabled, images with an imageType of VK_IMAGE_TYPE_2D and samples set to VK_SAMPLE_COUNT_4_BIT must not be created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkImageCreateInfo structure.
sparseResidency8Samples specifies whether the physical device can access partially resident 2D images with 8 samples per pixel. If this feature is not enabled, images with an imageType of VK_IMAGE_TYPE_2D and samples set to VK_SAMPLE_COUNT_8_BIT must not be created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkImageCreateInfo structure.
sparseResidency16Samples specifies whether the physical device can access partially resident 2D images with 16 samples per pixel. If this feature is not enabled, images with an imageType of VK_IMAGE_TYPE_2D and samples set to VK_SAMPLE_COUNT_16_BIT must not be created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set in the flags member of the VkImageCreateInfo structure.
sparseResidencyAliased specifies whether the physical device can correctly access data aliased into multiple locations. If this feature is not enabled, the VK_BUFFER_CREATE_SPARSE_ALIASED_BIT and VK_IMAGE_CREATE_SPARSE_ALIASED_BIT enum values must not be used in flags members of the VkBufferCreateInfo and VkImageCreateInfo structures, respectively.
variableMultisampleRate specifies whether all pipelines that will be bound to a command buffer during a subpass with no attachments must have the same value for VkPipelineMultisampleStateCreateInfo::rasterizationSamples. If set to VK_TRUE, the implementation supports variable multisample rates in a subpass with no attachments. If set to VK_FALSE, then all pipelines bound in such a subpass must have the same multisample rate. This has no effect in situations where a subpass uses any attachments.
inheritedQueries specifies whether a secondary command buffer may be executed while a query is active.
See Also
VkBool32, VkDeviceCreateInfo, VkPhysicalDeviceFeatures2, vkGetPhysicalDeviceFeatures

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceFeatures

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceFeatures2(3)
Name
VkPhysicalDeviceFeatures2 - Structure describing the fine-grained features that can be supported by an implementation

C Specification
The VkPhysicalDeviceFeatures2 structure is defined as:

typedef struct VkPhysicalDeviceFeatures2 {
    VkStructureType             sType;
    void*                       pNext;
    VkPhysicalDeviceFeatures    features;
} VkPhysicalDeviceFeatures2;
or the equivalent

typedef VkPhysicalDeviceFeatures2 VkPhysicalDeviceFeatures2KHR;
Members
The VkPhysicalDeviceFeatures2 structure is defined as:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
features is a structure of type VkPhysicalDeviceFeatures describing the fine-grained features of the Vulkan 1.0 API.
The pNext chain of this structure is used to extend the structure with features defined by extensions. This structure can be used in vkGetPhysicalDeviceFeatures2 or can be in the pNext chain of a VkDeviceCreateInfo structure, in which case it controls which features are enabled in the device in lieu of pEnabledFeatures.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2
See Also
VkPhysicalDeviceFeatures, VkStructureType, vkGetPhysicalDeviceFeatures2, vkGetPhysicalDeviceFeatures2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceFeatures2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceFloat16Int8FeaturesKHR(3)
Name
VkPhysicalDeviceFloat16Int8FeaturesKHR - Structure describing features supported by VK_KHR_shader_float16_int8

C Specification
To query features additionally supported by the html/vkspec.html#VK_KHR_shader_float16_int8 extension, call vkGetPhysicalDeviceFeatures2KHR with a VkPhysicalDeviceFloat16Int8FeaturesKHR structure in the pNext chain. The VkPhysicalDeviceFloat16Int8FeaturesKHR structure can also be in the pNext chain of a VkDeviceCreateInfo structure, in which case it controls which additional features are enabled in the device.

The VkPhysicalDeviceFloat16Int8FeaturesKHR structure is defined as:

typedef struct VkPhysicalDeviceFloat16Int8FeaturesKHR {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           shaderFloat16;
    VkBool32           shaderInt8;
} VkPhysicalDeviceFloat16Int8FeaturesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
shaderFloat16 indicates whether 16-bit floats (halfs) are supported in shader code. This also indicates whether shader modules can declare the Float16 capability.
shaderInt8 indicates whether 8-bit integers (signed and unsigned) are supported in shader code. This also indicates whether shader modules can declare the Int8 capability.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceFloat16Int8FeaturesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceFloatControlsPropertiesKHR(3)
Name
VkPhysicalDeviceFloatControlsPropertiesKHR - Structure describing properties supported by VK_KHR_shader_float_controls

C Specification
The members of the VkPhysicalDeviceFloatControlsPropertiesKHR structure describe the following implementation-dependent limits:

typedef struct VkPhysicalDeviceFloatControlsPropertiesKHR {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           separateDenormSettings;
    VkBool32           separateRoundingModeSettings;
    VkBool32           shaderSignedZeroInfNanPreserveFloat16;
    VkBool32           shaderSignedZeroInfNanPreserveFloat32;
    VkBool32           shaderSignedZeroInfNanPreserveFloat64;
    VkBool32           shaderDenormPreserveFloat16;
    VkBool32           shaderDenormPreserveFloat32;
    VkBool32           shaderDenormPreserveFloat64;
    VkBool32           shaderDenormFlushToZeroFloat16;
    VkBool32           shaderDenormFlushToZeroFloat32;
    VkBool32           shaderDenormFlushToZeroFloat64;
    VkBool32           shaderRoundingModeRTEFloat16;
    VkBool32           shaderRoundingModeRTEFloat32;
    VkBool32           shaderRoundingModeRTEFloat64;
    VkBool32           shaderRoundingModeRTZFloat16;
    VkBool32           shaderRoundingModeRTZFloat32;
    VkBool32           shaderRoundingModeRTZFloat64;
} VkPhysicalDeviceFloatControlsPropertiesKHR;
Members
separateDenormSettings is a boolean value indicating whether the implementation supports separate settings for 16-bit and 64-bit denormals.
separateRoundingModeSettings is a boolean value indicating whether the implementation supports separate rounding modes for 16-bit and 64-bit floating point instructions.
shaderSignedZeroInfNanPreserveFloat16 is a boolean value indicating whether sign of a zero, Nans and \(\pm\infty\) can be preserved in 16-bit floating-point computations. It also indicates whether the SignedZeroInfNanPreserve execution mode can be used for 16-bit floating-point types.
shaderSignedZeroInfNanPreserveFloat32 is a boolean value indicating whether sign of a zero, Nans and \(\pm\infty\) can be preserved in 32-bit floating-point computations. It also indicates whether the SignedZeroInfNanPreserve execution mode can be used for 32-bit floating-point types.
shaderSignedZeroInfNanPreserveFloat64 is a boolean value indicating whether sign of a zero, Nans and \(\pm\infty\) can be preserved in 64-bit floating-point computations. It also indicates whether the SignedZeroInfNanPreserve execution mode can be used for 64-bit floating-point types.
shaderDenormPreserveFloat16 is a boolean value indicating whether denormals can be preserved in 16-bit floating-point computations. It also indicates whether the DenormPreserve execution mode can be used for 16-bit floating-point types.
shaderDenormPreserveFloat32 is a boolean value indicating whether denormals can be preserved in 32-bit floating-point computations. It also indicates whether the DenormPreserve execution mode can be used for 32-bit floating-point types.
shaderDenormPreserveFloat64 is a boolean value indicating whether denormals can be preserved in 64-bit floating-point computations. It also indicates whether the DenormPreserve execution mode can be used for 64-bit floating-point types.
shaderDenormFlushToZeroFloat16 is a boolean value indicating whether denormals can be flushed to zero in 16-bit floating-point computations. It also indicates whether the DenormFlushToZero execution mode can be used for 16-bit floating-point types.
shaderDenormFlushToZeroFloat32 is a boolean value indicating whether denormals can be flushed to zero in 32-bit floating-point computations. It also indicates whether the DenormFlushToZero execution mode can be used for 32-bit floating-point types.
shaderDenormFlushToZeroFloat64 is a boolean value indicating whether denormals can be flushed to zero in 64-bit floating-point computations. It also indicates whether the DenormFlushToZero execution mode can be used for 64-bit floating-point types.
shaderRoundingModeRTEFloat16 is a boolean value indicating whether an implementation supports the round-to-nearest-even rounding mode for 16-bit floating-point arithmetic and conversion instructions. It also indicates whether the RoundingModeRTE execution mode can be used for 16-bit floating-point types.
shaderRoundingModeRTEFloat32 is a boolean value indicating whether an implementation supports the round-to-nearest-even rounding mode for 32-bit floating-point arithmetic and conversion instructions. It also indicates whether the RoundingModeRTE execution mode can be used for 32-bit floating-point types.
shaderRoundingModeRTEFloat64 is a boolean value indicating whether an implementation supports the round-to-nearest-even rounding mode for 64-bit floating-point arithmetic and conversion instructions. It also indicates whether the RoundingModeRTE execution mode can be used for 64-bit floating-point types.
shaderRoundingModeRTZFloat16 is a boolean value indicating whether an implementation supports the round-towards-zero rounding mode for 16-bit floating-point arithmetic and conversion instructions. It also indicates whether the RoundingModeRTZ execution mode can be used for 16-bit floating-point types.
shaderRoundingModeRTZFloat32 is a boolean value indicating whether an implementation supports the round-towards-zero rounding mode for 32-bit floating-point arithmetic and conversion instructions. It also indicates whether the RoundingModeRTZ execution mode can be used for 32-bit floating-point types.
shaderRoundingModeRTZFloat64 is a boolean value indicating whether an implementation supports the round-towards-zero rounding mode for 64-bit floating-point arithmetic and conversion instructions. It also indicates whether the RoundingModeRTZ execution mode can be used for 64-bit floating-point types.
Description
editing-note
Implementations may not be able to control behavior of denorms for floating-point atomics. This needs to be taken into account when such atomics will be added to Vulkan.
If the VkPhysicalDeviceFloatControlsPropertiesKHR structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceFloatControlsPropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceFragmentDensityMapFeaturesEXT(3)
Name
VkPhysicalDeviceFragmentDensityMapFeaturesEXT - Structure describing fragment density map features that can be supported by an implementation

C Specification
The VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           fragmentDensityMap;
    VkBool32           fragmentDensityMapDynamic;
    VkBool32           fragmentDensityMapNonSubsampledImages;
} VkPhysicalDeviceFragmentDensityMapFeaturesEXT;
Members
The members of the VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure describe the following features:

Description
fragmentDensityMap specifies whether the implementation supports render passes with a fragment density map attachment. If this feature is not enabled and the pNext chain of VkRenderPassCreateInfo contains VkRenderPassFragmentDensityMapCreateInfoEXT, fragmentDensityMapAttachment must be VK_ATTACHMENT_UNUSED.
fragmentDensityMapDynamic specifies whether the implementation supports dynamic fragment density map image views. If this feature is not enabled, VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT must not be included in VkImageViewCreateInfo::flags.
fragmentDensityMapNonSubsampledImages specifies whether the implementation supports regular non-subsampled image attachments with fragment density map render passes. If this feature is not enabled, render passes with a fragment density map attachment must only have subsampled attachments bound.
If the VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure is included in the pNext chain of VkPhysicalDeviceFeatures2, it is filled with values indicating whether each feature is supported. VkPhysicalDeviceFragmentDensityMapFeaturesEXT can also be used in pNext chain of VkDeviceCreateInfo to enable the features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceFragmentDensityMapFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceFragmentDensityMapPropertiesEXT(3)
Name
VkPhysicalDeviceFragmentDensityMapPropertiesEXT - Structure describing fragment density map properties that can be supported by an implementation

C Specification
The VkPhysicalDeviceFragmentDensityMapPropertiesEXT structure is defined as:

typedef struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkExtent2D         minFragmentDensityTexelSize;
    VkExtent2D         maxFragmentDensityTexelSize;
    VkBool32           fragmentDensityInvocations;
} VkPhysicalDeviceFragmentDensityMapPropertiesEXT;
Members
The members of the VkPhysicalDeviceFragmentDensityMapPropertiesEXT structure describe the following implementation-dependent limits:

Description
minFragmentDensityTexelSize is the minimum fragment density texel size.
maxFragmentDensityTexelSize is the maximum fragment density texel size.
fragmentDensityInvocations specifies whether the implementation may invoke additional fragment shader invocations for each covered sample.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT
If the VkPhysicalDeviceFragmentDensityMapPropertiesEXT structure is included in the pNext chain of VkPhysicalDeviceProperties2KHR, it is filled with the implementation-dependent limits and properties.

See Also
VkBool32, VkExtent2D, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceFragmentDensityMapPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(3)
Name
VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV - Structure describing barycentric support in fragment shaders that can be supported by an implementation

C Specification
The VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV structure is defined as:

typedef struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           fragmentShaderBarycentric;
} VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV;
Members
The members of the VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV structure describe the following features:

Description
fragmentShaderBarycentric indicates that the implementation supports the BaryCoordNV and BaryCoordNoPerspNV SPIR-V fragment shader built-ins and supports the PerVertexNV SPIR-V decoration on fragment shader input variables.
See Barycentric Interpolation for more information.

If the VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether the feature is supported. VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceGroupProperties(3)
Name
VkPhysicalDeviceGroupProperties - Structure specifying physical device group properties

C Specification
The VkPhysicalDeviceGroupProperties structure is defined as:

typedef struct VkPhysicalDeviceGroupProperties {
    VkStructureType     sType;
    void*               pNext;
    uint32_t            physicalDeviceCount;
    VkPhysicalDevice    physicalDevices[VK_MAX_DEVICE_GROUP_SIZE];
    VkBool32            subsetAllocation;
} VkPhysicalDeviceGroupProperties;
or the equivalent

typedef VkPhysicalDeviceGroupProperties VkPhysicalDeviceGroupPropertiesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
physicalDeviceCount is the number of physical devices in the group.
physicalDevices is an array of physical device handles representing all physical devices in the group. The first physicalDeviceCount elements of the array will be valid.
subsetAllocation specifies whether logical devices created from the group support allocating device memory on a subset of devices, via the deviceMask member of the VkMemoryAllocateFlagsInfo. If this is VK_FALSE, then all device memory allocations are made across all physical devices in the group. If physicalDeviceCount is 1, then subsetAllocation must be VK_FALSE.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES
pNext must be NULL
See Also
VkBool32, VkPhysicalDevice, VkStructureType, vkEnumeratePhysicalDeviceGroups, vkEnumeratePhysicalDeviceGroupsKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceGroupProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceHostQueryResetFeaturesEXT(3)
Name
VkPhysicalDeviceHostQueryResetFeaturesEXT - Structure describing whether queries can be reset from the host

C Specification
The VkPhysicalDeviceHostQueryResetFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceHostQueryResetFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           hostQueryReset;
} VkPhysicalDeviceHostQueryResetFeaturesEXT;
Members
The members of the VkPhysicalDeviceHostQueryResetFeaturesEXT structure describe the following features:

Description
hostQueryReset indicates that the implementation supports resetting queries from the host with vkResetQueryPoolEXT.
If the VkPhysicalDeviceHostQueryResetFeaturesEXT structure is included in the pNext chain of VkPhysicalDeviceFeatures2, it is filled with values indicating whether the feature is supported. VkPhysicalDeviceHostQueryResetFeaturesEXT can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceHostQueryResetFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceIDProperties(3)
Name
VkPhysicalDeviceIDProperties - Structure specifying IDs related to the physical device

C Specification
To query the UUID and LUID of a device, add VkPhysicalDeviceIDProperties to the pNext chain of the VkPhysicalDeviceProperties2 structure. The VkPhysicalDeviceIDProperties structure is defined as:

typedef struct VkPhysicalDeviceIDProperties {
    VkStructureType    sType;
    void*              pNext;
    uint8_t            deviceUUID[VK_UUID_SIZE];
    uint8_t            driverUUID[VK_UUID_SIZE];
    uint8_t            deviceLUID[VK_LUID_SIZE];
    uint32_t           deviceNodeMask;
    VkBool32           deviceLUIDValid;
} VkPhysicalDeviceIDProperties;
or the equivalent

typedef VkPhysicalDeviceIDProperties VkPhysicalDeviceIDPropertiesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
deviceUUID is an array of size VK_UUID_SIZE, containing 8-bit values that represent a universally unique identifier for the device.
driverUUID is an array of size VK_UUID_SIZE, containing 8-bit values that represent a universally unique identifier for the driver build in use by the device.
deviceLUID is an array of size VK_LUID_SIZE, containing 8-bit values that represent a locally unique identifier for the device.
deviceNodeMask is a bitfield identifying the node within a linked device adapter corresponding to the device.
deviceLUIDValid is a boolean value that will be VK_TRUE if deviceLUID contains a valid LUID and deviceNodeMask contains a valid node mask, and VK_FALSE if they do not.
Description
deviceUUID must be immutable for a given device across instances, processes, driver APIs, driver versions, and system reboots.

Applications can compare the driverUUID value across instance and process boundaries, and can make similar queries in external APIs to determine whether they are capable of sharing memory objects and resources using them with the device.

deviceUUID and/or driverUUID must be used to determine whether a particular external object can be shared between driver components, where such a restriction exists as defined in the compatibility table for the particular object type:

External memory handle types compatibility
External semaphore handle types compatibility
External fence handle types compatibility
If deviceLUIDValid is VK_FALSE, the values of deviceLUID and deviceNodeMask are undefined. If deviceLUIDValid is VK_TRUE and Vulkan is running on the Windows operating system, the contents of deviceLUID can be cast to an LUID object and must be equal to the locally unique identifier of a IDXGIAdapter1 object that corresponds to physicalDevice. If deviceLUIDValid is VK_TRUE, deviceNodeMask must contain exactly one bit. If Vulkan is running on an operating system that supports the Direct3D 12 API and physicalDevice corresponds to an individual device in a linked device adapter, deviceNodeMask identifies the Direct3D 12 node corresponding to physicalDevice. Otherwise, deviceNodeMask must be 1.

Note
Although they have identical descriptions, VkPhysicalDeviceIDProperties::deviceUUID may differ from VkPhysicalDeviceProperties2::pipelineCacheUUID. The former is intended to identify and correlate devices across API and driver boundaries, while the latter is used to identify a compatible device and driver combination to use when serializing and de-serializing pipeline state.
Note
While VkPhysicalDeviceIDProperties::deviceUUID is specified to remain consistent across driver versions and system reboots, it is not intended to be usable as a serializable persistent identifier for a device. It may change when a device is physically added to, removed from, or moved to a different connector in a system while that system is powered down. Further, there is no reasonable way to verify with conformance testing that a given device retains the same UUID in a given system across all driver versions supported in that system. While implementations should make every effort to report consistent device UUIDs across driver versions, applications should avoid relying on the persistence of this value for uses other than identifying compatible devices for external object sharing purposes.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceIDProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceImageDrmFormatModifierInfoEXT(3)
Name
VkPhysicalDeviceImageDrmFormatModifierInfoEXT - Structure specifying a DRM format modifier as image creation parameter

C Specification
To query the image capabilities that are compatible with a Linux DRM format modifier, set VkPhysicalDeviceImageFormatInfo2::tiling to VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT and add VkPhysicalDeviceImageDrmFormatModifierInfoEXT to the pNext chain of VkPhysicalDeviceImageFormatInfo2.

The VkPhysicalDeviceImageDrmFormatModifierInfoEXT structure is defined as:

typedef struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    uint64_t           drmFormatModifier;
    VkSharingMode      sharingMode;
    uint32_t           queueFamilyIndexCount;
    const uint32_t*    pQueueFamilyIndices;
} VkPhysicalDeviceImageDrmFormatModifierInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
drmFormatModifier is the image’s Linux DRM format modifier, corresponding to VkImageDrmFormatModifierExplicitCreateInfoEXT::modifier or to VkImageDrmFormatModifierListCreateInfoEXT::pModifiers.
sharingMode specifies how the image will be accessed by multiple queue families.
queueFamilyIndexCount is the number of entries in the pQueueFamilyIndices array.
pQueueFamilyIndices is a list of queue families that will access the image (ignored if sharingMode is not VK_SHARING_MODE_CONCURRENT).
Description
If the drmFormatModifier is incompatible with the parameters specified in VkPhysicalDeviceImageFormatInfo2 and its pNext chain, then vkGetPhysicalDeviceImageFormatProperties2 returns VK_ERROR_FORMAT_NOT_SUPPORTED. The implementation must support the query of any drmFormatModifier, including unknown and invalid modifier values.

Valid Usage
If sharingMode is VK_SHARING_MODE_CONCURRENT, then pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values.
If sharingMode is VK_SHARING_MODE_CONCURRENT, then queueFamilyIndexCount must be greater than 1.
If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than the pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT
sharingMode must be a valid VkSharingMode value
See Also
VkSharingMode, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceImageDrmFormatModifierInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceImageFormatInfo2(3)
Name
VkPhysicalDeviceImageFormatInfo2 - Structure specifying image creation parameters

C Specification
The VkPhysicalDeviceImageFormatInfo2 structure is defined as:

typedef struct VkPhysicalDeviceImageFormatInfo2 {
    VkStructureType       sType;
    const void*           pNext;
    VkFormat              format;
    VkImageType           type;
    VkImageTiling         tiling;
    VkImageUsageFlags     usage;
    VkImageCreateFlags    flags;
} VkPhysicalDeviceImageFormatInfo2;
or the equivalent

typedef VkPhysicalDeviceImageFormatInfo2 VkPhysicalDeviceImageFormatInfo2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure. The pNext chain of VkPhysicalDeviceImageFormatInfo2 is used to provide additional image parameters to vkGetPhysicalDeviceImageFormatProperties2.
format is a VkFormat value indicating the image format, corresponding to VkImageCreateInfo::format.
type is a VkImageType value indicating the image type, corresponding to VkImageCreateInfo::imageType.
tiling is a VkImageTiling value indicating the image tiling, corresponding to VkImageCreateInfo::tiling.
usage is a bitmask of VkImageUsageFlagBits indicating the intended usage of the image, corresponding to VkImageCreateInfo::usage.
flags is a bitmask of VkImageCreateFlagBits indicating additional parameters of the image, corresponding to VkImageCreateInfo::flags.
Description
The members of VkPhysicalDeviceImageFormatInfo2 correspond to the arguments to vkGetPhysicalDeviceImageFormatProperties, with sType and pNext added for extensibility.

Valid Usage
tiling must be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT if and only if the pNext chain contains VkPhysicalDeviceImageDrmFormatModifierInfoEXT.
If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT and flags contains VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, then the pNext chain must contain VkImageFormatListCreateInfoKHR with non-zero viewFormatCount.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkImageFormatListCreateInfoKHR, VkImageStencilUsageCreateInfoEXT, VkPhysicalDeviceExternalImageFormatInfo, VkPhysicalDeviceImageDrmFormatModifierInfoEXT, or VkPhysicalDeviceImageViewImageFormatInfoEXT
Each sType member in the pNext chain must be unique
format must be a valid VkFormat value
type must be a valid VkImageType value
tiling must be a valid VkImageTiling value
usage must be a valid combination of VkImageUsageFlagBits values
usage must not be 0
flags must be a valid combination of VkImageCreateFlagBits values
See Also
VkFormat, VkImageCreateFlags, VkImageTiling, VkImageType, VkImageUsageFlags, VkStructureType, vkGetPhysicalDeviceImageFormatProperties2, vkGetPhysicalDeviceImageFormatProperties2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceImageFormatInfo2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceImageViewImageFormatInfoEXT(3)
Name
VkPhysicalDeviceImageViewImageFormatInfoEXT - Structure for providing image view type

C Specification
The VkPhysicalDeviceImageViewImageFormatInfoEXT structure is defined as:

typedef struct VkPhysicalDeviceImageViewImageFormatInfoEXT {
    VkStructureType    sType;
    void*              pNext;
    VkImageViewType    imageViewType;
} VkPhysicalDeviceImageViewImageFormatInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
imageViewType is a VkImageViewType value specifying the type of the image view.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT
imageViewType must be a valid VkImageViewType value
See Also
VkImageViewType, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceImageViewImageFormatInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceInlineUniformBlockFeaturesEXT(3)
Name
VkPhysicalDeviceInlineUniformBlockFeaturesEXT - Structure describing inline uniform block features that can be supported by an implementation

C Specification
The VkPhysicalDeviceInlineUniformBlockFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceInlineUniformBlockFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           inlineUniformBlock;
    VkBool32           descriptorBindingInlineUniformBlockUpdateAfterBind;
} VkPhysicalDeviceInlineUniformBlockFeaturesEXT;
Members
The members of the VkPhysicalDeviceInlineUniformBlockFeaturesEXT structure describe the following features:

Description
inlineUniformBlock indicates whether the implementation supports inline uniform block descriptors. If this feature is not enabled, VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT must not be used.
descriptorBindingInlineUniformBlockUpdateAfterBind indicates whether the implementation supports updating inline uniform block descriptors after a set is bound. If this feature is not enabled, VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT must not be used with VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT.
If the VkPhysicalDeviceInlineUniformBlockFeaturesEXT structure is included in the pNext chain of VkPhysicalDeviceFeatures2, it is filled with values indicating whether each feature is supported. VkPhysicalDeviceInlineUniformBlockFeaturesEXT can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceInlineUniformBlockFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceInlineUniformBlockPropertiesEXT(3)
Name
VkPhysicalDeviceInlineUniformBlockPropertiesEXT - Structure describing inline uniform block properties that can be supported by an implementation

C Specification
The VkPhysicalDeviceInlineUniformBlockPropertiesEXT structure is defined as:

typedef struct VkPhysicalDeviceInlineUniformBlockPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxInlineUniformBlockSize;
    uint32_t           maxPerStageDescriptorInlineUniformBlocks;
    uint32_t           maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
    uint32_t           maxDescriptorSetInlineUniformBlocks;
    uint32_t           maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
} VkPhysicalDeviceInlineUniformBlockPropertiesEXT;
Members
The members of the VkPhysicalDeviceInlineUniformBlockPropertiesEXT structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
maxInlineUniformBlockSize is the maximum size in bytes of an inline uniform block binding.
maxPerStageDescriptorInlineUniformBlock is the maximum number of inline uniform block bindings that can be accessible to a single shader stage in a pipeline layout. Descriptor bindings with a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT count against this limit. Only descriptor bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit.
maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks is similar to maxPerStageDescriptorInlineUniformBlocks but counts descriptor bindings from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
maxDescriptorSetInlineUniformBlocks is the maximum number of inline uniform block bindings that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptor bindings with a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT count against this limit. Only descriptor bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit.
maxDescriptorSetUpdateAfterBindInlineUniformBlocks is similar to maxDescriptorSetInlineUniformBlocks but counts descriptor bindings from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set.
If the VkPhysicalDeviceInlineUniformBlockPropertiesEXT structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceInlineUniformBlockPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceLimits(3)
Name
VkPhysicalDeviceLimits - Structure reporting implementation-dependent physical device limits

C Specification
The VkPhysicalDeviceLimits structure is defined as:

typedef struct VkPhysicalDeviceLimits {
    uint32_t              maxImageDimension1D;
    uint32_t              maxImageDimension2D;
    uint32_t              maxImageDimension3D;
    uint32_t              maxImageDimensionCube;
    uint32_t              maxImageArrayLayers;
    uint32_t              maxTexelBufferElements;
    uint32_t              maxUniformBufferRange;
    uint32_t              maxStorageBufferRange;
    uint32_t              maxPushConstantsSize;
    uint32_t              maxMemoryAllocationCount;
    uint32_t              maxSamplerAllocationCount;
    VkDeviceSize          bufferImageGranularity;
    VkDeviceSize          sparseAddressSpaceSize;
    uint32_t              maxBoundDescriptorSets;
    uint32_t              maxPerStageDescriptorSamplers;
    uint32_t              maxPerStageDescriptorUniformBuffers;
    uint32_t              maxPerStageDescriptorStorageBuffers;
    uint32_t              maxPerStageDescriptorSampledImages;
    uint32_t              maxPerStageDescriptorStorageImages;
    uint32_t              maxPerStageDescriptorInputAttachments;
    uint32_t              maxPerStageResources;
    uint32_t              maxDescriptorSetSamplers;
    uint32_t              maxDescriptorSetUniformBuffers;
    uint32_t              maxDescriptorSetUniformBuffersDynamic;
    uint32_t              maxDescriptorSetStorageBuffers;
    uint32_t              maxDescriptorSetStorageBuffersDynamic;
    uint32_t              maxDescriptorSetSampledImages;
    uint32_t              maxDescriptorSetStorageImages;
    uint32_t              maxDescriptorSetInputAttachments;
    uint32_t              maxVertexInputAttributes;
    uint32_t              maxVertexInputBindings;
    uint32_t              maxVertexInputAttributeOffset;
    uint32_t              maxVertexInputBindingStride;
    uint32_t              maxVertexOutputComponents;
    uint32_t              maxTessellationGenerationLevel;
    uint32_t              maxTessellationPatchSize;
    uint32_t              maxTessellationControlPerVertexInputComponents;
    uint32_t              maxTessellationControlPerVertexOutputComponents;
    uint32_t              maxTessellationControlPerPatchOutputComponents;
    uint32_t              maxTessellationControlTotalOutputComponents;
    uint32_t              maxTessellationEvaluationInputComponents;
    uint32_t              maxTessellationEvaluationOutputComponents;
    uint32_t              maxGeometryShaderInvocations;
    uint32_t              maxGeometryInputComponents;
    uint32_t              maxGeometryOutputComponents;
    uint32_t              maxGeometryOutputVertices;
    uint32_t              maxGeometryTotalOutputComponents;
    uint32_t              maxFragmentInputComponents;
    uint32_t              maxFragmentOutputAttachments;
    uint32_t              maxFragmentDualSrcAttachments;
    uint32_t              maxFragmentCombinedOutputResources;
    uint32_t              maxComputeSharedMemorySize;
    uint32_t              maxComputeWorkGroupCount[3];
    uint32_t              maxComputeWorkGroupInvocations;
    uint32_t              maxComputeWorkGroupSize[3];
    uint32_t              subPixelPrecisionBits;
    uint32_t              subTexelPrecisionBits;
    uint32_t              mipmapPrecisionBits;
    uint32_t              maxDrawIndexedIndexValue;
    uint32_t              maxDrawIndirectCount;
    float                 maxSamplerLodBias;
    float                 maxSamplerAnisotropy;
    uint32_t              maxViewports;
    uint32_t              maxViewportDimensions[2];
    float                 viewportBoundsRange[2];
    uint32_t              viewportSubPixelBits;
    size_t                minMemoryMapAlignment;
    VkDeviceSize          minTexelBufferOffsetAlignment;
    VkDeviceSize          minUniformBufferOffsetAlignment;
    VkDeviceSize          minStorageBufferOffsetAlignment;
    int32_t               minTexelOffset;
    uint32_t              maxTexelOffset;
    int32_t               minTexelGatherOffset;
    uint32_t              maxTexelGatherOffset;
    float                 minInterpolationOffset;
    float                 maxInterpolationOffset;
    uint32_t              subPixelInterpolationOffsetBits;
    uint32_t              maxFramebufferWidth;
    uint32_t              maxFramebufferHeight;
    uint32_t              maxFramebufferLayers;
    VkSampleCountFlags    framebufferColorSampleCounts;
    VkSampleCountFlags    framebufferDepthSampleCounts;
    VkSampleCountFlags    framebufferStencilSampleCounts;
    VkSampleCountFlags    framebufferNoAttachmentsSampleCounts;
    uint32_t              maxColorAttachments;
    VkSampleCountFlags    sampledImageColorSampleCounts;
    VkSampleCountFlags    sampledImageIntegerSampleCounts;
    VkSampleCountFlags    sampledImageDepthSampleCounts;
    VkSampleCountFlags    sampledImageStencilSampleCounts;
    VkSampleCountFlags    storageImageSampleCounts;
    uint32_t              maxSampleMaskWords;
    VkBool32              timestampComputeAndGraphics;
    float                 timestampPeriod;
    uint32_t              maxClipDistances;
    uint32_t              maxCullDistances;
    uint32_t              maxCombinedClipAndCullDistances;
    uint32_t              discreteQueuePriorities;
    float                 pointSizeRange[2];
    float                 lineWidthRange[2];
    float                 pointSizeGranularity;
    float                 lineWidthGranularity;
    VkBool32              strictLines;
    VkBool32              standardSampleLocations;
    VkDeviceSize          optimalBufferCopyOffsetAlignment;
    VkDeviceSize          optimalBufferCopyRowPitchAlignment;
    VkDeviceSize          nonCoherentAtomSize;
} VkPhysicalDeviceLimits;
Members
The VkPhysicalDeviceLimits are properties of the physical device. These are available in the limits member of the VkPhysicalDeviceProperties structure which is returned from vkGetPhysicalDeviceProperties.

maxImageDimension1D is the maximum dimension (width) supported for all images created with an imageType of VK_IMAGE_TYPE_1D.
maxImageDimension2D is the maximum dimension (width or height) supported for all images created with an imageType of VK_IMAGE_TYPE_2D and without VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in flags.
maxImageDimension3D is the maximum dimension (width, height, or depth) supported for all images created with an imageType of VK_IMAGE_TYPE_3D.
maxImageDimensionCube is the maximum dimension (width or height) supported for all images created with an imageType of VK_IMAGE_TYPE_2D and with VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in flags.
maxImageArrayLayers is the maximum number of layers (arrayLayers) for an image.
maxTexelBufferElements is the maximum number of addressable texels for a buffer view created on a buffer which was created with the VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the usage member of the VkBufferCreateInfo structure.
maxUniformBufferRange is the maximum value that can be specified in the range member of any VkDescriptorBufferInfo structures passed to a call to vkUpdateDescriptorSets for descriptors of type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.
maxStorageBufferRange is the maximum value that can be specified in the range member of any VkDescriptorBufferInfo structures passed to a call to vkUpdateDescriptorSets for descriptors of type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.
maxPushConstantsSize is the maximum size, in bytes, of the pool of push constant memory. For each of the push constant ranges indicated by the pPushConstantRanges member of the VkPipelineLayoutCreateInfo structure, (offset + size) must be less than or equal to this limit.
maxMemoryAllocationCount is the maximum number of device memory allocations, as created by vkAllocateMemory, which can simultaneously exist.
maxSamplerAllocationCount is the maximum number of sampler objects, as created by vkCreateSampler, which can simultaneously exist on a device.
bufferImageGranularity is the granularity, in bytes, at which buffer or linear image resources, and optimal image resources can be bound to adjacent offsets in the same VkDeviceMemory object without aliasing. See Buffer-Image Granularity for more details.
sparseAddressSpaceSize is the total amount of address space available, in bytes, for sparse memory resources. This is an upper bound on the sum of the size of all sparse resources, regardless of whether any memory is bound to them.
maxBoundDescriptorSets is the maximum number of descriptor sets that can be simultaneously used by a pipeline. All DescriptorSet decorations in shader modules must have a value less than maxBoundDescriptorSets. See html/vkspec.html#descriptorsets-sets.
maxPerStageDescriptorSamplers is the maximum number of samplers that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. A descriptor is accessible to a shader stage when the stageFlags member of the VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See html/vkspec.html#descriptorsets-sampler and html/vkspec.html#descriptorsets-combinedimagesampler.
maxPerStageDescriptorUniformBuffers is the maximum number of uniform buffers that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. A descriptor is accessible to a shader stage when the stageFlags member of the VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See html/vkspec.html#descriptorsets-uniformbuffer and html/vkspec.html#descriptorsets-uniformbufferdynamic.
maxPerStageDescriptorStorageBuffers is the maximum number of storage buffers that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. A descriptor is accessible to a pipeline shader stage when the stageFlags member of the VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See html/vkspec.html#descriptorsets-storagebuffer and html/vkspec.html#descriptorsets-storagebufferdynamic.
maxPerStageDescriptorSampledImages is the maximum number of sampled images that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. A descriptor is accessible to a pipeline shader stage when the stageFlags member of the VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See html/vkspec.html#descriptorsets-combinedimagesampler, html/vkspec.html#descriptorsets-sampledimage, and html/vkspec.html#descriptorsets-uniformtexelbuffer.
maxPerStageDescriptorStorageImages is the maximum number of storage images that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. A descriptor is accessible to a pipeline shader stage when the stageFlags member of the VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See html/vkspec.html#descriptorsets-storageimage, and html/vkspec.html#descriptorsets-storagetexelbuffer.
maxPerStageDescriptorInputAttachments is the maximum number of input attachments that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. A descriptor is accessible to a pipeline shader stage when the stageFlags member of the VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. These are only supported for the fragment stage. See html/vkspec.html#descriptorsets-inputattachment.
maxPerStageResources is the maximum number of resources that can be accessible to a single shader stage in a pipeline layout. Descriptors with a type of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. For the fragment shader stage the framebuffer color attachments also count against this limit.
maxDescriptorSetSamplers is the maximum number of samplers that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. See html/vkspec.html#descriptorsets-sampler and html/vkspec.html#descriptorsets-combinedimagesampler.
maxDescriptorSetUniformBuffers is the maximum number of uniform buffers that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. See html/vkspec.html#descriptorsets-uniformbuffer and html/vkspec.html#descriptorsets-uniformbufferdynamic.
maxDescriptorSetUniformBuffersDynamic is the maximum number of dynamic uniform buffers that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. See html/vkspec.html#descriptorsets-uniformbufferdynamic.
maxDescriptorSetStorageBuffers is the maximum number of storage buffers that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. See html/vkspec.html#descriptorsets-storagebuffer and html/vkspec.html#descriptorsets-storagebufferdynamic.
maxDescriptorSetStorageBuffersDynamic is the maximum number of dynamic storage buffers that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. See html/vkspec.html#descriptorsets-storagebufferdynamic.
maxDescriptorSetSampledImages is the maximum number of sampled images that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. See html/vkspec.html#descriptorsets-combinedimagesampler, html/vkspec.html#descriptorsets-sampledimage, and html/vkspec.html#descriptorsets-uniformtexelbuffer.
maxDescriptorSetStorageImages is the maximum number of storage images that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. See html/vkspec.html#descriptorsets-storageimage, and html/vkspec.html#descriptorsets-storagetexelbuffer.
maxDescriptorSetInputAttachments is the maximum number of input attachments that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. Only descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set count against this limit. See html/vkspec.html#descriptorsets-inputattachment.
maxVertexInputAttributes is the maximum number of vertex input attributes that can be specified for a graphics pipeline. These are described in the array of VkVertexInputAttributeDescription structures that are provided at graphics pipeline creation time via the pVertexAttributeDescriptions member of the VkPipelineVertexInputStateCreateInfo structure. See html/vkspec.html#fxvertex-attrib and html/vkspec.html#fxvertex-input.
maxVertexInputBindings is the maximum number of vertex buffers that can be specified for providing vertex attributes to a graphics pipeline. These are described in the array of VkVertexInputBindingDescription structures that are provided at graphics pipeline creation time via the pVertexBindingDescriptions member of the VkPipelineVertexInputStateCreateInfo structure. The binding member of VkVertexInputBindingDescription must be less than this limit. See html/vkspec.html#fxvertex-input.
maxVertexInputAttributeOffset is the maximum vertex input attribute offset that can be added to the vertex input binding stride. The offset member of the VkVertexInputAttributeDescription structure must be less than or equal to this limit. See html/vkspec.html#fxvertex-input.
maxVertexInputBindingStride is the maximum vertex input binding stride that can be specified in a vertex input binding. The stride member of the VkVertexInputBindingDescription structure must be less than or equal to this limit. See html/vkspec.html#fxvertex-input.
maxVertexOutputComponents is the maximum number of components of output variables which can be output by a vertex shader. See html/vkspec.html#shaders-vertex.
maxTessellationGenerationLevel is the maximum tessellation generation level supported by the fixed-function tessellation primitive generator. See html/vkspec.html#tessellation.
maxTessellationPatchSize is the maximum patch size, in vertices, of patches that can be processed by the tessellation control shader and tessellation primitive generator. The patchControlPoints member of the VkPipelineTessellationStateCreateInfo structure specified at pipeline creation time and the value provided in the OutputVertices execution mode of shader modules must be less than or equal to this limit. See html/vkspec.html#tessellation.
maxTessellationControlPerVertexInputComponents is the maximum number of components of input variables which can be provided as per-vertex inputs to the tessellation control shader stage.
maxTessellationControlPerVertexOutputComponents is the maximum number of components of per-vertex output variables which can be output from the tessellation control shader stage.
maxTessellationControlPerPatchOutputComponents is the maximum number of components of per-patch output variables which can be output from the tessellation control shader stage.
maxTessellationControlTotalOutputComponents is the maximum total number of components of per-vertex and per-patch output variables which can be output from the tessellation control shader stage.
maxTessellationEvaluationInputComponents is the maximum number of components of input variables which can be provided as per-vertex inputs to the tessellation evaluation shader stage.
maxTessellationEvaluationOutputComponents is the maximum number of components of per-vertex output variables which can be output from the tessellation evaluation shader stage.
maxGeometryShaderInvocations is the maximum invocation count supported for instanced geometry shaders. The value provided in the Invocations execution mode of shader modules must be less than or equal to this limit. See html/vkspec.html#geometry.
maxGeometryInputComponents is the maximum number of components of input variables which can be provided as inputs to the geometry shader stage.
maxGeometryOutputComponents is the maximum number of components of output variables which can be output from the geometry shader stage.
maxGeometryOutputVertices is the maximum number of vertices which can be emitted by any geometry shader.
maxGeometryTotalOutputComponents is the maximum total number of components of output, across all emitted vertices, which can be output from the geometry shader stage.
maxFragmentInputComponents is the maximum number of components of input variables which can be provided as inputs to the fragment shader stage.
maxFragmentOutputAttachments is the maximum number of output attachments which can be written to by the fragment shader stage.
maxFragmentDualSrcAttachments is the maximum number of output attachments which can be written to by the fragment shader stage when blending is enabled and one of the dual source blend modes is in use. See html/vkspec.html#framebuffer-dsb and dualSrcBlend.
maxFragmentCombinedOutputResources is the total number of storage buffers, storage images, and output buffers which can be used in the fragment shader stage.
maxComputeSharedMemorySize is the maximum total storage size, in bytes, available for variables declared with the Workgroup storage class in shader modules (or with the shared storage qualifier in GLSL) in the compute shader stage. The amount of storage consumed by the variables declared with the Workgroup storage class is implementation-dependent. However, the amount of storage consumed may not exceed the largest block size that would be obtained if all active variables declared with Workgroup storage class were assigned offsets in an arbitrary order by successively taking the smallest valid offset according to the Standard Storage Buffer Layout rules. (This is equivalent to using the GLSL std430 layout rules.)
maxComputeWorkGroupCount[3] is the maximum number of local workgroups that can be dispatched by a single dispatch command. These three values represent the maximum number of local workgroups for the X, Y, and Z dimensions, respectively. The workgroup count parameters to the dispatch commands must be less than or equal to the corresponding limit. See html/vkspec.html#dispatch.
maxComputeWorkGroupInvocations is the maximum total number of compute shader invocations in a single local workgroup. The product of the X, Y, and Z sizes as specified by the LocalSize execution mode in shader modules and by the object decorated by the WorkgroupSize decoration must be less than or equal to this limit.
maxComputeWorkGroupSize[3] is the maximum size of a local compute workgroup, per dimension. These three values represent the maximum local workgroup size in the X, Y, and Z dimensions, respectively. The x, y, and z sizes specified by the LocalSize execution mode and by the object decorated by the WorkgroupSize decoration in shader modules must be less than or equal to the corresponding limit.
subPixelPrecisionBits is the number of bits of subpixel precision in framebuffer coordinates xf and yf. See html/vkspec.html#primsrast.
subTexelPrecisionBits is the number of bits of precision in the division along an axis of an image used for minification and magnification filters. 2subTexelPrecisionBits is the actual number of divisions along each axis of the image represented. Sub-texel values calculated during image sampling will snap to these locations when generating the filtered results.
mipmapPrecisionBits is the number of bits of division that the LOD calculation for mipmap fetching get snapped to when determining the contribution from each mip level to the mip filtered results. 2mipmapPrecisionBits is the actual number of divisions.
maxDrawIndexedIndexValue is the maximum index value that can be used for indexed draw calls when using 32-bit indices. This excludes the primitive restart index value of 0xFFFFFFFF. See fullDrawIndexUint32.
maxDrawIndirectCount is the maximum draw count that is supported for indirect draw calls. See multiDrawIndirect.
maxSamplerLodBias is the maximum absolute sampler LOD bias. The sum of the mipLodBias member of the VkSamplerCreateInfo structure and the Bias operand of image sampling operations in shader modules (or 0 if no Bias operand is provided to an image sampling operation) are clamped to the range [-maxSamplerLodBias,+maxSamplerLodBias]. See html/vkspec.html#samplers-mipLodBias.
maxSamplerAnisotropy is the maximum degree of sampler anisotropy. The maximum degree of anisotropic filtering used for an image sampling operation is the minimum of the maxAnisotropy member of the VkSamplerCreateInfo structure and this limit. See html/vkspec.html#samplers-maxAnisotropy.
maxViewports is the maximum number of active viewports. The viewportCount member of the VkPipelineViewportStateCreateInfo structure that is provided at pipeline creation must be less than or equal to this limit.
maxViewportDimensions[2] are the maximum viewport dimensions in the X (width) and Y (height) dimensions, respectively. The maximum viewport dimensions must be greater than or equal to the largest image which can be created and used as a framebuffer attachment. See Controlling the Viewport.
viewportBoundsRange[2] is the [minimum, maximum] range that the corners of a viewport must be contained in. This range must be at least [-2 × size, 2 × size - 1], where size = max(maxViewportDimensions[0], maxViewportDimensions[1]). See Controlling the Viewport.
Note
The intent of the viewportBoundsRange limit is to allow a maximum sized viewport to be arbitrarily shifted relative to the output target as long as at least some portion intersects. This would give a bounds limit of [-size + 1, 2 × size - 1] which would allow all possible non-empty-set intersections of the output target and the viewport. Since these numbers are typically powers of two, picking the signed number range using the smallest possible number of bits ends up with the specified range.
viewportSubPixelBits is the number of bits of subpixel precision for viewport bounds. The subpixel precision that floating-point viewport bounds are interpreted at is given by this limit.
minMemoryMapAlignment is the minimum required alignment, in bytes, of host visible memory allocations within the host address space. When mapping a memory allocation with vkMapMemory, subtracting offset bytes from the returned pointer will always produce an integer multiple of this limit. See html/vkspec.html#memory-device-hostaccess.
minTexelBufferOffsetAlignment is the minimum required alignment, in bytes, for the offset member of the VkBufferViewCreateInfo structure for texel buffers. When a buffer view is created for a buffer which was created with VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the usage member of the VkBufferCreateInfo structure, the offset must be an integer multiple of this limit.
minUniformBufferOffsetAlignment is the minimum required alignment, in bytes, for the offset member of the VkDescriptorBufferInfo structure for uniform buffers. When a descriptor of type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC is updated, the offset must be an integer multiple of this limit. Similarly, dynamic offsets for uniform buffers must be multiples of this limit.
minStorageBufferOffsetAlignment is the minimum required alignment, in bytes, for the offset member of the VkDescriptorBufferInfo structure for storage buffers. When a descriptor of type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC is updated, the offset must be an integer multiple of this limit. Similarly, dynamic offsets for storage buffers must be multiples of this limit.
minTexelOffset is the minimum offset value for the ConstOffset image operand of any of the OpImageSample* or OpImageFetch* image instructions.
maxTexelOffset is the maximum offset value for the ConstOffset image operand of any of the OpImageSample* or OpImageFetch* image instructions.
minTexelGatherOffset is the minimum offset value for the Offset or ConstOffsets image operands of any of the OpImage*Gather image instructions.
maxTexelGatherOffset is the maximum offset value for the Offset or ConstOffsets image operands of any of the OpImage*Gather image instructions.
minInterpolationOffset is the minimum negative offset value for the offset operand of the InterpolateAtOffset extended instruction.
maxInterpolationOffset is the maximum positive offset value for the offset operand of the InterpolateAtOffset extended instruction.
subPixelInterpolationOffsetBits is the number of subpixel fractional bits that the x and y offsets to the InterpolateAtOffset extended instruction may be rounded to as fixed-point values.
maxFramebufferWidth is the maximum width for a framebuffer. The width member of the VkFramebufferCreateInfo structure must be less than or equal to this limit.
maxFramebufferHeight is the maximum height for a framebuffer. The height member of the VkFramebufferCreateInfo structure must be less than or equal to this limit.
maxFramebufferLayers is the maximum layer count for a layered framebuffer. The layers member of the VkFramebufferCreateInfo structure must be less than or equal to this limit.
framebufferColorSampleCounts is a bitmask1 of VkSampleCountFlagBits indicating the color sample counts that are supported for all framebuffer color attachments with floating- or fixed-point formats. There is no limit that specifies the color sample counts that are supported for all color attachments with integer formats.
framebufferDepthSampleCounts is a bitmask1 of VkSampleCountFlagBits indicating the supported depth sample counts for all framebuffer depth/stencil attachments, when the format includes a depth component.
framebufferStencilSampleCounts is a bitmask1 of VkSampleCountFlagBits indicating the supported stencil sample counts for all framebuffer depth/stencil attachments, when the format includes a stencil component.
framebufferNoAttachmentsSampleCounts is a bitmask1 of VkSampleCountFlagBits indicating the supported sample counts for a framebuffer with no attachments.
maxColorAttachments is the maximum number of color attachments that can be used by a subpass in a render pass. The colorAttachmentCount member of the VkSubpassDescription structure must be less than or equal to this limit.
sampledImageColorSampleCounts is a bitmask1 of VkSampleCountFlagBits indicating the sample counts supported for all 2D images created with VK_IMAGE_TILING_OPTIMAL, usage containing VK_IMAGE_USAGE_SAMPLED_BIT, and a non-integer color format.
sampledImageIntegerSampleCounts is a bitmask1 of VkSampleCountFlagBits indicating the sample counts supported for all 2D images created with VK_IMAGE_TILING_OPTIMAL, usage containing VK_IMAGE_USAGE_SAMPLED_BIT, and an integer color format.
sampledImageDepthSampleCounts is a bitmask1 of VkSampleCountFlagBits indicating the sample counts supported for all 2D images created with VK_IMAGE_TILING_OPTIMAL, usage containing VK_IMAGE_USAGE_SAMPLED_BIT, and a depth format.
sampledImageStencilSampleCounts is a bitmask1 of VkSampleCountFlagBits indicating the sample supported for all 2D images created with VK_IMAGE_TILING_OPTIMAL, usage containing VK_IMAGE_USAGE_SAMPLED_BIT, and a stencil format.
storageImageSampleCounts is a bitmask1 of VkSampleCountFlagBits indicating the sample counts supported for all 2D images created with VK_IMAGE_TILING_OPTIMAL, and usage containing VK_IMAGE_USAGE_STORAGE_BIT.
maxSampleMaskWords is the maximum number of array elements of a variable decorated with the SampleMask built-in decoration.
timestampComputeAndGraphics specifies support for timestamps on all graphics and compute queues. If this limit is set to VK_TRUE, all queues that advertise the VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT in the VkQueueFamilyProperties::queueFlags support VkQueueFamilyProperties::timestampValidBits of at least 36. See Timestamp Queries.
timestampPeriod is the number of nanoseconds required for a timestamp query to be incremented by 1. See Timestamp Queries.
maxClipDistances is the maximum number of clip distances that can be used in a single shader stage. The size of any array declared with the ClipDistance built-in decoration in a shader module must be less than or equal to this limit.
maxCullDistances is the maximum number of cull distances that can be used in a single shader stage. The size of any array declared with the CullDistance built-in decoration in a shader module must be less than or equal to this limit.
maxCombinedClipAndCullDistances is the maximum combined number of clip and cull distances that can be used in a single shader stage. The sum of the sizes of any pair of arrays declared with the ClipDistance and CullDistance built-in decoration used by a single shader stage in a shader module must be less than or equal to this limit.
discreteQueuePriorities is the number of discrete priorities that can be assigned to a queue based on the value of each member of VkDeviceQueueCreateInfo::pQueuePriorities. This must be at least 2, and levels must be spread evenly over the range, with at least one level at 1.0, and another at 0.0. See html/vkspec.html#devsandqueues-priority.
pointSizeRange[2] is the range [minimum,maximum] of supported sizes for points. Values written to variables decorated with the PointSize built-in decoration are clamped to this range.
lineWidthRange[2] is the range [minimum,maximum] of supported widths for lines. Values specified by the lineWidth member of the VkPipelineRasterizationStateCreateInfo or the lineWidth parameter to vkCmdSetLineWidth are clamped to this range.
pointSizeGranularity is the granularity of supported point sizes. Not all point sizes in the range defined by pointSizeRange are supported. This limit specifies the granularity (or increment) between successive supported point sizes.
lineWidthGranularity is the granularity of supported line widths. Not all line widths in the range defined by lineWidthRange are supported. This limit specifies the granularity (or increment) between successive supported line widths.
strictLines specifies whether lines are rasterized according to the preferred method of rasterization. If set to VK_FALSE, lines may be rasterized under a relaxed set of rules. If set to VK_TRUE, lines are rasterized as per the strict definition. See Basic Line Segment Rasterization.
standardSampleLocations specifies whether rasterization uses the standard sample locations as documented in Multisampling. If set to VK_TRUE, the implementation uses the documented sample locations. If set to VK_FALSE, the implementation may use different sample locations.
optimalBufferCopyOffsetAlignment is the optimal buffer offset alignment in bytes for vkCmdCopyBufferToImage and vkCmdCopyImageToBuffer. The per texel alignment requirements are enforced, but applications should use the optimal alignment for optimal performance and power use.
optimalBufferCopyRowPitchAlignment is the optimal buffer row pitch alignment in bytes for vkCmdCopyBufferToImage and vkCmdCopyImageToBuffer. Row pitch is the number of bytes between texels with the same X coordinate in adjacent rows (Y coordinates differ by one). The per texel alignment requirements are enforced, but applications should use the optimal alignment for optimal performance and power use.
nonCoherentAtomSize is the size and alignment in bytes that bounds concurrent access to host-mapped device memory.
Description
1
For all bitmasks of VkSampleCountFlagBits, the sample count limits defined above represent the minimum supported sample counts for each image type. Individual images may support additional sample counts, which are queried using vkGetPhysicalDeviceImageFormatProperties as described in Supported Sample Counts.
See Also
VkBool32, VkDeviceSize, VkPhysicalDeviceProperties, VkSampleCountFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceLimits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceMaintenance3Properties(3)
Name
VkPhysicalDeviceMaintenance3Properties - Structure describing descriptor set properties

C Specification
The VkPhysicalDeviceMaintenance3Properties structure is defined as:

typedef struct VkPhysicalDeviceMaintenance3Properties {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxPerSetDescriptors;
    VkDeviceSize       maxMemoryAllocationSize;
} VkPhysicalDeviceMaintenance3Properties;
or the equivalent

typedef VkPhysicalDeviceMaintenance3Properties VkPhysicalDeviceMaintenance3PropertiesKHR;
Members
The members of the VkPhysicalDeviceMaintenance3Properties structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
maxPerSetDescriptors is a maximum number of descriptors (summed over all descriptor types) in a single descriptor set that is guaranteed to satisfy any implementation-dependent constraints on the size of a descriptor set itself. Applications can query whether a descriptor set that goes beyond this limit is supported using vkGetDescriptorSetLayoutSupport.
maxMemoryAllocationSize is the maximum size of a memory allocation that can be created, even if there is more space available in the heap.
If the VkPhysicalDeviceMaintenance3Properties structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES
See Also
VkDeviceSize, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceMaintenance3Properties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceMemoryBudgetPropertiesEXT(3)
Name
VkPhysicalDeviceMemoryBudgetPropertiesEXT - Structure specifying physical device memory budget and usage

C Specification
If the VkPhysicalDeviceMemoryBudgetPropertiesEXT structure is included in the pNext chain of VkPhysicalDeviceMemoryProperties2, it is filled with the current memory budgets and usages.

The VkPhysicalDeviceMemoryBudgetPropertiesEXT structure is defined as:

typedef struct VkPhysicalDeviceMemoryBudgetPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkDeviceSize       heapBudget[VK_MAX_MEMORY_HEAPS];
    VkDeviceSize       heapUsage[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryBudgetPropertiesEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
heapBudget is an array of memory budgets, with one element for each memory heap. A heap’s budget is a rough estimate of how much memory the process can allocate from that heap before allocations may fail or cause performance degradation. The budget includes any currently allocated device memory.
heapUsage is an array of memory usage, with one element for each memory heap. A heap’s usage is an estimate of how much memory the process is currently using in that heap.
Description
The values returned in this structure are not invariant. The heapBudget and heapUsage values must be zero for array elements greater than or equal to VkPhysicalDeviceMemoryProperties::memoryHeapCount. The heapBudget value must be non-zero for array elements less than VkPhysicalDeviceMemoryProperties::memoryHeapCount. The heapBudget value must be less than or equal to VkMemoryHeap::size for each heap.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT
See Also
VkDeviceSize, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceMemoryBudgetPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceMemoryPriorityFeaturesEXT(3)
Name
VkPhysicalDeviceMemoryPriorityFeaturesEXT - Structure describing memory priority features that can be supported by an implementation

C Specification
The VkPhysicalDeviceMemoryPriorityFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceMemoryPriorityFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           memoryPriority;
} VkPhysicalDeviceMemoryPriorityFeaturesEXT;
Members
The members of the VkPhysicalDeviceMemoryPriorityFeaturesEXT structure describe the following features:

Description
memoryPriority indicates that the implementation supports memory priorities specified at memory allocation time via VkMemoryPriorityAllocateInfoEXT.
If the VkPhysicalDeviceMemoryPriorityFeaturesEXT structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether the feature is supported. VkPhysicalDeviceMemoryPriorityFeaturesEXT can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceMemoryPriorityFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceMemoryProperties(3)
Name
VkPhysicalDeviceMemoryProperties - Structure specifying physical device memory properties

C Specification
The VkPhysicalDeviceMemoryProperties structure is defined as:

typedef struct VkPhysicalDeviceMemoryProperties {
    uint32_t        memoryTypeCount;
    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t        memoryHeapCount;
    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;
Members
memoryTypeCount is the number of valid elements in the memoryTypes array.
memoryTypes is an array of VkMemoryType structures describing the memory types that can be used to access memory allocated from the heaps specified by memoryHeaps.
memoryHeapCount is the number of valid elements in the memoryHeaps array.
memoryHeaps is an array of VkMemoryHeap structures describing the memory heaps from which memory can be allocated.
Description
The VkPhysicalDeviceMemoryProperties structure describes a number of memory heaps as well as a number of memory types that can be used to access memory allocated in those heaps. Each heap describes a memory resource of a particular size, and each memory type describes a set of memory properties (e.g. host cached vs uncached) that can be used with a given memory heap. Allocations using a particular memory type will consume resources from the heap indicated by that memory type’s heap index. More than one memory type may share each heap, and the heaps and memory types provide a mechanism to advertise an accurate size of the physical memory resources while allowing the memory to be used with a variety of different properties.

The number of memory heaps is given by memoryHeapCount and is less than or equal to VK_MAX_MEMORY_HEAPS. Each heap is described by an element of the memoryHeaps array as a VkMemoryHeap structure. The number of memory types available across all memory heaps is given by memoryTypeCount and is less than or equal to VK_MAX_MEMORY_TYPES. Each memory type is described by an element of the memoryTypes array as a VkMemoryType structure.

At least one heap must include VK_MEMORY_HEAP_DEVICE_LOCAL_BIT in VkMemoryHeap::flags. If there are multiple heaps that all have similar performance characteristics, they may all include VK_MEMORY_HEAP_DEVICE_LOCAL_BIT. In a unified memory architecture (UMA) system there is often only a single memory heap which is considered to be equally “local” to the host and to the device, and such an implementation must advertise the heap as device-local.

Each memory type returned by vkGetPhysicalDeviceMemoryProperties must have its propertyFlags set to one of the following values:

0
VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
VK_MEMORY_PROPERTY_HOST_CACHED_BIT
VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
VK_MEMORY_PROPERTY_HOST_CACHED_BIT |
VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
VK_MEMORY_PROPERTY_HOST_CACHED_BIT
VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
VK_MEMORY_PROPERTY_HOST_CACHED_BIT |
VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT
VK_MEMORY_PROPERTY_PROTECTED_BIT
VK_MEMORY_PROPERTY_PROTECTED_BIT | VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
There must be at least one memory type with both the VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT and VK_MEMORY_PROPERTY_HOST_COHERENT_BIT bits set in its propertyFlags. There must be at least one memory type with the VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT bit set in its propertyFlags.

For each pair of elements X and Y returned in memoryTypes, X must be placed at a lower index position than Y if:

either the set of bit flags returned in the propertyFlags member of X is a strict subset of the set of bit flags returned in the propertyFlags member of Y.
or the propertyFlags members of X and Y are equal, and X belongs to a memory heap with greater performance (as determined in an implementation-specific manner).
Note
There is no ordering requirement between X and Y elements for the case their propertyFlags members are not in a subset relation. That potentially allows more than one possible way to order the same set of memory types. Notice that the list of all allowed memory property flag combinations is written in a valid order. But if instead VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT was before VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, the list would still be in a valid order.
This ordering requirement enables applications to use a simple search loop to select the desired memory type along the lines of:

// Find a memory in `memoryTypeBitsRequirement` that includes all of `requiredProperties`
int32_t findProperties(const VkPhysicalDeviceMemoryProperties* pMemoryProperties,
                       uint32_t memoryTypeBitsRequirement,
                       VkMemoryPropertyFlags requiredProperties) {
    const uint32_t memoryCount = pMemoryProperties->memoryTypeCount;
    for (uint32_t memoryIndex = 0; memoryIndex < memoryCount; ++memoryIndex) {
        const uint32_t memoryTypeBits = (1 << memoryIndex);
        const bool isRequiredMemoryType = memoryTypeBitsRequirement & memoryTypeBits;

        const VkMemoryPropertyFlags properties =
            pMemoryProperties->memoryTypes[memoryIndex].propertyFlags;
        const bool hasRequiredProperties =
            (properties & requiredProperties) == requiredProperties;

        if (isRequiredMemoryType && hasRequiredProperties)
            return static_cast<int32_t>(memoryIndex);
    }

    // failed to find memory type
    return -1;
}

// Try to find an optimal memory type, or if it does not exist try fallback memory type
// `device` is the VkDevice
// `image` is the VkImage that requires memory to be bound
// `memoryProperties` properties as returned by vkGetPhysicalDeviceMemoryProperties
// `requiredProperties` are the property flags that must be present
// `optimalProperties` are the property flags that are preferred by the application
VkMemoryRequirements memoryRequirements;
vkGetImageMemoryRequirements(device, image, &memoryRequirements);
int32_t memoryType =
    findProperties(&memoryProperties, memoryRequirements.memoryTypeBits, optimalProperties);
if (memoryType == -1) // not found; try fallback properties
    memoryType =
        findProperties(&memoryProperties, memoryRequirements.memoryTypeBits, requiredProperties);
See Also
VkMemoryHeap, VkMemoryType, VkPhysicalDeviceMemoryProperties2, vkGetPhysicalDeviceMemoryProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceMemoryProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceMemoryProperties2(3)
Name
VkPhysicalDeviceMemoryProperties2 - Structure specifying physical device memory properties

C Specification
The VkPhysicalDeviceMemoryProperties2 structure is defined as:

typedef struct VkPhysicalDeviceMemoryProperties2 {
    VkStructureType                     sType;
    void*                               pNext;
    VkPhysicalDeviceMemoryProperties    memoryProperties;
} VkPhysicalDeviceMemoryProperties2;
or the equivalent

typedef VkPhysicalDeviceMemoryProperties2 VkPhysicalDeviceMemoryProperties2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
memoryProperties is a structure of type VkPhysicalDeviceMemoryProperties which is populated with the same values as in vkGetPhysicalDeviceMemoryProperties.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2
pNext must be NULL or a pointer to a valid instance of VkPhysicalDeviceMemoryBudgetPropertiesEXT
See Also
VkPhysicalDeviceMemoryProperties, VkStructureType, vkGetPhysicalDeviceMemoryProperties2, vkGetPhysicalDeviceMemoryProperties2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceMemoryProperties2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceMeshShaderFeaturesNV(3)
Name
VkPhysicalDeviceMeshShaderFeaturesNV - Structure describing mesh shading features that can be supported by an implementation

C Specification
The VkPhysicalDeviceMeshShaderFeaturesNV structure is defined as:

typedef struct VkPhysicalDeviceMeshShaderFeaturesNV {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           taskShader;
    VkBool32           meshShader;
} VkPhysicalDeviceMeshShaderFeaturesNV;
Members
taskShader indicates whether the task shader stage is supported.
meshShader indicates whether the mesh shader stage is supported.
Description
If the VkPhysicalDeviceMeshShaderFeaturesNV structure is included in the pNext chain of VkPhysicalDeviceFeatures2, it is filled with a value indicating whether the feature is supported. VkPhysicalDeviceMeshShaderFeaturesNV can also be used in pNext chain of VkDeviceCreateInfo to enable the features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceMeshShaderFeaturesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceMeshShaderPropertiesNV(3)
Name
VkPhysicalDeviceMeshShaderPropertiesNV - Structure describing mesh shading properties

C Specification
The VkPhysicalDeviceMeshShaderPropertiesNV structure is defined as:

typedef struct VkPhysicalDeviceMeshShaderPropertiesNV {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxDrawMeshTasksCount;
    uint32_t           maxTaskWorkGroupInvocations;
    uint32_t           maxTaskWorkGroupSize[3];
    uint32_t           maxTaskTotalMemorySize;
    uint32_t           maxTaskOutputCount;
    uint32_t           maxMeshWorkGroupInvocations;
    uint32_t           maxMeshWorkGroupSize[3];
    uint32_t           maxMeshTotalMemorySize;
    uint32_t           maxMeshOutputVertices;
    uint32_t           maxMeshOutputPrimitives;
    uint32_t           maxMeshMultiviewViewCount;
    uint32_t           meshOutputPerVertexGranularity;
    uint32_t           meshOutputPerPrimitiveGranularity;
} VkPhysicalDeviceMeshShaderPropertiesNV;
Members
The members of the VkPhysicalDeviceMeshShaderPropertiesNV structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
maxDrawMeshTasksCount is the maximum number of local workgroups that can be launched by a single draw mesh tasks command. See html/vkspec.html#drawing-mesh-shading.
maxTaskWorkGroupInvocations is the maximum total number of task shader invocations in a single local workgroup. The product of the X, Y, and Z sizes as specified by the LocalSize execution mode in shader modules and by the object decorated by the WorkgroupSize decoration must be less than or equal to this limit.
maxTaskWorkGroupSize[3] is the maximum size of a local task workgroup. These three values represent the maximum local workgroup size in the X, Y, and Z dimensions, respectively. The x, y, and z sizes specified by the LocalSize execution mode and by the object decorated by the WorkgroupSize decoration in shader modules must be less than or equal to the corresponding limit.
maxTaskTotalMemorySize is the maximum number of bytes that the task shader can use in total for shared and output memory combined.
maxTaskOutputCount is the maximum number of output tasks a single task shader workgroup can emit.
maxMeshWorkGroupInvocations is the maximum total number of mesh shader invocations in a single local workgroup. The product of the X, Y, and Z sizes as specified by the LocalSize execution mode in shader modules and by the object decorated by the WorkgroupSize decoration must be less than or equal to this limit.
maxMeshWorkGroupSize[3] is the maximum size of a local mesh workgroup. These three values represent the maximum local workgroup size in the X, Y, and Z dimensions, respectively. The x, y, and z sizes specified by the LocalSize execution mode and by the object decorated by the WorkgroupSize decoration in shader modules must be less than or equal to the corresponding limit.
maxMeshTotalMemorySize is the maximum number of bytes that the mesh shader can use in total for shared and output memory combined.
maxMeshOutputVertices is the maximum number of vertices a mesh shader output can store.
maxMeshOutputPrimitives is the maximum number of primitives a mesh shader output can store.
maxMeshMultiviewViewCount is the maximum number of multi-view views a mesh shader can use.
meshOutputPerVertexGranularity is the granularity with which mesh vertex outputs are allocated. The value can be used to compute the memory size used by the mesh shader, which must be less than or equal to maxMeshTotalMemorySize.
meshOutputPerPrimitiveGranularity is the granularity with which mesh outputs qualified as per-primitive are allocated. The value can be used to compute the memory size used by the mesh shader, which must be less than or equal to maxMeshTotalMemorySize.
If the VkPhysicalDeviceMeshShaderPropertiesNV structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceMeshShaderPropertiesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceMultiviewFeatures(3)
Name
VkPhysicalDeviceMultiviewFeatures - Structure describing multiview features that can be supported by an implementation

C Specification
The VkPhysicalDeviceMultiviewFeatures structure is defined as:

typedef struct VkPhysicalDeviceMultiviewFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           multiview;
    VkBool32           multiviewGeometryShader;
    VkBool32           multiviewTessellationShader;
} VkPhysicalDeviceMultiviewFeatures;
or the equivalent

typedef VkPhysicalDeviceMultiviewFeatures VkPhysicalDeviceMultiviewFeaturesKHR;
Members
The members of the VkPhysicalDeviceMultiviewFeatures structure describe the following features:

Description
multiview specifies whether the implementation supports multiview rendering within a render pass. If this feature is not enabled, the view mask of each subpass must always be zero.
multiviewGeometryShader specifies whether the implementation supports multiview rendering within a render pass, with geometry shaders. If this feature is not enabled, then a pipeline compiled against a subpass with a non-zero view mask must not include a geometry shader.
multiviewTessellationShader specifies whether the implementation supports multiview rendering within a render pass, with tessellation shaders. If this feature is not enabled, then a pipeline compiled against a subpass with a non-zero view mask must not include any tessellation shaders.
If the VkPhysicalDeviceMultiviewFeatures structure is included in the pNext chain of VkPhysicalDeviceFeatures2, it is filled with values indicating whether each feature is supported. VkPhysicalDeviceMultiviewFeatures can also be used in the pNext chain of VkDeviceCreateInfo to enable the features.

Valid Usage
If multiviewGeometryShader is enabled then multiview must also be enabled.
If multiviewTessellationShader is enabled then multiview must also be enabled.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceMultiviewFeatures

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(3)
Name
VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX - Structure describing multiview limits that can be supported by an implementation

C Specification
The VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX structure is defined as:

typedef struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           perViewPositionAllComponents;
} VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
Members
The members of the VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
perViewPositionAllComponents is VK_TRUE if the implementation supports per-view position values that differ in components other than the X component.
If the VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceMultiviewProperties(3)
Name
VkPhysicalDeviceMultiviewProperties - Structure describing multiview limits that can be supported by an implementation

C Specification
The VkPhysicalDeviceMultiviewProperties structure is defined as:

typedef struct VkPhysicalDeviceMultiviewProperties {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxMultiviewViewCount;
    uint32_t           maxMultiviewInstanceIndex;
} VkPhysicalDeviceMultiviewProperties;
or the equivalent

typedef VkPhysicalDeviceMultiviewProperties VkPhysicalDeviceMultiviewPropertiesKHR;
Members
The members of the VkPhysicalDeviceMultiviewProperties structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
maxMultiviewViewCount is one greater than the maximum view index that can be used in a subpass.
maxMultiviewInstanceIndex is the maximum valid value of instance index allowed to be generated by a drawing command recorded within a subpass of a multiview render pass instance.
If the VkPhysicalDeviceMultiviewProperties structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceMultiviewProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDevicePCIBusInfoPropertiesEXT(3)
Name
VkPhysicalDevicePCIBusInfoPropertiesEXT - Structure containing PCI bus information of a physical device

C Specification
To query the PCI bus information of a physical device, add VkPhysicalDevicePCIBusInfoPropertiesEXT to the pNext chain of the VkPhysicalDeviceProperties2 structure. The VkPhysicalDevicePCIBusInfoPropertiesEXT structure is defined as:

typedef struct VkPhysicalDevicePCIBusInfoPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           pciDomain;
    uint32_t           pciBus;
    uint32_t           pciDevice;
    uint32_t           pciFunction;
} VkPhysicalDevicePCIBusInfoPropertiesEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
pciDomain is the PCI bus domain.
pciBus is the PCI bus identifier.
pciDevice is the PCI device identifier.
pciFunction is the PCI device function identifier.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDevicePCIBusInfoPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDevicePointClippingProperties(3)
Name
VkPhysicalDevicePointClippingProperties - Structure describing the point clipping behavior supported by an implementation

C Specification
The VkPhysicalDevicePointClippingProperties structure is defined as:

typedef struct VkPhysicalDevicePointClippingProperties {
    VkStructureType            sType;
    void*                      pNext;
    VkPointClippingBehavior    pointClippingBehavior;
} VkPhysicalDevicePointClippingProperties;
or the equivalent

typedef VkPhysicalDevicePointClippingProperties VkPhysicalDevicePointClippingPropertiesKHR;
Members
The members of the VkPhysicalDevicePointClippingProperties structure describe the following implementation-dependent limit:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
pointClippingBehavior is the point clipping behavior supported by the implementation, and is of type VkPointClippingBehavior.
If the VkPhysicalDevicePointClippingProperties structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES
See Also
VkPointClippingBehavior, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDevicePointClippingProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceProperties(3)
Name
VkPhysicalDeviceProperties - Structure specifying physical device properties

C Specification
The VkPhysicalDeviceProperties structure is defined as:

typedef struct VkPhysicalDeviceProperties {
    uint32_t                            apiVersion;
    uint32_t                            driverVersion;
    uint32_t                            vendorID;
    uint32_t                            deviceID;
    VkPhysicalDeviceType                deviceType;
    char                                deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t                             pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceLimits              limits;
    VkPhysicalDeviceSparseProperties    sparseProperties;
} VkPhysicalDeviceProperties;
Members
apiVersion is the version of Vulkan supported by the device, encoded as described in html/vkspec.html#extendingvulkan-coreversions-versionnumbers.
driverVersion is the vendor-specified version of the driver.
vendorID is a unique identifier for the vendor (see below) of the physical device.
deviceID is a unique identifier for the physical device among devices available from the vendor.
deviceType is a VkPhysicalDeviceType specifying the type of device.
deviceName is a null-terminated UTF-8 string containing the name of the device.
pipelineCacheUUID is an array of size VK_UUID_SIZE, containing 8-bit values that represent a universally unique identifier for the device.
limits is the VkPhysicalDeviceLimits structure which specifies device-specific limits of the physical device. See Limits for details.
sparseProperties is the VkPhysicalDeviceSparseProperties structure which specifies various sparse related properties of the physical device. See Sparse Properties for details.
Description
Note
The value of apiVersion may be different than the version returned by vkEnumerateInstanceVersion; either higher or lower. In such cases, the application must not use functionality that exceeds the version of Vulkan associated with a given object. The pApiVersion parameter returned by vkEnumerateInstanceVersion is the version associated with a VkInstance and its children, except for a VkPhysicalDevice and its children. VkPhysicalDeviceProperties::apiVersion is the version associated with a VkPhysicalDevice and its children.
The vendorID and deviceID fields are provided to allow applications to adapt to device characteristics that are not adequately exposed by other Vulkan queries.

Note
These may include performance profiles, hardware errata, or other characteristics.
The vendor identified by vendorID is the entity responsible for the most salient characteristics of the underlying implementation of the VkPhysicalDevice being queried.

Note
For example, in the case of a discrete GPU implementation, this should be the GPU chipset vendor. In the case of a hardware accelerator integrated into a system-on-chip (SoC), this should be the supplier of the silicon IP used to create the accelerator.
If the vendor has a PCI vendor ID, the low 16 bits of vendorID must contain that PCI vendor ID, and the remaining bits must be set to zero. Otherwise, the value returned must be a valid Khronos vendor ID, obtained as described in the Vulkan Documentation and Extensions: Procedures and Conventions document in the section “Registering a Vendor ID with Khronos”. Khronos vendor IDs are allocated starting at 0x10000, to distinguish them from the PCI vendor ID namespace. Khronos vendor IDs are symbolically defined in the VkVendorId type.

The vendor is also responsible for the value returned in deviceID. If the implementation is driven primarily by a PCI device with a PCI device ID, the low 16 bits of deviceID must contain that PCI device ID, and the remaining bits must be set to zero. Otherwise, the choice of what values to return may be dictated by operating system or platform policies - but should uniquely identify both the device version and any major configuration options (for example, core count in the case of multicore devices).

Note
The same device ID should be used for all physical implementations of that device version and configuration. For example, all uses of a specific silicon IP GPU version and configuration should use the same device ID, even if those uses occur in different SoCs.
See Also
VkPhysicalDeviceLimits, VkPhysicalDeviceProperties2, VkPhysicalDeviceSparseProperties, VkPhysicalDeviceType, vkGetPhysicalDeviceProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceProperties2(3)
Name
VkPhysicalDeviceProperties2 - Structure specifying physical device properties

C Specification
The VkPhysicalDeviceProperties2 structure is defined as:

typedef struct VkPhysicalDeviceProperties2 {
    VkStructureType               sType;
    void*                         pNext;
    VkPhysicalDeviceProperties    properties;
} VkPhysicalDeviceProperties2;
or the equivalent

typedef VkPhysicalDeviceProperties2 VkPhysicalDeviceProperties2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
properties is a structure of type VkPhysicalDeviceProperties describing the properties of the physical device. This structure is written with the same values as if it were written by vkGetPhysicalDeviceProperties.
Description
The pNext chain of this structure is used to extend the structure with properties defined by extensions.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkPhysicalDeviceDepthStencilResolvePropertiesKHR, VkPhysicalDeviceDescriptorIndexingPropertiesEXT, VkPhysicalDeviceDiscardRectanglePropertiesEXT, VkPhysicalDeviceDriverPropertiesKHR, VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceFloatControlsPropertiesKHR, VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceIDProperties, VkPhysicalDeviceInlineUniformBlockPropertiesEXT, VkPhysicalDeviceMaintenance3Properties, VkPhysicalDeviceMeshShaderPropertiesNV, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, VkPhysicalDeviceMultiviewProperties, VkPhysicalDevicePCIBusInfoPropertiesEXT, VkPhysicalDevicePointClippingProperties, VkPhysicalDeviceProtectedMemoryProperties, VkPhysicalDevicePushDescriptorPropertiesKHR, VkPhysicalDeviceRayTracingPropertiesNV, VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, VkPhysicalDeviceShaderCorePropertiesAMD, VkPhysicalDeviceShadingRateImagePropertiesNV, VkPhysicalDeviceSubgroupProperties, VkPhysicalDeviceTransformFeedbackPropertiesEXT, or VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT
Each sType member in the pNext chain must be unique
See Also
VkPhysicalDeviceProperties, VkStructureType, vkGetPhysicalDeviceProperties2, vkGetPhysicalDeviceProperties2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceProperties2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceProtectedMemoryFeatures(3)
Name
VkPhysicalDeviceProtectedMemoryFeatures - Structure describing protected memory features that can be supported by an implementation

C Specification
The VkPhysicalDeviceProtectedMemoryFeatures structure is defined as:

typedef struct VkPhysicalDeviceProtectedMemoryFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           protectedMemory;
} VkPhysicalDeviceProtectedMemoryFeatures;
Members
protectedMemory specifies whether protected memory is supported.
Description
If the VkPhysicalDeviceProtectedMemoryFeatures structure is included in the pNext chain of VkPhysicalDeviceFeatures2, it is filled with a value indicating whether the feature is supported.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceProtectedMemoryFeatures

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceProtectedMemoryProperties(3)
Name
VkPhysicalDeviceProtectedMemoryProperties - Structure describing protected memory properties that can be supported by an implementation

C Specification
The VkPhysicalDeviceProtectedMemoryProperties structure is defined as:

typedef struct VkPhysicalDeviceProtectedMemoryProperties {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           protectedNoFault;
} VkPhysicalDeviceProtectedMemoryProperties;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
protectedNoFault specifies the behavior of the implementation when protected memory access rules are broken. If protectedNoFault is VK_TRUE, breaking those rules will not result in process termination or device loss.
Description
If the VkPhysicalDeviceProtectedMemoryProperties structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with a value indicating the implementation-dependent behavior.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceProtectedMemoryProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDevicePushDescriptorPropertiesKHR(3)
Name
VkPhysicalDevicePushDescriptorPropertiesKHR - Structure describing push descriptor limits that can be supported by an implementation

C Specification
The VkPhysicalDevicePushDescriptorPropertiesKHR structure is defined as:

typedef struct VkPhysicalDevicePushDescriptorPropertiesKHR {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxPushDescriptors;
} VkPhysicalDevicePushDescriptorPropertiesKHR;
Members
The members of the VkPhysicalDevicePushDescriptorPropertiesKHR structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
maxPushDescriptors is the maximum number of descriptors that can be used in a descriptor set created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set.
If the VkPhysicalDevicePushDescriptorPropertiesKHR structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDevicePushDescriptorPropertiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceRayTracingPropertiesNV(3)
Name
VkPhysicalDeviceRayTracingPropertiesNV - Properties of the physical device for ray tracing

C Specification
The VkPhysicalDeviceRayTracingPropertiesNV structure is defined as:

typedef struct VkPhysicalDeviceRayTracingPropertiesNV {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           shaderGroupHandleSize;
    uint32_t           maxRecursionDepth;
    uint32_t           maxShaderGroupStride;
    uint32_t           shaderGroupBaseAlignment;
    uint64_t           maxGeometryCount;
    uint64_t           maxInstanceCount;
    uint64_t           maxTriangleCount;
    uint32_t           maxDescriptorSetAccelerationStructures;
} VkPhysicalDeviceRayTracingPropertiesNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
shaderGroupHandleSize size in bytes of the shader header.
maxRecursionDepth is the maximum number of levels of recursion allowed in a trace command.
maxShaderGroupStride is the maximum stride in bytes allowed between shader groups in the SBT.
shaderGroupBaseAlignment is the required alignment in bytes for the base of the SBTs.
maxGeometryCount is the maximum number of geometries in the bottom level acceleration structure.
maxInstanceCount is the maximum number of instances in the top level acceleration structure.
maxTriangleCount is the maximum number of triangles in all geometries in the bottom level acceleration structure.
maxDescriptorSetAccelerationStructures is the maximum number of acceleration structure descriptors that are allowed in a descriptor set.
Description
If the VkPhysicalDeviceRayTracingPropertiesNV structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceRayTracingPropertiesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(3)
Name
VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV - Structure describing the representative fragment test features that can be supported by an implementation

C Specification
The VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure is defined as:

typedef struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           representativeFragmentTest;
} VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV;
Members
The members of the VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure describe the following features:

Description
representativeFragmentTest indicates whether the implementation supports the representative fragment test. See Representative Fragment Test.
If the VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether the feature is supported. VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV can also be used in the pNext chain of VkDeviceCreateInfo to enable the feature.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceSampleLocationsPropertiesEXT(3)
Name
VkPhysicalDeviceSampleLocationsPropertiesEXT - Structure describing sample location limits that can be supported by an implementation

C Specification
The VkPhysicalDeviceSampleLocationsPropertiesEXT structure is defined as:

typedef struct VkPhysicalDeviceSampleLocationsPropertiesEXT {
    VkStructureType       sType;
    void*                 pNext;
    VkSampleCountFlags    sampleLocationSampleCounts;
    VkExtent2D            maxSampleLocationGridSize;
    float                 sampleLocationCoordinateRange[2];
    uint32_t              sampleLocationSubPixelBits;
    VkBool32              variableSampleLocations;
} VkPhysicalDeviceSampleLocationsPropertiesEXT;
Members
The members of the VkPhysicalDeviceSampleLocationsPropertiesEXT structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
sampleLocationSampleCounts is a bitmask of VkSampleCountFlagBits indicating the sample counts supporting custom sample locations.
maxSampleLocationGridSize is the maximum size of the pixel grid in which sample locations can vary that is supported for all sample counts in sampleLocationSampleCounts.
sampleLocationCoordinateRange[2] is the range of supported sample location coordinates.
sampleLocationSubPixelBits is the number of bits of subpixel precision for sample locations.
variableSampleLocations specifies whether the sample locations used by all pipelines that will be bound to a command buffer during a subpass must match. If set to VK_TRUE, the implementation supports variable sample locations in a subpass. If set to VK_FALSE, then the sample locations must stay constant in each subpass.
If the VkPhysicalDeviceSampleLocationsPropertiesEXT structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT
See Also
VkBool32, VkExtent2D, VkSampleCountFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceSampleLocationsPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(3)
Name
VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT - Structure describing sampler filter minmax limits that can be supported by an implementation

C Specification
The VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT structure is defined as:

typedef struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           filterMinmaxSingleComponentFormats;
    VkBool32           filterMinmaxImageComponentMapping;
} VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT;
Members
The members of the VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
filterMinmaxSingleComponentFormats is a boolean value indicating whether a minimum set of required formats support min/max filtering.
filterMinmaxImageComponentMapping is a boolean value indicating whether the implementation supports non-identity component mapping of the image when doing min/max filtering.
If the VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

If filterMinmaxSingleComponentFormats is VK_TRUE, the following formats must support the VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT feature with VK_IMAGE_TILING_OPTIMAL, if they support VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT.

VK_FORMAT_R8_UNORM
VK_FORMAT_R8_SNORM
VK_FORMAT_R16_UNORM
VK_FORMAT_R16_SNORM
VK_FORMAT_R16_SFLOAT
VK_FORMAT_R32_SFLOAT
VK_FORMAT_D16_UNORM
VK_FORMAT_X8_D24_UNORM_PACK32
VK_FORMAT_D32_SFLOAT
VK_FORMAT_D16_UNORM_S8_UINT
VK_FORMAT_D24_UNORM_S8_UINT
VK_FORMAT_D32_SFLOAT_S8_UINT
If the format is a depth/stencil format, this bit only specifies that the depth aspect (not the stencil aspect) of an image of this format supports min/max filtering, and that min/max filtering of the depth aspect is supported when depth compare is disabled in the sampler.

If filterMinmaxImageComponentMapping is VK_FALSE the component mapping of the image view used with min/max filtering must have been created with the r component set to VK_COMPONENT_SWIZZLE_IDENTITY. Only the r component of the sampled image value is defined and the other component values are undefined. If filterMinmaxImageComponentMapping is VK_TRUE this restriction does not apply and image component mapping works as normal.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceSamplerYcbcrConversionFeatures(3)
Name
VkPhysicalDeviceSamplerYcbcrConversionFeatures - Structure describing Y’CbCr conversion features that can be supported by an implementation

C Specification
The VkPhysicalDeviceSamplerYcbcrConversionFeatures structure is defined as:

typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           samplerYcbcrConversion;
} VkPhysicalDeviceSamplerYcbcrConversionFeatures;
or the equivalent

typedef VkPhysicalDeviceSamplerYcbcrConversionFeatures VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR;
Members
The members of the VkPhysicalDeviceSamplerYcbcrConversionFeatures structure describe the following feature:

Description
samplerYcbcrConversion specifies whether the implementation supports sampler Y’CBCR conversion. If samplerYcbcrConversion is VK_FALSE, sampler Y’CBCR conversion is not supported, and samplers using sampler Y’CBCR conversion must not be used.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceSamplerYcbcrConversionFeatures

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT(3)
Name
VkPhysicalDeviceScalarBlockLayoutFeaturesEXT - Structure indicating support for scalar block layouts

C Specification
The VkPhysicalDeviceScalarBlockLayoutFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceScalarBlockLayoutFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           scalarBlockLayout;
} VkPhysicalDeviceScalarBlockLayoutFeaturesEXT;
Members
The members of the VkPhysicalDeviceScalarBlockLayoutFeaturesEXT structure describe the following features:

Description
scalarBlockLayout indicates that the implementation supports the layout of resource blocks in shaders using scalar alignment.
If the VkPhysicalDeviceScalarBlockLayoutFeaturesEXT structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether the feature is supported. VkPhysicalDeviceScalarBlockLayoutFeaturesEXT can also be used in the pNext chain of VkDeviceCreateInfo to enable this feature.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceScalarBlockLayoutFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR(3)
Name
VkPhysicalDeviceShaderAtomicInt64FeaturesKHR - Structure describing features supported by VK_KHR_shader_atomic_int64

C Specification
To query 64-bit atomic support for signed and unsigned integers call vkGetPhysicalDeviceFeatures2 with a VkPhysicalDeviceShaderAtomicInt64FeaturesKHR structure included in the pNext chain of its pFeatures parameter.

The VkPhysicalDeviceShaderAtomicInt64FeaturesKHR structure is defined as:

typedef struct VkPhysicalDeviceShaderAtomicInt64FeaturesKHR {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           shaderBufferInt64Atomics;
    VkBool32           shaderSharedInt64Atomics;
} VkPhysicalDeviceShaderAtomicInt64FeaturesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
shaderBufferInt64Atomics indicates whether shaders can support 64-bit unsigned and signed integer atomic operations on buffers.
shaderSharedInt64Atomics indicates whether shaders can support 64-bit unsigned and signed integer atomic operations on shared memory.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceShaderAtomicInt64FeaturesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceShaderCorePropertiesAMD(3)
Name
VkPhysicalDeviceShaderCorePropertiesAMD - Structure describing shader core properties that can be supported by an implementation

C Specification
The VkPhysicalDeviceShaderCorePropertiesAMD structure is defined as:

typedef struct VkPhysicalDeviceShaderCorePropertiesAMD {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           shaderEngineCount;
    uint32_t           shaderArraysPerEngineCount;
    uint32_t           computeUnitsPerShaderArray;
    uint32_t           simdPerComputeUnit;
    uint32_t           wavefrontsPerSimd;
    uint32_t           wavefrontSize;
    uint32_t           sgprsPerSimd;
    uint32_t           minSgprAllocation;
    uint32_t           maxSgprAllocation;
    uint32_t           sgprAllocationGranularity;
    uint32_t           vgprsPerSimd;
    uint32_t           minVgprAllocation;
    uint32_t           maxVgprAllocation;
    uint32_t           vgprAllocationGranularity;
} VkPhysicalDeviceShaderCorePropertiesAMD;
Members
The members of the VkPhysicalDeviceShaderCorePropertiesAMD structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
shaderEngineCount is an unsigned integer value indicating the number of shader engines found inside the shader core of the physical device.
shaderArraysPerEngineCount is an unsigned integer value indicating the number of shader arrays inside a shader engine. Each shader array has its own scan converter, set of compute units, and a render back end (color and depth buffers). Shader arrays within a shader engine share shader processor input (wave launcher) and shader export (export buffer) units. Currently, a shader engine can have one or two shader arrays.
computeUnitsPerShaderArray is an unsigned integer value indicating the number of compute units within a shader array. A compute unit houses a set of SIMDs along with a sequencer module and a local data store.
simdPerComputeUnit is an unsigned integer value indicating the number of SIMDs inside a compute unit. Each SIMD processes a single instruction at a time.
wavefrontSize is an unsigned integer value indicating the number of channels (or threads) in a wavefront.
sgprsPerSimd is an unsigned integer value indicating the number of physical Scalar General Purpose Registers (SGPRs) per SIMD.
minSgprAllocation is an unsigned integer value indicating the minimum number of SGPRs allocated for a wave.
maxSgprAllocation is an unsigned integer value indicating the maximum number of SGPRs allocated for a wave.
sgprAllocationGranularity is an unsigned integer value indicating the granularity of SGPR allocation for a wave.
vgprsPerSimd is an unsigned integer value indicating the number of physical Vector General Purpose Registers (VGPRs) per SIMD.
minVgprAllocation is an unsigned integer value indicating the minimum number of VGPRs allocated for a wave.
maxVgprAllocation is an unsigned integer value indicating the maximum number of VGPRs allocated for a wave.
vgprAllocationGranularity is an unsigned integer value indicating the granularity of VGPR allocation for a wave.
If the VkPhysicalDeviceShaderCorePropertiesAMD structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceShaderCorePropertiesAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceShaderDrawParametersFeatures(3)
Name
VkPhysicalDeviceShaderDrawParametersFeatures - Structure describing shader draw parameter features that can be supported by an implementation

C Specification
The VkPhysicalDeviceShaderDrawParametersFeatures structure is defined as:

typedef struct VkPhysicalDeviceShaderDrawParametersFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           shaderDrawParameters;
} VkPhysicalDeviceShaderDrawParametersFeatures;
Members
shaderDrawParameters specifies whether shader draw parameters are supported.
Description
If the VkPhysicalDeviceShaderDrawParametersFeatures structure is included in the pNext chain of VkPhysicalDeviceFeatures2, it is filled with a value indicating whether the feature is supported.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceShaderDrawParametersFeatures

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceShaderImageFootprintFeaturesNV(3)
Name
VkPhysicalDeviceShaderImageFootprintFeaturesNV - Structure describing shader image footprint features that can be supported by an implementation

C Specification
The VkPhysicalDeviceShaderImageFootprintFeaturesNV structure is defined as:

typedef struct VkPhysicalDeviceShaderImageFootprintFeaturesNV {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           imageFootprint;
} VkPhysicalDeviceShaderImageFootprintFeaturesNV;
Members
imageFootprint specifies whether the implementation supports the ImageFootprintNV SPIR-V capability.
Description
See Texel Footprint Evaluation for more information.

If the VkPhysicalDeviceShaderImageFootprintFeaturesNV structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether each feature is supported. VkPhysicalDeviceShaderImageFootprintFeaturesNV can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceShaderImageFootprintFeaturesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceShadingRateImageFeaturesNV(3)
Name
VkPhysicalDeviceShadingRateImageFeaturesNV - Structure describing shading rate image features that can be supported by an implementation

C Specification
The VkPhysicalDeviceShadingRateImageFeaturesNV structure is defined as:

typedef struct VkPhysicalDeviceShadingRateImageFeaturesNV {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           shadingRateImage;
    VkBool32           shadingRateCoarseSampleOrder;
} VkPhysicalDeviceShadingRateImageFeaturesNV;
Members
The members of the VkPhysicalDeviceShadingRateImageFeaturesNV structure describe the following features:

Description
shadingRateImage indicates that the implementation supports the use of a shading rate image to derive an effective shading rate for fragment processing. It also indicates that the implementation supports the ShadingRateNV SPIR-V execution mode.
shadingRateCoarseSampleOrder indicates that the implementation supports a user-configurable ordering of coverage samples in fragments larger than one pixel.
See Shading Rate Image for more information.

If the VkPhysicalDeviceShadingRateImageFeaturesNV structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether the feature is supported. VkPhysicalDeviceShadingRateImageFeaturesNV can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceShadingRateImageFeaturesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceShadingRateImagePropertiesNV(3)
Name
VkPhysicalDeviceShadingRateImagePropertiesNV - Structure describing shading rate image limits that can be supported by an implementation

C Specification
The VkPhysicalDeviceShadingRateImagePropertiesNV structure is defined as:

typedef struct VkPhysicalDeviceShadingRateImagePropertiesNV {
    VkStructureType    sType;
    void*              pNext;
    VkExtent2D         shadingRateTexelSize;
    uint32_t           shadingRatePaletteSize;
    uint32_t           shadingRateMaxCoarseSamples;
} VkPhysicalDeviceShadingRateImagePropertiesNV;
Members
The members of the VkPhysicalDeviceShadingRateImagePropertiesNV structure describe the following implementation-dependent properties related to the shading rate image feature:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
shadingRateTexelSize indicates the width and height of the portion of the framebuffer corresponding to each texel in the shading rate image.
shadingRatePaletteSize indicates the maximum number of palette entries supported for the shading rate image.
shadingRateMaxCoarseSamples specifies the maximum number of coverage samples supported in a single fragment. If the product of the fragment size derived from the base shading rate and the number of coverage samples per pixel exceeds this limit, the final shading rate will be adjusted so that its product does not exceed the limit.
If the VkPhysicalDeviceShadingRateImagePropertiesNV structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV
See Also
VkExtent2D, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceShadingRateImagePropertiesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceSparseImageFormatInfo2(3)
Name
VkPhysicalDeviceSparseImageFormatInfo2 - Structure specifying sparse image format inputs

C Specification
The VkPhysicalDeviceSparseImageFormatInfo2 structure is defined as:

typedef struct VkPhysicalDeviceSparseImageFormatInfo2 {
    VkStructureType          sType;
    const void*              pNext;
    VkFormat                 format;
    VkImageType              type;
    VkSampleCountFlagBits    samples;
    VkImageUsageFlags        usage;
    VkImageTiling            tiling;
} VkPhysicalDeviceSparseImageFormatInfo2;
or the equivalent

typedef VkPhysicalDeviceSparseImageFormatInfo2 VkPhysicalDeviceSparseImageFormatInfo2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
format is the image format.
type is the dimensionality of image.
samples is the number of samples per texel as defined in VkSampleCountFlagBits.
usage is a bitmask describing the intended usage of the image.
tiling is the tiling arrangement of the texel blocks in memory.
Description
Valid Usage
samples must be a bit value that is set in VkImageFormatProperties::sampleCounts returned by vkGetPhysicalDeviceImageFormatProperties with format, type, tiling, and usage equal to those in this command and flags equal to the value that is set in VkImageCreateInfo::flags when the image is created
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2
pNext must be NULL
format must be a valid VkFormat value
type must be a valid VkImageType value
samples must be a valid VkSampleCountFlagBits value
usage must be a valid combination of VkImageUsageFlagBits values
usage must not be 0
tiling must be a valid VkImageTiling value
See Also
VkFormat, VkImageTiling, VkImageType, VkImageUsageFlags, VkSampleCountFlagBits, VkStructureType, vkGetPhysicalDeviceSparseImageFormatProperties2, vkGetPhysicalDeviceSparseImageFormatProperties2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceSparseImageFormatInfo2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceSparseProperties(3)
Name
VkPhysicalDeviceSparseProperties - Structure specifying physical device sparse memory properties

C Specification
The VkPhysicalDeviceSparseProperties structure is defined as:

typedef struct VkPhysicalDeviceSparseProperties {
    VkBool32    residencyStandard2DBlockShape;
    VkBool32    residencyStandard2DMultisampleBlockShape;
    VkBool32    residencyStandard3DBlockShape;
    VkBool32    residencyAlignedMipSize;
    VkBool32    residencyNonResidentStrict;
} VkPhysicalDeviceSparseProperties;
Members
residencyStandard2DBlockShape is VK_TRUE if the physical device will access all single-sample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the Standard Sparse Image Block Shapes (Single Sample) table. If this property is not supported the value returned in the imageGranularity member of the VkSparseImageFormatProperties structure for single-sample 2D images is not required to match the standard sparse image block dimensions listed in the table.
residencyStandard2DMultisampleBlockShape is VK_TRUE if the physical device will access all multisample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the Standard Sparse Image Block Shapes (MSAA) table. If this property is not supported, the value returned in the imageGranularity member of the VkSparseImageFormatProperties structure for multisample 2D images is not required to match the standard sparse image block dimensions listed in the table.
residencyStandard3DBlockShape is VK_TRUE if the physical device will access all 3D sparse resources using the standard sparse image block shapes (based on image format), as described in the Standard Sparse Image Block Shapes (Single Sample) table. If this property is not supported, the value returned in the imageGranularity member of the VkSparseImageFormatProperties structure for 3D images is not required to match the standard sparse image block dimensions listed in the table.
residencyAlignedMipSize is VK_TRUE if images with mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block may be placed in the mip tail. If this property is not reported, only mip levels with dimensions smaller than the imageGranularity member of the VkSparseImageFormatProperties structure will be placed in the mip tail. If this property is reported the implementation is allowed to return VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT in the flags member of VkSparseImageFormatProperties, indicating that mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block will be placed in the mip tail.
residencyNonResidentStrict specifies whether the physical device can consistently access non-resident regions of a resource. If this property is VK_TRUE, access to non-resident regions of resources will be guaranteed to return values as if the resource were populated with 0; writes to non-resident regions will be discarded.
Description
See Also
VkBool32, VkPhysicalDeviceProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceSparseProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceSubgroupProperties(3)
Name
VkPhysicalDeviceSubgroupProperties - Structure describing subgroup support for an implementation

C Specification
The VkPhysicalDeviceSubgroupProperties structure is defined as:

typedef struct VkPhysicalDeviceSubgroupProperties {
    VkStructureType           sType;
    void*                     pNext;
    uint32_t                  subgroupSize;
    VkShaderStageFlags        supportedStages;
    VkSubgroupFeatureFlags    supportedOperations;
    VkBool32                  quadOperationsInAllStages;
} VkPhysicalDeviceSubgroupProperties;
Members
The members of the VkPhysicalDeviceSubgroupProperties structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
subgroupSize is the number of invocations in each subgroup. This will match any SubgroupSize decorated variable used in any shader module created on this device. subgroupSize is at least 1 if any of the physical device’s queues support VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT.
supportedStages is a bitfield of VkShaderStageFlagBits describing the shader stages that subgroup operations are supported in. supportedStages will have the VK_SHADER_STAGE_COMPUTE_BIT bit set if any of the physical device’s queues support VK_QUEUE_COMPUTE_BIT.
supportedOperations is a bitmask of VkSubgroupFeatureFlagBits specifying the sets of subgroup operations supported on this device. supportedOperations will have the VK_SUBGROUP_FEATURE_BASIC_BIT bit set if any of the physical device’s queues support VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT.
quadOperationsInAllStages is a boolean that specifies whether quad subgroup operations are available in all stages, or are restricted to fragment and compute stages.
If the VkPhysicalDeviceSubgroupProperties structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES
See Also
VkBool32, VkShaderStageFlags, VkStructureType, VkSubgroupFeatureFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceSubgroupProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceSurfaceInfo2KHR(3)
Name
VkPhysicalDeviceSurfaceInfo2KHR - Structure specifying a surface and related swapchain creation parameters

C Specification
The VkPhysicalDeviceSurfaceInfo2KHR structure is defined as:

typedef struct VkPhysicalDeviceSurfaceInfo2KHR {
    VkStructureType    sType;
    const void*        pNext;
    VkSurfaceKHR       surface;
} VkPhysicalDeviceSurfaceInfo2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
surface is the surface that will be associated with the swapchain.
Description
The members of VkPhysicalDeviceSurfaceInfo2KHR correspond to the arguments to vkGetPhysicalDeviceSurfaceCapabilitiesKHR, with sType and pNext added for extensibility.

Additional capabilities of a surface may be available to swapchains created with different full-screen exclusive settings - particularly if exclusive full-screen access is application controlled. These additional capabilities can be queried by including the VkSurfaceFullScreenExclusiveInfoEXT structure in the pNext chain of this structure when used to query surface properties. Additionally, for Win32 surfaces with application controlled exclusive full-screen access, chaining a valid instance of the VkSurfaceFullScreenExclusiveWin32InfoEXT structure may also report additional surface capabilities. These additional capabilities only apply to swapchains created with the same parameters passed into the pNext chain of VkSwapchainCreateInfoKHR.

Valid Usage
If the pNext chain includes an instance of VkSurfaceFullScreenExclusiveInfoEXT with its fullScreenExclusive member set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, and surface was created using vkCreateWin32SurfaceKHR, an instance of VkSurfaceFullScreenExclusiveWin32InfoEXT must be present in the pNext chain
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkSurfaceFullScreenExclusiveInfoEXT or VkSurfaceFullScreenExclusiveWin32InfoEXT
Each sType member in the pNext chain must be unique
surface must be a valid VkSurfaceKHR handle
See Also
VkStructureType, VkSurfaceKHR, vkGetDeviceGroupSurfacePresentModes2EXT, vkGetPhysicalDeviceSurfaceCapabilities2KHR, vkGetPhysicalDeviceSurfaceFormats2KHR, vkGetPhysicalDeviceSurfacePresentModes2EXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceSurfaceInfo2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceTransformFeedbackFeaturesEXT(3)
Name
VkPhysicalDeviceTransformFeedbackFeaturesEXT - Structure describing transform feedback features that can be supported by an implementation

C Specification
The VkPhysicalDeviceTransformFeedbackFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           transformFeedback;
    VkBool32           geometryStreams;
} VkPhysicalDeviceTransformFeedbackFeaturesEXT;
Members
The members of the VkPhysicalDeviceTransformFeedbackFeaturesEXT structure describe the following features:

Description
transformFeedback indicates whether the implementation supports transform feedback and shader modules can declare the TransformFeedback capability.
geometryStreams indicates whether the implementation supports the GeometryStreams SPIR-V capability.
If the VkPhysicalDeviceTransformFeedbackFeaturesEXT structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether each feature is supported. VkPhysicalDeviceTransformFeedbackFeaturesEXT can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceTransformFeedbackFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceTransformFeedbackPropertiesEXT(3)
Name
VkPhysicalDeviceTransformFeedbackPropertiesEXT - Structure describing transform feedback properties that can be supported by an implementation

C Specification
The VkPhysicalDeviceTransformFeedbackPropertiesEXT structure is defined as:

typedef struct VkPhysicalDeviceTransformFeedbackPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxTransformFeedbackStreams;
    uint32_t           maxTransformFeedbackBuffers;
    VkDeviceSize       maxTransformFeedbackBufferSize;
    uint32_t           maxTransformFeedbackStreamDataSize;
    uint32_t           maxTransformFeedbackBufferDataSize;
    uint32_t           maxTransformFeedbackBufferDataStride;
    VkBool32           transformFeedbackQueries;
    VkBool32           transformFeedbackStreamsLinesTriangles;
    VkBool32           transformFeedbackRasterizationStreamSelect;
    VkBool32           transformFeedbackDraw;
} VkPhysicalDeviceTransformFeedbackPropertiesEXT;
Members
The members of the VkPhysicalDeviceTransformFeedbackPropertiesEXT structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
maxTransformFeedbackStreams is the maximum number of vertex streams that can be output from geometry shaders declared with the GeometryStreams capability. If the implementation does not support VkPhysicalDeviceTransformFeedbackFeaturesEXT::geometryStreams then maxTransformFeedbackStreams must be set to 1.
maxTransformFeedbackBuffers is the maximum number of transform feedback buffers that can be bound for capturing shader outputs from the last vertex processing stage.
maxTransformFeedbackBufferSize is the maximum size that can be specified when binding a buffer for transform feedback in vkCmdBindTransformFeedbackBuffersEXT.
maxTransformFeedbackStreamDataSize is the maximum amount of data in bytes for each vertex that captured to one or more transform feedback buffers associated with a specific vertex stream.
maxTransformFeedbackBufferDataSize is the maximum amount of data in bytes for each vertex that can be captured to a specific transform feedback buffer.
maxTransformFeedbackBufferDataStride is the maximum stride between each capture of vertex data to the buffer.
transformFeedbackQueries is true if the implementation supports the VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT query type. transformFeedbackQueries is false if queries of this type cannot be created.
transformFeedbackStreamsLinesTriangles is true if the implementation supports the geometry shader OpExecutionMode of OutputLineStrip and OutputTriangleStrip in addition to OutputPoints when more than one vertex stream is output. If transformFeedbackStreamsLinesTriangles is false the implementation only supports an OpExecutionMode of OutputPoints when more than one vertex stream is output from the geometry shader.
transformFeedbackRasterizationStreamSelect is true if the implementation supports the GeometryStreams SPIR-V capability and the application can use VkPipelineRasterizationStateStreamCreateInfoEXT to modify which vertex stream output is used for rasterization. Otherwise vertex stream 0 must always be used for rasterization.
transformFeedbackDraw is true if the implementation supports the vkCmdDrawIndirectByteCountEXT function otherwise the function must not be called.
If the VkPhysicalDeviceTransformFeedbackPropertiesEXT structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits and properties.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT
See Also
VkBool32, VkDeviceSize, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceTransformFeedbackPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceVariablePointersFeatures(3)
Name
VkPhysicalDeviceVariablePointersFeatures - Structure describing variable pointers features that can be supported by an implementation

C Specification
The VkPhysicalDeviceVariablePointersFeatures structure is defined as:

typedef struct VkPhysicalDeviceVariablePointersFeatures {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           variablePointersStorageBuffer;
    VkBool32           variablePointers;
} VkPhysicalDeviceVariablePointersFeatures;
or the equivalent

typedef VkPhysicalDeviceVariablePointersFeatures VkPhysicalDeviceVariablePointersFeaturesKHR;
Members
The members of the VkPhysicalDeviceVariablePointersFeatures structure describe the following features:

Description
variablePointersStorageBuffer specifies whether the implementation supports the SPIR-V VariablePointersStorageBuffer capability. When this feature is not enabled, shader modules must not declare the SPV_KHR_variable_pointers extension or the VariablePointersStorageBuffer capability.
variablePointers specifies whether the implementation supports the SPIR-V VariablePointers capability. When this feature is not enabled, shader modules must not declare the VariablePointers capability.
If the VkPhysicalDeviceVariablePointersFeatures structure is included in the pNext chain of VkPhysicalDeviceFeatures2, it is filled with values indicating whether each feature is supported. VkPhysicalDeviceVariablePointersFeatures can also be used in the pNext chain of VkDeviceCreateInfo to enable the features.

Valid Usage
If variablePointers is enabled then variablePointersStorageBuffer must also be enabled.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceVariablePointersFeatures

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(3)
Name
VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT - Structure describing if fetching of vertex attribute may be repeated for instanced rendering

C Specification
The VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           vertexAttributeInstanceRateDivisor;
    VkBool32           vertexAttributeInstanceRateZeroDivisor;
} VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
vertexAttributeInstanceRateDivisor specifies whether vertex attribute fetching may be repeated in case of instanced rendering.
vertexAttributeInstanceRateZeroDivisor specifies whether a zero value for VkVertexInputBindingDivisorDescriptionEXT::divisor is supported.
Description
If the VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT structure is included in the pNext chain of VkPhysicalDeviceFeatures2, it is filled with values indicating the implementation-dependent behavior. VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT can also be used in pNext chain of VkDeviceCreateInfo to enable the feature.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(3)
Name
VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT - Structure describing max value of vertex attribute divisor that can be supported by an implementation

C Specification
The VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure is defined as:

typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           maxVertexAttribDivisor;
} VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;
Members
The members of the VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure describe the following implementation-dependent limits:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
maxVertexAttribDivisor is the maximum value of the number of instances that will repeat the value of vertex attribute data when instanced rendering is enabled.
If the VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure is included in the pNext chain of VkPhysicalDeviceProperties2, it is filled with the implementation-dependent limits.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR(3)
Name
VkPhysicalDeviceVulkanMemoryModelFeaturesKHR - Structure describing features supported by VK_KHR_vulkan_memory_model

C Specification
To query memory model features additionally supported call vkGetPhysicalDeviceFeatures2 with a VkPhysicalDeviceVulkanMemoryModelFeaturesKHR structure included in the pNext chain of its pFeatures parameter. The VkPhysicalDeviceVulkanMemoryModelFeaturesKHR structure can also be in the pNext chain of a VkDeviceCreateInfo structure, in which case it controls which additional features are enabled in the device.

The VkPhysicalDeviceVulkanMemoryModelFeaturesKHR structure is defined as:

typedef struct VkPhysicalDeviceVulkanMemoryModelFeaturesKHR {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           vulkanMemoryModel;
    VkBool32           vulkanMemoryModelDeviceScope;
    VkBool32           vulkanMemoryModelAvailabilityVisibilityChains;
} VkPhysicalDeviceVulkanMemoryModelFeaturesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
vulkanMemoryModel indicates whether the Vulkan Memory Model is supported, as defined in Vulkan Memory Model. This also indicates whether shader modules can declare the VulkanMemoryModelKHR capability.
vulkanMemoryModelDeviceScope indicates whether the Vulkan Memory Model can use Device scope synchronization. This also indicates whether shader modules can declare the VulkanMemoryModelDeviceScopeKHR capability.
vulkanMemoryModelAvailabilityVisibilityChains indicates whether the Vulkan Memory Model can use availability and visibility chains with more than one element.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceVulkanMemoryModelFeaturesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(3)
Name
VkPhysicalDeviceYcbcrImageArraysFeaturesEXT - Structure describing extended Y

C Specification
The VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure is defined as:

typedef struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           ycbcrImageArrays;
} VkPhysicalDeviceYcbcrImageArraysFeaturesEXT;
Members
The members of the VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure describe the following features:

Description
ycbcrImageArrays indicates that the implementation supports creating images with a format that requires Y’CBCR conversion and has multiple array layers.
If the VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure is included in the pNext chain of VkPhysicalDeviceFeatures2KHR, it is filled with values indicating whether the feature is supported. VkPhysicalDeviceYcbcrImageArraysFeaturesEXT can also be used in the pNext chain of VkDeviceCreateInfo to enable features.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceYcbcrImageArraysFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCacheCreateInfo(3)
Name
VkPipelineCacheCreateInfo - Structure specifying parameters of a newly created pipeline cache

C Specification
The VkPipelineCacheCreateInfo structure is defined as:

typedef struct VkPipelineCacheCreateInfo {
    VkStructureType               sType;
    const void*                   pNext;
    VkPipelineCacheCreateFlags    flags;
    size_t                        initialDataSize;
    const void*                   pInitialData;
} VkPipelineCacheCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
initialDataSize is the number of bytes in pInitialData. If initialDataSize is zero, the pipeline cache will initially be empty.
pInitialData is a pointer to previously retrieved pipeline cache data. If the pipeline cache data is incompatible (as defined below) with the device, the pipeline cache will be initially empty. If initialDataSize is zero, pInitialData is ignored.
Description
Valid Usage
If initialDataSize is not 0, it must be equal to the size of pInitialData, as returned by vkGetPipelineCacheData when pInitialData was originally retrieved
If initialDataSize is not 0, pInitialData must have been retrieved from a previous call to vkGetPipelineCacheData
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO
pNext must be NULL
flags must be 0
If initialDataSize is not 0, pInitialData must be a valid pointer to an array of initialDataSize bytes
See Also
VkPipelineCacheCreateFlags, VkStructureType, vkCreatePipelineCache

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCacheCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineColorBlendAdvancedStateCreateInfoEXT(3)
Name
VkPipelineColorBlendAdvancedStateCreateInfoEXT - Structure specifying parameters that affect advanced blend operations

C Specification
If the pNext chain of VkPipelineColorBlendStateCreateInfo includes a VkPipelineColorBlendAdvancedStateCreateInfoEXT structure, then that structure includes parameters that affect advanced blend operations.

The VkPipelineColorBlendAdvancedStateCreateInfoEXT structure is defined as:

typedef struct VkPipelineColorBlendAdvancedStateCreateInfoEXT {
    VkStructureType      sType;
    const void*          pNext;
    VkBool32             srcPremultiplied;
    VkBool32             dstPremultiplied;
    VkBlendOverlapEXT    blendOverlap;
} VkPipelineColorBlendAdvancedStateCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
srcPremultiplied specifies whether the source color of the blend operation is treated as premultiplied.
dstPremultiplied specifies whether the destination color of the blend operation is treated as premultiplied.
blendOverlap is a VkBlendOverlapEXT value specifying how the source and destination sample’s coverage is correlated.
Description
If this structure is not present, srcPremultiplied and dstPremultiplied are both considered to be VK_TRUE, and blendOverlap is considered to be VK_BLEND_OVERLAP_UNCORRELATED_EXT.

Valid Usage
If the non-premultiplied source color property is not supported, srcPremultiplied must be VK_TRUE
If the non-premultiplied destination color property is not supported, dstPremultiplied must be VK_TRUE
If the correlated overlap property is not supported, blendOverlap must be VK_BLEND_OVERLAP_UNCORRELATED_EXT
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT
blendOverlap must be a valid VkBlendOverlapEXT value
See Also
VkBlendOverlapEXT, VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineColorBlendAdvancedStateCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineColorBlendAttachmentState(3)
Name
VkPipelineColorBlendAttachmentState - Structure specifying a pipeline color blend attachment state

C Specification
The VkPipelineColorBlendAttachmentState structure is defined as:

typedef struct VkPipelineColorBlendAttachmentState {
    VkBool32                 blendEnable;
    VkBlendFactor            srcColorBlendFactor;
    VkBlendFactor            dstColorBlendFactor;
    VkBlendOp                colorBlendOp;
    VkBlendFactor            srcAlphaBlendFactor;
    VkBlendFactor            dstAlphaBlendFactor;
    VkBlendOp                alphaBlendOp;
    VkColorComponentFlags    colorWriteMask;
} VkPipelineColorBlendAttachmentState;
Members
blendEnable controls whether blending is enabled for the corresponding color attachment. If blending is not enabled, the source fragment’s color for that attachment is passed through unmodified.
srcColorBlendFactor selects which blend factor is used to determine the source factors (Sr,Sg,Sb).
dstColorBlendFactor selects which blend factor is used to determine the destination factors (Dr,Dg,Db).
colorBlendOp selects which blend operation is used to calculate the RGB values to write to the color attachment.
srcAlphaBlendFactor selects which blend factor is used to determine the source factor Sa.
dstAlphaBlendFactor selects which blend factor is used to determine the destination factor Da.
alphaBlendOp selects which blend operation is use to calculate the alpha values to write to the color attachment.
colorWriteMask is a bitmask of VkColorComponentFlagBits specifying which of the R, G, B, and/or A components are enabled for writing, as described for the Color Write Mask.
Description
Valid Usage
If the dual source blending feature is not enabled, srcColorBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA
If the dual source blending feature is not enabled, dstColorBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA
If the dual source blending feature is not enabled, srcAlphaBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA
If the dual source blending feature is not enabled, dstAlphaBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA
If either of colorBlendOp or alphaBlendOp is an advanced blend operation, then colorBlendOp must equal alphaBlendOp
If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendIndependentBlend is VK_FALSE and colorBlendOp is an advanced blend operation, then colorBlendOp must be the same for all attachments.
If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendIndependentBlend is VK_FALSE and alphaBlendOp is an advanced blend operation, then alphaBlendOp must be the same for all attachments.
If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendAllOperations is VK_FALSE, then colorBlendOp must not be VK_BLEND_OP_ZERO_EXT, VK_BLEND_OP_SRC_EXT, VK_BLEND_OP_DST_EXT, VK_BLEND_OP_SRC_OVER_EXT, VK_BLEND_OP_DST_OVER_EXT, VK_BLEND_OP_SRC_IN_EXT, VK_BLEND_OP_DST_IN_EXT, VK_BLEND_OP_SRC_OUT_EXT, VK_BLEND_OP_DST_OUT_EXT, VK_BLEND_OP_SRC_ATOP_EXT, VK_BLEND_OP_DST_ATOP_EXT, VK_BLEND_OP_XOR_EXT, VK_BLEND_OP_INVERT_EXT, VK_BLEND_OP_INVERT_RGB_EXT, VK_BLEND_OP_LINEARDODGE_EXT, VK_BLEND_OP_LINEARBURN_EXT, VK_BLEND_OP_VIVIDLIGHT_EXT, VK_BLEND_OP_LINEARLIGHT_EXT, VK_BLEND_OP_PINLIGHT_EXT, VK_BLEND_OP_HARDMIX_EXT, VK_BLEND_OP_PLUS_EXT, VK_BLEND_OP_PLUS_CLAMPED_EXT, VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT, VK_BLEND_OP_PLUS_DARKER_EXT, VK_BLEND_OP_MINUS_EXT, VK_BLEND_OP_MINUS_CLAMPED_EXT, VK_BLEND_OP_CONTRAST_EXT, VK_BLEND_OP_INVERT_OVG_EXT, VK_BLEND_OP_RED_EXT, VK_BLEND_OP_GREEN_EXT, or VK_BLEND_OP_BLUE_EXT
If colorBlendOp or alphaBlendOp is an advanced blend operation, then VkSubpassDescription::colorAttachmentCount of the subpass this pipeline is compiled against must be less than or equal to VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendMaxColorAttachments
Valid Usage (Implicit)
srcColorBlendFactor must be a valid VkBlendFactor value
dstColorBlendFactor must be a valid VkBlendFactor value
colorBlendOp must be a valid VkBlendOp value
srcAlphaBlendFactor must be a valid VkBlendFactor value
dstAlphaBlendFactor must be a valid VkBlendFactor value
alphaBlendOp must be a valid VkBlendOp value
colorWriteMask must be a valid combination of VkColorComponentFlagBits values
See Also
VkBlendFactor, VkBlendOp, VkBool32, VkColorComponentFlags, VkPipelineColorBlendStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineColorBlendAttachmentState

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineColorBlendStateCreateInfo(3)
Name
VkPipelineColorBlendStateCreateInfo - Structure specifying parameters of a newly created pipeline color blend state

C Specification
The VkPipelineColorBlendStateCreateInfo structure is defined as:

typedef struct VkPipelineColorBlendStateCreateInfo {
    VkStructureType                               sType;
    const void*                                   pNext;
    VkPipelineColorBlendStateCreateFlags          flags;
    VkBool32                                      logicOpEnable;
    VkLogicOp                                     logicOp;
    uint32_t                                      attachmentCount;
    const VkPipelineColorBlendAttachmentState*    pAttachments;
    float                                         blendConstants[4];
} VkPipelineColorBlendStateCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
logicOpEnable controls whether to apply Logical Operations.
logicOp selects which logical operation to apply.
attachmentCount is the number of VkPipelineColorBlendAttachmentState elements in pAttachments. This value must equal the colorAttachmentCount for the subpass in which this pipeline is used.
pAttachments: is a pointer to array of per target attachment states.
blendConstants is an array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the blend factor.
Description
Each element of the pAttachments array is a VkPipelineColorBlendAttachmentState structure specifying per-target blending state for each individual color attachment. If the independent blending feature is not enabled on the device, all VkPipelineColorBlendAttachmentState elements in the pAttachments array must be identical.

Valid Usage
If the independent blending feature is not enabled, all elements of pAttachments must be identical
If the logic operations feature is not enabled, logicOpEnable must be VK_FALSE
If logicOpEnable is VK_TRUE, logicOp must be a valid VkLogicOp value
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
pNext must be NULL or a pointer to a valid instance of VkPipelineColorBlendAdvancedStateCreateInfoEXT
flags must be 0
If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkPipelineColorBlendAttachmentState structures
See Also
VkBool32, VkGraphicsPipelineCreateInfo, VkLogicOp, VkPipelineColorBlendAttachmentState, VkPipelineColorBlendStateCreateFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineColorBlendStateCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCoverageModulationStateCreateInfoNV(3)
Name
VkPipelineCoverageModulationStateCreateInfoNV - Structure specifying parameters controlling coverage modulation

C Specification
As part of coverage reduction, fragment color values can also be modulated (multiplied) by a value that is a function of fraction of covered rasterization samples associated with that color sample.

Pipeline state controlling coverage reduction is specified through the members of the VkPipelineCoverageModulationStateCreateInfoNV structure.

The VkPipelineCoverageModulationStateCreateInfoNV structure is defined as:

typedef struct VkPipelineCoverageModulationStateCreateInfoNV {
    VkStructureType                                   sType;
    const void*                                       pNext;
    VkPipelineCoverageModulationStateCreateFlagsNV    flags;
    VkCoverageModulationModeNV                        coverageModulationMode;
    VkBool32                                          coverageModulationTableEnable;
    uint32_t                                          coverageModulationTableCount;
    const float*                                      pCoverageModulationTable;
} VkPipelineCoverageModulationStateCreateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
coverageModulationMode controls which color components are modulated and is of type VkCoverageModulationModeNV.
coverageModulationTableEnable controls whether the modulation factor is looked up from a table in pCoverageModulationTable.
coverageModulationTableCount is the number of elements in pCoverageModulationTable.
pCoverageModulationTable is a table of modulation factors containing a value for each number of covered samples.
Description
If coverageModulationTableEnable is VK_FALSE, then for each color sample the associated bits of the fragment’s coverage are counted and divided by the number of associated bits to produce a modulation factor R in the range (0,1] (a value of zero would have been killed due to a color coverage of 0). Specifically:

N = value of rasterizationSamples
M = value of VkAttachmentDescription::samples for any color attachments
R = popcount(associated coverage bits) / (N / M)
If coverageModulationTableEnable is VK_TRUE, the value R is computed using a programmable lookup table. The lookup table has N / M elements, and the element of the table is selected by:

R = pCoverageModulationTable[popcount(associated coverage bits)-1]
Note that the table does not have an entry for popcount(associated coverage bits) = 0, because such samples would have been killed.

The values of pCoverageModulationTable may be rounded to an implementation-dependent precision, which is at least as fine as 1 / N, and clamped to [0,1].

For each color attachment with a floating point or normalized color format, each fragment output color value is replicated to M values which can each be modulated (multiplied) by that color sample’s associated value of R. Which components are modulated is controlled by coverageModulationMode.

If this structure is not present, it is as if coverageModulationMode is VK_COVERAGE_MODULATION_MODE_NONE_NV.

Valid Usage
If coverageModulationTableEnable is VK_TRUE, coverageModulationTableCount must be equal to the number of rasterization samples divided by the number of color samples in the subpass.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV
flags must be 0
coverageModulationMode must be a valid VkCoverageModulationModeNV value
See Also
VkBool32, VkCoverageModulationModeNV, VkPipelineCoverageModulationStateCreateFlagsNV, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCoverageModulationStateCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCoverageToColorStateCreateInfoNV(3)
Name
VkPipelineCoverageToColorStateCreateInfoNV - Structure specifying whether fragment coverage replaces a color

C Specification
If the pNext chain of VkPipelineMultisampleStateCreateInfo includes a VkPipelineCoverageToColorStateCreateInfoNV structure, then that structure controls whether the fragment coverage is substituted for a fragment color output and, if so, which output is replaced.

The VkPipelineCoverageToColorStateCreateInfoNV structure is defined as:

typedef struct VkPipelineCoverageToColorStateCreateInfoNV {
    VkStructureType                                sType;
    const void*                                    pNext;
    VkPipelineCoverageToColorStateCreateFlagsNV    flags;
    VkBool32                                       coverageToColorEnable;
    uint32_t                                       coverageToColorLocation;
} VkPipelineCoverageToColorStateCreateInfoNV;
Members
sType is the type of this structure
pNext is NULL or a pointer to an extension-specific structure
flags is reserved for future use.
coverageToColorEnable controls whether the fragment coverage value replaces a fragment color output.
coverageToColorLocation controls which fragment shader color output value is replaced.
Description
If coverageToColorEnable is VK_TRUE, the fragment coverage information is treated as a bitmask with one bit for each sample (as in the Sample Mask section), and this bitmask replaces the first component of the color value corresponding to the fragment shader output location with Location equal to coverageToColorLocation and Index equal to zero. If the color attachment format has fewer bits than the sample coverage, the low bits of the sample coverage bitmask are taken without any clamping. If the color attachment format has more bits than the sample coverage, the high bits of the sample coverage bitmask are filled with zeros.

If Sample Shading is in use, the coverage bitmask only has bits set for samples that correspond to the fragment shader invocation that shades those samples.

This pipeline stage occurs after sample counting and before blending, and is always performed after fragment shading regardless of the setting of EarlyFragmentTests.

If coverageToColorEnable is VK_FALSE, these operations are skipped. If this structure is not present, it is as if coverageToColorEnable is VK_FALSE.

Valid Usage
If coverageToColorEnable is VK_TRUE, then the render pass subpass indicated by VkGraphicsPipelineCreateInfo::renderPass and VkGraphicsPipelineCreateInfo::subpass must have a color attachment at the location selected by coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV
flags must be 0
See Also
VkBool32, VkPipelineCoverageToColorStateCreateFlagsNV, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCoverageToColorStateCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCreationFeedbackCreateInfoEXT(3)
Name
VkPipelineCreationFeedbackCreateInfoEXT - Request for feedback about the creation of a pipeline

C Specification
Feedback about the creation of a particular pipeline object can be obtained by including a VkPipelineCreationFeedbackCreateInfoEXT structure in the pNext chain of VkGraphicsPipelineCreateInfo, VkRayTracingPipelineCreateInfoNV, or VkComputePipelineCreateInfo. The VkPipelineCreationFeedbackCreateInfoEXT structure is defined as:

typedef struct VkPipelineCreationFeedbackCreateInfoEXT {
    VkStructureType                   sType;
    const void*                       pNext;
    VkPipelineCreationFeedbackEXT*    pPipelineCreationFeedback;
    uint32_t                          pipelineStageCreationFeedbackCount;
    VkPipelineCreationFeedbackEXT*    pPipelineStageCreationFeedbacks;
} VkPipelineCreationFeedbackCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
pPipelineCreationFeedback is a pointer to a VkPipelineCreationFeedbackEXT structure.
pipelineStageCreationFeedbackCount is the number of elements in pPipelineStageCreationFeedbacks.
pPipelineStageCreationFeedbacks is an array of size pipelineStageCreationFeedbackCount of VkPipelineCreationFeedbackEXT structures.
Description
An implementation should write pipeline creation feedback to pPipelineCreationFeedback and may write pipeline stage creation feedback to pPipelineStageCreationFeedbacks. An implementation must set or clear the VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT in VkPipelineCreationFeedbackEXT::flags for pPipelineCreationFeedback and every element of pPipelineStageCreationFeedbacks.

Note
One common scenario for an implementation to skip per-stage feedback is when VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT is set in pPipelineCreationFeedback.
When chained to VkRayTracingPipelineCreateInfoNV or VkGraphicsPipelineCreateInfo, the i element of pPipelineStageCreationFeedbacks corresponds to the i element of VkRayTracingPipelineCreateInfoNV::pStages or VkGraphicsPipelineCreateInfo::pStages. When chained to VkComputePipelineCreateInfo, the first element of pPipelineStageCreationFeedbacks corresponds to VkComputePipelineCreateInfo::stage.

Valid Usage
When chained to VkGraphicsPipelineCreateInfo, VkPipelineCreationFeedbackEXT::pipelineStageCreationFeedbackCount must equal VkGraphicsPipelineCreateInfo::stageCount
When chained to VkComputePipelineCreateInfo, VkPipelineCreationFeedbackEXT::pipelineStageCreationFeedbackCount must equal 1
When chained to VkRayTracingPipelineCreateInfoNV, VkPipelineCreationFeedbackEXT::pipelineStageCreationFeedbackCount must equal VkRayTracingPipelineCreateInfoNV::stageCount
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT
pPipelineCreationFeedback must be a valid pointer to a VkPipelineCreationFeedbackEXT structure
pPipelineStageCreationFeedbacks must be a valid pointer to an array of pipelineStageCreationFeedbackCount VkPipelineCreationFeedbackEXT structures
pipelineStageCreationFeedbackCount must be greater than 0
See Also
VkComputePipelineCreateInfo, VkGraphicsPipelineCreateInfo, VkPipelineCreationFeedbackEXT, VkRayTracingPipelineCreateInfoNV, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCreationFeedbackCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCreationFeedbackEXT(3)
Name
VkPipelineCreationFeedbackEXT - Feedback about the creation of a pipeline or pipeline stage

C Specification
The VkPipelineCreationFeedbackEXT structure is defined as:

typedef struct VkPipelineCreationFeedbackEXT {
    VkPipelineCreationFeedbackFlagsEXT    flags;
    uint64_t                              duration;
} VkPipelineCreationFeedbackEXT;
Members
flags is a bitmask of VkPipelineCreationFeedbackFlagBitsEXT providing feedback about the creation of a pipeline or of a pipeline stage.
duration is the duration spent creating a pipeline or pipeline stage in nanoseconds.
Description
If the VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT is not set in flags, an implementation must not set any other bits in flags, and all other VkPipelineCreationFeedbackEXT data members are undefined.

See Also
VkPipelineCreationFeedbackCreateInfoEXT, VkPipelineCreationFeedbackFlagBitsEXT, VkPipelineCreationFeedbackFlagsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCreationFeedbackEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineDepthStencilStateCreateInfo(3)
Name
VkPipelineDepthStencilStateCreateInfo - Structure specifying parameters of a newly created pipeline depth stencil state

C Specification
The VkPipelineDepthStencilStateCreateInfo structure is defined as:

typedef struct VkPipelineDepthStencilStateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkPipelineDepthStencilStateCreateFlags    flags;
    VkBool32                                  depthTestEnable;
    VkBool32                                  depthWriteEnable;
    VkCompareOp                               depthCompareOp;
    VkBool32                                  depthBoundsTestEnable;
    VkBool32                                  stencilTestEnable;
    VkStencilOpState                          front;
    VkStencilOpState                          back;
    float                                     minDepthBounds;
    float                                     maxDepthBounds;
} VkPipelineDepthStencilStateCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
depthTestEnable controls whether depth testing is enabled.
depthWriteEnable controls whether depth writes are enabled when depthTestEnable is VK_TRUE. Depth writes are always disabled when depthTestEnable is VK_FALSE.
depthCompareOp is the comparison operator used in the depth test.
depthBoundsTestEnable controls whether depth bounds testing is enabled.
stencilTestEnable controls whether stencil testing is enabled.
front and back control the parameters of the stencil test.
minDepthBounds and maxDepthBounds define the range of values used in the depth bounds test.
Description
Valid Usage
If the depth bounds testing feature is not enabled, depthBoundsTestEnable must be VK_FALSE
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO
pNext must be NULL
flags must be 0
depthCompareOp must be a valid VkCompareOp value
front must be a valid VkStencilOpState structure
back must be a valid VkStencilOpState structure
See Also
VkBool32, VkCompareOp, VkGraphicsPipelineCreateInfo, VkPipelineDepthStencilStateCreateFlags, VkStencilOpState, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineDepthStencilStateCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineDiscardRectangleStateCreateInfoEXT(3)
Name
VkPipelineDiscardRectangleStateCreateInfoEXT - Structure specifying discard rectangle

C Specification
The discard rectangles test determines if fragment’s framebuffer coordinates (xf,yf) are inclusive or exclusive to a set of discard-space rectangles. The discard rectangles are set with the VkPipelineDiscardRectangleStateCreateInfoEXT pipeline state, which is defined as:

typedef struct VkPipelineDiscardRectangleStateCreateInfoEXT {
    VkStructureType                                  sType;
    const void*                                      pNext;
    VkPipelineDiscardRectangleStateCreateFlagsEXT    flags;
    VkDiscardRectangleModeEXT                        discardRectangleMode;
    uint32_t                                         discardRectangleCount;
    const VkRect2D*                                  pDiscardRectangles;
} VkPipelineDiscardRectangleStateCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
discardRectangleMode is the mode used to determine whether fragments that lie within the discard rectangle are discarded or not.
discardRectangleCount is the number of discard rectangles used by the pipeline.
pDiscardRectangles is a pointer to an array of VkRect2D structures, defining the discard rectangles. If the discard rectangle state is dynamic, this member is ignored.
Description
Valid Usage
discardRectangleCount must be between 0 and VkPhysicalDeviceDiscardRectanglePropertiesEXT::maxDiscardRectangles, inclusive
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT
flags must be 0
discardRectangleMode must be a valid VkDiscardRectangleModeEXT value
See Also
VkDiscardRectangleModeEXT, VkPipelineDiscardRectangleStateCreateFlagsEXT, VkRect2D, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineDiscardRectangleStateCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineDynamicStateCreateInfo(3)
Name
VkPipelineDynamicStateCreateInfo - Structure specifying parameters of a newly created pipeline dynamic state

C Specification
The VkPipelineDynamicStateCreateInfo structure is defined as:

typedef struct VkPipelineDynamicStateCreateInfo {
    VkStructureType                      sType;
    const void*                          pNext;
    VkPipelineDynamicStateCreateFlags    flags;
    uint32_t                             dynamicStateCount;
    const VkDynamicState*                pDynamicStates;
} VkPipelineDynamicStateCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
dynamicStateCount is the number of elements in the pDynamicStates array.
pDynamicStates is an array of VkDynamicState values specifying which pieces of pipeline state will use the values from dynamic state commands rather than from pipeline state creation info.
Description
Valid Usage
Each element of pDynamicStates must be unique
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
pNext must be NULL
flags must be 0
If dynamicStateCount is not 0, pDynamicStates must be a valid pointer to an array of dynamicStateCount valid VkDynamicState values
See Also
VkDynamicState, VkGraphicsPipelineCreateInfo, VkPipelineDynamicStateCreateFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineDynamicStateCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineInputAssemblyStateCreateInfo(3)
Name
VkPipelineInputAssemblyStateCreateInfo - Structure specifying parameters of a newly created pipeline input assembly state

C Specification
Drawing can be achieved in two modes:

Programmable Mesh Shading, the mesh shader assembles primitives, or
Programmable Primitive Shading, the input primitives are assembled
as follows.

Each draw is made up of zero or more vertices and zero or more instances, which are processed by the device and result in the assembly of primitives. Primitives are assembled according to the pInputAssemblyState member of the VkGraphicsPipelineCreateInfo structure, which is of type VkPipelineInputAssemblyStateCreateInfo:

typedef struct VkPipelineInputAssemblyStateCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineInputAssemblyStateCreateFlags    flags;
    VkPrimitiveTopology                        topology;
    VkBool32                                   primitiveRestartEnable;
} VkPipelineInputAssemblyStateCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
topology is a VkPrimitiveTopology defining the primitive topology, as described below.
primitiveRestartEnable controls whether a special vertex index value is treated as restarting the assembly of primitives. This enable only applies to indexed draws (vkCmdDrawIndexed and vkCmdDrawIndexedIndirect), and the special index value is either 0xFFFFFFFF when the indexType parameter of vkCmdBindIndexBuffer is equal to VK_INDEX_TYPE_UINT32, or 0xFFFF when indexType is equal to VK_INDEX_TYPE_UINT16. Primitive restart is not allowed for “list” topologies.
Description
Restarting the assembly of primitives discards the most recent index values if those elements formed an incomplete primitive, and restarts the primitive assembly using the subsequent indices, but only assembling the immediately following element through the end of the originally specified elements. The primitive restart index value comparison is performed before adding the vertexOffset value to the index value.

Valid Usage
If topology is VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, primitiveRestartEnable must be VK_FALSE
If the geometry shaders feature is not enabled, topology must not be any of VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY
If the tessellation shaders feature is not enabled, topology must not be VK_PRIMITIVE_TOPOLOGY_PATCH_LIST
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
pNext must be NULL
flags must be 0
topology must be a valid VkPrimitiveTopology value
See Also
VkBool32, VkGraphicsPipelineCreateInfo, VkPipelineInputAssemblyStateCreateFlags, VkPrimitiveTopology, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineInputAssemblyStateCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineLayoutCreateInfo(3)
Name
VkPipelineLayoutCreateInfo - Structure specifying the parameters of a newly created pipeline layout object

C Specification
The VkPipelineLayoutCreateInfo structure is defined as:

typedef struct VkPipelineLayoutCreateInfo {
    VkStructureType                 sType;
    const void*                     pNext;
    VkPipelineLayoutCreateFlags     flags;
    uint32_t                        setLayoutCount;
    const VkDescriptorSetLayout*    pSetLayouts;
    uint32_t                        pushConstantRangeCount;
    const VkPushConstantRange*      pPushConstantRanges;
} VkPipelineLayoutCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
setLayoutCount is the number of descriptor sets included in the pipeline layout.
pSetLayouts is a pointer to an array of VkDescriptorSetLayout objects.
pushConstantRangeCount is the number of push constant ranges included in the pipeline layout.
pPushConstantRanges is a pointer to an array of VkPushConstantRange structures defining a set of push constant ranges for use in a single pipeline layout. In addition to descriptor set layouts, a pipeline layout also describes how many push constants can be accessed by each stage of the pipeline.
Note
Push constants represent a high speed path to modify constant data in pipelines that is expected to outperform memory-backed resource updates.
Description
Valid Usage
setLayoutCount must be less than or equal to VkPhysicalDeviceLimits::maxBoundDescriptorSets
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSamplers
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorUniformBuffers
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageBuffers
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSampledImages
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageImages
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorInputAttachments
The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxPerStageDescriptorInlineUniformBlocks
The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindSamplers
The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindUniformBuffers
The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindStorageBuffers
The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindSampledImages
The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindStorageImages
The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxPerStageDescriptorUpdateAfterBindInputAttachments
The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSamplers
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffers
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffersDynamic
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffers
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffersDynamic
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSampledImages
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageImages
The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetInputAttachments
The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxDescriptorSetInlineUniformBlocks
The total number of descriptors of the type VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindSamplers
The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindUniformBuffers
The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindUniformBuffersDynamic
The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindStorageBuffers
The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindStorageBuffersDynamic
The total number of descriptors of the type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindSampledImages
The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindStorageImages
The total number of descriptors of the type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingPropertiesEXT::maxDescriptorSetUpdateAfterBindInputAttachments
The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockPropertiesEXT::maxDescriptorSetUpdateAfterBindInlineUniformBlocks
Any two elements of pPushConstantRanges must not include the same stage in stageFlags
pSetLayouts must not contain more than one descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set
The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxDescriptorSetAccelerationStructures
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
pNext must be NULL
flags must be 0
If setLayoutCount is not 0, pSetLayouts must be a valid pointer to an array of setLayoutCount valid VkDescriptorSetLayout handles
If pushConstantRangeCount is not 0, pPushConstantRanges must be a valid pointer to an array of pushConstantRangeCount valid VkPushConstantRange structures
See Also
VkDescriptorSetLayout, VkPipelineLayoutCreateFlags, VkPushConstantRange, VkStructureType, vkCreatePipelineLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineLayoutCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineMultisampleStateCreateInfo(3)
Name
VkPipelineMultisampleStateCreateInfo - Structure specifying parameters of a newly created pipeline multisample state

C Specification
The VkPipelineMultisampleStateCreateInfo structure is defined as:

typedef struct VkPipelineMultisampleStateCreateInfo {
    VkStructureType                          sType;
    const void*                              pNext;
    VkPipelineMultisampleStateCreateFlags    flags;
    VkSampleCountFlagBits                    rasterizationSamples;
    VkBool32                                 sampleShadingEnable;
    float                                    minSampleShading;
    const VkSampleMask*                      pSampleMask;
    VkBool32                                 alphaToCoverageEnable;
    VkBool32                                 alphaToOneEnable;
} VkPipelineMultisampleStateCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
rasterizationSamples is a VkSampleCountFlagBits specifying the number of samples used in rasterization.
sampleShadingEnable can be used to enable Sample Shading.
minSampleShading specifies a minimum fraction of sample shading if sampleShadingEnable is set to VK_TRUE.
pSampleMask is a bitmask of static coverage information that is ANDed with the coverage information generated during rasterization, as described in Sample Mask.
alphaToCoverageEnable controls whether a temporary coverage value is generated based on the alpha component of the fragment’s first color output as specified in the Multisample Coverage section.
alphaToOneEnable controls whether the alpha component of the fragment’s first color output is replaced with one as described in Multisample Coverage.
Description
Valid Usage
If the sample rate shading feature is not enabled, sampleShadingEnable must be VK_FALSE
If the alpha to one feature is not enabled, alphaToOneEnable must be VK_FALSE
minSampleShading must be in the range [0,1]
If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the subpass has any color attachments and rasterizationSamples is greater than the number of color samples, then sampleShadingEnable must be VK_FALSE
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineCoverageModulationStateCreateInfoNV, VkPipelineCoverageToColorStateCreateInfoNV, or VkPipelineSampleLocationsStateCreateInfoEXT
Each sType member in the pNext chain must be unique
flags must be 0
rasterizationSamples must be a valid VkSampleCountFlagBits value
If pSampleMask is not NULL, pSampleMask must be a valid pointer to an array of \(\lceil{\mathit{rasterizationSamples} \over 32}\rceil\) VkSampleMask values
See Also
VkBool32, VkGraphicsPipelineCreateInfo, VkPipelineMultisampleStateCreateFlags, VkSampleCountFlagBits, VkSampleMask, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineMultisampleStateCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineRasterizationConservativeStateCreateInfoEXT(3)
Name
VkPipelineRasterizationConservativeStateCreateInfoEXT - Structure specifying conservative raster state

C Specification
Polygon rasterization can be made conservative by setting conservativeRasterizationMode to VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT or VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT in VkPipelineRasterizationConservativeStateCreateInfoEXT. The VkPipelineRasterizationConservativeStateCreateInfoEXT state is set by adding an instance of this structure to the pNext chain of an instance of the VkPipelineRasterizationStateCreateInfo structure when creating the graphics pipeline. Enabling these modes also affects line and point rasterization if the implementation sets VkPhysicalDeviceConservativeRasterizationPropertiesEXT::conservativePointAndLineRasterization to VK_TRUE.

VkPipelineRasterizationConservativeStateCreateInfoEXT is defined as:

typedef struct VkPipelineRasterizationConservativeStateCreateInfoEXT {
    VkStructureType                                           sType;
    const void*                                               pNext;
    VkPipelineRasterizationConservativeStateCreateFlagsEXT    flags;
    VkConservativeRasterizationModeEXT                        conservativeRasterizationMode;
    float                                                     extraPrimitiveOverestimationSize;
} VkPipelineRasterizationConservativeStateCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
conservativeRasterizationMode is the conservative rasterization mode to use.
extraPrimitiveOverestimationSize is the extra size in pixels to increase the generating primitive during conservative rasterization at each of its edges in X and Y equally in screen space beyond the base overestimation specified in VkPhysicalDeviceConservativeRasterizationPropertiesEXT::primitiveOverestimationSize.
Description
Valid Usage
extraPrimitiveOverestimationSize must be in the range of 0.0 to VkPhysicalDeviceConservativeRasterizationPropertiesEXT::maxExtraPrimitiveOverestimationSize inclusive
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT
flags must be 0
conservativeRasterizationMode must be a valid VkConservativeRasterizationModeEXT value
See Also
VkConservativeRasterizationModeEXT, VkPipelineRasterizationConservativeStateCreateFlagsEXT, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineRasterizationConservativeStateCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineRasterizationDepthClipStateCreateInfoEXT(3)
Name
VkPipelineRasterizationDepthClipStateCreateInfoEXT - Structure specifying depth clipping state

C Specification
If the pNext chain of VkPipelineRasterizationStateCreateInfo includes a VkPipelineRasterizationDepthClipStateCreateInfoEXT structure, then that structure controls whether depth clipping is enabled or disabled.

The VkPipelineRasterizationDepthClipStateCreateInfoEXT structure is defined as:

typedef struct VkPipelineRasterizationDepthClipStateCreateInfoEXT {
    VkStructureType                                        sType;
    const void*                                            pNext;
    VkPipelineRasterizationDepthClipStateCreateFlagsEXT    flags;
    VkBool32                                               depthClipEnable;
} VkPipelineRasterizationDepthClipStateCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
depthClipEnable controls whether depth clipping is enabled as described in Primitive Clipping.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT
flags must be 0
See Also
VkBool32, VkPipelineRasterizationDepthClipStateCreateFlagsEXT, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineRasterizationDepthClipStateCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineRasterizationStateCreateInfo(3)
Name
VkPipelineRasterizationStateCreateInfo - Structure specifying parameters of a newly created pipeline rasterization state

C Specification
The VkPipelineRasterizationStateCreateInfo structure is defined as:

typedef struct VkPipelineRasterizationStateCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    VkPipelineRasterizationStateCreateFlags    flags;
    VkBool32                                   depthClampEnable;
    VkBool32                                   rasterizerDiscardEnable;
    VkPolygonMode                              polygonMode;
    VkCullModeFlags                            cullMode;
    VkFrontFace                                frontFace;
    VkBool32                                   depthBiasEnable;
    float                                      depthBiasConstantFactor;
    float                                      depthBiasClamp;
    float                                      depthBiasSlopeFactor;
    float                                      lineWidth;
} VkPipelineRasterizationStateCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
depthClampEnable controls whether to clamp the fragment’s depth values as described in Depth Test. If the pipeline is not created with VkPipelineRasterizationDepthClipStateCreateInfoEXT present then enabling depth clamp will also disable clipping primitives to the z planes of the frustrum as described in Primitive Clipping. Otherwise depth clipping is controlled by the state set in VkPipelineRasterizationDepthClipStateCreateInfoEXT.
rasterizerDiscardEnable controls whether primitives are discarded immediately before the rasterization stage.
polygonMode is the triangle rendering mode. See VkPolygonMode.
cullMode is the triangle facing direction used for primitive culling. See VkCullModeFlagBits.
frontFace is a VkFrontFace value specifying the front-facing triangle orientation to be used for culling.
depthBiasEnable controls whether to bias fragment depth values.
depthBiasConstantFactor is a scalar factor controlling the constant depth value added to each fragment.
depthBiasClamp is the maximum (or minimum) depth bias of a fragment.
depthBiasSlopeFactor is a scalar factor applied to a fragment’s slope in depth bias calculations.
lineWidth is the width of rasterized line segments.
Description
The application can also add a VkPipelineRasterizationStateRasterizationOrderAMD structure to the pNext chain of a VkPipelineRasterizationStateCreateInfo structure. This structure enables selecting the rasterization order to use when rendering with the corresponding graphics pipeline as described in Rasterization Order.

Valid Usage
If the depth clamping feature is not enabled, depthClampEnable must be VK_FALSE
If the non-solid fill modes feature is not enabled, polygonMode must be VK_POLYGON_MODE_FILL or VK_POLYGON_MODE_FILL_RECTANGLE_NV
If the html/vkspec.html#VK_NV_fill_rectangle extension is not enabled, polygonMode must not be VK_POLYGON_MODE_FILL_RECTANGLE_NV
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineRasterizationConservativeStateCreateInfoEXT, VkPipelineRasterizationDepthClipStateCreateInfoEXT, VkPipelineRasterizationStateRasterizationOrderAMD, or VkPipelineRasterizationStateStreamCreateInfoEXT
Each sType member in the pNext chain must be unique
flags must be 0
polygonMode must be a valid VkPolygonMode value
cullMode must be a valid combination of VkCullModeFlagBits values
frontFace must be a valid VkFrontFace value
See Also
VkBool32, VkCullModeFlags, VkFrontFace, VkGraphicsPipelineCreateInfo, VkPipelineRasterizationStateCreateFlags, VkPolygonMode, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineRasterizationStateCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineRasterizationStateRasterizationOrderAMD(3)
Name
VkPipelineRasterizationStateRasterizationOrderAMD - Structure defining rasterization order for a graphics pipeline

C Specification
The rasterization order to use for a graphics pipeline is specified by adding a VkPipelineRasterizationStateRasterizationOrderAMD structure to the pNext chain of a VkPipelineRasterizationStateCreateInfo structure.

The VkPipelineRasterizationStateRasterizationOrderAMD structure is defined as:

typedef struct VkPipelineRasterizationStateRasterizationOrderAMD {
    VkStructureType            sType;
    const void*                pNext;
    VkRasterizationOrderAMD    rasterizationOrder;
} VkPipelineRasterizationStateRasterizationOrderAMD;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
rasterizationOrder is a VkRasterizationOrderAMD value specifying the primitive rasterization order to use.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD
rasterizationOrder must be a valid VkRasterizationOrderAMD value
If the html/vkspec.html#VK_AMD_rasterization_order device extension is not enabled or the application does not request a particular rasterization order through specifying a VkPipelineRasterizationStateRasterizationOrderAMD structure then the rasterization order used by the graphics pipeline defaults to VK_RASTERIZATION_ORDER_STRICT_AMD.

See Also
VkRasterizationOrderAMD, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineRasterizationStateRasterizationOrderAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineRasterizationStateStreamCreateInfoEXT(3)
Name
VkPipelineRasterizationStateStreamCreateInfoEXT - Structure defining the geometry stream used for rasterization

C Specification
The vertex stream used for rasterization is specified by adding a VkPipelineRasterizationStateStreamCreateInfoEXT structure to the pNext chain of a VkPipelineRasterizationStateCreateInfo structure.

The VkPipelineRasterizationStateStreamCreateInfoEXT structure is defined as:

typedef struct VkPipelineRasterizationStateStreamCreateInfoEXT {
    VkStructureType                                     sType;
    const void*                                         pNext;
    VkPipelineRasterizationStateStreamCreateFlagsEXT    flags;
    uint32_t                                            rasterizationStream;
} VkPipelineRasterizationStateStreamCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
rasterizationStream is the vertex stream selected for rasterization.
Description
If this structure is not present, rasterizationStream is assumed to be zero.

Valid Usage
VkPhysicalDeviceTransformFeedbackFeaturesEXT::geometryStreams must be enabled
rasterizationStream must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams
rasterizationStream must be zero if VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackRasterizationStreamSelect is VK_FALSE
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT
flags must be 0
See Also
VkPipelineRasterizationStateStreamCreateFlagsEXT, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineRasterizationStateStreamCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineRepresentativeFragmentTestStateCreateInfoNV(3)
Name
VkPipelineRepresentativeFragmentTestStateCreateInfoNV - Structure specifying representative fragment test

C Specification
If the pNext chain of VkGraphicsPipelineCreateInfo includes a VkPipelineRepresentativeFragmentTestStateCreateInfoNV structure, then that structure includes parameters that control the representative fragment test.

The VkPipelineRepresentativeFragmentTestStateCreateInfoNV structure is defined as:

typedef struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           representativeFragmentTestEnable;
} VkPipelineRepresentativeFragmentTestStateCreateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
representativeFragmentTestEnable controls whether the representative fragment test is enabled.
Description
If this structure is not present, representativeFragmentTestEnable is considered to be VK_FALSE, and the representative fragment test is disabled.

If early fragment tests are not enabled in the active fragment shader, the representative fragment shader test has no effect, even if enabled.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineRepresentativeFragmentTestStateCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineSampleLocationsStateCreateInfoEXT(3)
Name
VkPipelineSampleLocationsStateCreateInfoEXT - Structure specifying sample locations for a pipeline

C Specification
Applications can also control the sample locations used for rasterization.

If the pNext chain of the VkPipelineMultisampleStateCreateInfo structure specified at pipeline creation time includes an instance of the VkPipelineSampleLocationsStateCreateInfoEXT structure, then that structure controls the sample locations used when rasterizing primitives with the pipeline.

The VkPipelineSampleLocationsStateCreateInfoEXT structure is defined as:

typedef struct VkPipelineSampleLocationsStateCreateInfoEXT {
    VkStructureType             sType;
    const void*                 pNext;
    VkBool32                    sampleLocationsEnable;
    VkSampleLocationsInfoEXT    sampleLocationsInfo;
} VkPipelineSampleLocationsStateCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
sampleLocationsEnable controls whether custom sample locations are used. If sampleLocationsEnable is VK_FALSE, the default sample locations are used and the values specified in sampleLocationsInfo are ignored.
sampleLocationsInfo is the sample locations to use during rasterization if sampleLocationsEnable is VK_TRUE and the graphics pipeline is not created with VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT
sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure
See Also
VkBool32, VkSampleLocationsInfoEXT, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineSampleLocationsStateCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineShaderStageCreateInfo(3)
Name
VkPipelineShaderStageCreateInfo - Structure specifying parameters of a newly created pipeline shader stage

C Specification
The VkPipelineShaderStageCreateInfo structure is defined as:

typedef struct VkPipelineShaderStageCreateInfo {
    VkStructureType                     sType;
    const void*                         pNext;
    VkPipelineShaderStageCreateFlags    flags;
    VkShaderStageFlagBits               stage;
    VkShaderModule                      module;
    const char*                         pName;
    const VkSpecializationInfo*         pSpecializationInfo;
} VkPipelineShaderStageCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
stage is a VkShaderStageFlagBits value specifying a single pipeline stage.
module is a VkShaderModule object that contains the shader for this stage.
pName is a pointer to a null-terminated UTF-8 string specifying the entry point name of the shader for this stage.
pSpecializationInfo is a pointer to VkSpecializationInfo, as described in Specialization Constants, and can be NULL.
Description
Valid Usage
If the geometry shaders feature is not enabled, stage must not be VK_SHADER_STAGE_GEOMETRY_BIT
If the tessellation shaders feature is not enabled, stage must not be VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT
If the mesh shader feature is not enabled, stage must not be VK_SHADER_STAGE_MESH_BIT_NV
If the task shader feature is not enabled, stage must not be VK_SHADER_STAGE_TASK_BIT_NV
stage must not be VK_SHADER_STAGE_ALL_GRAPHICS, or VK_SHADER_STAGE_ALL
pName must be the name of an OpEntryPoint in module with an execution model that matches stage
If the identified entry point includes any variable in its interface that is declared with the ClipDistance BuiltIn decoration, that variable must not have an array size greater than VkPhysicalDeviceLimits::maxClipDistances
If the identified entry point includes any variable in its interface that is declared with the CullDistance BuiltIn decoration, that variable must not have an array size greater than VkPhysicalDeviceLimits::maxCullDistances
If the identified entry point includes any variables in its interface that are declared with the ClipDistance or CullDistance BuiltIn decoration, those variables must not have array sizes which sum to more than VkPhysicalDeviceLimits::maxCombinedClipAndCullDistances
If the identified entry point includes any variable in its interface that is declared with the SampleMask BuiltIn decoration, that variable must not have an array size greater than VkPhysicalDeviceLimits::maxSampleMaskWords
If stage is VK_SHADER_STAGE_VERTEX_BIT, the identified entry point must not include any input variable in its interface that is decorated with CullDistance
If stage is VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, and the identified entry point has an OpExecutionMode instruction that specifies a patch size with OutputVertices, the patch size must be greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxTessellationPatchSize
If stage is VK_SHADER_STAGE_GEOMETRY_BIT, the identified entry point must have an OpExecutionMode instruction that specifies a maximum output vertex count that is greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxGeometryOutputVertices
If stage is VK_SHADER_STAGE_GEOMETRY_BIT, the identified entry point must have an OpExecutionMode instruction that specifies an invocation count that is greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxGeometryShaderInvocations
If stage is a vertex processing stage, and the identified entry point writes to Layer for any primitive, it must write the same value to Layer for all vertices of a given primitive
If stage is a vertex processing stage, and the identified entry point writes to ViewportIndex for any primitive, it must write the same value to ViewportIndex for all vertices of a given primitive
If stage is VK_SHADER_STAGE_FRAGMENT_BIT, the identified entry point must not include any output variables in its interface decorated with CullDistance
If stage is VK_SHADER_STAGE_FRAGMENT_BIT, and the identified entry point writes to FragDepth in any execution path, it must write to FragDepth in all execution paths
If stage is VK_SHADER_STAGE_FRAGMENT_BIT, and the identified entry point writes to FragStencilRefEXT in any execution path, it must write to FragStencilRefEXT in all execution paths
If stage is VK_SHADER_STAGE_MESH_BIT_NV, the identified entry point must have an OpExecutionMode instruction that specifies a maximum output vertex count, OutputVertices, that is greater than 0 and less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxMeshOutputVertices.
If stage is VK_SHADER_STAGE_MESH_BIT_NV, the identified entry point must have an OpExecutionMode instruction that specifies a maximum output primitive count, OutputPrimitivesNV, that is greater than 0 and less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxMeshOutputPrimitives.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
pNext must be NULL
flags must be 0
stage must be a valid VkShaderStageFlagBits value
module must be a valid VkShaderModule handle
pName must be a null-terminated UTF-8 string
If pSpecializationInfo is not NULL, pSpecializationInfo must be a valid pointer to a valid VkSpecializationInfo structure
See Also
VkComputePipelineCreateInfo, VkGraphicsPipelineCreateInfo, VkPipelineShaderStageCreateFlags, VkRayTracingPipelineCreateInfoNV, VkShaderModule, VkShaderStageFlagBits, VkSpecializationInfo, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineShaderStageCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineTessellationDomainOriginStateCreateInfo(3)
Name
VkPipelineTessellationDomainOriginStateCreateInfo - Structure specifying the orientation of the tessellation domain

C Specification
The VkPipelineTessellationDomainOriginStateCreateInfo structure is defined as:

typedef struct VkPipelineTessellationDomainOriginStateCreateInfo {
    VkStructureType               sType;
    const void*                   pNext;
    VkTessellationDomainOrigin    domainOrigin;
} VkPipelineTessellationDomainOriginStateCreateInfo;
or the equivalent

typedef VkPipelineTessellationDomainOriginStateCreateInfo VkPipelineTessellationDomainOriginStateCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
domainOrigin controls the origin of the tessellation domain space, and is of type VkTessellationDomainOrigin.
Description
If the VkPipelineTessellationDomainOriginStateCreateInfo structure is included in the pNext chain of VkPipelineTessellationStateCreateInfo, it controls the origin of the tessellation domain. If this structure is not present, it is as if domainOrigin were VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO
domainOrigin must be a valid VkTessellationDomainOrigin value
See Also
VkStructureType, VkTessellationDomainOrigin

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineTessellationDomainOriginStateCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineTessellationStateCreateInfo(3)
Name
VkPipelineTessellationStateCreateInfo - Structure specifying parameters of a newly created pipeline tessellation state

C Specification
The VkPipelineTessellationStateCreateInfo structure is defined as:

typedef struct VkPipelineTessellationStateCreateInfo {
    VkStructureType                           sType;
    const void*                               pNext;
    VkPipelineTessellationStateCreateFlags    flags;
    uint32_t                                  patchControlPoints;
} VkPipelineTessellationStateCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
patchControlPoints number of control points per patch.
Description
Valid Usage
patchControlPoints must be greater than zero and less than or equal to VkPhysicalDeviceLimits::maxTessellationPatchSize
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO
pNext must be NULL or a pointer to a valid instance of VkPipelineTessellationDomainOriginStateCreateInfo
flags must be 0
See Also
VkGraphicsPipelineCreateInfo, VkPipelineTessellationStateCreateFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineTessellationStateCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineVertexInputDivisorStateCreateInfoEXT(3)
Name
VkPipelineVertexInputDivisorStateCreateInfoEXT - Structure specifying vertex attributes assignment during instanced rendering

C Specification
If vertexAttributeInstanceRateDivisor feature is enabled and the pNext chain of VkPipelineVertexInputStateCreateInfo includes a VkPipelineVertexInputDivisorStateCreateInfoEXT structure, then that structure controls how vertex attributes are assigned to an instance when instanced rendering is enabled.

The VkPipelineVertexInputDivisorStateCreateInfoEXT structure is defined as:

typedef struct VkPipelineVertexInputDivisorStateCreateInfoEXT {
    VkStructureType                                     sType;
    const void*                                         pNext;
    uint32_t                                            vertexBindingDivisorCount;
    const VkVertexInputBindingDivisorDescriptionEXT*    pVertexBindingDivisors;
} VkPipelineVertexInputDivisorStateCreateInfoEXT;
Members
sType is the type of this structure
pNext is NULL or a pointer to an extension-specific structure
vertexBindingDivisorCount is the number of elements in the pVertexBindingDivisors array.
pVertexBindingDivisors is a pointer to an array of VkVertexInputBindingDivisorDescriptionEXT structures, which specifies the divisor value for each binding.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT
pVertexBindingDivisors must be a valid pointer to an array of vertexBindingDivisorCount VkVertexInputBindingDivisorDescriptionEXT structures
vertexBindingDivisorCount must be greater than 0
See Also
VkStructureType, VkVertexInputBindingDivisorDescriptionEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineVertexInputDivisorStateCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineVertexInputStateCreateInfo(3)
Name
VkPipelineVertexInputStateCreateInfo - Structure specifying parameters of a newly created pipeline vertex input state

C Specification
The VkPipelineVertexInputStateCreateInfo structure is defined as:

typedef struct VkPipelineVertexInputStateCreateInfo {
    VkStructureType                             sType;
    const void*                                 pNext;
    VkPipelineVertexInputStateCreateFlags       flags;
    uint32_t                                    vertexBindingDescriptionCount;
    const VkVertexInputBindingDescription*      pVertexBindingDescriptions;
    uint32_t                                    vertexAttributeDescriptionCount;
    const VkVertexInputAttributeDescription*    pVertexAttributeDescriptions;
} VkPipelineVertexInputStateCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
vertexBindingDescriptionCount is the number of vertex binding descriptions provided in pVertexBindingDescriptions.
pVertexBindingDescriptions is a pointer to an array of VkVertexInputBindingDescription structures.
vertexAttributeDescriptionCount is the number of vertex attribute descriptions provided in pVertexAttributeDescriptions.
pVertexAttributeDescriptions is a pointer to an array of VkVertexInputAttributeDescription structures.
Description
Valid Usage
vertexBindingDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings
vertexAttributeDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputAttributes
For every binding specified by each element of pVertexAttributeDescriptions, a VkVertexInputBindingDescription must exist in pVertexBindingDescriptions with the same value of binding
All elements of pVertexBindingDescriptions must describe distinct binding numbers
All elements of pVertexAttributeDescriptions must describe distinct attribute locations
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
pNext must be NULL or a pointer to a valid instance of VkPipelineVertexInputDivisorStateCreateInfoEXT
flags must be 0
If vertexBindingDescriptionCount is not 0, pVertexBindingDescriptions must be a valid pointer to an array of vertexBindingDescriptionCount valid VkVertexInputBindingDescription structures
If vertexAttributeDescriptionCount is not 0, pVertexAttributeDescriptions must be a valid pointer to an array of vertexAttributeDescriptionCount valid VkVertexInputAttributeDescription structures
See Also
VkGraphicsPipelineCreateInfo, VkPipelineVertexInputStateCreateFlags, VkStructureType, VkVertexInputAttributeDescription, VkVertexInputBindingDescription

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineVertexInputStateCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(3)
Name
VkPipelineViewportCoarseSampleOrderStateCreateInfoNV - Structure specifying parameters controlling sample order in coarse fragments

C Specification
If the pNext chain of VkPipelineViewportStateCreateInfo includes a VkPipelineViewportCoarseSampleOrderStateCreateInfoNV structure, then that structure includes parameters that control the order of coverage samples in fragments larger than one pixel.

The VkPipelineViewportCoarseSampleOrderStateCreateInfoNV structure is defined as:

typedef struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
    VkStructureType                       sType;
    const void*                           pNext;
    VkCoarseSampleOrderTypeNV             sampleOrderType;
    uint32_t                              customSampleOrderCount;
    const VkCoarseSampleOrderCustomNV*    pCustomSampleOrders;
} VkPipelineViewportCoarseSampleOrderStateCreateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
sampleOrderType specifies the mechanism used to order coverage samples in fragments larger than one pixel.
customSampleOrderCount specifies the number of custom sample orderings to use when ordering coverage samples.
pCustomSampleOrders is a pointer to an array of VkCoarseSampleOrderCustomNV structures, each of which specifies the coverage sample order for a single combination of fragment area and coverage sample count.
Description
If this structure is not present, sampleOrderType is considered to be VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV.

If sampleOrderType is VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, the coverage sample order used for any combination of fragment area and coverage sample count not enumerated in pCustomSampleOrders will be identical to that used for VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV.

If the pipeline was created with VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV, the contents of this structure (if present) are ignored, and the coverage sample order is instead specified by vkCmdSetCoarseSampleOrderNV.

Valid Usage
If sampleOrderType is not VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, customSamplerOrderCount must be 0
The array pCustomSampleOrders must not contain two structures with matching values for both the shadingRate and sampleCount members.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV
sampleOrderType must be a valid VkCoarseSampleOrderTypeNV value
If customSampleOrderCount is not 0, pCustomSampleOrders must be a valid pointer to an array of customSampleOrderCount valid VkCoarseSampleOrderCustomNV structures
See Also
VkCoarseSampleOrderCustomNV, VkCoarseSampleOrderTypeNV, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineViewportCoarseSampleOrderStateCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineViewportExclusiveScissorStateCreateInfoNV(3)
Name
VkPipelineViewportExclusiveScissorStateCreateInfoNV - Structure specifying parameters controlling exclusive scissor testing

C Specification
If the pNext chain of VkPipelineViewportStateCreateInfo includes a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure, then that structure includes parameters that affect the exclusive scissor test.

The VkPipelineViewportExclusiveScissorStateCreateInfoNV structure is defined as:

typedef struct VkPipelineViewportExclusiveScissorStateCreateInfoNV {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           exclusiveScissorCount;
    const VkRect2D*    pExclusiveScissors;
} VkPipelineViewportExclusiveScissorStateCreateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
exclusiveScissorCount is the number of exclusive scissor rectangles used by the pipeline.
pExclusiveScissors is a pointer to an array of VkRect2D structures defining exclusive scissor rectangles. If the exclusive scissor state is dynamic, this member is ignored.
Description
If this structure is not present, exclusiveScissorCount is considered to be 0 and the exclusive scissor test is disabled.

Valid Usage
If the multiple viewports feature is not enabled, exclusiveScissorCount must be 0 or 1
exclusiveScissorCount must be less than or equal to VkPhysicalDeviceLimits::maxViewports
exclusiveScissorCount must be 0 or identical to the viewportCount member of VkPipelineViewportStateCreateInfo
If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV and exclusiveScissorCount is not 0, pExclusiveScissors must be a valid pointer to an array of exclusiveScissorCount VkRect2D structures
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV
If exclusiveScissorCount is not 0, and pExclusiveScissors is not NULL, pExclusiveScissors must be a valid pointer to an array of exclusiveScissorCount VkRect2D structures
See Also
VkRect2D, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineViewportExclusiveScissorStateCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineViewportShadingRateImageStateCreateInfoNV(3)
Name
VkPipelineViewportShadingRateImageStateCreateInfoNV - Structure specifying parameters controlling shading rate image usage

C Specification
If the pNext chain of VkPipelineViewportStateCreateInfo includes a VkPipelineViewportShadingRateImageStateCreateInfoNV structure, then that structure includes parameters that control the shading rate.

The VkPipelineViewportShadingRateImageStateCreateInfoNV structure is defined as:

typedef struct VkPipelineViewportShadingRateImageStateCreateInfoNV {
    VkStructureType                  sType;
    const void*                      pNext;
    VkBool32                         shadingRateImageEnable;
    uint32_t                         viewportCount;
    const VkShadingRatePaletteNV*    pShadingRatePalettes;
} VkPipelineViewportShadingRateImageStateCreateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
shadingRateImageEnable specifies whether shading rate image and palettes are used during rasterization.
viewportCount specifies the number of per-viewport palettes used to translate values stored in shading rate images.
pShadingRatePalettes is a pointer to an array of VkShadingRatePaletteNV structures defining the palette for each viewport. If the shading rate palette state is dynamic, this member is ignored.
Description
If this structure is not present, shadingRateImageEnable is considered to be VK_FALSE, and the shading rate image and palettes are not used.

Valid Usage
If the multiple viewports feature is not enabled, viewportCount must be 0 or 1
viewportCount must be less than or equal to VkPhysicalDeviceLimits::maxViewports
If shadingRateImageEnable is VK_TRUE, viewportCount must be equal to the viewportCount member of VkPipelineViewportStateCreateInfo
If no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV, pShadingRatePalettes must be a valid pointer to an array of viewportCount VkShadingRatePaletteNV structures
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV
If viewportCount is not 0, and pShadingRatePalettes is not NULL, pShadingRatePalettes must be a valid pointer to an array of viewportCount valid VkShadingRatePaletteNV structures
See Also
VkBool32, VkShadingRatePaletteNV, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineViewportShadingRateImageStateCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineViewportStateCreateInfo(3)
Name
VkPipelineViewportStateCreateInfo - Structure specifying parameters of a newly created pipeline viewport state

C Specification
The VkPipelineViewportStateCreateInfo structure is defined as:

typedef struct VkPipelineViewportStateCreateInfo {
    VkStructureType                       sType;
    const void*                           pNext;
    VkPipelineViewportStateCreateFlags    flags;
    uint32_t                              viewportCount;
    const VkViewport*                     pViewports;
    uint32_t                              scissorCount;
    const VkRect2D*                       pScissors;
} VkPipelineViewportStateCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
viewportCount is the number of viewports used by the pipeline.
pViewports is a pointer to an array of VkViewport structures, defining the viewport transforms. If the viewport state is dynamic, this member is ignored.
scissorCount is the number of scissors and must match the number of viewports.
pScissors is a pointer to an array of VkRect2D structures which define the rectangular bounds of the scissor for the corresponding viewport. If the scissor state is dynamic, this member is ignored.
Description
Valid Usage
If the multiple viewports feature is not enabled, viewportCount must be 1
If the multiple viewports feature is not enabled, scissorCount must be 1
viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive
scissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive
scissorCount and viewportCount must be identical
If the viewportWScalingEnable member of a VkPipelineViewportWScalingStateCreateInfoNV structure chained to the pNext chain is VK_TRUE, the viewportCount member of the VkPipelineViewportWScalingStateCreateInfoNV structure must be equal to viewportCount
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, VkPipelineViewportExclusiveScissorStateCreateInfoNV, VkPipelineViewportShadingRateImageStateCreateInfoNV, VkPipelineViewportSwizzleStateCreateInfoNV, or VkPipelineViewportWScalingStateCreateInfoNV
Each sType member in the pNext chain must be unique
flags must be 0
viewportCount must be greater than 0
scissorCount must be greater than 0
See Also
VkGraphicsPipelineCreateInfo, VkPipelineViewportStateCreateFlags, VkRect2D, VkStructureType, VkViewport

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineViewportStateCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineViewportSwizzleStateCreateInfoNV(3)
Name
VkPipelineViewportSwizzleStateCreateInfoNV - Structure specifying swizzle applied to primitive clip coordinates

C Specification
Each primitive sent to a given viewport has a swizzle and optional negation applied to its clip coordinates. The swizzle that is applied depends on the viewport index, and is controlled by the VkPipelineViewportSwizzleStateCreateInfoNV pipeline state:

typedef struct VkPipelineViewportSwizzleStateCreateInfoNV {
    VkStructureType                                sType;
    const void*                                    pNext;
    VkPipelineViewportSwizzleStateCreateFlagsNV    flags;
    uint32_t                                       viewportCount;
    const VkViewportSwizzleNV*                     pViewportSwizzles;
} VkPipelineViewportSwizzleStateCreateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
viewportCount is the number of viewport swizzles used by the pipeline.
pViewportSwizzles is a pointer to an array of VkViewportSwizzleNV structures, defining the viewport swizzles.
Description
Valid Usage
viewportCount must match the viewportCount set in VkPipelineViewportStateCreateInfo
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV
flags must be 0
pViewportSwizzles must be a valid pointer to an array of viewportCount valid VkViewportSwizzleNV structures
viewportCount must be greater than 0
See Also
VkPipelineViewportSwizzleStateCreateFlagsNV, VkStructureType, VkViewportSwizzleNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineViewportSwizzleStateCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineViewportWScalingStateCreateInfoNV(3)
Name
VkPipelineViewportWScalingStateCreateInfoNV - Structure specifying parameters of a newly created pipeline viewport W scaling state

C Specification
The VkPipelineViewportWScalingStateCreateInfoNV structure is defined as:

typedef struct VkPipelineViewportWScalingStateCreateInfoNV {
    VkStructureType                sType;
    const void*                    pNext;
    VkBool32                       viewportWScalingEnable;
    uint32_t                       viewportCount;
    const VkViewportWScalingNV*    pViewportWScalings;
} VkPipelineViewportWScalingStateCreateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
viewportWScalingEnable controls whether viewport W scaling is enabled.
viewportCount is the number of viewports used by W scaling, and must match the number of viewports in the pipeline if viewport W scaling is enabled.
pViewportWScalings is a pointer to an array of VkViewportWScalingNV structures, which define the W scaling parameters for the corresponding viewport. If the viewport W scaling state is dynamic, this member is ignored.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV
viewportCount must be greater than 0
See Also
VkBool32, VkStructureType, VkViewportWScalingNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineViewportWScalingStateCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPresentFrameTokenGGP(3)
Name
VkPresentFrameTokenGGP - The Google Games Platform frame token

C Specification
When the html/vkspec.html#VK_GGP_frame_token extension is enabled, a Google Games Platform frame token can be specified when presenting an image to a swapchain by including the VkPresentFrameTokenGGP structure in the pNext chain of the VkPresentInfoKHR structure.

The VkPresentFrameTokenGGP structure is defined as:

typedef struct VkPresentFrameTokenGGP {
    VkStructureType    sType;
    const void*        pNext;
    GgpFrameToken      frameToken;
} VkPresentFrameTokenGGP;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
frameToken is the Google Games Platform frame token.
Description
Valid Usage
frameToken must be a valid GgpFrameToken
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPresentFrameTokenGGP

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPresentInfoKHR(3)
Name
VkPresentInfoKHR - Structure describing parameters of a queue presentation

C Specification
The VkPresentInfoKHR structure is defined as:

typedef struct VkPresentInfoKHR {
    VkStructureType          sType;
    const void*              pNext;
    uint32_t                 waitSemaphoreCount;
    const VkSemaphore*       pWaitSemaphores;
    uint32_t                 swapchainCount;
    const VkSwapchainKHR*    pSwapchains;
    const uint32_t*          pImageIndices;
    VkResult*                pResults;
} VkPresentInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
waitSemaphoreCount is the number of semaphores to wait for before issuing the present request. The number may be zero.
pWaitSemaphores, if not NULL, is an array of VkSemaphore objects with waitSemaphoreCount entries, and specifies the semaphores to wait for before issuing the present request.
swapchainCount is the number of swapchains being presented to by this command.
pSwapchains is an array of VkSwapchainKHR objects with swapchainCount entries. A given swapchain must not appear in this list more than once.
pImageIndices is an array of indices into the array of each swapchain’s presentable images, with swapchainCount entries. Each entry in this array identifies the image to present on the corresponding entry in the pSwapchains array.
pResults is an array of VkResult typed elements with swapchainCount entries. Applications that do not need per-swapchain results can use NULL for pResults. If non-NULL, each entry in pResults will be set to the VkResult for presenting the swapchain corresponding to the same index in pSwapchains.
Description
Before an application can present an image, the image’s layout must be transitioned to the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR layout, or for a shared presentable image the VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR layout.

Note
When transitioning the image to VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR or VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, there is no need to delay subsequent processing, or perform any visibility operations (as vkQueuePresentKHR performs automatic visibility operations). To achieve this, the dstAccessMask member of the VkImageMemoryBarrier should be set to 0, and the dstStageMask parameter should be set to VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT.
Valid Usage
Each element of pImageIndices must be the index of a presentable image acquired from the swapchain specified by the corresponding element of the pSwapchains array, and the presented image subresource must be in the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR layout at the time the operation is executed on a VkDevice
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PRESENT_INFO_KHR
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupPresentInfoKHR, VkDisplayPresentInfoKHR, VkPresentFrameTokenGGP, VkPresentRegionsKHR, or VkPresentTimesInfoGOOGLE
Each sType member in the pNext chain must be unique
If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles
pSwapchains must be a valid pointer to an array of swapchainCount valid VkSwapchainKHR handles
pImageIndices must be a valid pointer to an array of swapchainCount uint32_t values
If pResults is not NULL, pResults must be a valid pointer to an array of swapchainCount VkResult values
swapchainCount must be greater than 0
Both of the elements of pSwapchains, and the elements of pWaitSemaphores that are valid handles must have been created, allocated, or retrieved from the same VkInstance
See Also
VkResult, VkSemaphore, VkStructureType, VkSwapchainKHR, vkQueuePresentKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPresentInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPresentRegionKHR(3)
Name
VkPresentRegionKHR - Structure containing rectangular region changed by vkQueuePresentKHR for a given VkImage

C Specification
For a given image and swapchain, the region to present is specified by the VkPresentRegionKHR structure, which is defined as:

typedef struct VkPresentRegionKHR {
    uint32_t                 rectangleCount;
    const VkRectLayerKHR*    pRectangles;
} VkPresentRegionKHR;
Members
rectangleCount is the number of rectangles in pRectangles, or zero if the entire image has changed and should be presented.
pRectangles is either NULL or a pointer to an array of VkRectLayerKHR structures. The VkRectLayerKHR structure is the framebuffer coordinates, plus layer, of a portion of a presentable image that has changed and must be presented. If non-NULL, each entry in pRectangles is a rectangle of the given image that has changed since the last image was presented to the given swapchain.
Description
Valid Usage (Implicit)
If rectangleCount is not 0, and pRectangles is not NULL, pRectangles must be a valid pointer to an array of rectangleCount valid VkRectLayerKHR structures
See Also
VkPresentRegionsKHR, VkRectLayerKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPresentRegionKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPresentRegionsKHR(3)
Name
VkPresentRegionsKHR - Structure hint of rectangular regions changed by vkQueuePresentKHR

C Specification
When the VK_KHR_incremental_present extension is enabled, additional fields can be specified that allow an application to specify that only certain rectangular regions of the presentable images of a swapchain are changed. This is an optimization hint that a presentation engine may use to only update the region of a surface that is actually changing. The application still must ensure that all pixels of a presented image contain the desired values, in case the presentation engine ignores this hint. An application can provide this hint by including the VkPresentRegionsKHR structure in the pNext chain of the VkPresentInfoKHR structure.

The VkPresentRegionsKHR structure is defined as:

typedef struct VkPresentRegionsKHR {
    VkStructureType              sType;
    const void*                  pNext;
    uint32_t                     swapchainCount;
    const VkPresentRegionKHR*    pRegions;
} VkPresentRegionsKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
swapchainCount is the number of swapchains being presented to by this command.
pRegions is NULL or a pointer to an array of VkPresentRegionKHR elements with swapchainCount entries. If not NULL, each element of pRegions contains the region that has changed since the last present to the swapchain in the corresponding entry in the VkPresentInfoKHR::pSwapchains array.
Description
Valid Usage
swapchainCount must be the same value as VkPresentInfoKHR::swapchainCount, where VkPresentInfoKHR is in the pNext chain of this VkPresentRegionsKHR structure
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR
If pRegions is not NULL, pRegions must be a valid pointer to an array of swapchainCount valid VkPresentRegionKHR structures
swapchainCount must be greater than 0
See Also
VkPresentRegionKHR, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPresentRegionsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPresentTimeGOOGLE(3)
Name
VkPresentTimeGOOGLE - The earliest time image should be presented

C Specification
The VkPresentTimeGOOGLE structure is defined as:

typedef struct VkPresentTimeGOOGLE {
    uint32_t    presentID;
    uint64_t    desiredPresentTime;
} VkPresentTimeGOOGLE;
Members
presentID is an application-provided identification value, that can be used with the results of vkGetPastPresentationTimingGOOGLE, in order to uniquely identify this present. In order to be useful to the application, it should be unique within some period of time that is meaningful to the application.
desiredPresentTime specifies that the image given should not be displayed to the user any earlier than this time. desiredPresentTime is a time in nanoseconds, relative to a monotonically-increasing clock (e.g. CLOCK_MONOTONIC (see clock_gettime(2)) on Android and Linux). A value of zero specifies that the presentation engine may display the image at any time. This is useful when the application desires to provide presentID, but does not need a specific desiredPresentTime.
Description
See Also
VkPresentTimesInfoGOOGLE

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPresentTimeGOOGLE

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPresentTimesInfoGOOGLE(3)
Name
VkPresentTimesInfoGOOGLE - The earliest time each image should be presented

C Specification
When the html/vkspec.html#VK_GOOGLE_display_timing extension is enabled, additional fields can be specified that allow an application to specify the earliest time that an image should be displayed. This allows an application to avoid stutter that is caused by an image being displayed earlier than planned. Such stuttering can occur with both fixed and variable-refresh-rate displays, because stuttering occurs when the geometry is not correctly positioned for when the image is displayed. An application can instruct the presentation engine that an image should not be displayed earlier than a specified time by including the VkPresentTimesInfoGOOGLE structure in the pNext chain of the VkPresentInfoKHR structure.

The VkPresentTimesInfoGOOGLE structure is defined as:

typedef struct VkPresentTimesInfoGOOGLE {
    VkStructureType               sType;
    const void*                   pNext;
    uint32_t                      swapchainCount;
    const VkPresentTimeGOOGLE*    pTimes;
} VkPresentTimesInfoGOOGLE;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
swapchainCount is the number of swapchains being presented to by this command.
pTimes is NULL or a pointer to an array of VkPresentTimeGOOGLE elements with swapchainCount entries. If not NULL, each element of pTimes contains the earliest time to present the image corresponding to the entry in the VkPresentInfoKHR::pImageIndices array.
Description
Valid Usage
swapchainCount must be the same value as VkPresentInfoKHR::swapchainCount, where VkPresentInfoKHR is in the pNext chain of this VkPresentTimesInfoGOOGLE structure.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE
If pTimes is not NULL, pTimes must be a valid pointer to an array of swapchainCount VkPresentTimeGOOGLE structures
swapchainCount must be greater than 0
See Also
VkPresentTimeGOOGLE, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPresentTimesInfoGOOGLE

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkProtectedSubmitInfo(3)
Name
VkProtectedSubmitInfo - Structure indicating whether the submission is protected

C Specification
If the pNext chain of VkSubmitInfo includes a VkProtectedSubmitInfo structure, then the structure indicates whether the batch is protected. The VkProtectedSubmitInfo structure is defined as:

typedef struct VkProtectedSubmitInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           protectedSubmit;
} VkProtectedSubmitInfo;
Members
protectedSubmit specifies whether the batch is protected. If protectedSubmit is VK_TRUE, the batch is protected. If protectedSubmit is VK_FALSE, the batch is unprotected. If the VkSubmitInfo::pNext chain does not contain this structure, the batch is unprotected.
Description
Valid Usage
If the protected memory feature is not enabled, protectedSubmit must not be VK_TRUE.
If protectedSubmit is VK_TRUE, then each element of the pCommandBuffers array must be a protected command buffer.
If protectedSubmit is VK_FALSE, then each element of the pCommandBuffers array must be an unprotected command buffer.
If the VkSubmitInfo::pNext chain does not include a VkProtectedSubmitInfo structure, then each element of the command buffer of the pCommandBuffers array must be an unprotected command buffer.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkProtectedSubmitInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPushConstantRange(3)
Name
VkPushConstantRange - Structure specifying a push constant range

C Specification
The VkPushConstantRange structure is defined as:

typedef struct VkPushConstantRange {
    VkShaderStageFlags    stageFlags;
    uint32_t              offset;
    uint32_t              size;
} VkPushConstantRange;
Members
stageFlags is a set of stage flags describing the shader stages that will access a range of push constants. If a particular stage is not included in the range, then accessing members of that range of push constants from the corresponding shader stage will return undefined values.
offset and size are the start offset and size, respectively, consumed by the range. Both offset and size are in units of bytes and must be a multiple of 4. The layout of the push constant variables is specified in the shader.
Description
Valid Usage
offset must be less than VkPhysicalDeviceLimits::maxPushConstantsSize
offset must be a multiple of 4
size must be greater than 0
size must be a multiple of 4
size must be less than or equal to VkPhysicalDeviceLimits::maxPushConstantsSize minus offset
Valid Usage (Implicit)
stageFlags must be a valid combination of VkShaderStageFlagBits values
stageFlags must not be 0
See Also
VkPipelineLayoutCreateInfo, VkShaderStageFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPushConstantRange

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueryPoolCreateInfo(3)
Name
VkQueryPoolCreateInfo - Structure specifying parameters of a newly created query pool

C Specification
The VkQueryPoolCreateInfo structure is defined as:

typedef struct VkQueryPoolCreateInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkQueryPoolCreateFlags           flags;
    VkQueryType                      queryType;
    uint32_t                         queryCount;
    VkQueryPipelineStatisticFlags    pipelineStatistics;
} VkQueryPoolCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
queryType is a VkQueryType value specifying the type of queries managed by the pool.
queryCount is the number of queries managed by the pool.
pipelineStatistics is a bitmask of VkQueryPipelineStatisticFlagBits specifying which counters will be returned in queries on the new pool, as described below in html/vkspec.html#queries-pipestats.
Description
pipelineStatistics is ignored if queryType is not VK_QUERY_TYPE_PIPELINE_STATISTICS.

Valid Usage
If the pipeline statistics queries feature is not enabled, queryType must not be VK_QUERY_TYPE_PIPELINE_STATISTICS
If queryType is VK_QUERY_TYPE_PIPELINE_STATISTICS, pipelineStatistics must be a valid combination of VkQueryPipelineStatisticFlagBits values
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO
pNext must be NULL
flags must be 0
queryType must be a valid VkQueryType value
See Also
VkQueryPipelineStatisticFlags, VkQueryPoolCreateFlags, VkQueryType, VkStructureType, vkCreateQueryPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueryPoolCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueueFamilyCheckpointPropertiesNV(3)
Name
VkQueueFamilyCheckpointPropertiesNV - return structure for queue family checkpoint info query

C Specification
The VkQueueFamilyCheckpointPropertiesNV structure is defined as:

typedef struct VkQueueFamilyCheckpointPropertiesNV {
    VkStructureType         sType;
    void*                   pNext;
    VkPipelineStageFlags    checkpointExecutionStageMask;
} VkQueueFamilyCheckpointPropertiesNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
checkpointExecutionStageMask is a mask indicating which pipeline stages the implementation can execute checkpoint markers in.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV
See Also
VkPipelineStageFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueueFamilyCheckpointPropertiesNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueueFamilyProperties(3)
Name
VkQueueFamilyProperties - Structure providing information about a queue family

C Specification
The VkQueueFamilyProperties structure is defined as:

typedef struct VkQueueFamilyProperties {
    VkQueueFlags    queueFlags;
    uint32_t        queueCount;
    uint32_t        timestampValidBits;
    VkExtent3D      minImageTransferGranularity;
} VkQueueFamilyProperties;
Members
queueFlags is a bitmask of VkQueueFlagBits indicating capabilities of the queues in this queue family.
queueCount is the unsigned integer count of queues in this queue family. Each queue family must support at least one queue.
timestampValidBits is the unsigned integer count of meaningful bits in the timestamps written via vkCmdWriteTimestamp. The valid range for the count is 36..64 bits, or a value of 0, indicating no support for timestamps. Bits outside the valid range are guaranteed to be zeros.
minImageTransferGranularity is the minimum granularity supported for image transfer operations on the queues in this queue family.
Description
The value returned in minImageTransferGranularity has a unit of compressed texel blocks for images having a block-compressed format, and a unit of texels otherwise.

Possible values of minImageTransferGranularity are:

(0,0,0) which indicates that only whole mip levels must be transferred using the image transfer operations on the corresponding queues. In this case, the following restrictions apply to all offset and extent parameters of image transfer operations:
The x, y, and z members of a VkOffset3D parameter must always be zero.
The width, height, and depth members of a VkExtent3D parameter must always match the width, height, and depth of the image subresource corresponding to the parameter, respectively.
(Ax, Ay, Az) where Ax, Ay, and Az are all integer powers of two. In this case the following restrictions apply to all image transfer operations:
x, y, and z of a VkOffset3D parameter must be integer multiples of Ax, Ay, and Az, respectively.
width of a VkExtent3D parameter must be an integer multiple of Ax, or else x + width must equal the width of the image subresource corresponding to the parameter.
height of a VkExtent3D parameter must be an integer multiple of Ay, or else y + height must equal the height of the image subresource corresponding to the parameter.
depth of a VkExtent3D parameter must be an integer multiple of Az, or else z + depth must equal the depth of the image subresource corresponding to the parameter.
If the format of the image corresponding to the parameters is one of the block-compressed formats then for the purposes of the above calculations the granularity must be scaled up by the compressed texel block dimensions.
Queues supporting graphics and/or compute operations must report (1,1,1) in minImageTransferGranularity, meaning that there are no additional restrictions on the granularity of image transfer operations for these queues. Other queues supporting image transfer operations are only required to support whole mip level transfers, thus minImageTransferGranularity for queues belonging to such queue families may be (0,0,0).

The Device Memory section describes memory properties queried from the physical device.

For physical device feature queries see the Features chapter.

See Also
VkExtent3D, VkQueueFamilyProperties2, VkQueueFlags, vkGetPhysicalDeviceQueueFamilyProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueueFamilyProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueueFamilyProperties2(3)
Name
VkQueueFamilyProperties2 - Structure providing information about a queue family

C Specification
The VkQueueFamilyProperties2 structure is defined as:

typedef struct VkQueueFamilyProperties2 {
    VkStructureType            sType;
    void*                      pNext;
    VkQueueFamilyProperties    queueFamilyProperties;
} VkQueueFamilyProperties2;
or the equivalent

typedef VkQueueFamilyProperties2 VkQueueFamilyProperties2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
queueFamilyProperties is a structure of type VkQueueFamilyProperties which is populated with the same values as in vkGetPhysicalDeviceQueueFamilyProperties.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2
pNext must be NULL or a pointer to a valid instance of VkQueueFamilyCheckpointPropertiesNV
See Also
VkQueueFamilyProperties, VkStructureType, vkGetPhysicalDeviceQueueFamilyProperties2, vkGetPhysicalDeviceQueueFamilyProperties2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueueFamilyProperties2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRayTracingPipelineCreateInfoNV(3)
Name
VkRayTracingPipelineCreateInfoNV - Structure specifying parameters of a newly created ray tracing pipeline

C Specification
The VkRayTracingPipelineCreateInfoNV structure is defined as:

typedef struct VkRayTracingPipelineCreateInfoNV {
    VkStructureType                               sType;
    const void*                                   pNext;
    VkPipelineCreateFlags                         flags;
    uint32_t                                      stageCount;
    const VkPipelineShaderStageCreateInfo*        pStages;
    uint32_t                                      groupCount;
    const VkRayTracingShaderGroupCreateInfoNV*    pGroups;
    uint32_t                                      maxRecursionDepth;
    VkPipelineLayout                              layout;
    VkPipeline                                    basePipelineHandle;
    int32_t                                       basePipelineIndex;
} VkRayTracingPipelineCreateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkPipelineCreateFlagBits specifying how the pipeline will be generated.
stageCount is the number of entries in the pStages array.
pStages is an array of size stageCount structures of type VkPipelineShaderStageCreateInfo describing the set of the shader stages to be included in the ray tracing pipeline.
groupCount is the number of entries in the pGroups array.
pGroups is an array of size groupCount structures of type VkRayTracingShaderGroupCreateInfoNV describing the set of the shader stages to be included in each shader group in the ray tracing pipeline.
maxRecursionDepth is the maximum recursion that will be called from this pipeline.
layout is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.
basePipelineHandle is a pipeline to derive from.
basePipelineIndex is an index into the pCreateInfos parameter to use as a pipeline to derive from.
Description
The parameters basePipelineHandle and basePipelineIndex are described in more detail in Pipeline Derivatives.

Valid Usage
If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is -1, basePipelineHandle must be a valid handle to a ray tracing VkPipeline
If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command’s pCreateInfos parameter
If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE
If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is not VK_NULL_HANDLE, basePipelineIndex must be -1
The stage member of one element of pStages must be VK_SHADER_STAGE_RAYGEN_BIT_NV
The shader code for the entry points identified by pStages, and the rest of the state identified by this structure must adhere to the pipeline linking rules described in the Shader Interfaces chapter
layout must be consistent with all shaders specified in pStages
The number of resources in layout accessible to each shader stage that is used by the pipeline must be less than or equal to VkPhysicalDeviceLimits::maxPerStageResources
maxRecursionDepth must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxRecursionDepth
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV
pNext must be NULL or a pointer to a valid instance of VkPipelineCreationFeedbackCreateInfoEXT
flags must be a valid combination of VkPipelineCreateFlagBits values
pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures
pGroups must be a valid pointer to an array of groupCount valid VkRayTracingShaderGroupCreateInfoNV structures
layout must be a valid VkPipelineLayout handle
stageCount must be greater than 0
groupCount must be greater than 0
Both of basePipelineHandle, and layout that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkPipeline, VkPipelineCreateFlags, VkPipelineLayout, VkPipelineShaderStageCreateInfo, VkRayTracingShaderGroupCreateInfoNV, VkStructureType, vkCreateRayTracingPipelinesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRayTracingPipelineCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRayTracingShaderGroupCreateInfoNV(3)
Name
VkRayTracingShaderGroupCreateInfoNV - Structure specifying shaders in a shader group

C Specification
The VkRayTracingShaderGroupCreateInfoNV structure is defined as:

typedef struct VkRayTracingShaderGroupCreateInfoNV {
    VkStructureType                  sType;
    const void*                      pNext;
    VkRayTracingShaderGroupTypeNV    type;
    uint32_t                         generalShader;
    uint32_t                         closestHitShader;
    uint32_t                         anyHitShader;
    uint32_t                         intersectionShader;
} VkRayTracingShaderGroupCreateInfoNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
type is the type of hit group specified in this structure.
generalShader is the index of the ray generation, miss, or callable shader from VkRayTracingPipelineCreateInfoNV::pStages in the group if the shader group has type of VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV and VK_SHADER_UNUSED_NV otherwise.
closestHitShader is the optional index of the closest hit shader from VkRayTracingPipelineCreateInfoNV::pStages in the group if the shader group has type of VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV or VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV and VK_SHADER_UNUSED_NV otherwise.
anyHitShader is the optional index of the any-hit shader from VkRayTracingPipelineCreateInfoNV::pStages in the group if the shader group has type of VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV or VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV and VK_SHADER_UNUSED_NV otherwise.
intersectionShader is the index of the intersection shader from VkRayTracingPipelineCreateInfoNV::pStages in the group if the shader group has type of VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV and VK_SHADER_UNUSED_NV otherwise.
Description
Valid Usage
If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV then generalShader must be a valid index into pStages referring to a shader of VK_SHADER_STAGE_RAYGEN_BIT_NV, VK_SHADER_STAGE_MISS_BIT_NV, or VK_SHADER_STAGE_CALLABLE_BIT_NV
If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV then closestHitShader, anyHitShader, and intersectionShader must be VK_SHADER_UNUSED_NV
If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV then intersectionShader must be a valid index into pStages referring to a shader of VK_SHADER_STAGE_INTERSECTION_BIT_NV
If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV then intersectionShader must be VK_SHADER_UNUSED_NV
closestHitShader must be either VK_SHADER_UNUSED_NV or a valid index into pStages referring to a shader of VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV
anyHitShader must be either VK_SHADER_UNUSED_NV or a valid index into pStages referring to a shader of VK_SHADER_STAGE_ANY_HIT_BIT_NV
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV
pNext must be NULL
type must be a valid VkRayTracingShaderGroupTypeNV value
See Also
VkRayTracingPipelineCreateInfoNV, VkRayTracingShaderGroupTypeNV, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRayTracingShaderGroupCreateInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRect2D(3)
Name
VkRect2D - Structure specifying a two-dimensional subregion

C Specification
Rectangles are used to describe a specified rectangular region of pixels within an image or framebuffer. Rectangles include both an offset and an extent of the same dimensionality, as described above. Two-dimensional rectangles are defined by the structure

typedef struct VkRect2D {
    VkOffset2D    offset;
    VkExtent2D    extent;
} VkRect2D;
Members
offset is a VkOffset2D specifying the rectangle offset.
extent is a VkExtent2D specifying the rectangle extent.
Description
See Also
VkBindImageMemoryDeviceGroupInfo, VkClearRect, VkDeviceGroupRenderPassBeginInfo, VkDisplayPresentInfoKHR, VkExtent2D, VkOffset2D, VkPipelineDiscardRectangleStateCreateInfoEXT, VkPipelineViewportExclusiveScissorStateCreateInfoNV, VkPipelineViewportStateCreateInfo, VkRenderPassBeginInfo, vkCmdSetDiscardRectangleEXT, vkCmdSetExclusiveScissorNV, vkCmdSetScissor, vkGetPhysicalDevicePresentRectanglesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRect2D

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRectLayerKHR(3)
Name
VkRectLayerKHR - Structure containing a rectangle, including layer, changed by vkQueuePresentKHR for a given VkImage

C Specification
The VkRectLayerKHR structure is defined as:

typedef struct VkRectLayerKHR {
    VkOffset2D    offset;
    VkExtent2D    extent;
    uint32_t      layer;
} VkRectLayerKHR;
Members
offset is the origin of the rectangle, in pixels.
extent is the size of the rectangle, in pixels.
layer is the layer of the image. For images with only one layer, the value of layer must be 0.
Description
Valid Usage
The sum of offset and extent must be no greater than the imageExtent member of the VkSwapchainCreateInfoKHR structure given to vkCreateSwapchainKHR.
layer must be less than imageArrayLayers member of the VkSwapchainCreateInfoKHR structure given to vkCreateSwapchainKHR.
Some platforms allow the size of a surface to change, and then scale the pixels of the image to fit the surface. VkRectLayerKHR specifies pixels of the swapchain’s image(s), which will be constant for the life of the swapchain.

See Also
VkExtent2D, VkOffset2D, VkPresentRegionKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRectLayerKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRefreshCycleDurationGOOGLE(3)
Name
VkRefreshCycleDurationGOOGLE - Structure containing the RC duration of a display

C Specification
The VkRefreshCycleDurationGOOGLE structure is defined as:

typedef struct VkRefreshCycleDurationGOOGLE {
    uint64_t    refreshDuration;
} VkRefreshCycleDurationGOOGLE;
Members
refreshDuration is the number of nanoseconds from the start of one refresh cycle to the next.
Description
See Also
vkGetRefreshCycleDurationGOOGLE

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRefreshCycleDurationGOOGLE

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRenderPassBeginInfo(3)
Name
VkRenderPassBeginInfo - Structure specifying render pass begin info

C Specification
The VkRenderPassBeginInfo structure is defined as:

typedef struct VkRenderPassBeginInfo {
    VkStructureType        sType;
    const void*            pNext;
    VkRenderPass           renderPass;
    VkFramebuffer          framebuffer;
    VkRect2D               renderArea;
    uint32_t               clearValueCount;
    const VkClearValue*    pClearValues;
} VkRenderPassBeginInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
renderPass is the render pass to begin an instance of.
framebuffer is the framebuffer containing the attachments that are used with the render pass.
renderArea is the render area that is affected by the render pass instance, and is described in more detail below.
clearValueCount is the number of elements in pClearValues.
pClearValues is an array of VkClearValue structures that contains clear values for each attachment, if the attachment uses a loadOp value of VK_ATTACHMENT_LOAD_OP_CLEAR or if the attachment has a depth/stencil format and uses a stencilLoadOp value of VK_ATTACHMENT_LOAD_OP_CLEAR. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of pClearValues are ignored.
Description
renderArea is the render area that is affected by the render pass instance. The effects of attachment load, store and multisample resolve operations are restricted to the pixels whose x and y coordinates fall within the render area on all attachments. The render area extends to all layers of framebuffer. The application must ensure (using scissor if necessary) that all rendering is contained within the render area. The render area must be contained within the framebuffer dimensions.

When multiview is enabled, the resolve operation at the end of a subpass applies to all views in the view mask.

Note
There may be a performance cost for using a render area smaller than the framebuffer, unless it matches the render area granularity for the render pass.
Valid Usage
clearValueCount must be greater than the largest attachment index in renderPass that specifies a loadOp (or stencilLoadOp, if the attachment has a depth/stencil format) of VK_ATTACHMENT_LOAD_OP_CLEAR
renderPass must be compatible with the renderPass member of the VkFramebufferCreateInfo structure specified when creating framebuffer.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupRenderPassBeginInfo or VkRenderPassSampleLocationsBeginInfoEXT
Each sType member in the pNext chain must be unique
renderPass must be a valid VkRenderPass handle
framebuffer must be a valid VkFramebuffer handle
If clearValueCount is not 0, pClearValues must be a valid pointer to an array of clearValueCount VkClearValue unions
Both of framebuffer, and renderPass must have been created, allocated, or retrieved from the same VkDevice
See Also
VkClearValue, VkFramebuffer, VkRect2D, VkRenderPass, VkStructureType, vkCmdBeginRenderPass, vkCmdBeginRenderPass2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRenderPassBeginInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRenderPassCreateInfo(3)
Name
VkRenderPassCreateInfo - Structure specifying parameters of a newly created render pass

C Specification
The VkRenderPassCreateInfo structure is defined as:

typedef struct VkRenderPassCreateInfo {
    VkStructureType                   sType;
    const void*                       pNext;
    VkRenderPassCreateFlags           flags;
    uint32_t                          attachmentCount;
    const VkAttachmentDescription*    pAttachments;
    uint32_t                          subpassCount;
    const VkSubpassDescription*       pSubpasses;
    uint32_t                          dependencyCount;
    const VkSubpassDependency*        pDependencies;
} VkRenderPassCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
attachmentCount is the number of attachments used by this render pass.
pAttachments points to an array of attachmentCount VkAttachmentDescription structures describing the attachments used by the render pass.
subpassCount is the number of subpasses to create.
pSubpasses points to an array of subpassCount VkSubpassDescription structures describing each subpass.
dependencyCount is the number of memory dependencies between pairs of subpasses.
pDependencies points to an array of dependencyCount VkSubpassDependency structures describing dependencies between pairs of subpasses.
Description
Note
Care should be taken to avoid a data race here; if any subpasses access attachments with overlapping memory locations, and one of those accesses is a write, a subpass dependency needs to be included between them.
Valid Usage
If the attachment member of any element of pInputAttachments, pColorAttachments, pResolveAttachments or pDepthStencilAttachment, or any element of pPreserveAttachments in any element of pSubpasses is not VK_ATTACHMENT_UNUSED, it must be less than attachmentCount
For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL.
For any member of pAttachments with a stencilLoadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL.
For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL.
For any member of pAttachments with a stencilLoadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL.
If the pNext chain includes an instance of VkRenderPassInputAttachmentAspectCreateInfo, the subpass member of each element of its pAspectReferences member must be less than subpassCount
If the pNext chain includes an instance of VkRenderPassInputAttachmentAspectCreateInfo, the inputAttachmentIndex member of each element of its pAspectReferences member must be less than the value of inputAttachmentCount in the member of pSubpasses identified by its subpass member
If the pNext chain includes an instance of VkRenderPassInputAttachmentAspectCreateInfo, for any element of the pInputAttachments member of any element of pSubpasses where the attachment member is not VK_ATTACHMENT_UNUSED, the aspectMask member of the corresponding element of VkRenderPassInputAttachmentAspectCreateInfo::pAspectReferences must only include aspects that are present in images of the format specified by the element of pAttachments at attachment
If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, and its subpassCount member is not zero, that member must be equal to the value of subpassCount
If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, if its dependencyCount member is not zero, it must be equal to dependencyCount
If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, for each non-zero element of pViewOffsets, the srcSubpass and dstSubpass members of pDependencies at the same index must not be equal
If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, for any element of pDependencies with a dependencyFlags member that does not include VK_DEPENDENCY_VIEW_LOCAL_BIT, the corresponding element of the pViewOffsets member of that VkRenderPassMultiviewCreateInfo instance must be 0
If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, elements of its pViewMasks member must either all be 0, or all not be 0
If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, and each element of its pViewMasks member is 0, the dependencyFlags member of each element of pDependencies must not include VK_DEPENDENCY_VIEW_LOCAL_BIT
If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, and each element of its pViewMasks member is 0, correlatedViewMaskCount must be 0
If the pNext chain includes an instance of VkRenderPassMultiviewCreateInfo, each element of its pViewMask member must not include a bit at a position greater than the value of VkPhysicalDeviceLimits::maxFramebufferLayers
For any element of pDependencies, if the srcSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the srcStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass
For any element of pDependencies, if the dstSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the dstStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass
The srcSubpass member of each element of pDependencies must be less than subpassCount
The dstSubpass member of each element of pDependencies must be less than subpassCount
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkRenderPassFragmentDensityMapCreateInfoEXT, VkRenderPassInputAttachmentAspectCreateInfo, or VkRenderPassMultiviewCreateInfo
Each sType member in the pNext chain must be unique
If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkAttachmentDescription structures
pSubpasses must be a valid pointer to an array of subpassCount valid VkSubpassDescription structures
If dependencyCount is not 0, pDependencies must be a valid pointer to an array of dependencyCount valid VkSubpassDependency structures
subpassCount must be greater than 0
See Also
VkAttachmentDescription, VkRenderPassCreateFlags, VkStructureType, VkSubpassDependency, VkSubpassDescription, vkCreateRenderPass

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRenderPassCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRenderPassCreateInfo2KHR(3)
Name
VkRenderPassCreateInfo2KHR - Structure specifying parameters of a newly created render pass

C Specification
The VkRenderPassCreateInfo2KHR structure is defined as:

typedef struct VkRenderPassCreateInfo2KHR {
    VkStructureType                       sType;
    const void*                           pNext;
    VkRenderPassCreateFlags               flags;
    uint32_t                              attachmentCount;
    const VkAttachmentDescription2KHR*    pAttachments;
    uint32_t                              subpassCount;
    const VkSubpassDescription2KHR*       pSubpasses;
    uint32_t                              dependencyCount;
    const VkSubpassDependency2KHR*        pDependencies;
    uint32_t                              correlatedViewMaskCount;
    const uint32_t*                       pCorrelatedViewMasks;
} VkRenderPassCreateInfo2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
attachmentCount is the number of attachments used by this render pass.
pAttachments points to an array of attachmentCount VkAttachmentDescription2KHR structures describing the attachments used by the render pass.
subpassCount is the number of subpasses to create.
pSubpasses points to an array of subpassCount VkSubpassDescription2KHR structures describing each subpass.
dependencyCount is the number of dependencies between pairs of subpasses.
pDependencies points to an array of dependencyCount VkSubpassDependency2KHR structures describing dependencies between pairs of subpasses.
correlatedViewMaskCount is the number of correlation masks.
pCorrelatedViewMasks is an array of view masks indicating sets of views that may be more efficient to render concurrently.
Description
Parameters defined by this structure with the same name as those in VkRenderPassCreateInfo have the identical effect to those parameters; the child structures are variants of those used in VkRenderPassCreateInfo which include sType and pNext parameters, allowing them to be extended.

If the VkSubpassDescription2KHR::viewMask member of any element of pSubpasses is not zero, multiview functionality is considered to be enabled for this render pass.

correlatedViewMaskCount and pCorrelatedViewMasks have the same effect as VkRenderPassMultiviewCreateInfo::correlationMaskCount and VkRenderPassMultiviewCreateInfo::pCorrelationMasks, respectively.

Valid Usage
If any two subpasses operate on attachments with overlapping ranges of the same VkDeviceMemory object, and at least one subpass writes to that area of VkDeviceMemory, a subpass dependency must be included (either directly or via some intermediate subpasses) between them
If the attachment member of any element of pInputAttachments, pColorAttachments, pResolveAttachments or pDepthStencilAttachment, or the attachment indexed by any element of pPreserveAttachments in any given element of pSubpasses is bound to a range of a VkDeviceMemory object that overlaps with any other attachment in any subpass (including the same subpass), the VkAttachmentDescription2KHR structures describing them must include VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT in flags
If the attachment member of any element of pInputAttachments, pColorAttachments, pResolveAttachments or pDepthStencilAttachment, or any element of pPreserveAttachments in any given element of pSubpasses is not VK_ATTACHMENT_UNUSED, it must be less than attachmentCount
For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL
For any member of pAttachments with a stencilLoadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL.
For any element of pDependencies, if the srcSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the srcStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass.
For any element of pDependencies, if the dstSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the dstStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass.
The set of bits included in any element of pCorrelatedViewMasks must not overlap with the set of bits included in any other element of pCorrelatedViewMasks
If the VkSubpassDescription2KHR::viewMask member of all elements of pSubpasses is 0, correlatedViewMaskCount must be 0
The VkSubpassDescription2KHR::viewMask member of all elements of pSubpasses must either all be 0, or all not be 0
If the VkSubpassDescription2KHR::viewMask member of all elements of pSubpasses is 0, the dependencyFlags member of any element of pDependencies must not include VK_DEPENDENCY_VIEW_LOCAL_BIT
For any element of pDependencies where its srcSubpass member equals its dstSubpass member, if the viewMask member of the corresponding element of pSubpasses includes more than one bit, its dependencyFlags member must include VK_DEPENDENCY_VIEW_LOCAL_BIT
The viewMask member must not include a bit at a position greater than the value of VkPhysicalDeviceLimits::maxFramebufferLayers
If the attachment member of any element of the pInputAttachments member of any element of pSubpasses is not VK_ATTACHMENT_UNUSED, the aspectMask member of that element of pInputAttachments must only include aspects that are present in images of the format specified by the element of pAttachments specified by attachment
The srcSubpass member of each element of pDependencies must be less than subpassCount
The dstSubpass member of each element of pDependencies must be less than subpassCount
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR
pNext must be NULL
If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkAttachmentDescription2KHR structures
pSubpasses must be a valid pointer to an array of subpassCount valid VkSubpassDescription2KHR structures
If dependencyCount is not 0, pDependencies must be a valid pointer to an array of dependencyCount valid VkSubpassDependency2KHR structures
If correlatedViewMaskCount is not 0, pCorrelatedViewMasks must be a valid pointer to an array of correlatedViewMaskCount uint32_t values
subpassCount must be greater than 0
See Also
VkAttachmentDescription2KHR, VkRenderPassCreateFlags, VkStructureType, VkSubpassDependency2KHR, VkSubpassDescription2KHR, vkCreateRenderPass2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRenderPassCreateInfo2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRenderPassFragmentDensityMapCreateInfoEXT(3)
Name
VkRenderPassFragmentDensityMapCreateInfoEXT - Structure containing fragment density map attachment for render pass

C Specification
If the VkRenderPassCreateInfo::pNext chain includes a VkRenderPassFragmentDensityMapCreateInfoEXT structure, then that structure includes a fragment density map attachment for the render pass.

The VkRenderPassFragmentDensityMapCreateInfoEXT structure is defined as:

typedef struct VkRenderPassFragmentDensityMapCreateInfoEXT {
    VkStructureType          sType;
    const void*              pNext;
    VkAttachmentReference    fragmentDensityMapAttachment;
} VkRenderPassFragmentDensityMapCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
fragmentDensityMapAttachment is the fragment density map to use for the render pass.
Description
The fragment density map attachment is read at an implementation-dependent time either by the host during vkCmdBeginRenderPass if the attachment’s image view was not created with flags containing VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT, or by the device when drawing commands in the renderpass execute VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT.

If this structure is not present, it is as if fragmentDensityMapAttachment was given as VK_ATTACHMENT_UNUSED.

Valid Usage
If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must be less than VkRenderPassCreateInfo::attachmentCount
If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must not be an element of VkSubpassDescription::pInputAttachments, VkSubpassDescription::pColorAttachments, VkSubpassDescription::pResolveAttachments, VkSubpassDescription::pDepthStencilAttachment, or VkSubpassDescription::pPreserveAttachments for any subpass
If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, layout must be equal to VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT, or VK_IMAGE_LAYOUT_GENERAL
If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must reference an attachment with a loadOp equal to VK_ATTACHMENT_LOAD_OP_LOAD or VK_ATTACHMENT_LOAD_OP_DONT_CARE.
If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must reference an attachment with a storeOp equal to VK_ATTACHMENT_STORE_OP_DONT_CARE.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT
fragmentDensityMapAttachment must be a valid VkAttachmentReference structure
See Also
VkAttachmentReference, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRenderPassFragmentDensityMapCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRenderPassInputAttachmentAspectCreateInfo(3)
Name
VkRenderPassInputAttachmentAspectCreateInfo - Structure specifying, for a given subpass/input attachment pair, which aspect can be read.

C Specification
To specify which aspects of an input attachment can be read add a VkRenderPassInputAttachmentAspectCreateInfo structure to the pNext chain of the VkRenderPassCreateInfo structure:

The VkRenderPassInputAttachmentAspectCreateInfo structure is defined as:

typedef struct VkRenderPassInputAttachmentAspectCreateInfo {
    VkStructureType                            sType;
    const void*                                pNext;
    uint32_t                                   aspectReferenceCount;
    const VkInputAttachmentAspectReference*    pAspectReferences;
} VkRenderPassInputAttachmentAspectCreateInfo;
or the equivalent

typedef VkRenderPassInputAttachmentAspectCreateInfo VkRenderPassInputAttachmentAspectCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
aspectReferenceCount is the number of elements in the pAspectReferences array.
pAspectReferences points to an array of aspectReferenceCount number of VkInputAttachmentAspectReference structures describing which aspect(s) can be accessed for a given input attachment within a given subpass.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO
pAspectReferences must be a valid pointer to an array of aspectReferenceCount valid VkInputAttachmentAspectReference structures
aspectReferenceCount must be greater than 0
See Also
VkInputAttachmentAspectReference, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRenderPassInputAttachmentAspectCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRenderPassMultiviewCreateInfo(3)
Name
VkRenderPassMultiviewCreateInfo - Structure containing multiview info for all subpasses

C Specification
If the VkRenderPassCreateInfo::pNext chain includes a VkRenderPassMultiviewCreateInfo structure, then that structure includes an array of view masks, view offsets, and correlation masks for the render pass.

The VkRenderPassMultiviewCreateInfo structure is defined as:

typedef struct VkRenderPassMultiviewCreateInfo {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           subpassCount;
    const uint32_t*    pViewMasks;
    uint32_t           dependencyCount;
    const int32_t*     pViewOffsets;
    uint32_t           correlationMaskCount;
    const uint32_t*    pCorrelationMasks;
} VkRenderPassMultiviewCreateInfo;
or the equivalent

typedef VkRenderPassMultiviewCreateInfo VkRenderPassMultiviewCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
subpassCount is zero or is the number of subpasses in the render pass.
pViewMasks points to an array of subpassCount number of view masks, where each mask is a bitfield of view indices describing which views rendering is broadcast to in each subpass, when multiview is enabled. If subpassCount is zero, each view mask is treated as zero.
dependencyCount is zero or the number of dependencies in the render pass.
pViewOffsets points to an array of dependencyCount view offsets, one for each dependency. If dependencyCount is zero, each dependency’s view offset is treated as zero. Each view offset controls which views in the source subpass the views in the destination subpass depend on.
correlationMaskCount is zero or a number of correlation masks.
pCorrelationMasks is an array of view masks indicating sets of views that may be more efficient to render concurrently.
Description
When a subpass uses a non-zero view mask, multiview functionality is considered to be enabled. Multiview is all-or-nothing for a render pass - that is, either all subpasses must have a non-zero view mask (though some subpasses may have only one view) or all must be zero. Multiview causes all drawing and clear commands in the subpass to behave as if they were broadcast to each view, where a view is represented by one layer of the framebuffer attachments. All draws and clears are broadcast to each view index whose bit is set in the view mask. The view index is provided in the ViewIndex shader input variable, and color, depth/stencil, and input attachments all read/write the layer of the framebuffer corresponding to the view index.

If the view mask is zero for all subpasses, multiview is considered to be disabled and all drawing commands execute normally, without this additional broadcasting.

Some implementations may not support multiview in conjunction with geometry shaders or tessellation shaders.

When multiview is enabled, the VK_DEPENDENCY_VIEW_LOCAL_BIT bit in a dependency can be used to express a view-local dependency, meaning that each view in the destination subpass depends on a single view in the source subpass. Unlike pipeline barriers, a subpass dependency can potentially have a different view mask in the source subpass and the destination subpass. If the dependency is view-local, then each view (dstView) in the destination subpass depends on the view dstView + pViewOffsets[dependency] in the source subpass. If there is not such a view in the source subpass, then this dependency does not affect that view in the destination subpass. If the dependency is not view-local, then all views in the destination subpass depend on all views in the source subpass, and the view offset is ignored. A non-zero view offset is not allowed in a self-dependency.

The elements of pCorrelationMasks are a set of masks of views indicating that views in the same mask may exhibit spatial coherency between the views, making it more efficient to render them concurrently. Correlation masks must not have a functional effect on the results of the multiview rendering.

When multiview is enabled, at the beginning of each subpass all non-render pass state is undefined. In particular, each time vkCmdBeginRenderPass or vkCmdNextSubpass is called the graphics pipeline must be bound, any relevant descriptor sets or vertex/index buffers must be bound, and any relevant dynamic state or push constants must be set before they are used.

A multiview subpass can declare that its shaders will write per-view attributes for all views in a single invocation, by setting the VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX bit in the subpass description. The only supported per-view attributes are position and viewport mask, and per-view position and viewport masks are written to output array variables decorated with PositionPerViewNV and ViewportMaskPerViewNV, respectively. If html/vkspec.html#VK_NV_viewport_array2 is not supported and enabled, ViewportMaskPerViewNV must not be used. Values written to elements of PositionPerViewNV and ViewportMaskPerViewNV must not depend on the ViewIndex. The shader must also write to an output variable decorated with Position, and the value written to Position must equal the value written to PositionPerViewNV[ViewIndex]. Similarly, if ViewportMaskPerViewNV is written to then the shader must also write to an output variable decorated with ViewportMaskNV, and the value written to ViewportMaskNV must equal the value written to ViewportMaskPerViewNV[ViewIndex]. Implementations will either use values taken from Position and ViewportMaskNV and invoke the shader once for each view, or will use values taken from PositionPerViewNV and ViewportMaskPerViewNV and invoke the shader fewer times. The values written to Position and ViewportMaskNV must not depend on the values written to PositionPerViewNV and ViewportMaskPerViewNV, or vice versa (to allow compilers to eliminate the unused outputs). All attributes that do not have *PerViewNV counterparts must not depend on ViewIndex.

Per-view attributes are all-or-nothing for a subpass. That is, all pipelines compiled against a subpass that includes the VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX bit must write per-view attributes to the *PerViewNV[] shader outputs, in addition to the non-per-view (e.g. Position) outputs. Pipelines compiled against a subpass that does not include this bit must not include the *PerViewNV[] outputs in their interfaces.

Valid Usage
Each view index must not be set in more than one element of pCorrelationMasks
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO
If subpassCount is not 0, pViewMasks must be a valid pointer to an array of subpassCount uint32_t values
If dependencyCount is not 0, pViewOffsets must be a valid pointer to an array of dependencyCount int32_t values
If correlationMaskCount is not 0, pCorrelationMasks must be a valid pointer to an array of correlationMaskCount uint32_t values
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRenderPassMultiviewCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRenderPassSampleLocationsBeginInfoEXT(3)
Name
VkRenderPassSampleLocationsBeginInfoEXT - Structure specifying sample locations to use for the layout transition of custom sample locations compatible depth/stencil attachments

C Specification
The image layout of the depth aspect of a depth/stencil attachment referring to an image created with VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT is dependent on the last sample locations used to render to the image subresource, thus preserving the contents of such depth/stencil attachments across subpass boundaries requires the application to specify these sample locations whenever a layout transition of the attachment may occur. This information can be provided by chaining an instance of the VkRenderPassSampleLocationsBeginInfoEXT structure to the pNext chain of VkRenderPassBeginInfo.

The VkRenderPassSampleLocationsBeginInfoEXT structure is defined as:

typedef struct VkRenderPassSampleLocationsBeginInfoEXT {
    VkStructureType                          sType;
    const void*                              pNext;
    uint32_t                                 attachmentInitialSampleLocationsCount;
    const VkAttachmentSampleLocationsEXT*    pAttachmentInitialSampleLocations;
    uint32_t                                 postSubpassSampleLocationsCount;
    const VkSubpassSampleLocationsEXT*       pPostSubpassSampleLocations;
} VkRenderPassSampleLocationsBeginInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
attachmentInitialSampleLocationsCount is the number of elements in the pAttachmentInitialSampleLocations array.
pAttachmentInitialSampleLocations is an array of attachmentInitialSampleLocationsCount VkAttachmentSampleLocationsEXT structures specifying the attachment indices and their corresponding sample location state. Each element of pAttachmentInitialSampleLocations can specify the sample location state to use in the automatic layout transition performed to transition a depth/stencil attachment from the initial layout of the attachment to the image layout specified for the attachment in the first subpass using it.
postSubpassSampleLocationsCount is the number of elements in the pPostSubpassSampleLocations array.
pPostSubpassSampleLocations is an array of postSubpassSampleLocationsCount VkSubpassSampleLocationsEXT structures specifying the subpass indices and their corresponding sample location state. Each element of pPostSubpassSampleLocations can specify the sample location state to use in the automatic layout transition performed to transition the depth/stencil attachment used by the specified subpass to the image layout specified in a dependent subpass or to the final layout of the attachment in case the specified subpass is the last subpass using that attachment. In addition, if VkPhysicalDeviceSampleLocationsPropertiesEXT::variableSampleLocations is VK_FALSE, each element of pPostSubpassSampleLocations must specify the sample location state that matches the sample locations used by all pipelines that will be bound to a command buffer during the specified subpass. If variableSampleLocations is VK_TRUE, the sample locations used for rasterization do not depend on pPostSubpassSampleLocations.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT
If attachmentInitialSampleLocationsCount is not 0, pAttachmentInitialSampleLocations must be a valid pointer to an array of attachmentInitialSampleLocationsCount valid VkAttachmentSampleLocationsEXT structures
If postSubpassSampleLocationsCount is not 0, pPostSubpassSampleLocations must be a valid pointer to an array of postSubpassSampleLocationsCount valid VkSubpassSampleLocationsEXT structures
See Also
VkAttachmentSampleLocationsEXT, VkStructureType, VkSubpassSampleLocationsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRenderPassSampleLocationsBeginInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSampleLocationEXT(3)
Name
VkSampleLocationEXT - Structure specifying the coordinates of a sample location

C Specification
The VkSampleLocationEXT structure is defined as:

typedef struct VkSampleLocationEXT {
    float    x;
    float    y;
} VkSampleLocationEXT;
Members
x is the horizontal coordinate of the sample’s location.
y is the vertical coordinate of the sample’s location.
Description
The domain space of the sample location coordinates has an upper-left origin within the pixel in framebuffer space.

The values specified in a VkSampleLocationEXT structure are always clamped to the implementation-dependent sample location coordinate range [sampleLocationCoordinateRange[0],sampleLocationCoordinateRange[1]] that can be queried by chaining the VkPhysicalDeviceSampleLocationsPropertiesEXT structure to the pNext chain of VkPhysicalDeviceProperties2.

See Also
VkSampleLocationsInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSampleLocationEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSampleLocationsInfoEXT(3)
Name
VkSampleLocationsInfoEXT - Structure specifying a set of sample locations

C Specification
The VkSampleLocationsInfoEXT structure is defined as:

typedef struct VkSampleLocationsInfoEXT {
    VkStructureType               sType;
    const void*                   pNext;
    VkSampleCountFlagBits         sampleLocationsPerPixel;
    VkExtent2D                    sampleLocationGridSize;
    uint32_t                      sampleLocationsCount;
    const VkSampleLocationEXT*    pSampleLocations;
} VkSampleLocationsInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
sampleLocationsPerPixel is a VkSampleCountFlagBits specifying the number of sample locations per pixel.
sampleLocationGridSize is the size of the sample location grid to select custom sample locations for.
sampleLocationsCount is the number of sample locations in pSampleLocations.
pSampleLocations is an array of sampleLocationsCount VkSampleLocationEXT structures.
Description
This structure can be used either to specify the sample locations to be used for rendering or to specify the set of sample locations an image subresource has been last rendered with for the purposes of layout transitions of depth/stencil images created with VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT.

The sample locations in pSampleLocations specify sampleLocationsPerPixel number of sample locations for each pixel in the grid of the size specified in sampleLocationGridSize. The sample location for sample i at the pixel grid location (x,y) is taken from pSampleLocations[(x + y * sampleLocationGridSize.width) * sampleLocationsPerPixel + i].

If the render pass has a fragment density map, the implementation will choose the sample locations for the fragment and the contents of pSampleLocations may be ignored.

Valid Usage
sampleLocationsPerPixel must be a bit value that is set in VkPhysicalDeviceSampleLocationsPropertiesEXT::sampleLocationSampleCounts
sampleLocationsCount must equal sampleLocationsPerPixel × sampleLocationGridSize.width × sampleLocationGridSize.height
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT
If sampleLocationsPerPixel is not 0, sampleLocationsPerPixel must be a valid VkSampleCountFlagBits value
If sampleLocationsCount is not 0, pSampleLocations must be a valid pointer to an array of sampleLocationsCount VkSampleLocationEXT structures
See Also
VkAttachmentSampleLocationsEXT, VkExtent2D, VkPipelineSampleLocationsStateCreateInfoEXT, VkSampleCountFlagBits, VkSampleLocationEXT, VkStructureType, VkSubpassSampleLocationsEXT, vkCmdSetSampleLocationsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSampleLocationsInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSamplerCreateInfo(3)
Name
VkSamplerCreateInfo - Structure specifying parameters of a newly created sampler

C Specification
The VkSamplerCreateInfo structure is defined as:

typedef struct VkSamplerCreateInfo {
    VkStructureType         sType;
    const void*             pNext;
    VkSamplerCreateFlags    flags;
    VkFilter                magFilter;
    VkFilter                minFilter;
    VkSamplerMipmapMode     mipmapMode;
    VkSamplerAddressMode    addressModeU;
    VkSamplerAddressMode    addressModeV;
    VkSamplerAddressMode    addressModeW;
    float                   mipLodBias;
    VkBool32                anisotropyEnable;
    float                   maxAnisotropy;
    VkBool32                compareEnable;
    VkCompareOp             compareOp;
    float                   minLod;
    float                   maxLod;
    VkBorderColor           borderColor;
    VkBool32                unnormalizedCoordinates;
} VkSamplerCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkSamplerCreateFlagBits describing additional parameters of the sampler.
magFilter is a VkFilter value specifying the magnification filter to apply to lookups.
minFilter is a VkFilter value specifying the minification filter to apply to lookups.
mipmapMode is a VkSamplerMipmapMode value specifying the mipmap filter to apply to lookups.
addressModeU is a VkSamplerAddressMode value specifying the addressing mode for outside [0..1] range for U coordinate.
addressModeV is a VkSamplerAddressMode value specifying the addressing mode for outside [0..1] range for V coordinate.
addressModeW is a VkSamplerAddressMode value specifying the addressing mode for outside [0..1] range for W coordinate.
mipLodBias is the bias to be added to mipmap LOD (level-of-detail) calculation and bias provided by image sampling functions in SPIR-V, as described in the Level-of-Detail Operation section.
anisotropyEnable is VK_TRUE to enable anisotropic filtering, as described in the Texel Anisotropic Filtering section, or VK_FALSE otherwise.
maxAnisotropy is the anisotropy value clamp used by the sampler when anisotropyEnable is VK_TRUE. If anisotropyEnable is VK_FALSE, maxAnisotropy is ignored.
compareEnable is VK_TRUE to enable comparison against a reference value during lookups, or VK_FALSE otherwise.
Note: Some implementations will default to shader state if this member does not match.
compareOp is a VkCompareOp value specifying the comparison function to apply to fetched data before filtering as described in the Depth Compare Operation section.
minLod and maxLod are the values used to clamp the computed LOD value, as described in the Level-of-Detail Operation section.
borderColor is a VkBorderColor value specifying the predefined border color to use.
unnormalizedCoordinates controls whether to use unnormalized or normalized texel coordinates to address texels of the image. When set to VK_TRUE, the range of the image coordinates used to lookup the texel is in the range of zero to the image dimensions for x, y and z. When set to VK_FALSE the range of image coordinates is zero to one.
When unnormalizedCoordinates is VK_TRUE, images the sampler is used with in the shader have the following requirements:
The viewType must be either VK_IMAGE_VIEW_TYPE_1D or VK_IMAGE_VIEW_TYPE_2D.
The image view must have a single layer and a single mip level.
When unnormalizedCoordinates is VK_TRUE, image built-in functions in the shader that use the sampler have the following requirements:
The functions must not use projection.
The functions must not use offsets.
Description
Mapping of OpenGL to Vulkan filter modes
magFilter values of VK_FILTER_NEAREST and VK_FILTER_LINEAR directly correspond to GL_NEAREST and GL_LINEAR magnification filters. minFilter and mipmapMode combine to correspond to the similarly named OpenGL minification filter of GL_minFilter_MIPMAP_mipmapMode (e.g. minFilter of VK_FILTER_LINEAR and mipmapMode of VK_SAMPLER_MIPMAP_MODE_NEAREST correspond to GL_LINEAR_MIPMAP_NEAREST).

There are no Vulkan filter modes that directly correspond to OpenGL minification filters of GL_LINEAR or GL_NEAREST, but they can be emulated using VK_SAMPLER_MIPMAP_MODE_NEAREST, minLod = 0, and maxLod = 0.25, and using minFilter = VK_FILTER_LINEAR or minFilter = VK_FILTER_NEAREST, respectively.

Note that using a maxLod of zero would cause magnification to always be performed, and the magFilter to always be used. This is valid, just not an exact match for OpenGL behavior. Clamping the maximum LOD to 0.25 allows the λ value to be non-zero and minification to be performed, while still always rounding down to the base level. If the minFilter and magFilter are equal, then using a maxLod of zero also works.
The maximum number of sampler objects which can be simultaneously created on a device is implementation-dependent and specified by the maxSamplerAllocationCount member of the VkPhysicalDeviceLimits structure. If maxSamplerAllocationCount is exceeded, vkCreateSampler will return VK_ERROR_TOO_MANY_OBJECTS.

Since VkSampler is a non-dispatchable handle type, implementations may return the same handle for sampler state vectors that are identical. In such cases, all such objects would only count once against the maxSamplerAllocationCount limit.

Valid Usage
The absolute value of mipLodBias must be less than or equal to VkPhysicalDeviceLimits::maxSamplerLodBias
maxLod must be greater than or equal to minLod
If the anisotropic sampling feature is not enabled, anisotropyEnable must be VK_FALSE
If anisotropyEnable is VK_TRUE, maxAnisotropy must be between 1.0 and VkPhysicalDeviceLimits::maxSamplerAnisotropy, inclusive
If sampler Y’CBCR conversion is enabled and VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT is not set for the format, minFilter and magFilter must be equal to the sampler Y’CBCR conversion’s chromaFilter
If unnormalizedCoordinates is VK_TRUE, minFilter and magFilter must be equal
If unnormalizedCoordinates is VK_TRUE, mipmapMode must be VK_SAMPLER_MIPMAP_MODE_NEAREST
If unnormalizedCoordinates is VK_TRUE, minLod and maxLod must be zero
If unnormalizedCoordinates is VK_TRUE, addressModeU and addressModeV must each be either VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE or VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER
If unnormalizedCoordinates is VK_TRUE, anisotropyEnable must be VK_FALSE
If unnormalizedCoordinates is VK_TRUE, compareEnable must be VK_FALSE
If any of addressModeU, addressModeV or addressModeW are VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER, borderColor must be a valid VkBorderColor value
If sampler Y’CBCR conversion is enabled, addressModeU, addressModeV, and addressModeW must be VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, anisotropyEnable must be VK_FALSE, and unnormalizedCoordinates must be VK_FALSE
The sampler reduction mode must be set to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT if sampler Y’CBCR conversion is enabled
If the html/vkspec.html#VK_KHR_sampler_mirror_clamp_to_edge extension is not enabled, addressModeU, addressModeV and addressModeW must not be VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE
If compareEnable is VK_TRUE, compareOp must be a valid VkCompareOp value
If either magFilter or minFilter is VK_FILTER_CUBIC_EXT, anisotropyEnable must be VK_FALSE
If compareEnable is VK_TRUE, the reductionMode member of VkSamplerReductionModeCreateInfoEXT must be VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT
If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then minFilter and magFilter must be equal.
If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then mipmapMode must be VK_SAMPLER_MIPMAP_MODE_NEAREST.
If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then minLod and maxLod must be zero.
If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then addressModeU and addressModeV must each be either VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE or VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER.
If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then anisotropyEnable must be VK_FALSE.
If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then compareEnable must be VK_FALSE.
If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then unnormalizedCoordinates must be VK_FALSE.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkSamplerReductionModeCreateInfoEXT or VkSamplerYcbcrConversionInfo
Each sType member in the pNext chain must be unique
flags must be a valid combination of VkSamplerCreateFlagBits values
magFilter must be a valid VkFilter value
minFilter must be a valid VkFilter value
mipmapMode must be a valid VkSamplerMipmapMode value
addressModeU must be a valid VkSamplerAddressMode value
addressModeV must be a valid VkSamplerAddressMode value
addressModeW must be a valid VkSamplerAddressMode value
See Also
VkBool32, VkBorderColor, VkCompareOp, VkFilter, VkSamplerAddressMode, VkSamplerCreateFlags, VkSamplerMipmapMode, VkStructureType, vkCreateSampler

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSamplerReductionModeCreateInfoEXT(3)
Name
VkSamplerReductionModeCreateInfoEXT - Structure specifying sampler reduction mode

C Specification
If the pNext chain of VkSamplerCreateInfo includes a VkSamplerReductionModeCreateInfoEXT structure, then that structure includes a mode that controls how texture filtering combines texel values.

The VkSamplerReductionModeCreateInfoEXT structure is defined as:

typedef struct VkSamplerReductionModeCreateInfoEXT {
    VkStructureType              sType;
    const void*                  pNext;
    VkSamplerReductionModeEXT    reductionMode;
} VkSamplerReductionModeCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
reductionMode is an enum of type VkSamplerReductionModeEXT that controls how texture filtering combines texel values.
Description
If this structure is not present, reductionMode is considered to be VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT
reductionMode must be a valid VkSamplerReductionModeEXT value
See Also
VkSamplerReductionModeEXT, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerReductionModeCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSamplerYcbcrConversionCreateInfo(3)
Name
VkSamplerYcbcrConversionCreateInfo - Structure specifying the parameters of the newly created conversion

C Specification
The VkSamplerYcbcrConversionCreateInfo structure is defined as:

typedef struct VkSamplerYcbcrConversionCreateInfo {
    VkStructureType                  sType;
    const void*                      pNext;
    VkFormat                         format;
    VkSamplerYcbcrModelConversion    ycbcrModel;
    VkSamplerYcbcrRange              ycbcrRange;
    VkComponentMapping               components;
    VkChromaLocation                 xChromaOffset;
    VkChromaLocation                 yChromaOffset;
    VkFilter                         chromaFilter;
    VkBool32                         forceExplicitReconstruction;
} VkSamplerYcbcrConversionCreateInfo;
or the equivalent

typedef VkSamplerYcbcrConversionCreateInfo VkSamplerYcbcrConversionCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
format is the format of the image from which color information will be retrieved.
ycbcrModel describes the color matrix for conversion between color models.
ycbcrRange describes whether the encoded values have headroom and foot room, or whether the encoding uses the full numerical range.
components applies a swizzle based on VkComponentSwizzle enums prior to range expansion and color model conversion.
xChromaOffset describes the sample location associated with downsampled chroma channels in the x dimension. xChromaOffset has no effect for formats in which chroma channels are the same resolution as the luma channel.
yChromaOffset describes the sample location associated with downsampled chroma channels in the y dimension. yChromaOffset has no effect for formats in which the chroma channels are not downsampled vertically.
chromaFilter is the filter for chroma reconstruction.
forceExplicitReconstruction can be used to ensure that reconstruction is done explicitly, if supported.
Description
Note
Setting forceExplicitReconstruction to VK_TRUE may have a performance penalty on implementations where explicit reconstruction is not the default mode of operation.
If the pNext chain has an instance of VkExternalFormatANDROID with non-zero externalFormat member, the sampler Y’CBCR conversion object represents an external format conversion, and format must be VK_FORMAT_UNDEFINED. Such conversions must only be used to sample image views with a matching external format. When creating an external format conversion, the value of components is ignored.

Valid Usage
If an external format conversion is being created, format must be VK_FORMAT_UNDEFINED, otherwise it must not be VK_FORMAT_UNDEFINED.
format must support VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT or VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT
If the format does not support VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT, xChromaOffset and yChromaOffset must not be VK_CHROMA_LOCATION_COSITED_EVEN
If the format does not support VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT, xChromaOffset and yChromaOffset must not be VK_CHROMA_LOCATION_MIDPOINT
format must represent unsigned normalized values (i.e. the format must be a UNORM format)
If the format has a _422 or _420 suffix, then components.g must be VK_COMPONENT_SWIZZLE_IDENTITY
If the format has a _422 or _420 suffix, then components.a must be VK_COMPONENT_SWIZZLE_IDENTITY, VK_COMPONENT_SWIZZLE_ONE, or VK_COMPONENT_SWIZZLE_ZERO
If the format has a _422 or _420 suffix, then components.r must be VK_COMPONENT_SWIZZLE_IDENTITY or VK_COMPONENT_SWIZZLE_B
If the format has a _422 or _420 suffix, then components.b must be VK_COMPONENT_SWIZZLE_IDENTITY or VK_COMPONENT_SWIZZLE_R
If the format has a _422 or _420 suffix, and if either components.r or components.b is VK_COMPONENT_SWIZZLE_IDENTITY, both values must be VK_COMPONENT_SWIZZLE_IDENTITY
If ycbcrModel is not VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY, then components.r, components.g, and components.b must correspond to channels of the format; that is, components.r, components.g, and components.b must not be VK_COMPONENT_SWIZZLE_ZERO or VK_COMPONENT_SWIZZLE_ONE, and must not correspond to a channel which contains zero or one as a consequence of conversion to RGBA
If the format does not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT, forceExplicitReconstruction must be FALSE
If the format does not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT, chromaFilter must be VK_FILTER_NEAREST
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO
pNext must be NULL or a pointer to a valid instance of VkExternalFormatANDROID
format must be a valid VkFormat value
ycbcrModel must be a valid VkSamplerYcbcrModelConversion value
ycbcrRange must be a valid VkSamplerYcbcrRange value
components must be a valid VkComponentMapping structure
xChromaOffset must be a valid VkChromaLocation value
yChromaOffset must be a valid VkChromaLocation value
chromaFilter must be a valid VkFilter value
If chromaFilter is VK_FILTER_NEAREST, chroma samples are reconstructed to luma channel resolution using nearest-neighbour sampling. Otherwise, chroma samples are reconstructed using interpolation. More details can be found in the description of sampler Y’CBCR conversion in the Image Operations chapter.

See Also
VkBool32, VkChromaLocation, VkComponentMapping, VkFilter, VkFormat, VkSamplerYcbcrModelConversion, VkSamplerYcbcrRange, VkStructureType, vkCreateSamplerYcbcrConversion, vkCreateSamplerYcbcrConversionKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerYcbcrConversionCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSamplerYcbcrConversionImageFormatProperties(3)
Name
VkSamplerYcbcrConversionImageFormatProperties - Structure specifying combined image sampler descriptor count for multi-planar images

C Specification
To determine the number of combined image samplers required to support a multi-planar format, add VkSamplerYcbcrConversionImageFormatProperties to the pNext chain of the VkImageFormatProperties2 structure in a call to vkGetPhysicalDeviceImageFormatProperties2.

The VkSamplerYcbcrConversionImageFormatProperties structure is defined as:

typedef struct VkSamplerYcbcrConversionImageFormatProperties {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           combinedImageSamplerDescriptorCount;
} VkSamplerYcbcrConversionImageFormatProperties;
or the equivalent

typedef VkSamplerYcbcrConversionImageFormatProperties VkSamplerYcbcrConversionImageFormatPropertiesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
combinedImageSamplerDescriptorCount is the number of combined image sampler descriptors that the implementation uses to access the format.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerYcbcrConversionImageFormatProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSamplerYcbcrConversionInfo(3)
Name
VkSamplerYcbcrConversionInfo - Structure specifying Y’CbCr conversion to a sampler or image view

C Specification
To create a sampler with Y’CBCR conversion enabled, add a VkSamplerYcbcrConversionInfo to the pNext chain of the VkSamplerCreateInfo structure. To create a sampler Y’CBCR conversion, the samplerYcbcrConversion feature must be enabled. Conversion must be fixed at pipeline creation time, through use of a combined image sampler with an immutable sampler in VkDescriptorSetLayoutBinding.

A VkSamplerYcbcrConversionInfo must be provided for samplers to be used with image views that access VK_IMAGE_ASPECT_COLOR_BIT if the format appears in html/vkspec.html#formats-requiring-sampler-ycbcr-conversion , or if the image view has an external format .

The VkSamplerYcbcrConversionInfo structure is defined as:

typedef struct VkSamplerYcbcrConversionInfo {
    VkStructureType             sType;
    const void*                 pNext;
    VkSamplerYcbcrConversion    conversion;
} VkSamplerYcbcrConversionInfo;
or the equivalent

typedef VkSamplerYcbcrConversionInfo VkSamplerYcbcrConversionInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
conversion is a VkSamplerYcbcrConversion handle created with vkCreateSamplerYcbcrConversion.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO
conversion must be a valid VkSamplerYcbcrConversion handle
See Also
VkSamplerYcbcrConversion, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerYcbcrConversionInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSemaphoreCreateInfo(3)
Name
VkSemaphoreCreateInfo - Structure specifying parameters of a newly created semaphore

C Specification
The VkSemaphoreCreateInfo structure is defined as:

typedef struct VkSemaphoreCreateInfo {
    VkStructureType           sType;
    const void*               pNext;
    VkSemaphoreCreateFlags    flags;
} VkSemaphoreCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkExportSemaphoreCreateInfo or VkExportSemaphoreWin32HandleInfoKHR
Each sType member in the pNext chain must be unique
flags must be 0
See Also
VkSemaphoreCreateFlags, VkStructureType, vkCreateSemaphore

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSemaphoreCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSemaphoreGetFdInfoKHR(3)
Name
VkSemaphoreGetFdInfoKHR - Structure describing a POSIX FD semaphore export operation

C Specification
The VkSemaphoreGetFdInfoKHR structure is defined as:

typedef struct VkSemaphoreGetFdInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkSemaphore                              semaphore;
    VkExternalSemaphoreHandleTypeFlagBits    handleType;
} VkSemaphoreGetFdInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
semaphore is the semaphore from which state will be exported.
handleType is the type of handle requested.
Description
The properties of the file descriptor returned depend on the value of handleType. See VkExternalSemaphoreHandleTypeFlagBits for a description of the properties of the defined external semaphore handle types.

Valid Usage
handleType must have been included in VkExportSemaphoreCreateInfo::handleTypes when semaphore’s current payload was created.
semaphore must not currently have its payload replaced by an imported payload as described below in Importing Semaphore Payloads unless that imported payload’s handle type was included in VkExternalSemaphoreProperties::exportFromImportedHandleTypes for handleType.
If handleType refers to a handle type with copy payload transference semantics, as defined below in Importing Semaphore Payloads, there must be no queue waiting on semaphore.
If handleType refers to a handle type with copy payload transference semantics, semaphore must be signaled, or have an associated semaphore signal operation pending execution.
handleType must be defined as a POSIX file descriptor handle.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR
pNext must be NULL
semaphore must be a valid VkSemaphore handle
handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value
See Also
VkExternalSemaphoreHandleTypeFlagBits, VkSemaphore, VkStructureType, vkGetSemaphoreFdKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSemaphoreGetFdInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSemaphoreGetWin32HandleInfoKHR(3)
Name
VkSemaphoreGetWin32HandleInfoKHR - Structure describing a Win32 handle semaphore export operation

C Specification
The VkSemaphoreGetWin32HandleInfoKHR structure is defined as:

typedef struct VkSemaphoreGetWin32HandleInfoKHR {
    VkStructureType                          sType;
    const void*                              pNext;
    VkSemaphore                              semaphore;
    VkExternalSemaphoreHandleTypeFlagBits    handleType;
} VkSemaphoreGetWin32HandleInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
semaphore is the semaphore from which state will be exported.
handleType is the type of handle requested.
Description
The properties of the handle returned depend on the value of handleType. See VkExternalSemaphoreHandleTypeFlagBits for a description of the properties of the defined external semaphore handle types.

Valid Usage
handleType must have been included in VkExportSemaphoreCreateInfo::handleTypes when the semaphore’s current payload was created.
If handleType is defined as an NT handle, vkGetSemaphoreWin32HandleKHR must be called no more than once for each valid unique combination of semaphore and handleType.
semaphore must not currently have its payload replaced by an imported payload as described below in Importing Semaphore Payloads unless that imported payload’s handle type was included in VkExternalSemaphoreProperties::exportFromImportedHandleTypes for handleType.
If handleType refers to a handle type with copy payload transference semantics, as defined below in Importing Semaphore Payloads, there must be no queue waiting on semaphore.
If handleType refers to a handle type with copy payload transference semantics, semaphore must be signaled, or have an associated semaphore signal operation pending execution.
handleType must be defined as an NT handle or a global share handle.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR
pNext must be NULL
semaphore must be a valid VkSemaphore handle
handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value
See Also
VkExternalSemaphoreHandleTypeFlagBits, VkSemaphore, VkStructureType, vkGetSemaphoreWin32HandleKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSemaphoreGetWin32HandleInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkShaderModuleCreateInfo(3)
Name
VkShaderModuleCreateInfo - Structure specifying parameters of a newly created shader module

C Specification
The VkShaderModuleCreateInfo structure is defined as:

typedef struct VkShaderModuleCreateInfo {
    VkStructureType              sType;
    const void*                  pNext;
    VkShaderModuleCreateFlags    flags;
    size_t                       codeSize;
    const uint32_t*              pCode;
} VkShaderModuleCreateInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
codeSize is the size, in bytes, of the code pointed to by pCode.
pCode points to code that is used to create the shader module. The type and format of the code is determined from the content of the memory addressed by pCode.
Description
Valid Usage
codeSize must be greater than 0
If pCode points to SPIR-V code, codeSize must be a multiple of 4
pCode must point to either valid SPIR-V code, formatted and packed as described by the Khronos SPIR-V Specification or valid GLSL code which must be written to the GL_KHR_vulkan_glsl extension specification
If pCode points to SPIR-V code, that code must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix
If pCode points to GLSL code, it must be valid GLSL code written to the GL_KHR_vulkan_glsl GLSL extension specification
pCode must declare the Shader capability for SPIR-V code
pCode must not declare any capability that is not supported by the API, as described by the Capabilities section of the SPIR-V Environment appendix
If pCode declares any of the capabilities listed as optional in the SPIR-V Environment appendix, the corresponding feature(s) must be enabled.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
pNext must be NULL or a pointer to a valid instance of VkShaderModuleValidationCacheCreateInfoEXT
flags must be 0
pCode must be a valid pointer to an array of \(\textrm{codeSize} \over 4\) uint32_t values
See Also
VkShaderModuleCreateFlags, VkStructureType, vkCreateShaderModule

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkShaderModuleCreateInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkShaderModuleValidationCacheCreateInfoEXT(3)
Name
VkShaderModuleValidationCacheCreateInfoEXT - Specify validation cache to use during shader module creation

C Specification
To use a VkValidationCacheEXT to cache shader validation results, add a VkShaderModuleValidationCacheCreateInfoEXT to the pNext chain of the VkShaderModuleCreateInfo structure, specifying the cache object to use.

The VkShaderModuleValidationCacheCreateInfoEXT struct is defined as:

typedef struct VkShaderModuleValidationCacheCreateInfoEXT {
    VkStructureType         sType;
    const void*             pNext;
    VkValidationCacheEXT    validationCache;
} VkShaderModuleValidationCacheCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
validationCache is the validation cache object from which the results of prior validation attempts will be written, and to which new validation results for this VkShaderModule will be written (if not already present).
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT
validationCache must be a valid VkValidationCacheEXT handle
See Also
VkStructureType, VkValidationCacheEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkShaderModuleValidationCacheCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkShaderResourceUsageAMD(3)
Name
VkShaderResourceUsageAMD - Resource usage information about a particular shader within a pipeline

C Specification
The VkShaderResourceUsageAMD structure is defined as:

typedef struct VkShaderResourceUsageAMD {
    uint32_t    numUsedVgprs;
    uint32_t    numUsedSgprs;
    uint32_t    ldsSizePerLocalWorkGroup;
    size_t      ldsUsageSizeInBytes;
    size_t      scratchMemUsageInBytes;
} VkShaderResourceUsageAMD;
Members
numUsedVgprs is the number of vector instruction general-purpose registers used by this shader.
numUsedSgprs is the number of scalar instruction general-purpose registers used by this shader.
ldsSizePerLocalWorkGroup is the maximum local data store size per work group in bytes.
ldsUsageSizeInBytes is the LDS usage size in bytes per work group by this shader.
scratchMemUsageInBytes is the scratch memory usage in bytes by this shader.
Description
See Also
VkShaderStatisticsInfoAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkShaderResourceUsageAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkShaderStatisticsInfoAMD(3)
Name
VkShaderStatisticsInfoAMD - Statistical information about a particular shader within a pipeline

C Specification
The VkShaderStatisticsInfoAMD structure is defined as:

typedef struct VkShaderStatisticsInfoAMD {
    VkShaderStageFlags          shaderStageMask;
    VkShaderResourceUsageAMD    resourceUsage;
    uint32_t                    numPhysicalVgprs;
    uint32_t                    numPhysicalSgprs;
    uint32_t                    numAvailableVgprs;
    uint32_t                    numAvailableSgprs;
    uint32_t                    computeWorkGroupSize[3];
} VkShaderStatisticsInfoAMD;
Members
shaderStageMask are the combination of logical shader stages contained within this shader.
resourceUsage is an instance of VkShaderResourceUsageAMD describing internal physical device resources used by this shader.
numPhysicalVgprs is the maximum number of vector instruction general-purpose registers (VGPRs) available to the physical device.
numPhysicalSgprs is the maximum number of scalar instruction general-purpose registers (SGPRs) available to the physical device.
numAvailableVgprs is the maximum limit of VGPRs made available to the shader compiler.
numAvailableSgprs is the maximum limit of SGPRs made available to the shader compiler.
computeWorkGroupSize is the local workgroup size of this shader in { X, Y, Z } dimensions.
Description
Some implementations may merge multiple logical shader stages together in a single shader. In such cases, shaderStageMask will contain a bitmask of all of the stages that are active within that shader. Consequently, if specifying those stages as input to vkGetShaderInfoAMD, the same output information may be returned for all such shader stage queries.

The number of available VGPRs and SGPRs (numAvailableVgprs and numAvailableSgprs respectively) are the shader-addressable subset of physical registers that is given as a limit to the compiler for register assignment. These values may further be limited by implementations due to performance optimizations where register pressure is a bottleneck.

See Also
VkShaderResourceUsageAMD, VkShaderStageFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkShaderStatisticsInfoAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkShadingRatePaletteNV(3)
Name
VkShadingRatePaletteNV - Structure specifying a single shading rate palette

C Specification
The VkShadingRatePaletteNV structure specifies to contents of a single shading rate image palette and is defined as:

typedef struct VkShadingRatePaletteNV {
    uint32_t                              shadingRatePaletteEntryCount;
    const VkShadingRatePaletteEntryNV*    pShadingRatePaletteEntries;
} VkShadingRatePaletteNV;
Members
shadingRatePaletteEntryCount specifies the number of entries in the shading rate image palette.
pShadingRatePaletteEntries is a pointer to an array of VkShadingRatePaletteEntryNV enums defining the shading rate for each palette entry.
Description
Valid Usage
shadingRatePaletteEntryCount must be between 1 and VkPhysicalDeviceShadingRateImagePropertiesNV::shadingRatePaletteSize, inclusive
Valid Usage (Implicit)
pShadingRatePaletteEntries must be a valid pointer to an array of shadingRatePaletteEntryCount valid VkShadingRatePaletteEntryNV values
shadingRatePaletteEntryCount must be greater than 0
See Also
VkPipelineViewportShadingRateImageStateCreateInfoNV, VkShadingRatePaletteEntryNV, vkCmdSetViewportShadingRatePaletteNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkShadingRatePaletteNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSharedPresentSurfaceCapabilitiesKHR(3)
Name
VkSharedPresentSurfaceCapabilitiesKHR - structure describing capabilities of a surface for shared presentation

C Specification
The VkSharedPresentSurfaceCapabilitiesKHR structure is defined as:

typedef struct VkSharedPresentSurfaceCapabilitiesKHR {
    VkStructureType      sType;
    void*                pNext;
    VkImageUsageFlags    sharedPresentSupportedUsageFlags;
} VkSharedPresentSurfaceCapabilitiesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
sharedPresentSupportedUsageFlags is a bitmask of VkImageUsageFlagBits representing the ways the application can use the shared presentable image from a swapchain created with VkPresentModeKHR set to VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR for the surface on the specified device. VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT must be included in the set but implementations may support additional usages.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR
See Also
VkImageUsageFlags, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSharedPresentSurfaceCapabilitiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSparseBufferMemoryBindInfo(3)
Name
VkSparseBufferMemoryBindInfo - Structure specifying a sparse buffer memory bind operation

C Specification
Memory is bound to VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag using the following structure:

typedef struct VkSparseBufferMemoryBindInfo {
    VkBuffer                     buffer;
    uint32_t                     bindCount;
    const VkSparseMemoryBind*    pBinds;
} VkSparseBufferMemoryBindInfo;
Members
buffer is the VkBuffer object to be bound.
bindCount is the number of VkSparseMemoryBind structures in the pBinds array.
pBinds is a pointer to array of VkSparseMemoryBind structures.
Description
Valid Usage (Implicit)
buffer must be a valid VkBuffer handle
pBinds must be a valid pointer to an array of bindCount valid VkSparseMemoryBind structures
bindCount must be greater than 0
See Also
VkBindSparseInfo, VkBuffer, VkSparseMemoryBind

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSparseBufferMemoryBindInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSparseImageFormatProperties(3)
Name
VkSparseImageFormatProperties - Structure specifying sparse image format properties

C Specification
The VkSparseImageFormatProperties structure is defined as:

typedef struct VkSparseImageFormatProperties {
    VkImageAspectFlags          aspectMask;
    VkExtent3D                  imageGranularity;
    VkSparseImageFormatFlags    flags;
} VkSparseImageFormatProperties;
Members
aspectMask is a bitmask VkImageAspectFlagBits specifying which aspects of the image the properties apply to.
imageGranularity is the width, height, and depth of the sparse image block in texels or compressed texel blocks.
flags is a bitmask of VkSparseImageFormatFlagBits specifying additional information about the sparse resource.
Description
See Also
VkExtent3D, VkImageAspectFlags, VkSparseImageFormatFlags, VkSparseImageFormatProperties2, VkSparseImageMemoryRequirements, vkGetPhysicalDeviceSparseImageFormatProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSparseImageFormatProperties

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSparseImageFormatProperties2(3)
Name
VkSparseImageFormatProperties2 - Structure specifying sparse image format properties

C Specification
The VkSparseImageFormatProperties2 structure is defined as:

typedef struct VkSparseImageFormatProperties2 {
    VkStructureType                  sType;
    void*                            pNext;
    VkSparseImageFormatProperties    properties;
} VkSparseImageFormatProperties2;
or the equivalent

typedef VkSparseImageFormatProperties2 VkSparseImageFormatProperties2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
properties is a structure of type VkSparseImageFormatProperties which is populated with the same values as in vkGetPhysicalDeviceSparseImageFormatProperties.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2
pNext must be NULL
See Also
VkSparseImageFormatProperties, VkStructureType, vkGetPhysicalDeviceSparseImageFormatProperties2, vkGetPhysicalDeviceSparseImageFormatProperties2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSparseImageFormatProperties2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSparseImageMemoryBind(3)
Name
VkSparseImageMemoryBind - Structure specifying sparse image memory bind

C Specification
The VkSparseImageMemoryBind structure is defined as:

typedef struct VkSparseImageMemoryBind {
    VkImageSubresource         subresource;
    VkOffset3D                 offset;
    VkExtent3D                 extent;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseImageMemoryBind;
Members
subresource is the image aspect and region of interest in the image.
offset are the coordinates of the first texel within the image subresource to bind.
extent is the size in texels of the region within the image subresource to bind. The extent must be a multiple of the sparse image block dimensions, except when binding sparse image blocks along the edge of an image subresource it can instead be such that any coordinate of offset + extent equals the corresponding dimensions of the image subresource.
memory is the VkDeviceMemory object that the sparse image blocks of the image are bound to. If memory is VK_NULL_HANDLE, the sparse image blocks are unbound.
memoryOffset is an offset into VkDeviceMemory object. If memory is VK_NULL_HANDLE, this value is ignored.
flags are sparse memory binding flags.
Description
Valid Usage
If the sparse aliased residency feature is not enabled, and if any other resources are bound to ranges of memory, the range of memory being bound must not overlap with those bound ranges
memory and memoryOffset must match the memory requirements of the calling command’s image, as described in section html/vkspec.html#resources-association
subresource must be a valid image subresource for image (see html/vkspec.html#resources-image-views)
offset.x must be a multiple of the sparse image block width (VkSparseImageFormatProperties::imageGranularity.width) of the image
extent.width must either be a multiple of the sparse image block width of the image, or else (extent.width + offset.x) must equal the width of the image subresource
offset.y must be a multiple of the sparse image block height (VkSparseImageFormatProperties::imageGranularity.height) of the image
extent.height must either be a multiple of the sparse image block height of the image, or else (extent.height + offset.y) must equal the height of the image subresource
offset.z must be a multiple of the sparse image block depth (VkSparseImageFormatProperties::imageGranularity.depth) of the image
extent.depth must either be a multiple of the sparse image block depth of the image, or else (extent.depth + offset.z) must equal the depth of the image subresource
Valid Usage (Implicit)
subresource must be a valid VkImageSubresource structure
If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle
flags must be a valid combination of VkSparseMemoryBindFlagBits values
See Also
VkDeviceMemory, VkDeviceSize, VkExtent3D, VkImageSubresource, VkOffset3D, VkSparseImageMemoryBindInfo, VkSparseMemoryBindFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSparseImageMemoryBind

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSparseImageMemoryBindInfo(3)
Name
VkSparseImageMemoryBindInfo - Structure specifying sparse image memory bind info

C Specification
Memory can be bound to sparse image blocks of VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag using the following structure:

typedef struct VkSparseImageMemoryBindInfo {
    VkImage                           image;
    uint32_t                          bindCount;
    const VkSparseImageMemoryBind*    pBinds;
} VkSparseImageMemoryBindInfo;
Members
image is the VkImage object to be bound
bindCount is the number of VkSparseImageMemoryBind structures in pBinds array
pBinds is a pointer to array of VkSparseImageMemoryBind structures
Description
Valid Usage
The subresource.mipLevel member of each element of pBinds must be less than the mipLevels specified in VkImageCreateInfo when image was created
The subresource.arrayLayer member of each element of pBinds must be less than the arrayLayers specified in VkImageCreateInfo when image was created
Valid Usage (Implicit)
image must be a valid VkImage handle
pBinds must be a valid pointer to an array of bindCount valid VkSparseImageMemoryBind structures
bindCount must be greater than 0
See Also
VkBindSparseInfo, VkImage, VkSparseImageMemoryBind

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSparseImageMemoryBindInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSparseImageMemoryRequirements(3)
Name
VkSparseImageMemoryRequirements - Structure specifying sparse image memory requirements

C Specification
The VkSparseImageMemoryRequirements structure is defined as:

typedef struct VkSparseImageMemoryRequirements {
    VkSparseImageFormatProperties    formatProperties;
    uint32_t                         imageMipTailFirstLod;
    VkDeviceSize                     imageMipTailSize;
    VkDeviceSize                     imageMipTailOffset;
    VkDeviceSize                     imageMipTailStride;
} VkSparseImageMemoryRequirements;
Members
formatProperties.aspectMask is the set of aspects of the image that this sparse memory requirement applies to. This will usually have a single aspect specified. However, depth/stencil images may have depth and stencil data interleaved in the same sparse block, in which case both VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT would be present.
formatProperties.imageGranularity describes the dimensions of a single bindable sparse image block in texel units. For aspect VK_IMAGE_ASPECT_METADATA_BIT, all dimensions will be zero. All metadata is located in the mip tail region.
formatProperties.flags is a bitmask of VkSparseImageFormatFlagBits:
If VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT is set the image uses a single mip tail region for all array layers.
If VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT is set the dimensions of mip levels must be integer multiples of the corresponding dimensions of the sparse image block for levels not located in the mip tail.
If VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT is set the image uses non-standard sparse image block dimensions. The formatProperties.imageGranularity values do not match the standard sparse image block dimension corresponding to the image’s format.
imageMipTailFirstLod is the first mip level at which image subresources are included in the mip tail region.
imageMipTailSize is the memory size (in bytes) of the mip tail region. If formatProperties.flags contains VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT, this is the size of the whole mip tail, otherwise this is the size of the mip tail of a single array layer. This value is guaranteed to be a multiple of the sparse block size in bytes.
imageMipTailOffset is the opaque memory offset used with VkSparseImageOpaqueMemoryBindInfo to bind the mip tail region(s).
imageMipTailStride is the offset stride between each array-layer’s mip tail, if formatProperties.flags does not contain VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT (otherwise the value is undefined).
Description
See Also
VkDeviceSize, VkSparseImageFormatProperties, VkSparseImageMemoryRequirements2, vkGetImageSparseMemoryRequirements

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSparseImageMemoryRequirements

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSparseImageMemoryRequirements2(3)
Name
VkSparseImageMemoryRequirements2 - (None)

C Specification
The VkSparseImageMemoryRequirements2 structure is defined as:

typedef struct VkSparseImageMemoryRequirements2 {
    VkStructureType                    sType;
    void*                              pNext;
    VkSparseImageMemoryRequirements    memoryRequirements;
} VkSparseImageMemoryRequirements2;
or the equivalent

typedef VkSparseImageMemoryRequirements2 VkSparseImageMemoryRequirements2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
memoryRequirements is a structure of type VkSparseImageMemoryRequirements describing the memory requirements of the sparse image.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2
pNext must be NULL
See Also
VkSparseImageMemoryRequirements, VkStructureType, vkGetImageSparseMemoryRequirements2, vkGetImageSparseMemoryRequirements2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSparseImageMemoryRequirements2

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSparseImageOpaqueMemoryBindInfo(3)
Name
VkSparseImageOpaqueMemoryBindInfo - Structure specifying sparse image opaque memory bind info

C Specification
Memory is bound to opaque regions of VkImage objects created with the VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag using the following structure:

typedef struct VkSparseImageOpaqueMemoryBindInfo {
    VkImage                      image;
    uint32_t                     bindCount;
    const VkSparseMemoryBind*    pBinds;
} VkSparseImageOpaqueMemoryBindInfo;
Members
image is the VkImage object to be bound.
bindCount is the number of VkSparseMemoryBind structures in the pBinds array.
pBinds is a pointer to array of VkSparseMemoryBind structures.
Description
Valid Usage
If the flags member of any element of pBinds contains VK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range defined must be within the mip tail region of the metadata aspect of image
Valid Usage (Implicit)
image must be a valid VkImage handle
pBinds must be a valid pointer to an array of bindCount valid VkSparseMemoryBind structures
bindCount must be greater than 0
See Also
VkBindSparseInfo, VkImage, VkSparseMemoryBind

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSparseImageOpaqueMemoryBindInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSparseMemoryBind(3)
Name
VkSparseMemoryBind - Structure specifying a sparse memory bind operation

C Specification
The VkSparseMemoryBind structure is defined as:

typedef struct VkSparseMemoryBind {
    VkDeviceSize               resourceOffset;
    VkDeviceSize               size;
    VkDeviceMemory             memory;
    VkDeviceSize               memoryOffset;
    VkSparseMemoryBindFlags    flags;
} VkSparseMemoryBind;
Members
resourceOffset is the offset into the resource.
size is the size of the memory region to be bound.
memory is the VkDeviceMemory object that the range of the resource is bound to. If memory is VK_NULL_HANDLE, the range is unbound.
memoryOffset is the offset into the VkDeviceMemory object to bind the resource range to. If memory is VK_NULL_HANDLE, this value is ignored.
flags is a bitmask of VkSparseMemoryBindFlagBits specifying usage of the binding operation.
Description
The binding range [resourceOffset, resourceOffset + size) has different constraints based on flags. If flags contains VK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range must be within the mip tail region of the metadata aspect. This metadata region is defined by:

:: [eq]#metadataRegion = [base, base {plus} pname:imageMipTailSize)#
:: [eq]#base = pname:imageMipTailOffset {plus} pname:imageMipTailStride
   {times} n#
and imageMipTailOffset, imageMipTailSize, and imageMipTailStride values are from the VkSparseImageMemoryRequirements corresponding to the metadata aspect of the image, and n is a valid array layer index for the image,

imageMipTailStride is considered to be zero for aspects where VkSparseImageMemoryRequirements::formatProperties.flags contains VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT.

If flags does not contain VK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range must be within the range [0,VkMemoryRequirements::size).

Valid Usage
If memory is not VK_NULL_HANDLE, memory and memoryOffset must match the memory requirements of the resource, as described in section html/vkspec.html#resources-association
If memory is not VK_NULL_HANDLE, memory must not have been created with a memory type that reports VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set
size must be greater than 0
resourceOffset must be less than the size of the resource
size must be less than or equal to the size of the resource minus resourceOffset
memoryOffset must be less than the size of memory
size must be less than or equal to the size of memory minus memoryOffset
Valid Usage (Implicit)
If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle
flags must be a valid combination of VkSparseMemoryBindFlagBits values
See Also
VkDeviceMemory, VkDeviceSize, VkSparseBufferMemoryBindInfo, VkSparseImageOpaqueMemoryBindInfo, VkSparseMemoryBindFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSparseMemoryBind

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSpecializationInfo(3)
Name
VkSpecializationInfo - Structure specifying specialization info

C Specification
The VkSpecializationInfo structure is defined as:

typedef struct VkSpecializationInfo {
    uint32_t                           mapEntryCount;
    const VkSpecializationMapEntry*    pMapEntries;
    size_t                             dataSize;
    const void*                        pData;
} VkSpecializationInfo;
Members
mapEntryCount is the number of entries in the pMapEntries array.
pMapEntries is a pointer to an array of VkSpecializationMapEntry which maps constant IDs to offsets in pData.
dataSize is the byte size of the pData buffer.
pData contains the actual constant values to specialize with.
Description
pMapEntries points to a structure of type VkSpecializationMapEntry.

Valid Usage
The offset member of each element of pMapEntries must be less than dataSize
The size member of each element of pMapEntries must be less than or equal to dataSize minus offset
Valid Usage (Implicit)
If mapEntryCount is not 0, pMapEntries must be a valid pointer to an array of mapEntryCount valid VkSpecializationMapEntry structures
If dataSize is not 0, pData must be a valid pointer to an array of dataSize bytes
See Also
VkPipelineShaderStageCreateInfo, VkSpecializationMapEntry

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSpecializationInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSpecializationMapEntry(3)
Name
VkSpecializationMapEntry - Structure specifying a specialization map entry

C Specification
The VkSpecializationMapEntry structure is defined as:

typedef struct VkSpecializationMapEntry {
    uint32_t    constantID;
    uint32_t    offset;
    size_t      size;
} VkSpecializationMapEntry;
Members
constantID is the ID of the specialization constant in SPIR-V.
offset is the byte offset of the specialization constant value within the supplied data buffer.
size is the byte size of the specialization constant value within the supplied data buffer.
Description
If a constantID value is not a specialization constant ID used in the shader, that map entry does not affect the behavior of the pipeline.

Valid Usage
For a constantID specialization constant declared in a shader, size must match the byte size of the constantID. If the specialization constant is of type boolean, size must be the byte size of VkBool32
See Also
VkSpecializationInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSpecializationMapEntry

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkStencilOpState(3)
Name
VkStencilOpState - Structure specifying stencil operation state

C Specification
The VkStencilOpState structure is defined as:

typedef struct VkStencilOpState {
    VkStencilOp    failOp;
    VkStencilOp    passOp;
    VkStencilOp    depthFailOp;
    VkCompareOp    compareOp;
    uint32_t       compareMask;
    uint32_t       writeMask;
    uint32_t       reference;
} VkStencilOpState;
Members
failOp is a VkStencilOp value specifying the action performed on samples that fail the stencil test.
passOp is a VkStencilOp value specifying the action performed on samples that pass both the depth and stencil tests.
depthFailOp is a VkStencilOp value specifying the action performed on samples that pass the stencil test and fail the depth test.
compareOp is a VkCompareOp value specifying the comparison operator used in the stencil test.
compareMask selects the bits of the unsigned integer stencil values participating in the stencil test.
writeMask selects the bits of the unsigned integer stencil values updated by the stencil test in the stencil framebuffer attachment.
reference is an integer reference value that is used in the unsigned stencil comparison.
Description
Valid Usage (Implicit)
failOp must be a valid VkStencilOp value
passOp must be a valid VkStencilOp value
depthFailOp must be a valid VkStencilOp value
compareOp must be a valid VkCompareOp value
See Also
VkCompareOp, VkPipelineDepthStencilStateCreateInfo, VkStencilOp

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkStencilOpState

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkStreamDescriptorSurfaceCreateInfoGGP(3)
Name
VkStreamDescriptorSurfaceCreateInfoGGP - Structure specifying parameters of a newly created Google Games Platform stream surface object

C Specification
The VkStreamDescriptorSurfaceCreateInfoGGP structure is defined as:

typedef struct VkStreamDescriptorSurfaceCreateInfoGGP {
    VkStructureType                            sType;
    const void*                                pNext;
    VkStreamDescriptorSurfaceCreateFlagsGGP    flags;
    GgpStreamDescriptor                        streamDescriptor;
} VkStreamDescriptorSurfaceCreateInfoGGP;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
streamDescriptor is a GgpStreamDescriptor referring to the GGP stream descriptor to associate with the surface.
Description
Valid Usage
streamDescriptor must be a valid GgpStreamDescriptor
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP
pNext must be NULL
flags must be 0
See Also
VkStreamDescriptorSurfaceCreateFlagsGGP, VkStructureType, vkCreateStreamDescriptorSurfaceGGP

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkStreamDescriptorSurfaceCreateInfoGGP

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubmitInfo(3)
Name
VkSubmitInfo - Structure specifying a queue submit operation

C Specification
The VkSubmitInfo structure is defined as:

typedef struct VkSubmitInfo {
    VkStructureType                sType;
    const void*                    pNext;
    uint32_t                       waitSemaphoreCount;
    const VkSemaphore*             pWaitSemaphores;
    const VkPipelineStageFlags*    pWaitDstStageMask;
    uint32_t                       commandBufferCount;
    const VkCommandBuffer*         pCommandBuffers;
    uint32_t                       signalSemaphoreCount;
    const VkSemaphore*             pSignalSemaphores;
} VkSubmitInfo;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
waitSemaphoreCount is the number of semaphores upon which to wait before executing the command buffers for the batch.
pWaitSemaphores is a pointer to an array of semaphores upon which to wait before the command buffers for this batch begin execution. If semaphores to wait on are provided, they define a semaphore wait operation.
pWaitDstStageMask is a pointer to an array of pipeline stages at which each corresponding semaphore wait will occur.
commandBufferCount is the number of command buffers to execute in the batch.
pCommandBuffers is a pointer to an array of command buffers to execute in the batch.
signalSemaphoreCount is the number of semaphores to be signaled once the commands specified in pCommandBuffers have completed execution.
pSignalSemaphores is a pointer to an array of semaphores which will be signaled when the command buffers for this batch have completed execution. If semaphores to be signaled are provided, they define a semaphore signal operation.
Description
The order that command buffers appear in pCommandBuffers is used to determine submission order, and thus all the implicit ordering guarantees that respect it. Other than these implicit ordering guarantees and any explicit synchronization primitives, these command buffers may overlap or otherwise execute out of order.

Valid Usage
Each element of pCommandBuffers must not have been allocated with VK_COMMAND_BUFFER_LEVEL_SECONDARY
If the geometry shaders feature is not enabled, each element of pWaitDstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
If the tessellation shaders feature is not enabled, each element of pWaitDstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
Each element of pWaitDstStageMask must not include VK_PIPELINE_STAGE_HOST_BIT.
If the mesh shaders feature is not enabled, each element of pWaitDstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
If the task shaders feature is not enabled, each element of pWaitDstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SUBMIT_INFO
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkD3D12FenceSubmitInfoKHR, VkDeviceGroupSubmitInfo, VkProtectedSubmitInfo, VkWin32KeyedMutexAcquireReleaseInfoKHR, or VkWin32KeyedMutexAcquireReleaseInfoNV
Each sType member in the pNext chain must be unique
If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles
If waitSemaphoreCount is not 0, pWaitDstStageMask must be a valid pointer to an array of waitSemaphoreCount valid combinations of VkPipelineStageFlagBits values
Each element of pWaitDstStageMask must not be 0
If commandBufferCount is not 0, pCommandBuffers must be a valid pointer to an array of commandBufferCount valid VkCommandBuffer handles
If signalSemaphoreCount is not 0, pSignalSemaphores must be a valid pointer to an array of signalSemaphoreCount valid VkSemaphore handles
Each of the elements of pCommandBuffers, the elements of pSignalSemaphores, and the elements of pWaitSemaphores that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkCommandBuffer, VkPipelineStageFlags, VkSemaphore, VkStructureType, vkQueueSubmit

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubmitInfo

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubpassBeginInfoKHR(3)
Name
VkSubpassBeginInfoKHR - Structure specifying subpass begin info

C Specification
The VkSubpassBeginInfoKHR structure is defined as:

typedef struct VkSubpassBeginInfoKHR {
    VkStructureType      sType;
    const void*          pNext;
    VkSubpassContents    contents;
} VkSubpassBeginInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
contents is a VkSubpassContents value specifying how the commands in the next subpass will be provided.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR
pNext must be NULL
contents must be a valid VkSubpassContents value
See Also
VkStructureType, VkSubpassContents, vkCmdBeginRenderPass2KHR, vkCmdNextSubpass2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubpassBeginInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubpassDependency(3)
Name
VkSubpassDependency - Structure specifying a subpass dependency

C Specification
The VkSubpassDependency structure is defined as:

typedef struct VkSubpassDependency {
    uint32_t                srcSubpass;
    uint32_t                dstSubpass;
    VkPipelineStageFlags    srcStageMask;
    VkPipelineStageFlags    dstStageMask;
    VkAccessFlags           srcAccessMask;
    VkAccessFlags           dstAccessMask;
    VkDependencyFlags       dependencyFlags;
} VkSubpassDependency;
Members
srcSubpass is the subpass index of the first subpass in the dependency, or VK_SUBPASS_EXTERNAL.
dstSubpass is the subpass index of the second subpass in the dependency, or VK_SUBPASS_EXTERNAL.
srcStageMask is a bitmask of VkPipelineStageFlagBits specifying the source stage mask.
dstStageMask is a bitmask of VkPipelineStageFlagBits specifying the destination stage mask
srcAccessMask is a bitmask of VkAccessFlagBits specifying a source access mask.
dstAccessMask is a bitmask of VkAccessFlagBits specifying a destination access mask.
dependencyFlags is a bitmask of VkDependencyFlagBits.
Description
If srcSubpass is equal to dstSubpass then the VkSubpassDependency describes a subpass self-dependency, and only constrains the pipeline barriers allowed within a subpass instance. Otherwise, when a render pass instance which includes a subpass dependency is submitted to a queue, it defines a memory dependency between the subpasses identified by srcSubpass and dstSubpass.

If srcSubpass is equal to VK_SUBPASS_EXTERNAL, the first synchronization scope includes commands that occur earlier in submission order than the vkCmdBeginRenderPass used to begin the render pass instance. Otherwise, the first set of commands includes all commands submitted as part of the subpass instance identified by srcSubpass and any load, store or multisample resolve operations on attachments used in srcSubpass. In either case, the first synchronization scope is limited to operations on the pipeline stages determined by the source stage mask specified by srcStageMask.

If dstSubpass is equal to VK_SUBPASS_EXTERNAL, the second synchronization scope includes commands that occur later in submission order than the vkCmdEndRenderPass used to end the render pass instance. Otherwise, the second set of commands includes all commands submitted as part of the subpass instance identified by dstSubpass and any load, store or multisample resolve operations on attachments used in dstSubpass. In either case, the second synchronization scope is limited to operations on the pipeline stages determined by the destination stage mask specified by dstStageMask.

The first access scope is limited to access in the pipeline stages determined by the source stage mask specified by srcStageMask. It is also limited to access types in the source access mask specified by srcAccessMask.

The second access scope is limited to access in the pipeline stages determined by the destination stage mask specified by dstStageMask. It is also limited to access types in the destination access mask specified by dstAccessMask.

The availability and visibility operations defined by a subpass dependency affect the execution of image layout transitions within the render pass.

Note
For non-attachment resources, the memory dependency expressed by subpass dependency is nearly identical to that of a VkMemoryBarrier (with matching srcAccessMask/dstAccessMask parameters) submitted as a part of a vkCmdPipelineBarrier (with matching srcStageMask/dstStageMask parameters). The only difference being that its scopes are limited to the identified subpasses rather than potentially affecting everything before and after.

For attachments however, subpass dependencies work more like a VkImageMemoryBarrier defined similarly to the VkMemoryBarrier above, the queue family indices set to VK_QUEUE_FAMILY_IGNORED, and layouts as follows:

The equivalent to oldLayout is the attachment’s layout according to the subpass description for srcSubpass.
The equivalent to newLayout is the attachment’s layout according to the subpass description for dstSubpass.
Valid Usage
If srcSubpass is not VK_SUBPASS_EXTERNAL, srcStageMask must not include VK_PIPELINE_STAGE_HOST_BIT
If dstSubpass is not VK_SUBPASS_EXTERNAL, dstStageMask must not include VK_PIPELINE_STAGE_HOST_BIT
If the geometry shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
If the geometry shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
If the tessellation shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
If the tessellation shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
srcSubpass must be less than or equal to dstSubpass, unless one of them is VK_SUBPASS_EXTERNAL, to avoid cyclic dependencies and ensure a valid execution order
srcSubpass and dstSubpass must not both be equal to VK_SUBPASS_EXTERNAL
If srcSubpass is equal to dstSubpass, srcStageMask and dstStageMask must not set any bits that are neither VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, nor one of the graphics pipeline stages
If srcSubpass is equal to dstSubpass and not all of the stages in srcStageMask and dstStageMask are framebuffer-space stages, the logically latest pipeline stage in srcStageMask must be logically earlier than or equal to the logically earliest pipeline stage in dstStageMask
Any access flag included in srcAccessMask must be supported by one of the pipeline stages in srcStageMask, as specified in the table of supported access types
Any access flag included in dstAccessMask must be supported by one of the pipeline stages in dstStageMask, as specified in the table of supported access types
If srcSubpass equals dstSubpass, and srcStageMask and dstStageMask both include a framebuffer-space stage, then dependencyFlags must include VK_DEPENDENCY_BY_REGION_BIT
If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, srcSubpass must not be equal to VK_SUBPASS_EXTERNAL
If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, dstSubpass must not be equal to VK_SUBPASS_EXTERNAL
If srcSubpass equals dstSubpass and that subpass has more than one bit set in the view mask, then dependencyFlags must include VK_DEPENDENCY_VIEW_LOCAL_BIT
If the mesh shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
If the task shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
If the mesh shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
If the task shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
Valid Usage (Implicit)
srcStageMask must be a valid combination of VkPipelineStageFlagBits values
srcStageMask must not be 0
dstStageMask must be a valid combination of VkPipelineStageFlagBits values
dstStageMask must not be 0
srcAccessMask must be a valid combination of VkAccessFlagBits values
dstAccessMask must be a valid combination of VkAccessFlagBits values
dependencyFlags must be a valid combination of VkDependencyFlagBits values
See Also
VkAccessFlags, VkDependencyFlags, VkPipelineStageFlags, VkRenderPassCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubpassDependency

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubpassDependency2KHR(3)
Name
VkSubpassDependency2KHR - Structure specifying a subpass dependency

C Specification
The VkSubpassDependency2KHR structure is defined as:

typedef struct VkSubpassDependency2KHR {
    VkStructureType         sType;
    const void*             pNext;
    uint32_t                srcSubpass;
    uint32_t                dstSubpass;
    VkPipelineStageFlags    srcStageMask;
    VkPipelineStageFlags    dstStageMask;
    VkAccessFlags           srcAccessMask;
    VkAccessFlags           dstAccessMask;
    VkDependencyFlags       dependencyFlags;
    int32_t                 viewOffset;
} VkSubpassDependency2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
srcSubpass is the subpass index of the first subpass in the dependency, or VK_SUBPASS_EXTERNAL.
dstSubpass is the subpass index of the second subpass in the dependency, or VK_SUBPASS_EXTERNAL.
srcStageMask is a bitmask of VkPipelineStageFlagBits specifying the source stage mask.
dstStageMask is a bitmask of VkPipelineStageFlagBits specifying the destination stage mask
srcAccessMask is a bitmask of VkAccessFlagBits specifying a source access mask.
dstAccessMask is a bitmask of VkAccessFlagBits specifying a destination access mask.
dependencyFlags is a bitmask of VkDependencyFlagBits.
viewOffset controls which views in the source subpass the views in the destination subpass depend on.
Description
Parameters defined by this structure with the same name as those in VkSubpassDependency have the identical effect to those parameters.

viewOffset has the same effect for the described subpass dependency as VkRenderPassMultiviewCreateInfo::pViewOffsets has on each corresponding subpass dependency.

Valid Usage
If srcSubpass is not VK_SUBPASS_EXTERNAL, srcStageMask must not include VK_PIPELINE_STAGE_HOST_BIT
If dstSubpass is not VK_SUBPASS_EXTERNAL, dstStageMask must not include VK_PIPELINE_STAGE_HOST_BIT
If the geometry shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
If the geometry shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
If the tessellation shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
If the tessellation shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
srcSubpass must be less than or equal to dstSubpass, unless one of them is VK_SUBPASS_EXTERNAL, to avoid cyclic dependencies and ensure a valid execution order
srcSubpass and dstSubpass must not both be equal to VK_SUBPASS_EXTERNAL
If srcSubpass is equal to dstSubpass, srcStageMask and dstStageMask must not set any bits that are neither VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, nor one of the graphics pipeline stages
If srcSubpass is equal to dstSubpass and not all of the stages in srcStageMask and dstStageMask are framebuffer-space stages, the logically latest pipeline stage in srcStageMask must be logically earlier than or equal to the logically earliest pipeline stage in dstStageMask
Any access flag included in srcAccessMask must be supported by one of the pipeline stages in srcStageMask, as specified in the table of supported access types
Any access flag included in dstAccessMask must be supported by one of the pipeline stages in dstStageMask, as specified in the table of supported access types
If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, srcSubpass must not be equal to VK_SUBPASS_EXTERNAL
If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, dstSubpass must not be equal to VK_SUBPASS_EXTERNAL
If srcSubpass equals dstSubpass, and srcStageMask and dstStageMask both include a framebuffer-space stage, then dependencyFlags must include VK_DEPENDENCY_BY_REGION_BIT
If viewOffset is not equal to 0, srcSubpass must not be equal to dstSubpass
If dependencyFlags does not include VK_DEPENDENCY_VIEW_LOCAL_BIT, viewOffset must be 0
If viewOffset is not 0, srcSubpass must not be equal to dstSubpass.
If the mesh shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
If the task shaders feature is not enabled, srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
If the mesh shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
If the task shaders feature is not enabled, dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR
srcStageMask must be a valid combination of VkPipelineStageFlagBits values
srcStageMask must not be 0
dstStageMask must be a valid combination of VkPipelineStageFlagBits values
dstStageMask must not be 0
srcAccessMask must be a valid combination of VkAccessFlagBits values
dstAccessMask must be a valid combination of VkAccessFlagBits values
dependencyFlags must be a valid combination of VkDependencyFlagBits values
See Also
VkAccessFlags, VkDependencyFlags, VkPipelineStageFlags, VkRenderPassCreateInfo2KHR, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubpassDependency2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubpassDescription(3)
Name
VkSubpassDescription - Structure specifying a subpass description

C Specification
The VkSubpassDescription structure is defined as:

typedef struct VkSubpassDescription {
    VkSubpassDescriptionFlags       flags;
    VkPipelineBindPoint             pipelineBindPoint;
    uint32_t                        inputAttachmentCount;
    const VkAttachmentReference*    pInputAttachments;
    uint32_t                        colorAttachmentCount;
    const VkAttachmentReference*    pColorAttachments;
    const VkAttachmentReference*    pResolveAttachments;
    const VkAttachmentReference*    pDepthStencilAttachment;
    uint32_t                        preserveAttachmentCount;
    const uint32_t*                 pPreserveAttachments;
} VkSubpassDescription;
Members
flags is a bitmask of VkSubpassDescriptionFlagBits specifying usage of the subpass.
pipelineBindPoint is a VkPipelineBindPoint value specifying the pipeline type supported for this subpass.
inputAttachmentCount is the number of input attachments.
pInputAttachments is an array of VkAttachmentReference structures defining the input attachments for this subpass and their layouts.
colorAttachmentCount is the number of color attachments.
pColorAttachments is an array of VkAttachmentReference structures defining the color attachments for this subpass and their layouts.
pResolveAttachments is an optional array of colorAttachmentCount VkAttachmentReference structures defining the resolve attachments for this subpass and their layouts.
pDepthStencilAttachment is a pointer to a VkAttachmentReference specifying the depth/stencil attachment for this subpass and its layout.
preserveAttachmentCount is the number of preserved attachments.
pPreserveAttachments is an array of preserveAttachmentCount render pass attachment indices identifying attachments that are not used by this subpass, but whose contents must be preserved throughout the subpass.
Description
Each element of the pInputAttachments array corresponds to an input attachment index in a fragment shader, i.e. if a shader declares an image variable decorated with a InputAttachmentIndex value of X, then it uses the attachment provided in pInputAttachments[X]. Input attachments must also be bound to the pipeline in a descriptor set. If the attachment member of any element of pInputAttachments is VK_ATTACHMENT_UNUSED, the application must not read from the corresponding input attachment index. Fragment shaders can use subpass input variables to access the contents of an input attachment at the fragment’s (x, y, layer) framebuffer coordinates.

Each element of the pColorAttachments array corresponds to an output location in the shader, i.e. if the shader declares an output variable decorated with a Location value of X, then it uses the attachment provided in pColorAttachments[X]. If the attachment member of any element of pColorAttachments is VK_ATTACHMENT_UNUSED, writes to the corresponding location by a fragment are discarded.

If pResolveAttachments is not NULL, each of its elements corresponds to a color attachment (the element in pColorAttachments at the same index), and a multisample resolve operation is defined for each attachment. At the end of each subpass, multisample resolve operations read the subpass’s color attachments, and resolve the samples for each pixel to the same pixel location in the corresponding resolve attachments, unless the resolve attachment index is VK_ATTACHMENT_UNUSED.

Similarly, if VkSubpassDescriptionDepthStencilResolveKHR::pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, it corresponds to the depth/stencil attachment in pDepthStencilAttachment, and multisample resolve operations for depth and stencil are defined by VkSubpassDescriptionDepthStencilResolveKHR::depthResolveMode and VkSubpassDescriptionDepthStencilResolveKHR::stencilResolveMode, respectively. At the end of each subpass, multisample resolve operations read the subpass’s depth/stencil attachment, and resolve the samples for each pixel to the same pixel location in the corresponding resolve attachment. If VkSubpassDescriptionDepthStencilResolveKHR::depthResolveMode is VK_RESOLVE_MODE_NONE_KHR, then the depth component of the resolve attachment is not written to and its contents are preserved. Similarly, if VkSubpassDescriptionDepthStencilResolveKHR::stencilResolveMode is VK_RESOLVE_MODE_NONE_KHR, then the stencil component of the resolve attachment is not written to and its contents are preserved. VkSubpassDescriptionDepthStencilResolveKHR::depthResolveMode is ignored if the VkFormat of the pDepthStencilResolveAttachment does not have a depth component. Similarly, VkSubpassDescriptionDepthStencilResolveKHR::stencilResolveMode is ignored if the VkFormat of the pDepthStencilResolveAttachment does not have a stencil component.

If the image subresource range referenced by the depth/stencil attachment is created with VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT, then the multisample resolve operation uses the sample locations state specified in the sampleLocationsInfo member of the element of the VkRenderPassSampleLocationsBeginInfoEXT::pPostSubpassSampleLocations for the subpass.

If pDepthStencilAttachment is NULL, or if its attachment index is VK_ATTACHMENT_UNUSED, it indicates that no depth/stencil attachment will be used in the subpass.

The contents of an attachment within the render area become undefined at the start of a subpass S if all of the following conditions are true:

The attachment is used as a color, depth/stencil, or resolve attachment in any subpass in the render pass.
There is a subpass S1 that uses or preserves the attachment, and a subpass dependency from S1 to S.
The attachment is not used or preserved in subpass S.
Once the contents of an attachment become undefined in subpass S, they remain undefined for subpasses in subpass dependency chains starting with subpass S until they are written again. However, they remain valid for subpasses in other subpass dependency chains starting with subpass S1 if those subpasses use or preserve the attachment.

Valid Usage
pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS
colorAttachmentCount must be less than or equal to VkPhysicalDeviceLimits::maxColorAttachments
If the first use of an attachment in this render pass is as an input attachment, and the attachment is not also used as a color or depth/stencil attachment in the same subpass, then loadOp must not be VK_ATTACHMENT_LOAD_OP_CLEAR
If pResolveAttachments is not NULL, for each resolve attachment that is not VK_ATTACHMENT_UNUSED, the corresponding color attachment must not be VK_ATTACHMENT_UNUSED
If pResolveAttachments is not NULL, for each resolve attachment that is not VK_ATTACHMENT_UNUSED, the corresponding color attachment must not have a sample count of VK_SAMPLE_COUNT_1_BIT
If pResolveAttachments is not NULL, each resolve attachment that is not VK_ATTACHMENT_UNUSED must have a sample count of VK_SAMPLE_COUNT_1_BIT
If pResolveAttachments is not NULL, each resolve attachment that is not VK_ATTACHMENT_UNUSED must have the same VkFormat as its corresponding color attachment
All attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have the same sample count
All attachments in pInputAttachments that are not VK_ATTACHMENT_UNUSED must have formats whose features contain at least one of VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT.
All attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have formats whose features contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT
All attachments in pResolveAttachments that are not VK_ATTACHMENT_UNUSED must have formats whose features contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT
If pDepthStencilAttachment is not NULL and the attachment is not VK_ATTACHMENT_UNUSED then it must have a format whose features contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
If the VK_AMD_mixed_attachment_samples extension is enabled, and all attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have a sample count that is smaller than or equal to the sample count of pDepthStencilAttachment if it is not VK_ATTACHMENT_UNUSED
If neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, and if pDepthStencilAttachment is not VK_ATTACHMENT_UNUSED and any attachments in pColorAttachments are not VK_ATTACHMENT_UNUSED, they must have the same sample count
The attachment member of each element of pPreserveAttachments must not be VK_ATTACHMENT_UNUSED
Each element of pPreserveAttachments must not also be an element of any other member of the subpass description
If any attachment is used by more than one VkAttachmentReference member, then each use must use the same layout
If flags includes VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX, it must also include VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX.
Valid Usage (Implicit)
flags must be a valid combination of VkSubpassDescriptionFlagBits values
pipelineBindPoint must be a valid VkPipelineBindPoint value
If inputAttachmentCount is not 0, pInputAttachments must be a valid pointer to an array of inputAttachmentCount valid VkAttachmentReference structures
If colorAttachmentCount is not 0, pColorAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference structures
If colorAttachmentCount is not 0, and pResolveAttachments is not NULL, pResolveAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference structures
If pDepthStencilAttachment is not NULL, pDepthStencilAttachment must be a valid pointer to a valid VkAttachmentReference structure
If preserveAttachmentCount is not 0, pPreserveAttachments must be a valid pointer to an array of preserveAttachmentCount uint32_t values
See Also
VkAttachmentReference, VkPipelineBindPoint, VkRenderPassCreateInfo, VkSubpassDescriptionFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubpassDescription

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubpassDescription2KHR(3)
Name
VkSubpassDescription2KHR - Structure specifying a subpass description

C Specification
The VkSubpassDescription2KHR structure is defined as:

typedef struct VkSubpassDescription2KHR {
    VkStructureType                     sType;
    const void*                         pNext;
    VkSubpassDescriptionFlags           flags;
    VkPipelineBindPoint                 pipelineBindPoint;
    uint32_t                            viewMask;
    uint32_t                            inputAttachmentCount;
    const VkAttachmentReference2KHR*    pInputAttachments;
    uint32_t                            colorAttachmentCount;
    const VkAttachmentReference2KHR*    pColorAttachments;
    const VkAttachmentReference2KHR*    pResolveAttachments;
    const VkAttachmentReference2KHR*    pDepthStencilAttachment;
    uint32_t                            preserveAttachmentCount;
    const uint32_t*                     pPreserveAttachments;
} VkSubpassDescription2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkSubpassDescriptionFlagBits specifying usage of the subpass.
pipelineBindPoint is a VkPipelineBindPoint value specifying the pipeline type supported for this subpass.
viewMask is a bitfield of view indices describing which views rendering is broadcast to in this subpass, when multiview is enabled.
inputAttachmentCount is the number of input attachments.
pInputAttachments is an array of VkAttachmentReference2KHR structures defining the input attachments for this subpass and their layouts.
colorAttachmentCount is the number of color attachments.
pColorAttachments is an array of VkAttachmentReference2KHR structures defining the color attachments for this subpass and their layouts.
pResolveAttachments is an optional array of colorAttachmentCount VkAttachmentReference2KHR structures defining the resolve attachments for this subpass and their layouts.
pDepthStencilAttachment is a pointer to a VkAttachmentReference2KHR specifying the depth/stencil attachment for this subpass and its layout.
preserveAttachmentCount is the number of preserved attachments.
pPreserveAttachments is an array of preserveAttachmentCount render pass attachment indices identifying attachments that are not used by this subpass, but whose contents must be preserved throughout the subpass.
Description
Parameters defined by this structure with the same name as those in VkSubpassDescription have the identical effect to those parameters.

viewMask has the same effect for the described subpass as VkRenderPassMultiviewCreateInfo::pViewMasks has on each corresponding subpass.

Valid Usage
pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS
colorAttachmentCount must be less than or equal to VkPhysicalDeviceLimits::maxColorAttachments
If the first use of an attachment in this render pass is as an input attachment, and the attachment is not also used as a color or depth/stencil attachment in the same subpass, then loadOp must not be VK_ATTACHMENT_LOAD_OP_CLEAR
If pResolveAttachments is not NULL, for each resolve attachment that does not have the value VK_ATTACHMENT_UNUSED, the corresponding color attachment must not have the value VK_ATTACHMENT_UNUSED
If pResolveAttachments is not NULL, for each resolve attachment that is not VK_ATTACHMENT_UNUSED, the corresponding color attachment must not have a sample count of VK_SAMPLE_COUNT_1_BIT
If pResolveAttachments is not NULL, each resolve attachment that is not VK_ATTACHMENT_UNUSED must have a sample count of VK_SAMPLE_COUNT_1_BIT
Any given element of pResolveAttachments must have the same VkFormat as its corresponding color attachment
All attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have the same sample count
If the VK_AMD_mixed_attachment_samples extension is enabled, all attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have a sample count that is smaller than or equal to the sample count of pDepthStencilAttachment if it is not VK_ATTACHMENT_UNUSED
If neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, and if pDepthStencilAttachment is not VK_ATTACHMENT_UNUSED and any attachments in pColorAttachments are not VK_ATTACHMENT_UNUSED, they must have the same sample count
The attachment member of any element of pPreserveAttachments must not be VK_ATTACHMENT_UNUSED
Any given element of pPreserveAttachments must not also be an element of any other member of the subpass description
If any attachment is used by more than one VkAttachmentReference member, then each use must use the same layout
If flags includes VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX, it must also include VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX.
The aspectMask member of any element of pInputAttachments must be a valid combination of VkImageAspectFlagBits
The aspectMask member of any element of pInputAttachments must not be 0
The aspectMask member of each element of pInputAttachments must not include VK_IMAGE_ASPECT_METADATA_BIT
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR
flags must be a valid combination of VkSubpassDescriptionFlagBits values
pipelineBindPoint must be a valid VkPipelineBindPoint value
If inputAttachmentCount is not 0, pInputAttachments must be a valid pointer to an array of inputAttachmentCount valid VkAttachmentReference2KHR structures
If colorAttachmentCount is not 0, pColorAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference2KHR structures
If colorAttachmentCount is not 0, and pResolveAttachments is not NULL, pResolveAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference2KHR structures
If pDepthStencilAttachment is not NULL, pDepthStencilAttachment must be a valid pointer to a valid VkAttachmentReference2KHR structure
If preserveAttachmentCount is not 0, pPreserveAttachments must be a valid pointer to an array of preserveAttachmentCount uint32_t values
See Also
VkAttachmentReference2KHR, VkPipelineBindPoint, VkRenderPassCreateInfo2KHR, VkStructureType, VkSubpassDescriptionFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubpassDescription2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubpassDescriptionDepthStencilResolveKHR(3)
Name
VkSubpassDescriptionDepthStencilResolveKHR - Structure specifying depth/stencil resolve operations for a subpass

C Specification
If the pNext list of VkSubpassDescription2KHR includes a VkSubpassDescriptionDepthStencilResolveKHR structure, then that structure describes multisample resolve operations for the depth/stencil attachment in a subpass.

The VkSubpassDescriptionDepthStencilResolveKHR structure is defined as:

typedef struct VkSubpassDescriptionDepthStencilResolveKHR {
    VkStructureType                     sType;
    const void*                         pNext;
    VkResolveModeFlagBitsKHR            depthResolveMode;
    VkResolveModeFlagBitsKHR            stencilResolveMode;
    const VkAttachmentReference2KHR*    pDepthStencilResolveAttachment;
} VkSubpassDescriptionDepthStencilResolveKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
depthResolveMode is a bitmask of VkResolveModeFlagBitsKHR describing the depth resolve mode.
stencilResolveMode is a bitmask of VkResolveModeFlagBitsKHR describing the stencil resolve mode.
pDepthStencilResolveAttachment is an optional VkAttachmentReference structure defining the depth/stencil resolve attachment for this subpass and its layout.
Description
Valid Usage
If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, pDepthStencilAttachment must not have the value VK_ATTACHMENT_UNUSED
If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, depthResolveMode and stencilResolveMode must not both be VK_RESOLVE_MODE_NONE_KHR
If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, pDepthStencilAttachment must not have a sample count of VK_SAMPLE_COUNT_1_BIT
If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, pDepthStencilResolveAttachment must have a sample count of VK_SAMPLE_COUNT_1_BIT
If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED then it must have a format whose features contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
If the VkFormat of pDepthStencilResolveAttachment has a depth component, then the VkFormat of pDepthStencilAttachment must have a depth component with the same number of bits and numerical type
If the VkFormat of pDepthStencilResolveAttachment has a stencil component, then the VkFormat of pDepthStencilAttachment must have a stencil component with the same number of bits and numerical type
The value of depthResolveMode must be one of the bits set in VkPhysicalDeviceDepthStencilResolvePropertiesKHR::supportedDepthResolveModes or VK_RESOLVE_MODE_NONE_KHR
The value of stencilResolveMode must be one of the bits set in VkPhysicalDeviceDepthStencilResolvePropertiesKHR::supportedStencilResolveModes or VK_RESOLVE_MODE_NONE_KHR
If the VkFormat of pDepthStencilResolveAttachment has both depth and stencil components, VkPhysicalDeviceDepthStencilResolvePropertiesKHR::independentResolve is VK_FALSE, and VkPhysicalDeviceDepthStencilResolvePropertiesKHR::independentResolveNone is VK_FALSE, then the values of depthResolveMode and stencilResolveMode must be identical
If the VkFormat of pDepthStencilResolveAttachment has both depth and stencil components, VkPhysicalDeviceDepthStencilResolvePropertiesKHR::independentResolve is VK_FALSE and VkPhysicalDeviceDepthStencilResolvePropertiesKHR::independentResolveNone is VK_TRUE, then the values of depthResolveMode and stencilResolveMode must be identical or one of them must be VK_RESOLVE_MODE_NONE_KHR
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR
depthResolveMode must be a valid VkResolveModeFlagBitsKHR value
stencilResolveMode must be a valid VkResolveModeFlagBitsKHR value
If pDepthStencilResolveAttachment is not NULL, pDepthStencilResolveAttachment must be a valid pointer to a valid VkAttachmentReference2KHR structure
See Also
VkAttachmentReference2KHR, VkResolveModeFlagBitsKHR, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubpassDescriptionDepthStencilResolveKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubpassEndInfoKHR(3)
Name
VkSubpassEndInfoKHR - Structure specifying subpass end info

C Specification
The VkSubpassEndInfoKHR structure is defined as:

typedef struct VkSubpassEndInfoKHR {
    VkStructureType    sType;
    const void*        pNext;
} VkSubpassEndInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR
pNext must be NULL
See Also
VkStructureType, vkCmdEndRenderPass2KHR, vkCmdNextSubpass2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubpassEndInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubpassSampleLocationsEXT(3)
Name
VkSubpassSampleLocationsEXT - Structure specifying the sample locations state to use for layout transitions of attachments performed after a given subpass

C Specification
The VkSubpassSampleLocationsEXT structure is defined as:

typedef struct VkSubpassSampleLocationsEXT {
    uint32_t                    subpassIndex;
    VkSampleLocationsInfoEXT    sampleLocationsInfo;
} VkSubpassSampleLocationsEXT;
Members
subpassIndex is the index of the subpass for which the sample locations state is provided.
sampleLocationsInfo is the sample locations state to use for the layout transition of the depth/stencil attachment away from the image layout the attachment is used with in the subpass specified in subpassIndex.
Description
If the image referenced by the depth/stencil attachment used in the subpass identified by subpassIndex was not created with VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT or if the subpass does not use a depth/stencil attachment, and VkPhysicalDeviceSampleLocationsPropertiesEXT::variableSampleLocations is VK_TRUE then the values specified in sampleLocationsInfo are ignored.

Valid Usage
subpassIndex must be less than the subpassCount specified in VkRenderPassCreateInfo the render pass specified by VkRenderPassBeginInfo::renderPass was created with
Valid Usage (Implicit)
sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure
See Also
VkRenderPassSampleLocationsBeginInfoEXT, VkSampleLocationsInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubpassSampleLocationsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubresourceLayout(3)
Name
VkSubresourceLayout - Structure specifying subresource layout

C Specification
Information about the layout of the image subresource is returned in a VkSubresourceLayout structure:

typedef struct VkSubresourceLayout {
    VkDeviceSize    offset;
    VkDeviceSize    size;
    VkDeviceSize    rowPitch;
    VkDeviceSize    arrayPitch;
    VkDeviceSize    depthPitch;
} VkSubresourceLayout;
Members
offset is the byte offset from the start of the image or the plane where the image subresource begins.
size is the size in bytes of the image subresource. size includes any extra memory that is required based on rowPitch.
rowPitch describes the number of bytes between each row of texels in an image.
arrayPitch describes the number of bytes between each array layer of an image.
depthPitch describes the number of bytes between each slice of 3D image.
Description
If the image is linear, then rowPitch, arrayPitch and depthPitch describe the layout of the image subresource in linear memory. For uncompressed formats, rowPitch is the number of bytes between texels with the same x coordinate in adjacent rows (y coordinates differ by one). arrayPitch is the number of bytes between texels with the same x and y coordinate in adjacent array layers of the image (array layer values differ by one). depthPitch is the number of bytes between texels with the same x and y coordinate in adjacent slices of a 3D image (z coordinates differ by one). Expressed as an addressing formula, the starting byte of a texel in the image subresource has address:

// (x,y,z,layer) are in texel coordinates
address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*elementSize + offset
For compressed formats, the rowPitch is the number of bytes between compressed texel blocks in adjacent rows. arrayPitch is the number of bytes between compressed texel blocks in adjacent array layers. depthPitch is the number of bytes between compressed texel blocks in adjacent slices of a 3D image.

// (x,y,z,layer) are in compressed texel block coordinates
address(x,y,z,layer) = layer*arrayPitch + z*depthPitch + y*rowPitch + x*compressedTexelBlockByteSize + offset;
The value of arrayPitch is undefined for images that were not created as arrays. depthPitch is defined only for 3D images.

If the image has a single-plane color format and its tiling is VK_IMAGE_TILING_LINEAR , then the aspectMask member of VkImageSubresource must be VK_IMAGE_ASPECT_COLOR_BIT.

If the image has a depth/stencil format and its tiling is VK_IMAGE_TILING_LINEAR , then aspectMask must be either VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT. On implementations that store depth and stencil aspects separately, querying each of these image subresource layouts will return a different offset and size representing the region of memory used for that aspect. On implementations that store depth and stencil aspects interleaved, the same offset and size are returned and represent the interleaved memory allocation.

If the image has a multi-planar format and its tiling is VK_IMAGE_TILING_LINEAR , then the aspectMask member of VkImageSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or (for 3-plane formats only) VK_IMAGE_ASPECT_PLANE_2_BIT. Querying each of these image subresource layouts will return a different offset and size representing the region of memory used for that plane. If the image is disjoint, then the offset is relative to the base address of the plane. If the image is non-disjoint, then the offset is relative to the base address of the image.

If the image’s tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the aspectMask member of VkImageSubresource must be one of VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT, where the maximum allowed plane index i is defined by the drmFormatModifierPlaneCount associated with the image’s format and modifier. The memory range used by the subresource is described by offset and size. If the image is disjoint, then the offset is relative to the base address of the memory plane. If the image is non-disjoint, then the offset is relative to the base address of the image. If the image is non-linear, then rowPitch, arrayPitch, and depthPitch have an implementation-dependent meaning.

See Also
VkDeviceSize, VkImageDrmFormatModifierExplicitCreateInfoEXT, vkGetImageSubresourceLayout

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubresourceLayout

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceCapabilities2EXT(3)
Name
VkSurfaceCapabilities2EXT - Structure describing capabilities of a surface

C Specification
The VkSurfaceCapabilities2EXT structure is defined as:

typedef struct VkSurfaceCapabilities2EXT {
    VkStructureType                  sType;
    void*                            pNext;
    uint32_t                         minImageCount;
    uint32_t                         maxImageCount;
    VkExtent2D                       currentExtent;
    VkExtent2D                       minImageExtent;
    VkExtent2D                       maxImageExtent;
    uint32_t                         maxImageArrayLayers;
    VkSurfaceTransformFlagsKHR       supportedTransforms;
    VkSurfaceTransformFlagBitsKHR    currentTransform;
    VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    VkImageUsageFlags                supportedUsageFlags;
    VkSurfaceCounterFlagsEXT         supportedSurfaceCounters;
} VkSurfaceCapabilities2EXT;
Members
All members of VkSurfaceCapabilities2EXT are identical to the corresponding members of VkSurfaceCapabilitiesKHR where one exists. The remaining members are:

Description
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
supportedSurfaceCounters is a bitmask of VkSurfaceCounterFlagBitsEXT indicating the supported surface counter types.
Valid Usage
supportedSurfaceCounters must not include VK_SURFACE_COUNTER_VBLANK_EXT unless the surface queried is a display surface.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT
pNext must be NULL
See Also
VkCompositeAlphaFlagsKHR, VkExtent2D, VkImageUsageFlags, VkStructureType, VkSurfaceCounterFlagsEXT, VkSurfaceTransformFlagBitsKHR, VkSurfaceTransformFlagsKHR, vkGetPhysicalDeviceSurfaceCapabilities2EXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceCapabilities2EXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceCapabilities2KHR(3)
Name
VkSurfaceCapabilities2KHR - Structure describing capabilities of a surface

C Specification
The VkSurfaceCapabilities2KHR structure is defined as:

typedef struct VkSurfaceCapabilities2KHR {
    VkStructureType             sType;
    void*                       pNext;
    VkSurfaceCapabilitiesKHR    surfaceCapabilities;
} VkSurfaceCapabilities2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
surfaceCapabilities is a structure of type VkSurfaceCapabilitiesKHR describing the capabilities of the specified surface.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDisplayNativeHdrSurfaceCapabilitiesAMD, VkSharedPresentSurfaceCapabilitiesKHR, VkSurfaceCapabilitiesFullScreenExclusiveEXT, or VkSurfaceProtectedCapabilitiesKHR
Each sType member in the pNext chain must be unique
See Also
VkStructureType, VkSurfaceCapabilitiesKHR, vkGetPhysicalDeviceSurfaceCapabilities2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceCapabilities2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceCapabilitiesFullScreenExclusiveEXT(3)
Name
VkSurfaceCapabilitiesFullScreenExclusiveEXT - Structure describing full screen exclusive capabilities of a surface

C Specification
The VkSurfaceCapabilitiesFullScreenExclusiveEXT structure is defined as:

typedef struct VkSurfaceCapabilitiesFullScreenExclusiveEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           fullScreenExclusiveSupported;
} VkSurfaceCapabilitiesFullScreenExclusiveEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
fullScreenExclusiveControlSupported is a boolean describing whether the surface is able to make use of exclusive full-screen access.
Description
This structure can be included in the pNext chain of VkSurfaceCapabilities2KHR to determine support for exclusive full-screen access. If fullScreenExclusiveSupported is VK_FALSE, it indicates that exclusive full-screen access is not obtainable for this surface.

Applications must not attempt to create swapchains with VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT set if fullScreenExclusiveSupported is VK_FALSE.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceCapabilitiesFullScreenExclusiveEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceCapabilitiesKHR(3)
Name
VkSurfaceCapabilitiesKHR - Structure describing capabilities of a surface

C Specification
The VkSurfaceCapabilitiesKHR structure is defined as:

typedef struct VkSurfaceCapabilitiesKHR {
    uint32_t                         minImageCount;
    uint32_t                         maxImageCount;
    VkExtent2D                       currentExtent;
    VkExtent2D                       minImageExtent;
    VkExtent2D                       maxImageExtent;
    uint32_t                         maxImageArrayLayers;
    VkSurfaceTransformFlagsKHR       supportedTransforms;
    VkSurfaceTransformFlagBitsKHR    currentTransform;
    VkCompositeAlphaFlagsKHR         supportedCompositeAlpha;
    VkImageUsageFlags                supportedUsageFlags;
} VkSurfaceCapabilitiesKHR;
Members
minImageCount is the minimum number of images the specified device supports for a swapchain created for the surface, and will be at least one.
maxImageCount is the maximum number of images the specified device supports for a swapchain created for the surface, and will be either 0, or greater than or equal to minImageCount. A value of 0 means that there is no limit on the number of images, though there may be limits related to the total amount of memory used by presentable images.
currentExtent is the current width and height of the surface, or the special value (0xFFFFFFFF, 0xFFFFFFFF) indicating that the surface size will be determined by the extent of a swapchain targeting the surface.
minImageExtent contains the smallest valid swapchain extent for the surface on the specified device. The width and height of the extent will each be less than or equal to the corresponding width and height of currentExtent, unless currentExtent has the special value described above.
maxImageExtent contains the largest valid swapchain extent for the surface on the specified device. The width and height of the extent will each be greater than or equal to the corresponding width and height of minImageExtent. The width and height of the extent will each be greater than or equal to the corresponding width and height of currentExtent, unless currentExtent has the special value described above.
maxImageArrayLayers is the maximum number of layers presentable images can have for a swapchain created for this device and surface, and will be at least one.
supportedTransforms is a bitmask of VkSurfaceTransformFlagBitsKHR indicating the presentation transforms supported for the surface on the specified device. At least one bit will be set.
currentTransform is VkSurfaceTransformFlagBitsKHR value indicating the surface’s current transform relative to the presentation engine’s natural orientation.
supportedCompositeAlpha is a bitmask of VkCompositeAlphaFlagBitsKHR, representing the alpha compositing modes supported by the presentation engine for the surface on the specified device, and at least one bit will be set. Opaque composition can be achieved in any alpha compositing mode by either using an image format that has no alpha component, or by ensuring that all pixels in the presentable images have an alpha value of 1.0.
supportedUsageFlags is a bitmask of VkImageUsageFlagBits representing the ways the application can use the presentable images of a swapchain created with VkPresentModeKHR set to VK_PRESENT_MODE_IMMEDIATE_KHR, VK_PRESENT_MODE_MAILBOX_KHR, VK_PRESENT_MODE_FIFO_KHR or VK_PRESENT_MODE_FIFO_RELAXED_KHR for the surface on the specified device. VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT must be included in the set but implementations may support additional usages.
Description
Note
Supported usage flags of a presentable image when using VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR presentation mode are provided by VkSharedPresentSurfaceCapabilitiesKHR::sharedPresentSupportedUsageFlags.
Note
Formulas such as min(N, maxImageCount) are not correct, since maxImageCount may be zero.
See Also
VkCompositeAlphaFlagsKHR, VkExtent2D, VkImageUsageFlags, VkSurfaceCapabilities2KHR, VkSurfaceTransformFlagBitsKHR, VkSurfaceTransformFlagsKHR, vkGetPhysicalDeviceSurfaceCapabilitiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceCapabilitiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceFormat2KHR(3)
Name
VkSurfaceFormat2KHR - Structure describing a supported swapchain format tuple

C Specification
The VkSurfaceFormat2KHR structure is defined as:

typedef struct VkSurfaceFormat2KHR {
    VkStructureType       sType;
    void*                 pNext;
    VkSurfaceFormatKHR    surfaceFormat;
} VkSurfaceFormat2KHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
surfaceFormat is an instance of VkSurfaceFormatKHR describing a format-color space pair that is compatible with the specified surface.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR
pNext must be NULL
See Also
VkStructureType, VkSurfaceFormatKHR, vkGetPhysicalDeviceSurfaceFormats2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceFormat2KHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceFormatKHR(3)
Name
VkSurfaceFormatKHR - Structure describing a supported swapchain format-color space pair

C Specification
The VkSurfaceFormatKHR structure is defined as:

typedef struct VkSurfaceFormatKHR {
    VkFormat           format;
    VkColorSpaceKHR    colorSpace;
} VkSurfaceFormatKHR;
Members
format is a VkFormat that is compatible with the specified surface.
colorSpace is a presentation VkColorSpaceKHR that is compatible with the surface.
Description
See Also
VkColorSpaceKHR, VkFormat, VkSurfaceFormat2KHR, vkGetPhysicalDeviceSurfaceFormatsKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceFormatKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceFullScreenExclusiveInfoEXT(3)
Name
VkSurfaceFullScreenExclusiveInfoEXT - Structure specifying the preferred full-screen transition behavior

C Specification
If the pNext chain of VkSwapchainCreateInfoKHR includes a VkSurfaceFullScreenExclusiveInfoEXT structure, then that structure specifies the application’s preferred full-screen transition behavior.

The VkSurfaceFullScreenExclusiveInfoEXT structure is defined as:

typedef struct VkSurfaceFullScreenExclusiveInfoEXT {
    VkStructureType             sType;
    void*                       pNext;
    VkFullScreenExclusiveEXT    fullScreenExclusive;
} VkSurfaceFullScreenExclusiveInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
fullScreenExclusive is a VkFullScreenExclusiveEXT value specifying the preferred full-screen transition behavior.
Description
If this structure is not present, fullScreenExclusive is considered to be VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT
fullScreenExclusive must be a valid VkFullScreenExclusiveEXT value
See Also
VkFullScreenExclusiveEXT, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceFullScreenExclusiveInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceFullScreenExclusiveWin32InfoEXT(3)
Name
VkSurfaceFullScreenExclusiveWin32InfoEXT - Structure specifying additional creation parameters specific to Win32 fullscreen exclusive mode

C Specification
The VkSurfaceFullScreenExclusiveWin32InfoEXT structure is defined as:

typedef struct VkSurfaceFullScreenExclusiveWin32InfoEXT {
    VkStructureType    sType;
    const void*        pNext;
    HMONITOR           hmonitor;
} VkSurfaceFullScreenExclusiveWin32InfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
hmonitor is the Win32 HMONITOR handle identifying the display to create the surface with.
Description
Note
If hmonitor is invalidated (e.g. the monitor is unplugged) during the lifetime of a swapchain created with this structure, operations on that swapchain will return VK_ERROR_OUT_OF_DATE_KHR.
Note
It’s the responsibility of the application to change the display settings of the targeted Win32 display using the appropriate platform APIs. Such changes may alter the surface capabilities reported for the created surface.
Valid Usage
hmonitor must be a valid HMONITOR
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceFullScreenExclusiveWin32InfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceProtectedCapabilitiesKHR(3)
Name
VkSurfaceProtectedCapabilitiesKHR - Structure describing capability of a surface to be protected

C Specification
An application queries if a protected VkSurface is displayable on a specific windowing system using VkSurfaceProtectedCapabilitiesKHR, which can be passed in pNext parameter of VkSurfaceCapabilities2KHR.

The VkSurfaceProtectedCapabilitiesKHR structure is defined as:

typedef struct VkSurfaceProtectedCapabilitiesKHR {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           supportsProtected;
} VkSurfaceProtectedCapabilitiesKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
supportsProtected specifies whether a protected swapchain created from VkPhysicalDeviceSurfaceInfo2KHR::surface for a particular windowing system can be displayed on screen or not. If supportsProtected is VK_TRUE, then creation of swapchains with the VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR flag set must be supported for surface.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceProtectedCapabilitiesKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSwapchainCounterCreateInfoEXT(3)
Name
VkSwapchainCounterCreateInfoEXT - Specify the surface counters desired

C Specification
To enable surface counters when creating a swapchain, add VkSwapchainCounterCreateInfoEXT to the pNext chain of VkSwapchainCreateInfoKHR. VkSwapchainCounterCreateInfoEXT is defined as:

typedef struct VkSwapchainCounterCreateInfoEXT {
    VkStructureType             sType;
    const void*                 pNext;
    VkSurfaceCounterFlagsEXT    surfaceCounters;
} VkSwapchainCounterCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
surfaceCounters is a bitmask of VkSurfaceCounterFlagBitsEXT specifying surface counters to enable for the swapchain.
Description
Valid Usage
The bits in surfaceCounters must be supported by VkSwapchainCreateInfoKHR::surface, as reported by vkGetPhysicalDeviceSurfaceCapabilities2EXT.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT
surfaceCounters must be a valid combination of VkSurfaceCounterFlagBitsEXT values
See Also
VkStructureType, VkSurfaceCounterFlagsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSwapchainCounterCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSwapchainCreateInfoKHR(3)
Name
VkSwapchainCreateInfoKHR - Structure specifying parameters of a newly created swapchain object

C Specification
The VkSwapchainCreateInfoKHR structure is defined as:

typedef struct VkSwapchainCreateInfoKHR {
    VkStructureType                  sType;
    const void*                      pNext;
    VkSwapchainCreateFlagsKHR        flags;
    VkSurfaceKHR                     surface;
    uint32_t                         minImageCount;
    VkFormat                         imageFormat;
    VkColorSpaceKHR                  imageColorSpace;
    VkExtent2D                       imageExtent;
    uint32_t                         imageArrayLayers;
    VkImageUsageFlags                imageUsage;
    VkSharingMode                    imageSharingMode;
    uint32_t                         queueFamilyIndexCount;
    const uint32_t*                  pQueueFamilyIndices;
    VkSurfaceTransformFlagBitsKHR    preTransform;
    VkCompositeAlphaFlagBitsKHR      compositeAlpha;
    VkPresentModeKHR                 presentMode;
    VkBool32                         clipped;
    VkSwapchainKHR                   oldSwapchain;
} VkSwapchainCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is a bitmask of VkSwapchainCreateFlagBitsKHR indicating parameters of the swapchain creation.
surface is the surface onto which the swapchain will present images. If the creation succeeds, the swapchain becomes associated with surface.
minImageCount is the minimum number of presentable images that the application needs. The implementation will either create the swapchain with at least that many images, or it will fail to create the swapchain.
imageFormat is a VkFormat value specifying the format the swapchain image(s) will be created with.
imageColorSpace is a VkColorSpaceKHR value specifying the way the swapchain interprets image data.
imageExtent is the size (in pixels) of the swapchain image(s). The behavior is platform-dependent if the image extent does not match the surface’s currentExtent as returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR.
Description
Note
On some platforms, it is normal that maxImageExtent may become (0, 0), for example when the window is minimized. In such a case, it is not possible to create a swapchain due to the Valid Usage requirements.
imageArrayLayers is the number of views in a multiview/stereo surface. For non-stereoscopic-3D applications, this value is 1.
imageUsage is a bitmask of VkImageUsageFlagBits describing the intended usage of the (acquired) swapchain images.
imageSharingMode is the sharing mode used for the image(s) of the swapchain.
queueFamilyIndexCount is the number of queue families having access to the image(s) of the swapchain when imageSharingMode is VK_SHARING_MODE_CONCURRENT.
pQueueFamilyIndices is an array of queue family indices having access to the images(s) of the swapchain when imageSharingMode is VK_SHARING_MODE_CONCURRENT.
preTransform is a VkSurfaceTransformFlagBitsKHR value describing the transform, relative to the presentation engine’s natural orientation, applied to the image content prior to presentation. If it does not match the currentTransform value returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR, the presentation engine will transform the image content as part of the presentation operation.
compositeAlpha is a VkCompositeAlphaFlagBitsKHR value indicating the alpha compositing mode to use when this surface is composited together with other surfaces on certain window systems.
presentMode is the presentation mode the swapchain will use. A swapchain’s present mode determines how incoming present requests will be processed and queued internally.
clipped specifies whether the Vulkan implementation is allowed to discard rendering operations that affect regions of the surface that are not visible.
If set to VK_TRUE, the presentable images associated with the swapchain may not own all of their pixels. Pixels in the presentable images that correspond to regions of the target surface obscured by another window on the desktop, or subject to some other clipping mechanism will have undefined content when read back. Pixel shaders may not execute for these pixels, and thus any side effects they would have had will not occur. VK_TRUE value does not guarantee any clipping will occur, but allows more optimal presentation methods to be used on some platforms.
If set to VK_FALSE, presentable images associated with the swapchain will own all of the pixels they contain.
Note
Applications should set this value to VK_TRUE if they do not expect to read back the content of presentable images before presenting them or after reacquiring them, and if their pixel shaders do not have any side effects that require them to run for all pixels in the presentable image.
oldSwapchain is VK_NULL_HANDLE, or the existing non-retired swapchain currently associated with surface. Providing a valid oldSwapchain may aid in the resource reuse, and also allows the application to still present any images that are already acquired from it.
Upon calling vkCreateSwapchainKHR with an oldSwapchain that is not VK_NULL_HANDLE, oldSwapchain is retired — even if creation of the new swapchain fails. The new swapchain is created in the non-retired state whether or not oldSwapchain is VK_NULL_HANDLE.

Upon calling vkCreateSwapchainKHR with an oldSwapchain that is not VK_NULL_HANDLE, any images from oldSwapchain that are not acquired by the application may be freed by the implementation, which may occur even if creation of the new swapchain fails. The application can destroy oldSwapchain to free all memory associated with oldSwapchain.

Note
Multiple retired swapchains can be associated with the same VkSurfaceKHR through multiple uses of oldSwapchain that outnumber calls to vkDestroySwapchainKHR.

After oldSwapchain is retired, the application can pass to vkQueuePresentKHR any images it had already acquired from oldSwapchain. E.g., an application may present an image from the old swapchain before an image from the new swapchain is ready to be presented. As usual, vkQueuePresentKHR may fail if oldSwapchain has entered a state that causes VK_ERROR_OUT_OF_DATE_KHR to be returned.

The application can continue to use a shared presentable image obtained from oldSwapchain until a presentable image is acquired from the new swapchain, as long as it has not entered a state that causes it to return VK_ERROR_OUT_OF_DATE_KHR.
Valid Usage
surface must be a surface that is supported by the device as determined using vkGetPhysicalDeviceSurfaceSupportKHR
minImageCount must be greater than or equal to the value returned in the minImageCount member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
minImageCount must be less than or equal to the value returned in the maxImageCount member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface if the returned maxImageCount is not zero
minImageCount must be 1 if presentMode is either VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR
imageFormat and imageColorSpace must match the format and colorSpace members, respectively, of one of the VkSurfaceFormatKHR structures returned by vkGetPhysicalDeviceSurfaceFormatsKHR for the surface
imageExtent must be between minImageExtent and maxImageExtent, inclusive, where minImageExtent and maxImageExtent are members of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
imageExtent members width and height must both be non-zero
imageArrayLayers must be greater than 0 and less than or equal to the maxImageArrayLayers member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
If presentMode is VK_PRESENT_MODE_IMMEDIATE_KHR, VK_PRESENT_MODE_MAILBOX_KHR, VK_PRESENT_MODE_FIFO_KHR or VK_PRESENT_MODE_FIFO_RELAXED_KHR, imageUsage must be a subset of the supported usage flags present in the supportedUsageFlags member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for surface
If presentMode is VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, imageUsage must be a subset of the supported usage flags present in the sharedPresentSupportedUsageFlags member of the VkSharedPresentSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilities2KHR for surface
If imageSharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values
If imageSharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1
If imageSharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by either vkGetPhysicalDeviceQueueFamilyProperties or vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device
preTransform must be one of the bits present in the supportedTransforms member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
compositeAlpha must be one of the bits present in the supportedCompositeAlpha member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface
presentMode must be one of the VkPresentModeKHR values returned by vkGetPhysicalDeviceSurfacePresentModesKHR for the surface
If the logical device was created with VkDeviceGroupDeviceCreateInfo::physicalDeviceCount equal to 1, flags must not contain VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR
If oldSwapchain is not VK_NULL_HANDLE, oldSwapchain must be a non-retired swapchain associated with native window referred to by surface
The implied image creation parameters of the swapchain must be supported as reported by vkGetPhysicalDeviceImageFormatProperties
If flags contains VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR then the pNext chain must contain an instance of VkImageFormatListCreateInfoKHR with a viewFormatCount greater than zero and pViewFormats must have an element equal to imageFormat
If flags contains VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR, then VkSurfaceProtectedCapabilitiesKHR::supportsProtected must be VK_TRUE in the VkSurfaceProtectedCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilities2KHR for surface
If the pNext chain includes an instance of VkSurfaceFullScreenExclusiveInfoEXT with its fullScreenExclusive member set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, and surface was created using vkCreateWin32SurfaceKHR, an instance of VkSurfaceFullScreenExclusiveWin32InfoEXT must be present in the pNext chain
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupSwapchainCreateInfoKHR, VkImageFormatListCreateInfoKHR, VkSurfaceFullScreenExclusiveInfoEXT, VkSurfaceFullScreenExclusiveWin32InfoEXT, VkSwapchainCounterCreateInfoEXT, or VkSwapchainDisplayNativeHdrCreateInfoAMD
Each sType member in the pNext chain must be unique
flags must be a valid combination of VkSwapchainCreateFlagBitsKHR values
surface must be a valid VkSurfaceKHR handle
imageFormat must be a valid VkFormat value
imageColorSpace must be a valid VkColorSpaceKHR value
imageUsage must be a valid combination of VkImageUsageFlagBits values
imageUsage must not be 0
imageSharingMode must be a valid VkSharingMode value
preTransform must be a valid VkSurfaceTransformFlagBitsKHR value
compositeAlpha must be a valid VkCompositeAlphaFlagBitsKHR value
presentMode must be a valid VkPresentModeKHR value
If oldSwapchain is not VK_NULL_HANDLE, oldSwapchain must be a valid VkSwapchainKHR handle
If oldSwapchain is a valid handle, it must have been created, allocated, or retrieved from surface
Both of oldSwapchain, and surface that are valid handles must have been created, allocated, or retrieved from the same VkInstance
See Also
VkBool32, VkColorSpaceKHR, VkCompositeAlphaFlagBitsKHR, VkExtent2D, VkFormat, VkImageUsageFlags, VkPresentModeKHR, VkSharingMode, VkStructureType, VkSurfaceKHR, VkSurfaceTransformFlagBitsKHR, VkSwapchainCreateFlagsKHR, VkSwapchainKHR, vkCreateSharedSwapchainsKHR, vkCreateSwapchainKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSwapchainCreateInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSwapchainDisplayNativeHdrCreateInfoAMD(3)
Name
VkSwapchainDisplayNativeHdrCreateInfoAMD - Structure specifying display native HDR parameters of a newly created swapchain object

C Specification
If the pNext chain of VkSwapchainCreateInfoKHR includes a VkSwapchainDisplayNativeHdrCreateInfoAMD structure, then that structure includes additional swapchain creation parameters specific to display native HDR support.

The VkSwapchainDisplayNativeHdrCreateInfoAMD structure is defined as:

typedef struct VkSwapchainDisplayNativeHdrCreateInfoAMD {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           localDimmingEnable;
} VkSwapchainDisplayNativeHdrCreateInfoAMD;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
localDimmingEnable specifies whether local dimming is enabled for the swapchain.
Description
If the pNext chain of VkSwapchainCreateInfoKHR does not contain this structure, the default value for localDimmingEnable is VK_TRUE, meaning local dimming is initially enabled for the swapchain.

Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD
Valid Usage
It is only valid to set localDimmingEnable to VK_TRUE if VkDisplayNativeHdrSurfaceCapabilitiesAMD::localDimmingSupport is supported.
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSwapchainDisplayNativeHdrCreateInfoAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkTextureLODGatherFormatPropertiesAMD(3)
Name
VkTextureLODGatherFormatPropertiesAMD - Structure informing whether or not texture gather bias/LOD functionality is supported for a given image format and a given physical device.

C Specification
To determine if texture gather functions that take explicit LOD and/or bias argument values can be used with a given image format, add VkImageFormatProperties2 to the pNext chain of the VkPhysicalDeviceImageFormatInfo2 structure and VkTextureLODGatherFormatPropertiesAMD to the pNext chain of the VkImageFormatProperties2 structure.

The VkTextureLODGatherFormatPropertiesAMD structure is defined as:

typedef struct VkTextureLODGatherFormatPropertiesAMD {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           supportsTextureGatherLODBiasAMD;
} VkTextureLODGatherFormatPropertiesAMD;
Members
sType is the type of this structure.
pNext is NULL.
supportsTextureGatherLODBiasAMD tells if the image format can be used with texture gather bias/LOD functions, as introduced by the html/vkspec.html#VK_AMD_texture_gather_bias_lod extension. This field is set by the implementation. User-specified value is ignored.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD
See Also
VkBool32, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkTextureLODGatherFormatPropertiesAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkValidationCacheCreateInfoEXT(3)
Name
VkValidationCacheCreateInfoEXT - Structure specifying parameters of a newly created validation cache

C Specification
The VkValidationCacheCreateInfoEXT structure is defined as:

typedef struct VkValidationCacheCreateInfoEXT {
    VkStructureType                    sType;
    const void*                        pNext;
    VkValidationCacheCreateFlagsEXT    flags;
    size_t                             initialDataSize;
    const void*                        pInitialData;
} VkValidationCacheCreateInfoEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
initialDataSize is the number of bytes in pInitialData. If initialDataSize is zero, the validation cache will initially be empty.
pInitialData is a pointer to previously retrieved validation cache data. If the validation cache data is incompatible (as defined below) with the device, the validation cache will be initially empty. If initialDataSize is zero, pInitialData is ignored.
Description
Valid Usage
If initialDataSize is not 0, it must be equal to the size of pInitialData, as returned by vkGetValidationCacheDataEXT when pInitialData was originally retrieved
If initialDataSize is not 0, pInitialData must have been retrieved from a previous call to vkGetValidationCacheDataEXT
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT
pNext must be NULL
flags must be 0
If initialDataSize is not 0, pInitialData must be a valid pointer to an array of initialDataSize bytes
See Also
VkStructureType, VkValidationCacheCreateFlagsEXT, vkCreateValidationCacheEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkValidationCacheCreateInfoEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkValidationFeaturesEXT(3)
Name
VkValidationFeaturesEXT - Specify validation features to enable or disable for a Vulkan instance

C Specification
When creating a Vulkan instance for which you wish to enable or disable specific validation features, add a VkValidationFeaturesEXT structure to the pNext chain of the VkInstanceCreateInfo structure, specifying the features to be enabled or disabled.

typedef struct VkValidationFeaturesEXT {
    VkStructureType                         sType;
    const void*                             pNext;
    uint32_t                                enabledValidationFeatureCount;
    const VkValidationFeatureEnableEXT*     pEnabledValidationFeatures;
    uint32_t                                disabledValidationFeatureCount;
    const VkValidationFeatureDisableEXT*    pDisabledValidationFeatures;
} VkValidationFeaturesEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
enabledValidationFeatureCount is the number of features to enable.
pEnabledValidationFeatures is a pointer to an array of VkValidationFeatureEnableEXT values specifying the validation features to be enabled.
disabledValidationFeatureCount is the number of features to disable.
pDisabledValidationFeatures is a pointer to an array of VkValidationFeatureDisableEXT values specifying the validation features to be disabled.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT
If enabledValidationFeatureCount is not 0, pEnabledValidationFeatures must be a valid pointer to an array of enabledValidationFeatureCount valid VkValidationFeatureEnableEXT values
If disabledValidationFeatureCount is not 0, pDisabledValidationFeatures must be a valid pointer to an array of disabledValidationFeatureCount valid VkValidationFeatureDisableEXT values
See Also
VkStructureType, VkValidationFeatureDisableEXT, VkValidationFeatureEnableEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkValidationFeaturesEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkValidationFlagsEXT(3)
Name
VkValidationFlagsEXT - Specify validation checks to disable for a Vulkan instance

C Specification
When creating a Vulkan instance for which you wish to disable validation checks, add a VkValidationFlagsEXT structure to the pNext chain of the VkInstanceCreateInfo structure, specifying the checks to be disabled.

typedef struct VkValidationFlagsEXT {
    VkStructureType                sType;
    const void*                    pNext;
    uint32_t                       disabledValidationCheckCount;
    const VkValidationCheckEXT*    pDisabledValidationChecks;
} VkValidationFlagsEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
disabledValidationCheckCount is the number of checks to disable.
pDisabledValidationChecks is a pointer to an array of VkValidationCheckEXT values specifying the validation checks to be disabled.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
pDisabledValidationChecks must be a valid pointer to an array of disabledValidationCheckCount valid VkValidationCheckEXT values
disabledValidationCheckCount must be greater than 0
See Also
VkStructureType, VkValidationCheckEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkValidationFlagsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkVertexInputAttributeDescription(3)
Name
VkVertexInputAttributeDescription - Structure specifying vertex input attribute description

C Specification
Each vertex input attribute is specified by an instance of the VkVertexInputAttributeDescription structure.

The VkVertexInputAttributeDescription structure is defined as:

typedef struct VkVertexInputAttributeDescription {
    uint32_t    location;
    uint32_t    binding;
    VkFormat    format;
    uint32_t    offset;
} VkVertexInputAttributeDescription;
Members
location is the shader binding location number for this attribute.
binding is the binding number which this attribute takes its data from.
format is the size and type of the vertex attribute data.
offset is a byte offset of this attribute relative to the start of an element in the vertex input binding.
Description
Valid Usage
location must be less than VkPhysicalDeviceLimits::maxVertexInputAttributes
binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings
offset must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputAttributeOffset
format must be allowed as a vertex buffer format, as specified by the VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT flag in VkFormatProperties::bufferFeatures returned by vkGetPhysicalDeviceFormatProperties
Valid Usage (Implicit)
format must be a valid VkFormat value
See Also
VkFormat, VkPipelineVertexInputStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkVertexInputAttributeDescription

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkVertexInputBindingDescription(3)
Name
VkVertexInputBindingDescription - Structure specifying vertex input binding description

C Specification
The VkVertexInputBindingDescription structure is defined as:

typedef struct VkVertexInputBindingDescription {
    uint32_t             binding;
    uint32_t             stride;
    VkVertexInputRate    inputRate;
} VkVertexInputBindingDescription;
Members
binding is the binding number that this structure describes.
stride is the distance in bytes between two consecutive elements within the buffer.
inputRate is a VkVertexInputRate value specifying whether vertex attribute addressing is a function of the vertex index or of the instance index.
Description
Valid Usage
binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings
stride must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindingStride
Valid Usage (Implicit)
inputRate must be a valid VkVertexInputRate value
See Also
VkPipelineVertexInputStateCreateInfo, VkVertexInputRate

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkVertexInputBindingDescription

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkVertexInputBindingDivisorDescriptionEXT(3)
Name
VkVertexInputBindingDivisorDescriptionEXT - Structure specifying a divisor used in instanced rendering

C Specification
The individual divisor values per binding are specified using the VkVertexInputBindingDivisorDescriptionEXT structure which is defined as:

typedef struct VkVertexInputBindingDivisorDescriptionEXT {
    uint32_t    binding;
    uint32_t    divisor;
} VkVertexInputBindingDivisorDescriptionEXT;
Members
binding is the binding number for which the divisor is specified.
divisor is the number of successive instances that will use the same value of the vertex attribute when instanced rendering is enabled. For example, if the divisor is N, the same vertex attribute will applied to N successive instances before moving on to the next vertex attribute. The maximum value of divisor is implementation dependent and can be queried using VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::maxVertexAttribDivisor. A value of 0 can be used for the divisor if the vertexAttributeInstanceRateZeroDivisor feature is enabled. In this case, the same vertex attribute will be applied to all instances.
Description
If this structure is not used to define a divisor value for an attribute then the divisor has a logical default value of 1.

Valid Usage
binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings
If the vertexAttributeInstanceRateZeroDivisor feature is not enabled, divisor must not be 0
If the vertexAttributeInstanceRateDivisor feature is not enabled, divisor must be 1
divisor must be a value between 0 and VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::maxVertexAttribDivisor, inclusive.
VkVertexInputBindingDescription::inputRate must be of type VK_VERTEX_INPUT_RATE_INSTANCE for this binding.
See Also
VkPipelineVertexInputDivisorStateCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkVertexInputBindingDivisorDescriptionEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkViSurfaceCreateInfoNN(3)
Name
VkViSurfaceCreateInfoNN - Structure specifying parameters of a newly created VI surface object

C Specification
The VkViSurfaceCreateInfoNN structure is defined as:

typedef struct VkViSurfaceCreateInfoNN {
    VkStructureType             sType;
    const void*                 pNext;
    VkViSurfaceCreateFlagsNN    flags;
    void*                       window;
} VkViSurfaceCreateInfoNN;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
window is the nn::vi::NativeWindowHandle for the nn::vi::Layer with which to associate the surface.
Description
Valid Usage
window must be a valid nn::vi::NativeWindowHandle
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN
pNext must be NULL
flags must be 0
See Also
VkStructureType, VkViSurfaceCreateFlagsNN, vkCreateViSurfaceNN

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkViSurfaceCreateInfoNN

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkViewport(3)
Name
VkViewport - Structure specifying a viewport

C Specification
The VkViewport structure is defined as:

typedef struct VkViewport {
    float    x;
    float    y;
    float    width;
    float    height;
    float    minDepth;
    float    maxDepth;
} VkViewport;
Members
x and y are the viewport’s upper left corner (x,y).
width and height are the viewport’s width and height, respectively.
minDepth and maxDepth are the depth range for the viewport. It is valid for minDepth to be greater than or equal to maxDepth.
Description
The framebuffer depth coordinate zf may be represented using either a fixed-point or floating-point representation. However, a floating-point representation must be used if the depth/stencil attachment has a floating-point depth component. If an m-bit fixed-point representation is used, we assume that it represents each value \(\frac{k}{2^m - 1}\), where k ∈ { 0, 1, …​, 2m-1 }, as k (e.g. 1.0 is represented in binary as a string of all ones).

The viewport parameters shown in the above equations are found from these values as

:: [eq]#o~x~ = pname:x {plus} pname:width / 2#
:: [eq]#o~y~ = pname:y {plus} pname:height / 2#
:: [eq]#o~z~ = pname:minDepth#
:: [eq]#p~x~ = pname:width#
:: [eq]#p~y~ = pname:height#
:: [eq]#p~z~ = pname:maxDepth - pname:minDepth#.
The application can specify a negative term for height, which has the effect of negating the y coordinate in clip space before performing the transform. When using a negative height, the application should also adjust the y value to point to the lower left corner of the viewport instead of the upper left corner. Using the negative height allows the application to avoid having to negate the y component of the Position output from the last vertex processing stage in shaders that also target other graphics APIs.

The width and height of the implementation-dependent maximum viewport dimensions must be greater than or equal to the width and height of the largest image which can be created and attached to a framebuffer.

The floating-point viewport bounds are represented with an implementation-dependent precision.

Valid Usage
width must be greater than 0.0
width must be less than or equal to VkPhysicalDeviceLimits::maxViewportDimensions[0]
The absolute value of height must be less than or equal to VkPhysicalDeviceLimits::maxViewportDimensions[1]
x must be greater than or equal to viewportBoundsRange[0]
(x + width) must be less than or equal to viewportBoundsRange[1]
y must be greater than or equal to viewportBoundsRange[0]
y must be less than or equal to viewportBoundsRange[1]
(y + height) must be greater than or equal to viewportBoundsRange[0]
(y + height) must be less than or equal to viewportBoundsRange[1]
Unless html/vkspec.html#VK_EXT_depth_range_unrestricted extension is enabled minDepth must be between 0.0 and 1.0, inclusive
Unless html/vkspec.html#VK_EXT_depth_range_unrestricted extension is enabled maxDepth must be between 0.0 and 1.0, inclusive
See Also
VkPipelineViewportStateCreateInfo, vkCmdSetViewport

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkViewport

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkViewportSwizzleNV(3)
Name
VkViewportSwizzleNV - Structure specifying a viewport swizzle

C Specification
The VkViewportSwizzleNV structure is defined as:

typedef struct VkViewportSwizzleNV {
    VkViewportCoordinateSwizzleNV    x;
    VkViewportCoordinateSwizzleNV    y;
    VkViewportCoordinateSwizzleNV    z;
    VkViewportCoordinateSwizzleNV    w;
} VkViewportSwizzleNV;
Members
x is a VkViewportCoordinateSwizzleNV value specifying the swizzle operation to apply to the x component of the primitive
y is a VkViewportCoordinateSwizzleNV value specifying the swizzle operation to apply to the y component of the primitive
z is a VkViewportCoordinateSwizzleNV value specifying the swizzle operation to apply to the z component of the primitive
w is a VkViewportCoordinateSwizzleNV value specifying the swizzle operation to apply to the w component of the primitive
Description
Valid Usage (Implicit)
x must be a valid VkViewportCoordinateSwizzleNV value
y must be a valid VkViewportCoordinateSwizzleNV value
z must be a valid VkViewportCoordinateSwizzleNV value
w must be a valid VkViewportCoordinateSwizzleNV value
See Also
VkPipelineViewportSwizzleStateCreateInfoNV, VkViewportCoordinateSwizzleNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkViewportSwizzleNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkViewportWScalingNV(3)
Name
VkViewportWScalingNV - Structure specifying a viewport

C Specification
The VkViewportWScalingNV structure is defined as:

typedef struct VkViewportWScalingNV {
    float    xcoeff;
    float    ycoeff;
} VkViewportWScalingNV;
Members
xcoeff and ycoeff are the viewport’s W scaling factor for x and y respectively.
Description
See Also
VkPipelineViewportWScalingStateCreateInfoNV, vkCmdSetViewportWScalingNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkViewportWScalingNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkWaylandSurfaceCreateInfoKHR(3)
Name
VkWaylandSurfaceCreateInfoKHR - Structure specifying parameters of a newly created Wayland surface object

C Specification
The VkWaylandSurfaceCreateInfoKHR structure is defined as:

typedef struct VkWaylandSurfaceCreateInfoKHR {
    VkStructureType                   sType;
    const void*                       pNext;
    VkWaylandSurfaceCreateFlagsKHR    flags;
    struct wl_display*                display;
    struct wl_surface*                surface;
} VkWaylandSurfaceCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
display and surface are pointers to the Wayland wl_display and wl_surface to associate the surface with.
Description
Valid Usage
display must point to a valid Wayland wl_display.
surface must point to a valid Wayland wl_surface.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR
pNext must be NULL
flags must be 0
See Also
VkStructureType, VkWaylandSurfaceCreateFlagsKHR, vkCreateWaylandSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkWaylandSurfaceCreateInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkWin32KeyedMutexAcquireReleaseInfoKHR(3)
Name
VkWin32KeyedMutexAcquireReleaseInfoKHR - Use the Windows keyed mutex mechanism to synchronize work

C Specification
When submitting work that operates on memory imported from a Direct3D 11 resource to a queue, the keyed mutex mechanism may be used in addition to Vulkan semaphores to synchronize the work. Keyed mutexes are a property of a properly created shareable Direct3D 11 resource. They can only be used if the imported resource was created with the D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX flag.

To acquire keyed mutexes before submitted work and/or release them after, add a VkWin32KeyedMutexAcquireReleaseInfoKHR structure to the pNext chain of the VkSubmitInfo structure.

The VkWin32KeyedMutexAcquireReleaseInfoKHR structure is defined as:

typedef struct VkWin32KeyedMutexAcquireReleaseInfoKHR {
    VkStructureType          sType;
    const void*              pNext;
    uint32_t                 acquireCount;
    const VkDeviceMemory*    pAcquireSyncs;
    const uint64_t*          pAcquireKeys;
    const uint32_t*          pAcquireTimeouts;
    uint32_t                 releaseCount;
    const VkDeviceMemory*    pReleaseSyncs;
    const uint64_t*          pReleaseKeys;
} VkWin32KeyedMutexAcquireReleaseInfoKHR;
Members
acquireCount is the number of entries in the pAcquireSyncs, pAcquireKeys, and pAcquireTimeoutMilliseconds arrays.
pAcquireSyncs is a pointer to an array of VkDeviceMemory objects which were imported from Direct3D 11 resources.
pAcquireKeys is a pointer to an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in pAcquireSyncs.
pAcquireTimeoutMilliseconds is an array of timeout values, in millisecond units, for each acquire specified in pAcquireKeys.
releaseCount is the number of entries in the pReleaseSyncs and pReleaseKeys arrays.
pReleaseSyncs is a pointer to an array of VkDeviceMemory objects which were imported from Direct3D 11 resources.
pReleaseKeys is a pointer to an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in pReleaseSyncs.
Description
Valid Usage
Each member of pAcquireSyncs and pReleaseSyncs must be a device memory object imported by setting VkImportMemoryWin32HandleInfoKHR::handleType to VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR
If acquireCount is not 0, pAcquireSyncs must be a valid pointer to an array of acquireCount valid VkDeviceMemory handles
If acquireCount is not 0, pAcquireKeys must be a valid pointer to an array of acquireCount uint64_t values
If acquireCount is not 0, pAcquireTimeouts must be a valid pointer to an array of acquireCount uint32_t values
If releaseCount is not 0, pReleaseSyncs must be a valid pointer to an array of releaseCount valid VkDeviceMemory handles
If releaseCount is not 0, pReleaseKeys must be a valid pointer to an array of releaseCount uint64_t values
Both of the elements of pAcquireSyncs, and the elements of pReleaseSyncs that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkDeviceMemory, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkWin32KeyedMutexAcquireReleaseInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkWin32KeyedMutexAcquireReleaseInfoNV(3)
Name
VkWin32KeyedMutexAcquireReleaseInfoNV - use Windows keyex mutex mechanism to synchronize work

C Specification
When submitting work that operates on memory imported from a Direct3D 11 resource to a queue, the keyed mutex mechanism may be used in addition to Vulkan semaphores to synchronize the work. Keyed mutexes are a property of a properly created shareable Direct3D 11 resource. They can only be used if the imported resource was created with the D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX flag.

To acquire keyed mutexes before submitted work and/or release them after, add a VkWin32KeyedMutexAcquireReleaseInfoNV structure to the pNext chain of the VkSubmitInfo structure.

The VkWin32KeyedMutexAcquireReleaseInfoNV structure is defined as:

typedef struct VkWin32KeyedMutexAcquireReleaseInfoNV {
    VkStructureType          sType;
    const void*              pNext;
    uint32_t                 acquireCount;
    const VkDeviceMemory*    pAcquireSyncs;
    const uint64_t*          pAcquireKeys;
    const uint32_t*          pAcquireTimeoutMilliseconds;
    uint32_t                 releaseCount;
    const VkDeviceMemory*    pReleaseSyncs;
    const uint64_t*          pReleaseKeys;
} VkWin32KeyedMutexAcquireReleaseInfoNV;
Members
acquireCount is the number of entries in the pAcquireSyncs, pAcquireKeys, and pAcquireTimeoutMilliseconds arrays.
pAcquireSyncs is a pointer to an array of VkDeviceMemory objects which were imported from Direct3D 11 resources.
pAcquireKeys is a pointer to an array of mutex key values to wait for prior to beginning the submitted work. Entries refer to the keyed mutex associated with the corresponding entries in pAcquireSyncs.
pAcquireTimeoutMilliseconds is an array of timeout values, in millisecond units, for each acquire specified in pAcquireKeys.
releaseCount is the number of entries in the pReleaseSyncs and pReleaseKeys arrays.
pReleaseSyncs is a pointer to an array of VkDeviceMemory objects which were imported from Direct3D 11 resources.
pReleaseKeys is a pointer to an array of mutex key values to set when the submitted work has completed. Entries refer to the keyed mutex associated with the corresponding entries in pReleaseSyncs.
Description
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV
If acquireCount is not 0, pAcquireSyncs must be a valid pointer to an array of acquireCount valid VkDeviceMemory handles
If acquireCount is not 0, pAcquireKeys must be a valid pointer to an array of acquireCount uint64_t values
If acquireCount is not 0, pAcquireTimeoutMilliseconds must be a valid pointer to an array of acquireCount uint32_t values
If releaseCount is not 0, pReleaseSyncs must be a valid pointer to an array of releaseCount valid VkDeviceMemory handles
If releaseCount is not 0, pReleaseKeys must be a valid pointer to an array of releaseCount uint64_t values
Both of the elements of pAcquireSyncs, and the elements of pReleaseSyncs that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkDeviceMemory, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkWin32KeyedMutexAcquireReleaseInfoNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkWin32SurfaceCreateInfoKHR(3)
Name
VkWin32SurfaceCreateInfoKHR - Structure specifying parameters of a newly created Win32 surface object

C Specification
The VkWin32SurfaceCreateInfoKHR structure is defined as:

typedef struct VkWin32SurfaceCreateInfoKHR {
    VkStructureType                 sType;
    const void*                     pNext;
    VkWin32SurfaceCreateFlagsKHR    flags;
    HINSTANCE                       hinstance;
    HWND                            hwnd;
} VkWin32SurfaceCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
hinstance and hwnd are the Win32 HINSTANCE and HWND for the window to associate the surface with.
Description
Valid Usage
hinstance must be a valid Win32 HINSTANCE.
hwnd must be a valid Win32 HWND.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR
pNext must be NULL
flags must be 0
See Also
VkStructureType, VkWin32SurfaceCreateFlagsKHR, vkCreateWin32SurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkWin32SurfaceCreateInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkWriteDescriptorSet(3)
Name
VkWriteDescriptorSet - Structure specifying the parameters of a descriptor set write operation

C Specification
The VkWriteDescriptorSet structure is defined as:

typedef struct VkWriteDescriptorSet {
    VkStructureType                  sType;
    const void*                      pNext;
    VkDescriptorSet                  dstSet;
    uint32_t                         dstBinding;
    uint32_t                         dstArrayElement;
    uint32_t                         descriptorCount;
    VkDescriptorType                 descriptorType;
    const VkDescriptorImageInfo*     pImageInfo;
    const VkDescriptorBufferInfo*    pBufferInfo;
    const VkBufferView*              pTexelBufferView;
} VkWriteDescriptorSet;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
dstSet is the destination descriptor set to update.
dstBinding is the descriptor binding within that set.
dstArrayElement is the starting element in that array. If the descriptor binding identified by dstSet and dstBinding has a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then dstArrayElement specifies the starting byte offset within the binding.
descriptorCount is the number of descriptors to update (the number of elements in pImageInfo, pBufferInfo, or pTexelBufferView , or a value matching the dataSize member of an instance of VkWriteDescriptorSetInlineUniformBlockEXT in the pNext chain , or a value matching the accelerationStructureCount of an instance of VkWriteDescriptorSetAccelerationStructureNV in the pNext chain ). If the descriptor binding identified by dstSet and dstBinding has a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then descriptorCount specifies the number of bytes to update.
descriptorType is a VkDescriptorType specifying the type of each descriptor in pImageInfo, pBufferInfo, or pTexelBufferView, as described below. It must be the same type as that specified in VkDescriptorSetLayoutBinding for dstSet at dstBinding. The type of the descriptor also controls which array the descriptors are taken from.
pImageInfo points to an array of VkDescriptorImageInfo structures or is ignored, as described below.
pBufferInfo points to an array of VkDescriptorBufferInfo structures or is ignored, as described below.
pTexelBufferView points to an array of VkBufferView handles as described in the Buffer Views section or is ignored, as described below.
Description
Only one of pImageInfo, pBufferInfo, or pTexelBufferView members is used according to the descriptor type specified in the descriptorType member of the containing VkWriteDescriptorSet structure, or none of them in case descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, in which case the source data for the descriptor writes is taken from the instance of VkWriteDescriptorSetInlineUniformBlockEXT in the pNext chain of VkWriteDescriptorSet, or if descriptorType is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, in which case the source data for the descriptor writes is taken from the instance of VkWriteDescriptorSetAccelerationStructureNV in the pNext chain of VkWriteDescriptorSet, as specified below.

If the dstBinding has fewer than descriptorCount array elements remaining starting from dstArrayElement, then the remainder will be used to update the subsequent binding - dstBinding+1 starting at array element zero. If a binding has a descriptorCount of zero, it is skipped. This behavior applies recursively, with the update affecting consecutive bindings as needed to update all descriptorCount descriptors.

Note
The same behavior applies to bindings with a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT where descriptorCount specifies the number of bytes to update while dstArrayElement specifies the starting byte offset, thus in this case if the dstBinding has a smaller byte size than the sum of dstArrayElement and descriptorCount, then the remainder will be used to update the subsequent binding - dstBinding+1 starting at offset zero. This falls out as a special case of the above rule.
Valid Usage
dstBinding must be less than or equal to the maximum value of binding of all VkDescriptorSetLayoutBinding structures specified when dstSet’s descriptor set layout was created
dstBinding must be a binding with a non-zero descriptorCount
All consecutive bindings updated via a single VkWriteDescriptorSet structure, except those with a descriptorCount of zero, must have identical descriptorType and stageFlags.
All consecutive bindings updated via a single VkWriteDescriptorSet structure, except those with a descriptorCount of zero, must all either use immutable samplers or must all not use immutable samplers.
descriptorType must match the type of dstBinding within dstSet
dstSet must be a valid VkDescriptorSet handle
The sum of dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by dstBinding, and all applicable consecutive bindings, as described by html/vkspec.html#descriptorsets-updates-consecutive
If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, dstArrayElement must be an integer multiple of 4
If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, descriptorCount must be an integer multiple of 4
If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, pImageInfo must be a valid pointer to an array of descriptorCount valid VkDescriptorImageInfo structures
If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, pTexelBufferView must be a valid pointer to an array of descriptorCount valid VkBufferView handles
If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, pBufferInfo must be a valid pointer to an array of descriptorCount valid VkDescriptorBufferInfo structures
If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet was not allocated with a layout that included immutable samplers for dstBinding with descriptorType, the sampler member of each element of pImageInfo must be a valid VkSampler object
If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView and imageLayout members of each element of pImageInfo must be a valid VkImageView and VkImageLayout, respectively
If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, the pNext chain must include a VkWriteDescriptorSetInlineUniformBlockEXT structure whose dataSize member equals descriptorCount
If descriptorType is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, the pNext chain must include a VkWriteDescriptorSetAccelerationStructureNV structure whose accelerationStructureCount member equals descriptorCount
If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, then the imageView member of each pImageInfo element must have been created without a VkSamplerYcbcrConversionInfo structure in its pNext chain
If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and if any element of pImageInfo has a imageView member that was created with a VkSamplerYcbcrConversionInfo structure in its pNext chain, then dstSet must have been allocated with a layout that included immutable samplers for dstBinding
If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet was allocated with a layout that included immutable samplers for dstBinding, then the imageView member of each element of pImageInfo which corresponds to an immutable sampler that enables sampler Y’CBCR conversion must have been created with a VkSamplerYcbcrConversionInfo structure in its pNext chain with an identically defined VkSamplerYcbcrConversionInfo to the corresponding immutable sampler
If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, for each descriptor that will be accessed via load or store operations the imageLayout member for corresponding elements of pImageInfo must be VK_IMAGE_LAYOUT_GENERAL
If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the offset member of each element of pBufferInfo must be a multiple of VkPhysicalDeviceLimits::minUniformBufferOffsetAlignment
If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the offset member of each element of pBufferInfo must be a multiple of VkPhysicalDeviceLimits::minStorageBufferOffsetAlignment
If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, and the buffer member of any element of pBufferInfo is the handle of a non-sparse buffer, then that buffer must be bound completely and contiguously to a single VkDeviceMemory object
If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the buffer member of each element of pBufferInfo must have been created with VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT set
If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the buffer member of each element of pBufferInfo must have been created with VK_BUFFER_USAGE_STORAGE_BUFFER_BIT set
If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the range member of each element of pBufferInfo, or the effective range if range is VK_WHOLE_SIZE, must be less than or equal to VkPhysicalDeviceLimits::maxUniformBufferRange
If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the range member of each element of pBufferInfo, or the effective range if range is VK_WHOLE_SIZE, must be less than or equal to VkPhysicalDeviceLimits::maxStorageBufferRange
If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, the VkBuffer that each element of pTexelBufferView was created from must have been created with VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT set
If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, the VkBuffer that each element of pTexelBufferView was created from must have been created with VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set
If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView member of each element of pImageInfo must have been created with the identity swizzle
If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_SAMPLED_BIT set
If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the imageLayout member of each element of pImageInfo must be a member of the list given in Sampled Image or Combined Image Sampler, corresponding to its type
If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set
If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_STORAGE_BIT set
All consecutive bindings updated via a single VkWriteDescriptorSet structure, except those with a descriptorCount of zero, must have identical VkDescriptorBindingFlagBitsEXT.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkWriteDescriptorSetAccelerationStructureNV or VkWriteDescriptorSetInlineUniformBlockEXT
Each sType member in the pNext chain must be unique
descriptorType must be a valid VkDescriptorType value
descriptorCount must be greater than 0
Both of dstSet, and the elements of pTexelBufferView that are valid handles must have been created, allocated, or retrieved from the same VkDevice
See Also
VkBufferView, VkDescriptorBufferInfo, VkDescriptorImageInfo, VkDescriptorSet, VkDescriptorType, VkStructureType, vkCmdPushDescriptorSetKHR, vkUpdateDescriptorSets

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkWriteDescriptorSet

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkWriteDescriptorSetAccelerationStructureNV(3)
Name
VkWriteDescriptorSetAccelerationStructureNV - Structure specifying acceleration to query for memory requirements

C Specification
The VkWriteDescriptorSetAccelerationStructureNV structure is defined as:

typedef struct VkWriteDescriptorSetAccelerationStructureNV {
    VkStructureType                     sType;
    const void*                         pNext;
    uint32_t                            accelerationStructureCount;
    const VkAccelerationStructureNV*    pAccelerationStructures;
} VkWriteDescriptorSetAccelerationStructureNV;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
accelerationStructureCount is the number of elements in pAccelerationStructures.
pAccelerationStructures are the acceleration structures to update.
Description
Valid Usage
accelerationStructureCount must be equal to descriptorCount in the extended structure
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV
pAccelerationStructures must be a valid pointer to an array of accelerationStructureCount valid VkAccelerationStructureNV handles
accelerationStructureCount must be greater than 0
See Also
VkAccelerationStructureNV, VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkWriteDescriptorSetAccelerationStructureNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkWriteDescriptorSetInlineUniformBlockEXT(3)
Name
VkWriteDescriptorSetInlineUniformBlockEXT - Structure specifying inline uniform block data

C Specification
If the descriptorType member of VkWriteDescriptorSet is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT then the data to write to the descriptor set is specified through an instance of VkWriteDescriptorSetInlineUniformBlockEXT chained to the pNext chain of VkWriteDescriptorSet.

The VkWriteDescriptorSetInlineUniformBlockEXT structure is defined as:

typedef struct VkWriteDescriptorSetInlineUniformBlockEXT {
    VkStructureType    sType;
    const void*        pNext;
    uint32_t           dataSize;
    const void*        pData;
} VkWriteDescriptorSetInlineUniformBlockEXT;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
dataSize is the number of bytes of inline uniform block data pointed to by pData.
pData is a pointer to dataSize number of bytes of data to write to the inline uniform block.
Description
Valid Usage
dataSize must be an integer multiple of 4
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT
pData must be a valid pointer to an array of dataSize bytes
dataSize must be greater than 0
See Also
VkStructureType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkWriteDescriptorSetInlineUniformBlockEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkXYColorEXT(3)
Name
VkXYColorEXT - structure to specify X,Y chromaticity coordinates

C Specification
typedef struct VkXYColorEXT {
    float    x;
    float    y;
} VkXYColorEXT;
Members
Description
See Also
VkHdrMetadataEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkXYColorEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkXcbSurfaceCreateInfoKHR(3)
Name
VkXcbSurfaceCreateInfoKHR - Structure specifying parameters of a newly created Xcb surface object

C Specification
The VkXcbSurfaceCreateInfoKHR structure is defined as:

typedef struct VkXcbSurfaceCreateInfoKHR {
    VkStructureType               sType;
    const void*                   pNext;
    VkXcbSurfaceCreateFlagsKHR    flags;
    xcb_connection_t*             connection;
    xcb_window_t                  window;
} VkXcbSurfaceCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
connection is a pointer to an xcb_connection_t to the X server.
window is the xcb_window_t for the X11 window to associate the surface with.
Description
Valid Usage
connection must point to a valid X11 xcb_connection_t.
window must be a valid X11 xcb_window_t.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR
pNext must be NULL
flags must be 0
See Also
VkStructureType, VkXcbSurfaceCreateFlagsKHR, vkCreateXcbSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkXcbSurfaceCreateInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkXlibSurfaceCreateInfoKHR(3)
Name
VkXlibSurfaceCreateInfoKHR - Structure specifying parameters of a newly created Xlib surface object

C Specification
The VkXlibSurfaceCreateInfoKHR structure is defined as:

typedef struct VkXlibSurfaceCreateInfoKHR {
    VkStructureType                sType;
    const void*                    pNext;
    VkXlibSurfaceCreateFlagsKHR    flags;
    Display*                       dpy;
    Window                         window;
} VkXlibSurfaceCreateInfoKHR;
Members
sType is the type of this structure.
pNext is NULL or a pointer to an extension-specific structure.
flags is reserved for future use.
dpy is a pointer to an Xlib Display connection to the X server.
window is an Xlib Window to associate the surface with.
Description
Valid Usage
dpy must point to a valid Xlib Display.
window must be a valid Xlib Window.
Valid Usage (Implicit)
sType must be VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR
pNext must be NULL
flags must be 0
See Also
VkStructureType, VkXlibSurfaceCreateFlagsKHR, vkCreateXlibSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkXlibSurfaceCreateInfoKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Enumerations
VkAccelerationStructureMemoryRequirementsTypeNV(3)
Name
VkAccelerationStructureMemoryRequirementsTypeNV - Acceleration structure memory requirement type

C Specification
Possible values of type in VkAccelerationStructureMemoryRequirementsInfoNV are:,

typedef enum VkAccelerationStructureMemoryRequirementsTypeNV {
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0,
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1,
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2,
    VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
} VkAccelerationStructureMemoryRequirementsTypeNV;
Description
VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV requests the memory requirement for the VkAccelerationStructureNV backing store.
VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV requests the memory requirement for scratch space during the initial build.
VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV requests the memory requirement for scratch space during an update.
See Also
VkAccelerationStructureMemoryRequirementsInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAccelerationStructureMemoryRequirementsTypeNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAccelerationStructureTypeNV(3)
Name
VkAccelerationStructureTypeNV - Type of acceleration structure

C Specification
Values which can be set in VkAccelerationStructureInfoNV::type, specifying the type of acceleration structure, are:

typedef enum VkAccelerationStructureTypeNV {
    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV = 0,
    VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV = 1,
    VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
} VkAccelerationStructureTypeNV;
Description
VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV is a top-level acceleration structure containing instance data referring to bottom-level level acceleration structures.
VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV is a bottom-level acceleration structure containing the AABBs or geometry to be intersected.
See Also
VkAccelerationStructureInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAccelerationStructureTypeNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAccessFlagBits(3)
Name
VkAccessFlagBits - Bitmask specifying memory access types that will participate in a memory dependency

C Specification
Memory in Vulkan can be accessed from within shader invocations and via some fixed-function stages of the pipeline. The access type is a function of the descriptor type used, or how a fixed-function stage accesses memory. Each access type corresponds to a bit flag in VkAccessFlagBits.

Some synchronization commands take sets of access types as parameters to define the access scopes of a memory dependency. If a synchronization command includes a source access mask, its first access scope only includes accesses via the access types specified in that mask. Similarly, if a synchronization command includes a destination access mask, its second access scope only includes accesses via the access types specified in that mask.

Access types that can be set in an access mask include:

typedef enum VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001,
    VK_ACCESS_INDEX_READ_BIT = 0x00000002,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004,
    VK_ACCESS_UNIFORM_READ_BIT = 0x00000008,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010,
    VK_ACCESS_SHADER_READ_BIT = 0x00000020,
    VK_ACCESS_SHADER_WRITE_BIT = 0x00000040,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400,
    VK_ACCESS_TRANSFER_READ_BIT = 0x00000800,
    VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000,
    VK_ACCESS_HOST_READ_BIT = 0x00002000,
    VK_ACCESS_HOST_WRITE_BIT = 0x00004000,
    VK_ACCESS_MEMORY_READ_BIT = 0x00008000,
    VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000,
    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000,
    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000,
    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000,
    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000,
    VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX = 0x00020000,
    VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = 0x00040000,
    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000,
    VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = 0x00800000,
    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x00200000,
    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x00400000,
    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000,
    VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAccessFlagBits;
Description
VK_ACCESS_INDIRECT_COMMAND_READ_BIT specifies read access to indirect command data read as part of an indirect drawing or dispatch command.
VK_ACCESS_INDEX_READ_BIT specifies read access to an index buffer as part of an indexed drawing command, bound by vkCmdBindIndexBuffer.
VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT specifies read access to a vertex buffer as part of a drawing command, bound by vkCmdBindVertexBuffers.
VK_ACCESS_UNIFORM_READ_BIT specifies read access to a uniform buffer.
VK_ACCESS_INPUT_ATTACHMENT_READ_BIT specifies read access to an input attachment within a render pass during fragment shading.
VK_ACCESS_SHADER_READ_BIT specifies read access to a storage buffer, physical storage buffer, uniform texel buffer, storage texel buffer, sampled image, or storage image.
VK_ACCESS_SHADER_WRITE_BIT specifies write access to a storage buffer, physical storage buffer, storage texel buffer, or storage image.
VK_ACCESS_COLOR_ATTACHMENT_READ_BIT specifies read access to a color attachment, such as via blending, logic operations, or via certain subpass load operations. It does not include advanced blend operations.
VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT specifies write access to a color, resolve, or depth/stencil resolve attachment during a render pass or via certain subpass load and store operations.
VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT specifies read access to a depth/stencil attachment, via depth or stencil operations or via certain subpass load operations.
VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT specifies write access to a depth/stencil attachment, via depth or stencil operations or via certain subpass load and store operations.
VK_ACCESS_TRANSFER_READ_BIT specifies read access to an image or buffer in a copy operation.
VK_ACCESS_TRANSFER_WRITE_BIT specifies write access to an image or buffer in a clear or copy operation.
VK_ACCESS_HOST_READ_BIT specifies read access by a host operation. Accesses of this type are not performed through a resource, but directly on memory.
VK_ACCESS_HOST_WRITE_BIT specifies write access by a host operation. Accesses of this type are not performed through a resource, but directly on memory.
VK_ACCESS_MEMORY_READ_BIT specifies read access via non-specific entities. These entities include the Vulkan device and host, but may also include entities external to the Vulkan device or otherwise not part of the core Vulkan pipeline. When included in a destination access mask, makes all available writes visible to all future read accesses on entities known to the Vulkan device.
VK_ACCESS_MEMORY_WRITE_BIT specifies write access via non-specific entities. These entities include the Vulkan device and host, but may also include entities external to the Vulkan device or otherwise not part of the core Vulkan pipeline. When included in a source access mask, all writes that are performed by entities known to the Vulkan device are made available. When included in a destination access mask, makes all available writes visible to all future write accesses on entities known to the Vulkan device.
VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT specifies read access to a predicate as part of conditional rendering.
VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT specifies write access to a transform feedback buffer made when transform feedback is active.
VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT specifies read access to a transform feedback counter buffer which is read when vkCmdBeginTransformFeedbackEXT executes.
VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT specifies write access to a transform feedback counter buffer which is written when vkCmdEndTransformFeedbackEXT executes.
VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX specifies reads from VkBuffer inputs to vkCmdProcessCommandsNVX.
VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX specifies writes to the target command buffer in vkCmdProcessCommandsNVX.
VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT is similar to VK_ACCESS_COLOR_ATTACHMENT_READ_BIT, but also includes advanced blend operations.
VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV specifies read access to a shading rate image as part of a drawing command, as bound by vkCmdBindShadingRateImageNV.
VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV specifies read access to an acceleration structure as part of a trace or build command.
VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV specifies write access to an acceleration structure as part of a build command.
VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT specifies read access to a fragment density map attachment during dynamic fragment density map operations
Certain access types are only performed by a subset of pipeline stages. Any synchronization command that takes both stage masks and access masks uses both to define the access scopes - only the specified access types performed by the specified stages are included in the access scope. An application must not specify an access flag in a synchronization command if it does not include a pipeline stage in the corresponding stage mask that is able to perform accesses of that type. The following table lists, for each access flag, which pipeline stages can perform that type of access.

Table 12. Supported access types
Access flag	Supported pipeline stages
VK_ACCESS_INDIRECT_COMMAND_READ_BIT
VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT
VK_ACCESS_INDEX_READ_BIT
VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT
VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
VK_ACCESS_UNIFORM_READ_BIT
VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV, VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV, VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV, VK_PIPELINE_STAGE_VERTEX_SHADER_BIT, VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, or VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT
VK_ACCESS_SHADER_READ_BIT
VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV, VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV, VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV, VK_PIPELINE_STAGE_VERTEX_SHADER_BIT, VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, or VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT
VK_ACCESS_SHADER_WRITE_BIT
VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV, VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV, VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV, VK_PIPELINE_STAGE_VERTEX_SHADER_BIT, VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT, VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT, VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, or VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT
VK_ACCESS_INPUT_ATTACHMENT_READ_BIT
VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
VK_ACCESS_COLOR_ATTACHMENT_READ_BIT
VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT
VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, or VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, or VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
VK_ACCESS_TRANSFER_READ_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
VK_ACCESS_TRANSFER_WRITE_BIT
VK_PIPELINE_STAGE_TRANSFER_BIT
VK_ACCESS_HOST_READ_BIT
VK_PIPELINE_STAGE_HOST_BIT
VK_ACCESS_HOST_WRITE_BIT
VK_PIPELINE_STAGE_HOST_BIT
VK_ACCESS_MEMORY_READ_BIT
N/A
VK_ACCESS_MEMORY_WRITE_BIT
N/A
VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT
VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX
VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX
VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX
VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX
VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT
VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT
VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV
VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV
VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT
VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT
VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT
VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT
VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT
VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT
VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV
VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV, or VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV
VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV
VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV
VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT
VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT
If a memory object does not have the VK_MEMORY_PROPERTY_HOST_COHERENT_BIT property, then vkFlushMappedMemoryRanges must be called in order to guarantee that writes to the memory object from the host are made available to the host domain, where they can be further made available to the device domain via a domain operation. Similarly, vkInvalidateMappedMemoryRanges must be called to guarantee that writes which are available to the host domain are made visible to host operations.

If the memory object does have the VK_MEMORY_PROPERTY_HOST_COHERENT_BIT property flag, writes to the memory object from the host are automatically made available to the host domain. Similarly, writes made available to the host domain are automatically made visible to the host.

Note
The vkQueueSubmit command automatically performs a domain operation from host to device for all writes performed before the command executes, so in most cases an explicit memory barrier is not needed for this case. In the few circumstances where a submit does not occur between the host write and the device read access, writes can be made available by using an explicit memory barrier.
See Also
VkAccessFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAccessFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAttachmentDescriptionFlagBits(3)
Name
VkAttachmentDescriptionFlagBits - Bitmask specifying additional properties of an attachment

C Specification
Bits which can be set in VkAttachmentDescription::flags describing additional properties of the attachment are:

typedef enum VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x00000001,
    VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentDescriptionFlagBits;
Description
VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT specifies that the attachment aliases the same device memory as other attachments.
See Also
VkAttachmentDescriptionFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAttachmentDescriptionFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAttachmentLoadOp(3)
Name
VkAttachmentLoadOp - Specify how contents of an attachment are treated at the beginning of a subpass

C Specification
Possible values of VkAttachmentDescription::loadOp and stencilLoadOp, specifying how the contents of the attachment are treated, are:

typedef enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentLoadOp;
Description
VK_ATTACHMENT_LOAD_OP_LOAD specifies that the previous contents of the image within the render area will be preserved. For attachments with a depth/stencil format, this uses the access type VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT. For attachments with a color format, this uses the access type VK_ACCESS_COLOR_ATTACHMENT_READ_BIT.
VK_ATTACHMENT_LOAD_OP_CLEAR specifies that the contents within the render area will be cleared to a uniform value, which is specified when a render pass instance is begun. For attachments with a depth/stencil format, this uses the access type VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT. For attachments with a color format, this uses the access type VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT.
VK_ATTACHMENT_LOAD_OP_DONT_CARE specifies that the previous contents within the area need not be preserved; the contents of the attachment will be undefined inside the render area. For attachments with a depth/stencil format, this uses the access type VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT. For attachments with a color format, this uses the access type VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT.
See Also
VkAttachmentDescription, VkAttachmentDescription2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAttachmentLoadOp

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkAttachmentStoreOp(3)
Name
VkAttachmentStoreOp - Specify how contents of an attachment are treated at the end of a subpass

C Specification
Possible values of VkAttachmentDescription::storeOp and stencilStoreOp, specifying how the contents of the attachment are treated, are:

typedef enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    VK_ATTACHMENT_STORE_OP_MAX_ENUM = 0x7FFFFFFF
} VkAttachmentStoreOp;
Description
VK_ATTACHMENT_STORE_OP_STORE specifies the contents generated during the render pass and within the render area are written to memory. For attachments with a depth/stencil format, this uses the access type VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT. For attachments with a color format, this uses the access type VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT.
VK_ATTACHMENT_STORE_OP_DONT_CARE specifies the contents within the render area are not needed after rendering, and may be discarded; the contents of the attachment will be undefined inside the render area. For attachments with a depth/stencil format, this uses the access type VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT. For attachments with a color format, this uses the access type VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT.
See Also
VkAttachmentDescription, VkAttachmentDescription2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAttachmentStoreOp

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBlendFactor(3)
Name
VkBlendFactor - Framebuffer blending factors

C Specification
The source and destination color and alpha blending factors are selected from the enum:

typedef enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    VK_BLEND_FACTOR_MAX_ENUM = 0x7FFFFFFF
} VkBlendFactor;
Description
The semantics of each enum value is described in the table below:

Table 13. Blend Factors
VkBlendFactor	RGB Blend Factors (Sr,Sg,Sb) or (Dr,Dg,Db)	Alpha Blend Factor (Sa or Da)
VK_BLEND_FACTOR_ZERO
(0,0,0)
0
VK_BLEND_FACTOR_ONE
(1,1,1)
1
VK_BLEND_FACTOR_SRC_COLOR
(Rs0,Gs0,Bs0)
As0
VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR
(1-Rs0,1-Gs0,1-Bs0)
1-As0
VK_BLEND_FACTOR_DST_COLOR
(Rd,Gd,Bd)
Ad
VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR
(1-Rd,1-Gd,1-Bd)
1-Ad
VK_BLEND_FACTOR_SRC_ALPHA
(As0,As0,As0)
As0
VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA
(1-As0,1-As0,1-As0)
1-As0
VK_BLEND_FACTOR_DST_ALPHA
(Ad,Ad,Ad)
Ad
VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA
(1-Ad,1-Ad,1-Ad)
1-Ad
VK_BLEND_FACTOR_CONSTANT_COLOR
(Rc,Gc,Bc)
Ac
VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR
(1-Rc,1-Gc,1-Bc)
1-Ac
VK_BLEND_FACTOR_CONSTANT_ALPHA
(Ac,Ac,Ac)
Ac
VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA
(1-Ac,1-Ac,1-Ac)
1-Ac
VK_BLEND_FACTOR_SRC_ALPHA_SATURATE
(f,f,f); f = min(As0,1-Ad)
1
VK_BLEND_FACTOR_SRC1_COLOR
(Rs1,Gs1,Bs1)
As1
VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR
(1-Rs1,1-Gs1,1-Bs1)
1-As1
VK_BLEND_FACTOR_SRC1_ALPHA
(As1,As1,As1)
As1
VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA
(1-As1,1-As1,1-As1)
1-As1
In this table, the following conventions are used:

Rs0,Gs0,Bs0 and As0 represent the first source color R, G, B, and A components, respectively, for the fragment output location corresponding to the color attachment being blended.
Rs1,Gs1,Bs1 and As1 represent the second source color R, G, B, and A components, respectively, used in dual source blending modes, for the fragment output location corresponding to the color attachment being blended.
Rd,Gd,Bd and Ad represent the R, G, B, and A components of the destination color. That is, the color currently in the corresponding color attachment for this fragment/sample.
Rc,Gc,Bc and Ac represent the blend constant R, G, B, and A components, respectively.
See Also
VkPipelineColorBlendAttachmentState

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBlendFactor

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBlendOp(3)
Name
VkBlendOp - Framebuffer blending operations

C Specification
Once the source and destination blend factors have been selected, they along with the source and destination components are passed to the blending operations. RGB and alpha components can use different operations. Possible values of VkBlendOp, specifying the operations, are:

typedef enum VkBlendOp {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_ZERO_EXT = 1000148000,
    VK_BLEND_OP_SRC_EXT = 1000148001,
    VK_BLEND_OP_DST_EXT = 1000148002,
    VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
    VK_BLEND_OP_DST_OVER_EXT = 1000148004,
    VK_BLEND_OP_SRC_IN_EXT = 1000148005,
    VK_BLEND_OP_DST_IN_EXT = 1000148006,
    VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
    VK_BLEND_OP_DST_OUT_EXT = 1000148008,
    VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
    VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
    VK_BLEND_OP_XOR_EXT = 1000148011,
    VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
    VK_BLEND_OP_SCREEN_EXT = 1000148013,
    VK_BLEND_OP_OVERLAY_EXT = 1000148014,
    VK_BLEND_OP_DARKEN_EXT = 1000148015,
    VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
    VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
    VK_BLEND_OP_COLORBURN_EXT = 1000148018,
    VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
    VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
    VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
    VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
    VK_BLEND_OP_INVERT_EXT = 1000148023,
    VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
    VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
    VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
    VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
    VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
    VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
    VK_BLEND_OP_HARDMIX_EXT = 1000148030,
    VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
    VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
    VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
    VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
    VK_BLEND_OP_PLUS_EXT = 1000148035,
    VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
    VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
    VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
    VK_BLEND_OP_MINUS_EXT = 1000148039,
    VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
    VK_BLEND_OP_CONTRAST_EXT = 1000148041,
    VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
    VK_BLEND_OP_RED_EXT = 1000148043,
    VK_BLEND_OP_GREEN_EXT = 1000148044,
    VK_BLEND_OP_BLUE_EXT = 1000148045,
    VK_BLEND_OP_MAX_ENUM = 0x7FFFFFFF
} VkBlendOp;
Description
The semantics of each basic blend operations is described in the table below:

Table 14. Basic Blend Operations
VkBlendOp	RGB Components	Alpha Component
VK_BLEND_OP_ADD
R = Rs0 × Sr + Rd × Dr
G = Gs0 × Sg + Gd × Dg
B = Bs0 × Sb + Bd × Db
A = As0 × Sa + Ad × Da
VK_BLEND_OP_SUBTRACT
R = Rs0 × Sr - Rd × Dr
G = Gs0 × Sg - Gd × Dg
B = Bs0 × Sb - Bd × Db
A = As0 × Sa - Ad × Da
VK_BLEND_OP_REVERSE_SUBTRACT
R = Rd × Dr - Rs0 × Sr
G = Gd × Dg - Gs0 × Sg
B = Bd × Db - Bs0 × Sb
A = Ad × Da - As0 × Sa
VK_BLEND_OP_MIN
R = min(Rs0,Rd)
G = min(Gs0,Gd)
B = min(Bs0,Bd)
A = min(As0,Ad)
VK_BLEND_OP_MAX
R = max(Rs0,Rd)
G = max(Gs0,Gd)
B = max(Bs0,Bd)
A = max(As0,Ad)
In this table, the following conventions are used:

Rs0, Gs0, Bs0 and As0 represent the first source color R, G, B, and A components, respectively.
Rd, Gd, Bd and Ad represent the R, G, B, and A components of the destination color. That is, the color currently in the corresponding color attachment for this fragment/sample.
Sr, Sg, Sb and Sa represent the source blend factor R, G, B, and A components, respectively.
Dr, Dg, Db and Da represent the destination blend factor R, G, B, and A components, respectively.
The blending operation produces a new set of values R, G, B and A, which are written to the framebuffer attachment. If blending is not enabled for this attachment, then R, G, B and A are assigned Rs0, Gs0, Bs0 and As0, respectively.

If the color attachment is fixed-point, the components of the source and destination values and blend factors are each clamped to [0,1] or [-1,1] respectively for an unsigned normalized or signed normalized color attachment prior to evaluating the blend operations. If the color attachment is floating-point, no clamping occurs.

See Also
VkPipelineColorBlendAttachmentState

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBlendOp

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBlendOverlapEXT(3)
Name
VkBlendOverlapEXT - Enumerant specifying the blend overlap parameter

C Specification
When blending using advanced blend operations, we expect that the R, G, and B components of premultiplied source and destination color inputs be stored as the product of non-premultiplied R, G, and B component values and the A component of the color. If any R, G, or B component of a premultiplied input color is non-zero and the A component is zero, the color is considered ill-formed, and the corresponding component of the blend result is undefined.

The weighting functions p0, p1, and p2 are defined in table Advanced Blend Overlap Modes. In these functions, the A components of the source and destination colors are taken to indicate the portion of the pixel covered by the fragment (source) and the fragments previously accumulated in the pixel (destination). The functions p0, p1, and p2 approximate the relative portion of the pixel covered by the intersection of the source and destination, covered only by the source, and covered only by the destination, respectively.

Possible values of VkPipelineColorBlendAdvancedStateCreateInfoEXT::blendOverlap, specifying the blend overlap functions, are:

typedef enum VkBlendOverlapEXT {
    VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
    VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
    VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
    VK_BLEND_OVERLAP_MAX_ENUM_EXT = 0x7FFFFFFF
} VkBlendOverlapEXT;
Description
VK_BLEND_OVERLAP_UNCORRELATED_EXT specifies that there is no correlation between the source and destination coverage.
VK_BLEND_OVERLAP_CONJOINT_EXT specifies that the source and destination coverage are considered to have maximal overlap.
VK_BLEND_OVERLAP_DISJOINT_EXT specifies that the source and destination coverage are considered to have minimal overlap.
Table 15. Advanced Blend Overlap Modes
Overlap Mode	Weighting Equations
VK_BLEND_OVERLAP_UNCORRELATED_EXT
\[ \begin{aligned} p_0(A_s,A_d) & = A_sA_d \\ p_1(A_s,A_d) & = A_s(1-A_d) \\ p_2(A_s,A_d) & = A_d(1-A_s) \\ \end{aligned}\]
VK_BLEND_OVERLAP_CONJOINT_EXT
\[ \begin{aligned} p_0(A_s,A_d) & = min(A_s,A_d) \\ p_1(A_s,A_d) & = max(A_s-A_d,0) \\ p_2(A_s,A_d) & = max(A_d-A_s,0) \\ \end{aligned}\]
VK_BLEND_OVERLAP_DISJOINT_EXT
\[ \begin{aligned} p_0(A_s,A_d) & = max(A_s+A_d-1,0) \\ p_1(A_s,A_d) & = min(A_s,1-A_d) \\ p_2(A_s,A_d) & = min(A_d,1-A_s) \\ \end{aligned}\]
See Also
VkPipelineColorBlendAdvancedStateCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBlendOverlapEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBorderColor(3)
Name
VkBorderColor - Specify border color used for texture lookups

C Specification
Possible values of VkSamplerCreateInfo::borderColor, specifying the border color used for texture lookups, are:

typedef enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    VK_BORDER_COLOR_MAX_ENUM = 0x7FFFFFFF
} VkBorderColor;
Description
VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK specifies a transparent, floating-point format, black color.
VK_BORDER_COLOR_INT_TRANSPARENT_BLACK specifies a transparent, integer format, black color.
VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK specifies an opaque, floating-point format, black color.
VK_BORDER_COLOR_INT_OPAQUE_BLACK specifies an opaque, integer format, black color.
VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE specifies an opaque, floating-point format, white color.
VK_BORDER_COLOR_INT_OPAQUE_WHITE specifies an opaque, integer format, white color.
These colors are described in detail in Texel Replacement.

See Also
VkSamplerCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBorderColor

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferCreateFlagBits(3)
Name
VkBufferCreateFlagBits - Bitmask specifying additional parameters of a buffer

C Specification
Bits which can be set in VkBufferCreateInfo::flags, specifying additional parameters of a buffer, are:

typedef enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_BUFFER_CREATE_PROTECTED_BIT = 0x00000008,
    VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 0x00000010,
    VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferCreateFlagBits;
Description
VK_BUFFER_CREATE_SPARSE_BINDING_BIT specifies that the buffer will be backed using sparse memory binding.
VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT specifies that the buffer can be partially backed using sparse memory binding. Buffers created with this flag must also be created with the VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag.
VK_BUFFER_CREATE_SPARSE_ALIASED_BIT specifies that the buffer will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another buffer (or another portion of the same buffer). Buffers created with this flag must also be created with the VK_BUFFER_CREATE_SPARSE_BINDING_BIT flag.
VK_BUFFER_CREATE_PROTECTED_BIT specifies that the buffer is a protected buffer.
VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT specifies that the buffer’s address can be saved and reused on a subsequent run (e.g. for trace capture and replay), see VkBufferDeviceAddressCreateInfoEXT for more detail.
See Sparse Resource Features and Physical Device Features for details of the sparse memory features supported on a device.

See Also
VkBufferCreateFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferCreateFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferUsageFlagBits(3)
Name
VkBufferUsageFlagBits - Bitmask specifying allowed usage of a buffer

C Specification
Bits which can be set in VkBufferCreateInfo::usage, specifying usage behavior of a buffer, are:

typedef enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100,
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800,
    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000,
    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200,
    VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = 0x00000400,
    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = 0x00020000,
    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkBufferUsageFlagBits;
Description
VK_BUFFER_USAGE_TRANSFER_SRC_BIT specifies that the buffer can be used as the source of a transfer command (see the definition of VK_PIPELINE_STAGE_TRANSFER_BIT).
VK_BUFFER_USAGE_TRANSFER_DST_BIT specifies that the buffer can be used as the destination of a transfer command.
VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT specifies that the buffer can be used to create a VkBufferView suitable for occupying a VkDescriptorSet slot of type VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.
VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT specifies that the buffer can be used to create a VkBufferView suitable for occupying a VkDescriptorSet slot of type VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.
VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT specifies that the buffer can be used in a VkDescriptorBufferInfo suitable for occupying a VkDescriptorSet slot either of type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.
VK_BUFFER_USAGE_STORAGE_BUFFER_BIT specifies that the buffer can be used in a VkDescriptorBufferInfo suitable for occupying a VkDescriptorSet slot either of type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.
VK_BUFFER_USAGE_INDEX_BUFFER_BIT specifies that the buffer is suitable for passing as the buffer parameter to vkCmdBindIndexBuffer.
VK_BUFFER_USAGE_VERTEX_BUFFER_BIT specifies that the buffer is suitable for passing as an element of the pBuffers array to vkCmdBindVertexBuffers.
VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT specifies that the buffer is suitable for passing as the buffer parameter to vkCmdDrawIndirect, vkCmdDrawIndexedIndirect, vkCmdDrawMeshTasksIndirectNV, vkCmdDrawMeshTasksIndirectCountNV, or vkCmdDispatchIndirect. It is also suitable for passing as the buffer member of VkIndirectCommandsTokenNVX, or sequencesCountBuffer or sequencesIndexBuffer member of VkCmdProcessCommandsInfoNVX
VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT specifies that the buffer is suitable for passing as the buffer parameter to vkCmdBeginConditionalRenderingEXT.
VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT specifies that the buffer is suitable for using for binding as a transform feedback buffer with vkCmdBindTransformFeedbackBuffersEXT.
VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT specifies that the buffer is suitable for using as a counter buffer with vkCmdBeginTransformFeedbackEXT and vkCmdEndTransformFeedbackEXT.
VK_BUFFER_USAGE_RAY_TRACING_BIT_NV specifies that the buffer is suitable for use in vkCmdTraceRaysNV and vkCmdBuildAccelerationStructureNV.
VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT specifies that the buffer can be used to retrieve a buffer device address via vkGetBufferDeviceAddressEXT and use that address to access the buffer’s memory from a shader.
See Also
VkBufferUsageFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferUsageFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBuildAccelerationStructureFlagBitsNV(3)
Name
VkBuildAccelerationStructureFlagBitsNV - Bitmask specifying additional parameters for acceleration structure builds

C Specification
Bits which can be set in VkAccelerationStructureInfoNV::flags, specifying additional parameters for acceleration structure builds, are:

typedef enum VkBuildAccelerationStructureFlagBitsNV {
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV = 0x00000001,
    VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV = 0x00000002,
    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV = 0x00000004,
    VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV = 0x00000008,
    VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV = 0x00000010,
    VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkBuildAccelerationStructureFlagBitsNV;
Description
VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV indicates that the specified acceleration structure can be updated with update of VK_TRUE in vkCmdBuildAccelerationStructureNV.
VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV indicates that the specified acceleration structure can act as the source for vkCmdCopyAccelerationStructureNV with mode of VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV to produce a compacted acceleration structure.
VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV indicates that the given acceleration structure build should prioritize trace performance over build time.
VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV indicates that the given acceleration structure build should prioritize build time over trace performance.
VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV indicates that this acceleration structure should minimize the size of the scratch memory and the final result build, potentially at the expense of build time or trace performance.
Note
VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV and VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV may take more time and memory than a normal build, and so should only be used when those features are used.
See Also
VkBuildAccelerationStructureFlagsNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBuildAccelerationStructureFlagBitsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkChromaLocation(3)
Name
VkChromaLocation - Position of downsampled chroma samples

C Specification
The VkChromaLocation enum, which defines the location of downsampled chroma channel samples relative to the luma samples, is defined as:

typedef enum VkChromaLocation {
    VK_CHROMA_LOCATION_COSITED_EVEN = 0,
    VK_CHROMA_LOCATION_MIDPOINT = 1,
    VK_CHROMA_LOCATION_COSITED_EVEN_KHR = VK_CHROMA_LOCATION_COSITED_EVEN,
    VK_CHROMA_LOCATION_MIDPOINT_KHR = VK_CHROMA_LOCATION_MIDPOINT,
    VK_CHROMA_LOCATION_MAX_ENUM = 0x7FFFFFFF
} VkChromaLocation;
or the equivalent

typedef VkChromaLocation VkChromaLocationKHR;
Description
VK_CHROMA_LOCATION_COSITED_EVEN specifies that downsampled chroma samples are aligned with luma samples with even coordinates.
VK_CHROMA_LOCATION_MIDPOINT specifies that downsampled chroma samples are located half way between each even luma sample and the nearest higher odd luma sample.
See Also
VkAndroidHardwareBufferFormatPropertiesANDROID, VkSamplerYcbcrConversionCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkChromaLocation

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCoarseSampleOrderTypeNV(3)
Name
VkCoarseSampleOrderTypeNV - Shading rate image sample ordering types

C Specification
The type VkCoarseSampleOrderTypeNV specifies the technique used to order coverage samples in fragments larger than one pixel, and is defined as:

typedef enum VkCoarseSampleOrderTypeNV {
    VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0,
    VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1,
    VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2,
    VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3,
    VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
} VkCoarseSampleOrderTypeNV;
Description
VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV specifies that coverage samples will be ordered in an implementation-dependent manner.
VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV specifies that coverage samples will be ordered according to the array of custom orderings provided in either the pCustomSampleOrders member of VkPipelineViewportCoarseSampleOrderStateCreateInfoNV or the pCustomSampleOrders member of vkCmdSetCoarseSampleOrderNV.
VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV specifies that coverage samples will be ordered sequentially, sorted first by pixel coordinate (in row-major order) and then by coverage sample number.
VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV specifies that coverage samples will be ordered sequentially, sorted first by coverage sample number and then by pixel coordinate (in row-major order).
See Also
VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, vkCmdSetCoarseSampleOrderNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCoarseSampleOrderTypeNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkColorComponentFlagBits(3)
Name
VkColorComponentFlagBits - Bitmask controlling which components are written to the framebuffer

C Specification
Bits which can be set in VkPipelineColorBlendAttachmentState::colorWriteMask to determine whether the final color values R, G, B and A are written to the framebuffer attachment are:

typedef enum VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT = 0x00000001,
    VK_COLOR_COMPONENT_G_BIT = 0x00000002,
    VK_COLOR_COMPONENT_B_BIT = 0x00000004,
    VK_COLOR_COMPONENT_A_BIT = 0x00000008,
    VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkColorComponentFlagBits;
Description
VK_COLOR_COMPONENT_R_BIT specifies that the R value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified.
VK_COLOR_COMPONENT_G_BIT specifies that the G value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified.
VK_COLOR_COMPONENT_B_BIT specifies that the B value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified.
VK_COLOR_COMPONENT_A_BIT specifies that the A value is written to the color attachment for the appropriate sample. Otherwise, the value in memory is unmodified.
The color write mask operation is applied regardless of whether blending is enabled.

See Also
VkColorComponentFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkColorComponentFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkColorSpaceKHR(3)
Name
VkColorSpaceKHR - supported color space of the presentation engine

C Specification
Possible values of VkSurfaceFormatKHR::colorSpace, specifying supported color spaces of a presentation engine, are:

typedef enum VkColorSpaceKHR {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
    VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = 1000104003,
    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
    VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
    VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
    VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
    VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
    VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
    VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
    VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
    VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
    VK_COLORSPACE_SRGB_NONLINEAR_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkColorSpaceKHR;
Description
VK_COLOR_SPACE_SRGB_NONLINEAR_KHR specifies support for the sRGB color space.
VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT specifies support for the Display-P3 color space and applies an sRGB-like transfer function (defined below).
VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT specifies support for the extended sRGB color space and applies a linear transfer function.
VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT specifies support for the extended sRGB color space and applies an sRGB transfer function.
VK_COLOR_SPACE_DCI_P3_LINEAR_EXT specifies support for the DCI-P3 color space and applies a linear OETF.
VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT specifies support for the DCI-P3 color space and applies the Gamma 2.6 OETF.
VK_COLOR_SPACE_BT709_LINEAR_EXT specifies support for the BT709 color space and applies a linear OETF.
VK_COLOR_SPACE_BT709_NONLINEAR_EXT specifies support for the BT709 color space and applies the SMPTE 170M OETF.
VK_COLOR_SPACE_BT2020_LINEAR_EXT specifies support for the BT2020 color space and applies a linear OETF.
VK_COLOR_SPACE_HDR10_ST2084_EXT specifies support for the HDR10 (BT2020 color) space and applies the SMPTE ST2084 Perceptual Quantizer (PQ) OETF.
VK_COLOR_SPACE_DOLBYVISION_EXT specifies support for the Dolby Vision (BT2020 color space), proprietary encoding, and applies the SMPTE ST2084 OETF.
VK_COLOR_SPACE_HDR10_HLG_EXT specifies support for the HDR10 (BT2020 color space) and applies the Hybrid Log Gamma (HLG) OETF.
VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT specifies support for the AdobeRGB color space and applies a linear OETF.
VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT specifies support for the AdobeRGB color space and applies the Gamma 2.2 OETF.
VK_COLOR_SPACE_PASS_THROUGH_EXT specifies that color components are used “as is”. This is intended to allow applications to supply data for color spaces not described here.
VK_COLOR_SPACE_DISPLAY_NATIVE_AMD specifies support for the display’s native color space. This matches the color space expectations of AMD’s FreeSync2 standard, for displays supporting it.
The color components of Non-linear color space swap chain images have had the appropriate transfer function applied. Vulkan requires that all implementations support the sRGB transfer function when using an SRGB pixel format. Other transfer functions, such as SMPTE 170M or SMPTE2084, must not be performed by the implementation, but can be performed by the application shader. This extension defines enums for VkColorSpaceKHR that correspond to the following color spaces:

Table 16. Color Spaces and Attributes
Name	Red Primary	Green Primary	Blue Primary	White-point	Transfer function
DCI-P3
0.680, 0.320
0.265, 0.690
0.150, 0.060
0.3127, 0.3290 (D65)
Gamma 2.6
Display-P3
0.680, 0.320
0.265, 0.690
0.150, 0.060
0.3127, 0.3290 (D65)
Display-P3
BT709
0.640, 0.330
0.300, 0.600
0.150, 0.060
0.3127, 0.3290 (D65)
SMPTE 170M
sRGB
0.640, 0.330
0.300, 0.600
0.150, 0.060
0.3127, 0.3290 (D65)
sRGB
extended sRGB
0.640, 0.330
0.300, 0.600
0.150, 0.060
0.3127, 0.3290 (D65)
extended sRGB
HDR10_ST2084
0.708, 0.292
0.170, 0.797
0.131, 0.046
0.3127, 0.3290 (D65)
ST2084
DOLBYVISION
0.708, 0.292
0.170, 0.797
0.131, 0.046
0.3127, 0.3290 (D65)
ST2084
HDR10_HLG
0.708, 0.292
0.170, 0.797
0.131, 0.046
0.3127, 0.3290 (D65)
HLG
AdobeRGB
0.640, 0.330
0.210, 0.710
0.150, 0.060
0.3127, 0.3290 (D65)
AdobeRGB
For Opto-Electrical Transfer Function (OETF), unless otherwise specified, the values of L and E are defined as:

L - linear luminance of image \(0 \leq L \leq 1\) for conventional colorimetry

E - corresponding electrical signal (value stored in memory)

See Also
VkSurfaceFormatKHR, VkSwapchainCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkColorSpaceKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandBufferLevel(3)
Name
VkCommandBufferLevel - Enumerant specifying a command buffer level

C Specification
Possible values of VkCommandBufferAllocateInfo::level, specifying the command buffer level, are:

typedef enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferLevel;
Description
VK_COMMAND_BUFFER_LEVEL_PRIMARY specifies a primary command buffer.
VK_COMMAND_BUFFER_LEVEL_SECONDARY specifies a secondary command buffer.
See Also
VkCommandBufferAllocateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandBufferLevel

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandBufferResetFlagBits(3)
Name
VkCommandBufferResetFlagBits - Bitmask controlling behavior of a command buffer reset

C Specification
Bits which can be set in vkResetCommandBuffer::flags to control the reset operation are:

typedef enum VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferResetFlagBits;
Description
VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT specifies that most or all memory resources currently owned by the command buffer should be returned to the parent command pool. If this flag is not set, then the command buffer may hold onto memory resources and reuse them when recording commands. commandBuffer is moved to the initial state.
See Also
VkCommandBufferResetFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandBufferResetFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandBufferUsageFlagBits(3)
Name
VkCommandBufferUsageFlagBits - Bitmask specifying usage behavior for command buffer

C Specification
Bits which can be set in VkCommandBufferBeginInfo::flags to specify usage behavior for a command buffer are:

typedef enum VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004,
    VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandBufferUsageFlagBits;
Description
VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT specifies that each recording of the command buffer will only be submitted once, and the command buffer will be reset and recorded again between each submission.
VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT specifies that a secondary command buffer is considered to be entirely inside a render pass. If this is a primary command buffer, then this bit is ignored.
VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT specifies that a command buffer can be resubmitted to a queue while it is in the pending state, and recorded into multiple primary command buffers.
See Also
VkCommandBufferUsageFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandBufferUsageFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandPoolCreateFlagBits(3)
Name
VkCommandPoolCreateFlagBits - Bitmask specifying usage behavior for a command pool

C Specification
Bits which can be set in VkCommandPoolCreateInfo::flags to specify usage behavior for a command pool are:

typedef enum VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002,
    VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 0x00000004,
    VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolCreateFlagBits;
Description
VK_COMMAND_POOL_CREATE_TRANSIENT_BIT specifies that command buffers allocated from the pool will be short-lived, meaning that they will be reset or freed in a relatively short timeframe. This flag may be used by the implementation to control memory allocation behavior within the pool.
VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT allows any command buffer allocated from a pool to be individually reset to the initial state; either by calling vkResetCommandBuffer, or via the implicit reset when calling vkBeginCommandBuffer. If this flag is not set on a pool, then vkResetCommandBuffer must not be called for any command buffer allocated from that pool.
VK_COMMAND_POOL_CREATE_PROTECTED_BIT specifies that command buffers allocated from the pool are protected command buffers. If the protected memory feature is not enabled, the VK_COMMAND_POOL_CREATE_PROTECTED_BIT bit of flags must not be set.
See Also
VkCommandPoolCreateFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandPoolCreateFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandPoolResetFlagBits(3)
Name
VkCommandPoolResetFlagBits - Bitmask controlling behavior of a command pool reset

C Specification
Bits which can be set in vkResetCommandPool::flags to control the reset operation are:

typedef enum VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x00000001,
    VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCommandPoolResetFlagBits;
Description
VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT specifies that resetting a command pool recycles all of the resources from the command pool back to the system.
See Also
VkCommandPoolResetFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandPoolResetFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCompareOp(3)
Name
VkCompareOp - Stencil comparison function

C Specification
Possible values of VkStencilOpState::compareOp, specifying the stencil comparison function, are:

typedef enum VkCompareOp {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    VK_COMPARE_OP_MAX_ENUM = 0x7FFFFFFF
} VkCompareOp;
Description
VK_COMPARE_OP_NEVER specifies that the test never passes.
VK_COMPARE_OP_LESS specifies that the test passes when R < S.
VK_COMPARE_OP_EQUAL specifies that the test passes when R = S.
VK_COMPARE_OP_LESS_OR_EQUAL specifies that the test passes when R ≤ S.
VK_COMPARE_OP_GREATER specifies that the test passes when R > S.
VK_COMPARE_OP_NOT_EQUAL specifies that the test passes when R ≠ S.
VK_COMPARE_OP_GREATER_OR_EQUAL specifies that the test passes when R ≥ S.
VK_COMPARE_OP_ALWAYS specifies that the test always passes.
See Also
VkPipelineDepthStencilStateCreateInfo, VkSamplerCreateInfo, VkStencilOpState

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCompareOp

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkComponentSwizzle(3)
Name
VkComponentSwizzle - Specify how a component is swizzled

C Specification
Possible values of the members of VkComponentMapping, specifying the component values placed in each component of the output vector, are:

typedef enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    VK_COMPONENT_SWIZZLE_MAX_ENUM = 0x7FFFFFFF
} VkComponentSwizzle;
Description
VK_COMPONENT_SWIZZLE_IDENTITY specifies that the component is set to the identity swizzle.
VK_COMPONENT_SWIZZLE_ZERO specifies that the component is set to zero.
VK_COMPONENT_SWIZZLE_ONE specifies that the component is set to either 1 or 1.0, depending on whether the type of the image view format is integer or floating-point respectively, as determined by the Format Definition section for each VkFormat.
VK_COMPONENT_SWIZZLE_R specifies that the component is set to the value of the R component of the image.
VK_COMPONENT_SWIZZLE_G specifies that the component is set to the value of the G component of the image.
VK_COMPONENT_SWIZZLE_B specifies that the component is set to the value of the B component of the image.
VK_COMPONENT_SWIZZLE_A specifies that the component is set to the value of the A component of the image.
Setting the identity swizzle on a component is equivalent to setting the identity mapping on that component. That is:

Table 17. Component Mappings Equivalent To VK_COMPONENT_SWIZZLE_IDENTITY
Component	Identity Mapping
components.r
VK_COMPONENT_SWIZZLE_R
components.g
VK_COMPONENT_SWIZZLE_G
components.b
VK_COMPONENT_SWIZZLE_B
components.a
VK_COMPONENT_SWIZZLE_A
See Also
VkComponentMapping

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkComponentSwizzle

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkComponentTypeNV(3)
Name
VkComponentTypeNV - Specify SPIR-V cooperative matrix component type

C Specification
Possible values for VkComponentTypeNV include:

typedef enum VkComponentTypeNV {
    VK_COMPONENT_TYPE_FLOAT16_NV = 0,
    VK_COMPONENT_TYPE_FLOAT32_NV = 1,
    VK_COMPONENT_TYPE_FLOAT64_NV = 2,
    VK_COMPONENT_TYPE_SINT8_NV = 3,
    VK_COMPONENT_TYPE_SINT16_NV = 4,
    VK_COMPONENT_TYPE_SINT32_NV = 5,
    VK_COMPONENT_TYPE_SINT64_NV = 6,
    VK_COMPONENT_TYPE_UINT8_NV = 7,
    VK_COMPONENT_TYPE_UINT16_NV = 8,
    VK_COMPONENT_TYPE_UINT32_NV = 9,
    VK_COMPONENT_TYPE_UINT64_NV = 10,
    VK_COMPONENT_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
} VkComponentTypeNV;
Description
VK_COMPONENT_TYPE_FLOAT16_NV corresponds to SPIR-V OpTypeFloat 16.
VK_COMPONENT_TYPE_FLOAT32_NV corresponds to SPIR-V OpTypeFloat 32.
VK_COMPONENT_TYPE_FLOAT64_NV corresponds to SPIR-V OpTypeFloat 64.
VK_COMPONENT_TYPE_SINT8_NV corresponds to SPIR-V OpTypeInt 8 1.
VK_COMPONENT_TYPE_SINT16_NV corresponds to SPIR-V OpTypeInt 16 1.
VK_COMPONENT_TYPE_SINT32_NV corresponds to SPIR-V OpTypeInt 32 1.
VK_COMPONENT_TYPE_SINT64_NV corresponds to SPIR-V OpTypeInt 64 1.
VK_COMPONENT_TYPE_UINT8_NV corresponds to SPIR-V OpTypeInt 8 0.
VK_COMPONENT_TYPE_UINT16_NV corresponds to SPIR-V OpTypeInt 16 0.
VK_COMPONENT_TYPE_UINT32_NV corresponds to SPIR-V OpTypeInt 32 0.
VK_COMPONENT_TYPE_UINT64_NV corresponds to SPIR-V OpTypeInt 64 0.
See Also
VkCooperativeMatrixPropertiesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkComponentTypeNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCompositeAlphaFlagBitsKHR(3)
Name
VkCompositeAlphaFlagBitsKHR - alpha compositing modes supported on a device

C Specification
The supportedCompositeAlpha member is of type VkCompositeAlphaFlagBitsKHR, which contains the following values:

typedef enum VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x00000002,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x00000004,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x00000008,
    VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkCompositeAlphaFlagBitsKHR;
Description
These values are described as follows:

VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR: The alpha channel, if it exists, of the images is ignored in the compositing process. Instead, the image is treated as if it has a constant alpha of 1.0.
VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR: The alpha channel, if it exists, of the images is respected in the compositing process. The non-alpha channels of the image are expected to already be multiplied by the alpha channel by the application.
VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: The alpha channel, if it exists, of the images is respected in the compositing process. The non-alpha channels of the image are not expected to already be multiplied by the alpha channel by the application; instead, the compositor will multiply the non-alpha channels of the image by the alpha channel during compositing.
VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR: The way in which the presentation engine treats the alpha channel in the images is unknown to the Vulkan API. Instead, the application is responsible for setting the composite alpha blending mode using native window system commands. If the application does not set the blending mode using native window system commands, then a platform-specific default will be used.
See Also
VkCompositeAlphaFlagsKHR, VkSwapchainCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCompositeAlphaFlagBitsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkConditionalRenderingFlagBitsEXT(3)
Name
VkConditionalRenderingFlagBitsEXT - Specify the behavior of conditional rendering

C Specification
Bits which can be set in vkCmdBeginConditionalRenderingEXT::flags specifying the behavior of conditional rendering are:

typedef enum VkConditionalRenderingFlagBitsEXT {
    VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 0x00000001,
    VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkConditionalRenderingFlagBitsEXT;
Description
VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT specifies the condition used to determine whether to discard rendering commands or not. That is, if the 32-bit predicate read from buffer memory at offset is zero, the rendering commands are not discarded, and if non zero, then they are discarded.
See Also
VkConditionalRenderingFlagsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkConditionalRenderingFlagBitsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkConservativeRasterizationModeEXT(3)
Name
VkConservativeRasterizationModeEXT - Specify the conservative rasterization mode

C Specification
Possible values of VkPipelineRasterizationConservativeStateCreateInfoEXT::conservativeRasterizationMode, specifying the conservative rasterization mode are:

typedef enum VkConservativeRasterizationModeEXT {
    VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
    VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
    VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2,
    VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkConservativeRasterizationModeEXT;
Description
VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT specifies that conservative rasterization is disabled and rasterization proceeds as normal.
VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT specifies that conservative rasterization is enabled in overestimation mode.
VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT specifies that conservative rasterization is enabled in underestimation mode.
See Also
VkPipelineRasterizationConservativeStateCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkConservativeRasterizationModeEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCopyAccelerationStructureModeNV(3)
Name
VkCopyAccelerationStructureModeNV - Acceleration structure copy mode

C Specification
Possible values of vkCmdCopyAccelerationStructureNV::mode, specifying additional operations to perform during the copy, are:

typedef enum VkCopyAccelerationStructureModeNV {
    VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV = 0,
    VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV = 1,
    VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_NV = 0x7FFFFFFF
} VkCopyAccelerationStructureModeNV;
Description
VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV creates a direct copy of the acceleration structure specified in src into the one specified by dst. The dst acceleration structure must have been created with the same parameters as src.
VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV creates a more compact version of an acceleration structure src into dst. The acceleration structure dst must have been created with a compactedSize corresponding to the one returned by vkCmdWriteAccelerationStructuresPropertiesNV after the build of the acceleration structure specified by src.
See Also
vkCmdCopyAccelerationStructureNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCopyAccelerationStructureModeNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCoverageModulationModeNV(3)
Name
VkCoverageModulationModeNV - Specify the discard rectangle mode

C Specification
Possible values of VkPipelineCoverageModulationStateCreateInfoNV::coverageModulationMode, specifying which color components are modulated, are:

typedef enum VkCoverageModulationModeNV {
    VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
    VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
    VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
    VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
    VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV = 0x7FFFFFFF
} VkCoverageModulationModeNV;
Description
VK_COVERAGE_MODULATION_MODE_NONE_NV specifies that no components are multiplied by the modulation factor.
VK_COVERAGE_MODULATION_MODE_RGB_NV specifies that the red, green, and blue components are multiplied by the modulation factor.
VK_COVERAGE_MODULATION_MODE_ALPHA_NV specifies that the alpha component is multiplied by the modulation factor.
VK_COVERAGE_MODULATION_MODE_RGBA_NV specifies that all components are multiplied by the modulation factor.
See Also
VkPipelineCoverageModulationStateCreateInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCoverageModulationModeNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCullModeFlagBits(3)
Name
VkCullModeFlagBits - Bitmask controlling triangle culling

C Specification
Once the orientation of triangles is determined, they are culled according to the VkPipelineRasterizationStateCreateInfo::cullMode property of the currently active pipeline. Possible values are:

typedef enum VkCullModeFlagBits {
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 0x00000001,
    VK_CULL_MODE_BACK_BIT = 0x00000002,
    VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
    VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkCullModeFlagBits;
Description
VK_CULL_MODE_NONE specifies that no triangles are discarded
VK_CULL_MODE_FRONT_BIT specifies that front-facing triangles are discarded
VK_CULL_MODE_BACK_BIT specifies that back-facing triangles are discarded
VK_CULL_MODE_FRONT_AND_BACK specifies that all triangles are discarded.
Following culling, fragments are produced for any triangles which have not been discarded.

See Also
VkCullModeFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCullModeFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugReportFlagBitsEXT(3)
Name
VkDebugReportFlagBitsEXT - Bitmask specifying events which cause a debug report callback

C Specification
Bits which can be set in VkDebugReportCallbackCreateInfoEXT::flags, specifying events which cause a debug report, are:

typedef enum VkDebugReportFlagBitsEXT {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x00000001,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x00000002,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x00000004,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x00000008,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x00000010,
    VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportFlagBitsEXT;
Description
VK_DEBUG_REPORT_ERROR_BIT_EXT specifies that the application has violated a valid usage condition of the specification.
VK_DEBUG_REPORT_WARNING_BIT_EXT specifies use of Vulkan that may expose an app bug. Such cases may not be immediately harmful, such as a fragment shader outputting to a location with no attachment. Other cases may point to behavior that is almost certainly bad when unintended such as using an image whose memory has not been filled. In general if you see a warning but you know that the behavior is intended/desired, then simply ignore the warning.
VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT specifies a potentially non-optimal use of Vulkan, e.g. using vkCmdClearColorImage when setting VkAttachmentDescription::loadOp to VK_ATTACHMENT_LOAD_OP_CLEAR would have worked.
VK_DEBUG_REPORT_INFORMATION_BIT_EXT specifies an informational message such as resource details that may be handy when debugging an application.
VK_DEBUG_REPORT_DEBUG_BIT_EXT specifies diagnostic information from the implementation and layers.
See Also
VkDebugReportFlagsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugReportFlagBitsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugReportObjectTypeEXT(3)
Name
VkDebugReportObjectTypeEXT - Specify the type of an object handle

C Specification
Possible values passed to the objectType parameter of the callback function specified by VkDebugReportCallbackCreateInfoEXT::pfnCallback, specifying the type of object handle being reported, are:

typedef enum VkDebugReportObjectTypeEXT {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
    VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT = 31,
    VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = 32,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
    VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugReportObjectTypeEXT;
Description
Table 18. VkDebugReportObjectTypeEXT and Vulkan Handle Relationship
VkDebugReportObjectTypeEXT	Vulkan Handle Type
VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT
Unknown/Undefined Handle
VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT
VkInstance
VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT
VkPhysicalDevice
VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT
VkDevice
VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT
VkQueue
VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT
VkSemaphore
VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT
VkCommandBuffer
VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT
VkFence
VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT
VkDeviceMemory
VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT
VkBuffer
VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT
VkImage
VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT
VkEvent
VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT
VkQueryPool
VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT
VkBufferView
VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT
VkImageView
VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT
VkShaderModule
VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT
VkPipelineCache
VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT
VkPipelineLayout
VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT
VkRenderPass
VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT
VkPipeline
VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT
VkDescriptorSetLayout
VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT
VkSampler
VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT
VkDescriptorPool
VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT
VkDescriptorSet
VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT
VkFramebuffer
VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT
VkCommandPool
VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT
VkSurfaceKHR
VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT
VkSwapchainKHR
VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT
VkDebugReportCallbackEXT
VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT
VkDisplayKHR
VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT
VkDisplayModeKHR
VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT
VkObjectTableNVX
VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT
VkIndirectCommandsLayoutNVX
VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT
VkDescriptorUpdateTemplate
Note
The primary expected use of VK_ERROR_VALIDATION_FAILED_EXT is for validation layer testing. It is not expected that an application would see this error code during normal use of the validation layers.
See Also
VkDebugMarkerObjectNameInfoEXT, VkDebugMarkerObjectTagInfoEXT, vkDebugReportMessageEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugReportObjectTypeEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugUtilsMessageSeverityFlagBitsEXT(3)
Name
VkDebugUtilsMessageSeverityFlagBitsEXT - Bitmask specifying which severities of events cause a debug messenger callback

C Specification
Bits which can be set in VkDebugUtilsMessengerCreateInfoEXT::messageSeverity, specifying event severities which cause a debug messenger to call the callback, are:

typedef enum VkDebugUtilsMessageSeverityFlagBitsEXT {
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 0x00000001,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 0x00000010,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 0x00000100,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 0x00001000,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugUtilsMessageSeverityFlagBitsEXT;
Description
VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT specifies the most verbose output indicating all diagnostic messages from the Vulkan loader, layers, and drivers should be captured.
VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT specifies an informational message such as resource details that may be handy when debugging an application.
VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT specifies use of Vulkan that may expose an app bug. Such cases may not be immediately harmful, such as a fragment shader outputting to a location with no attachment. Other cases may point to behavior that is almost certainly bad when unintended such as using an image whose memory has not been filled. In general if you see a warning but you know that the behavior is intended/desired, then simply ignore the warning.
VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT specifies that the application has violated a valid usage condition of the specification.
See Also
VkDebugUtilsMessageSeverityFlagsEXT, vkSubmitDebugUtilsMessageEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugUtilsMessageSeverityFlagBitsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugUtilsMessageTypeFlagBitsEXT(3)
Name
VkDebugUtilsMessageTypeFlagBitsEXT - Bitmask specifying which types of events cause a debug messenger callback

C Specification
Bits which can be set in VkDebugUtilsMessengerCreateInfoEXT::messageType, specifying event types which cause a debug messenger to call the callback, are:

typedef enum VkDebugUtilsMessageTypeFlagBitsEXT {
    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 0x00000001,
    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 0x00000002,
    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 0x00000004,
    VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDebugUtilsMessageTypeFlagBitsEXT;
Description
VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT specifies that some general event has occurred. This is typically a non-specification, non-performance event.
VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT specifies that something has occurred during validation against the Vulkan specification that may indicate invalid behavior.
VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT specifies a potentially non-optimal use of Vulkan, e.g. using vkCmdClearColorImage when setting VkAttachmentDescription::loadOp to VK_ATTACHMENT_LOAD_OP_CLEAR would have worked.
See Also
VkDebugUtilsMessageTypeFlagsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugUtilsMessageTypeFlagBitsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDependencyFlagBits(3)
Name
VkDependencyFlagBits - Bitmask specifying how execution and memory dependencies are formed

C Specification
Bits which can be set in vkCmdPipelineBarrier::dependencyFlags, specifying how execution and memory dependencies are formed, are:

typedef enum VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT = 0x00000001,
    VK_DEPENDENCY_DEVICE_GROUP_BIT = 0x00000004,
    VK_DEPENDENCY_VIEW_LOCAL_BIT = 0x00000002,
    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,
    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT,
    VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDependencyFlagBits;
Description
VK_DEPENDENCY_BY_REGION_BIT specifies that dependencies will be framebuffer-local.
VK_DEPENDENCY_VIEW_LOCAL_BIT specifies that a subpass has more than one view.
VK_DEPENDENCY_DEVICE_GROUP_BIT specifies that dependencies are non-device-local dependency.
See Also
VkDependencyFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDependencyFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorBindingFlagBitsEXT(3)
Name
VkDescriptorBindingFlagBitsEXT - Bitmask specifying descriptor set layout binding properties

C Specification
Bits which can be set in each element of VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::pBindingFlags to specify options for the corresponding descriptor set layout binding are:

typedef enum VkDescriptorBindingFlagBitsEXT {
    VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = 0x00000001,
    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = 0x00000002,
    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = 0x00000004,
    VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = 0x00000008,
    VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDescriptorBindingFlagBitsEXT;
Description
VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT indicates that if descriptors in this binding are updated between when the descriptor set is bound in a command buffer and when that command buffer is submitted to a queue, then the submission will use the most recently set descriptors for this binding and the updates do not invalidate the command buffer. Descriptor bindings created with this flag are also partially exempt from the external synchronization requirement in vkUpdateDescriptorSetWithTemplateKHR and vkUpdateDescriptorSets. They can be updated concurrently with the set being bound to a command buffer in another thread, but not concurrently with the set being reset or freed.
VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT indicates that descriptors in this binding that are not dynamically used need not contain valid descriptors at the time the descriptors are consumed. A descriptor is dynamically used if any shader invocation executes an instruction that performs any memory access using the descriptor.
VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT indicates that descriptors in this binding can be updated after a command buffer has bound this descriptor set, or while a command buffer that uses this descriptor set is pending execution, as long as the descriptors that are updated are not used by those command buffers. If VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT is also set, then descriptors can be updated as long as they are not dynamically used by any shader invocations. If VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT is not set, then descriptors can be updated as long as they are not statically used by any shader invocations.
VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT indicates that this descriptor binding has a variable size that will be specified when a descriptor set is allocated using this layout. The value of descriptorCount is treated as an upper bound on the size of the binding. This must only be used for the last binding in the descriptor set layout (i.e. the binding with the largest value of binding). For the purposes of counting against limits such as maxDescriptorSet* and maxPerStageDescriptor*, the full value of descriptorCount is counted , except for descriptor bindings with a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT where descriptorCount specifies the upper bound on the byte size of the binding, thus it counts against the maxInlineUniformBlockSize limit instead. .
Note
Note that while VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT and VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT both involve updates to descriptor sets after they are bound, VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT is a weaker requirement since it is only about descriptors that are not used, whereas VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT requires the implementation to observe updates to descriptors that are used.
See Also
VkDescriptorBindingFlagsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorBindingFlagBitsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorPoolCreateFlagBits(3)
Name
VkDescriptorPoolCreateFlagBits - Bitmask specifying certain supported operations on a descriptor pool

C Specification
Bits which can be set in VkDescriptorPoolCreateInfo::flags to enable operations on a descriptor pool are:

typedef enum VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x00000001,
    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = 0x00000002,
    VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorPoolCreateFlagBits;
Description
VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT specifies that descriptor sets can return their individual allocations to the pool, i.e. all of vkAllocateDescriptorSets, vkFreeDescriptorSets, and vkResetDescriptorPool are allowed. Otherwise, descriptor sets allocated from the pool must not be individually freed back to the pool, i.e. only vkAllocateDescriptorSets and vkResetDescriptorPool are allowed.
VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT specifies that descriptor sets allocated from this pool can include bindings with the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT bit set. It is valid to allocate descriptor sets that have bindings that do not set the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT bit from a pool that has VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT set.
See Also
VkDescriptorPoolCreateFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorPoolCreateFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorSetLayoutCreateFlagBits(3)
Name
VkDescriptorSetLayoutCreateFlagBits - Bitmask specifying descriptor set layout properties

C Specification
Bits which can be set in VkDescriptorSetLayoutCreateInfo::flags to specify options for descriptor set layout are:

typedef enum VkDescriptorSetLayoutCreateFlagBits {
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x00000001,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = 0x00000002,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorSetLayoutCreateFlagBits;
Description
VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR specifies that descriptor sets must not be allocated using this layout, and descriptors are instead pushed by vkCmdPushDescriptorSetKHR.
VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT specifies that descriptor sets using this layout must be allocated from a descriptor pool created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT bit set. Descriptor set layouts created with this bit set have alternate limits for the maximum number of descriptors per-stage and per-pipeline layout. The non-UpdateAfterBind limits only count descriptors in sets created without this flag. The UpdateAfterBind limits count all descriptors, but the limits may be higher than the non-UpdateAfterBind limits.
See Also
VkDescriptorSetLayoutCreateFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorSetLayoutCreateFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorType(3)
Name
VkDescriptorType - Specifies the type of a descriptor in a descriptor set

C Specification
The type of descriptors in a descriptor set is specified by VkWriteDescriptorSet::descriptorType, which must be one of the values:

typedef enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = 1000138000,
    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
    VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorType;
Description
VK_DESCRIPTOR_TYPE_SAMPLER specifies a sampler descriptor.
VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER specifies a combined image sampler descriptor.
VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE specifies a sampled image descriptor.
VK_DESCRIPTOR_TYPE_STORAGE_IMAGE specifies a storage image descriptor.
VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER specifies a uniform texel buffer descriptor.
VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER specifies a storage texel buffer descriptor.
VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER specifies a uniform buffer descriptor.
VK_DESCRIPTOR_TYPE_STORAGE_BUFFER specifies a storage buffer descriptor.
VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC specifies a dynamic uniform buffer descriptor.
VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC specifies a dynamic storage buffer descriptor.
VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT specifies an input attachment descriptor.
VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT specifies an inline uniform block.
When a descriptor set is updated via elements of VkWriteDescriptorSet, members of pImageInfo, pBufferInfo and pTexelBufferView are only accessed by the implementation when they correspond to descriptor type being defined - otherwise they are ignored. The members accessed are as follows for each descriptor type:

For VK_DESCRIPTOR_TYPE_SAMPLER, only the sampler member of each element of VkWriteDescriptorSet::pImageInfo is accessed.
For VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, only the imageView and imageLayout members of each element of VkWriteDescriptorSet::pImageInfo are accessed.
For VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, all members of each element of VkWriteDescriptorSet::pImageInfo are accessed.
For VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, all members of each element of VkWriteDescriptorSet::pBufferInfo are accessed.
For VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, each element of VkWriteDescriptorSet::pTexelBufferView is accessed.
When updating descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, none of the pImageInfo, pBufferInfo, or pTexelBufferView members are accessed, instead the source data of the descriptor update operation is taken from the instance of VkWriteDescriptorSetInlineUniformBlockEXT in the pNext chain of VkWriteDescriptorSet. When updating descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, none of the pImageInfo, pBufferInfo, or pTexelBufferView members are accessed, instead the source data of the descriptor update operation is taken from the instance of VkWriteDescriptorSetAccelerationStructureNV in the pNext chain of VkWriteDescriptorSet.

See Also
VkDescriptorPoolSize, VkDescriptorSetLayoutBinding, VkDescriptorUpdateTemplateEntry, VkImageViewHandleInfoNVX, VkWriteDescriptorSet

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorType

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorUpdateTemplateType(3)
Name
VkDescriptorUpdateTemplateType - Indicates the valid usage of the descriptor update template

C Specification
The descriptor update template type is determined by the VkDescriptorUpdateTemplateCreateInfo::templateType property, which takes the following values:

typedef enum VkDescriptorUpdateTemplateType {
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkDescriptorUpdateTemplateType;
or the equivalent

typedef VkDescriptorUpdateTemplateType VkDescriptorUpdateTemplateTypeKHR;
Description
VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET specifies that the descriptor update template will be used for descriptor set updates only.
VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR specifies that the descriptor update template will be used for push descriptor updates only.
See Also
VkDescriptorUpdateTemplateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorUpdateTemplateType

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceEventTypeEXT(3)
Name
VkDeviceEventTypeEXT - Events that can occur on a device object

C Specification
Possible values of VkDeviceEventInfoEXT::device, specifying when a fence will be signaled, are:

typedef enum VkDeviceEventTypeEXT {
    VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
    VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDeviceEventTypeEXT;
Description
VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT specifies that the fence is signaled when a display is plugged into or unplugged from the specified device. Applications can use this notification to determine when they need to re-enumerate the available displays on a device.
See Also
VkDeviceEventInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceEventTypeEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceGroupPresentModeFlagBitsKHR(3)
Name
VkDeviceGroupPresentModeFlagBitsKHR - Bitmask specifying supported device group present modes

C Specification
Bits which may be set in VkDeviceGroupPresentCapabilitiesKHR::modes to indicate which device group presentation modes are supported are:

typedef enum VkDeviceGroupPresentModeFlagBitsKHR {
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 0x00000001,
    VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 0x00000002,
    VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 0x00000004,
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 0x00000008,
    VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkDeviceGroupPresentModeFlagBitsKHR;
Description
VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR specifies that any physical device with a presentation engine can present its own swapchain images.
VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR specifies that any physical device with a presentation engine can present swapchain images from any physical device in its presentMask.
VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR specifies that any physical device with a presentation engine can present the sum of swapchain images from any physical devices in its presentMask.
VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR specifies that multiple physical devices with a presentation engine can each present their own swapchain images.
See Also
VkDeviceGroupPresentInfoKHR, VkDeviceGroupPresentModeFlagsKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceGroupPresentModeFlagBitsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceQueueCreateFlagBits(3)
Name
VkDeviceQueueCreateFlagBits - Bitmask specifying behavior of the queue

C Specification
Bits which can be set in VkDeviceQueueCreateInfo::flags to specify usage behavior of the queue are:

typedef enum VkDeviceQueueCreateFlagBits {
    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001,
    VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkDeviceQueueCreateFlagBits;
Description
VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT specifies that the device queue is a protected-capable queue. If the protected memory feature is not enabled, the VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT bit of flags must not be set.
See Also
VkDeviceQueueCreateFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceQueueCreateFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDiscardRectangleModeEXT(3)
Name
VkDiscardRectangleModeEXT - Specify the discard rectangle mode

C Specification
Possible values of VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleMode, specifying the behavior of the discard rectangle test, are:

typedef enum VkDiscardRectangleModeEXT {
    VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
    VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
    VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDiscardRectangleModeEXT;
Description
VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT specifies that a fragment within any discard rectangle satisfies the test.
VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT specifies that a fragment not within any of the discard rectangles satisfies the test.
See Also
VkPipelineDiscardRectangleStateCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDiscardRectangleModeEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayEventTypeEXT(3)
Name
VkDisplayEventTypeEXT - Events that can occur on a display object

C Specification
Possible values of VkDisplayEventInfoEXT::displayEvent, specifying when a fence will be signaled, are:

typedef enum VkDisplayEventTypeEXT {
    VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
    VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDisplayEventTypeEXT;
Description
VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT specifies that the fence is signaled when the first pixel of the next display refresh cycle leaves the display engine for the display.
See Also
VkDisplayEventInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayEventTypeEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayPlaneAlphaFlagBitsKHR(3)
Name
VkDisplayPlaneAlphaFlagBitsKHR - Alpha blending type

C Specification
Possible values of VkDisplaySurfaceCreateInfoKHR::alphaMode, specifying the type of alpha blending to use on a display, are:

typedef enum VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x00000001,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x00000002,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x00000004,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x00000008,
    VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkDisplayPlaneAlphaFlagBitsKHR;
Description
VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR specifies that the source image will be treated as opaque.
VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR specifies that a global alpha value must be specified that will be applied to all pixels in the source image.
VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR specifies that the alpha value will be determined by the alpha channel of the source image’s pixels. If the source format contains no alpha values, no blending will be applied. The source alpha values are not premultiplied into the source image’s other color channels.
VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR is equivalent to VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR, except the source alpha values are assumed to be premultiplied into the source image’s other color channels.
See Also
VkDisplayPlaneAlphaFlagsKHR, VkDisplaySurfaceCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayPlaneAlphaFlagBitsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDisplayPowerStateEXT(3)
Name
VkDisplayPowerStateEXT - Possible power states for a display

C Specification
Possible values of VkDisplayPowerInfoEXT::powerState, specifying the new power state of a display, are:

typedef enum VkDisplayPowerStateEXT {
    VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
    VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
    VK_DISPLAY_POWER_STATE_ON_EXT = 2,
    VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkDisplayPowerStateEXT;
Description
VK_DISPLAY_POWER_STATE_OFF_EXT specifies that the display is powered down.
VK_DISPLAY_POWER_STATE_SUSPEND_EXT specifies that the display is put into a low power mode, from which it may be able to transition back to VK_DISPLAY_POWER_STATE_ON_EXT more quickly than if it were in VK_DISPLAY_POWER_STATE_OFF_EXT. This state may be the same as VK_DISPLAY_POWER_STATE_OFF_EXT.
VK_DISPLAY_POWER_STATE_ON_EXT specifies that the display is powered on.
See Also
VkDisplayPowerInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayPowerStateEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDriverIdKHR(3)
Name
VkDriverIdKHR - Khronos driver IDs

C Specification
Khronos driver IDs which may be returned in VkPhysicalDeviceDriverPropertiesKHR::driverID are:

typedef enum VkDriverIdKHR {
    VK_DRIVER_ID_AMD_PROPRIETARY_KHR = 1,
    VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR = 2,
    VK_DRIVER_ID_MESA_RADV_KHR = 3,
    VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR = 4,
    VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR = 5,
    VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR = 6,
    VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR = 7,
    VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR = 8,
    VK_DRIVER_ID_ARM_PROPRIETARY_KHR = 9,
    VK_DRIVER_ID_GOOGLE_PASTEL_KHR = 10,
    VK_DRIVER_ID_GGP_PROPRIETARY_KHR = 11,
    VK_DRIVER_ID_MAX_ENUM_KHR = 0x7FFFFFFF
} VkDriverIdKHR;
Description
Note
Khronos driver IDs may be allocated by vendors at any time. There may be multiple driver IDs for the same vendor, representing different drivers (for e.g. different platforms, proprietary or open source, etc.). Only the latest canonical versions of this Specification, of the corresponding vk.xml API Registry, and of the corresponding vulkan_core.h header file must contain all reserved Khronos driver IDs.

Only driver IDs registered with Khronos are given symbolic names. There may be unregistered driver IDs returned.
See Also
VkPhysicalDeviceDriverPropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDriverIdKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDynamicState(3)
Name
VkDynamicState - Indicate which dynamic state is taken from dynamic state commands

C Specification
The source of different pieces of dynamic state is specified by the VkPipelineDynamicStateCreateInfo::pDynamicStates property of the currently active pipeline, each of whose elements must be one of the values:

typedef enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
    VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
    VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
    VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
    VK_DYNAMIC_STATE_MAX_ENUM = 0x7FFFFFFF
} VkDynamicState;
Description
VK_DYNAMIC_STATE_VIEWPORT specifies that the pViewports state in VkPipelineViewportStateCreateInfo will be ignored and must be set dynamically with vkCmdSetViewport before any draw commands. The number of viewports used by a pipeline is still specified by the viewportCount member of VkPipelineViewportStateCreateInfo.
VK_DYNAMIC_STATE_SCISSOR specifies that the pScissors state in VkPipelineViewportStateCreateInfo will be ignored and must be set dynamically with vkCmdSetScissor before any draw commands. The number of scissor rectangles used by a pipeline is still specified by the scissorCount member of VkPipelineViewportStateCreateInfo.
VK_DYNAMIC_STATE_LINE_WIDTH specifies that the lineWidth state in VkPipelineRasterizationStateCreateInfo will be ignored and must be set dynamically with vkCmdSetLineWidth before any draw commands that generate line primitives for the rasterizer.
VK_DYNAMIC_STATE_DEPTH_BIAS specifies that the depthBiasConstantFactor, depthBiasClamp and depthBiasSlopeFactor states in VkPipelineRasterizationStateCreateInfo will be ignored and must be set dynamically with vkCmdSetDepthBias before any draws are performed with depthBiasEnable in VkPipelineRasterizationStateCreateInfo set to VK_TRUE.
VK_DYNAMIC_STATE_BLEND_CONSTANTS specifies that the blendConstants state in VkPipelineColorBlendStateCreateInfo will be ignored and must be set dynamically with vkCmdSetBlendConstants before any draws are performed with a pipeline state with VkPipelineColorBlendAttachmentState member blendEnable set to VK_TRUE and any of the blend functions using a constant blend color.
VK_DYNAMIC_STATE_DEPTH_BOUNDS specifies that the minDepthBounds and maxDepthBounds states of VkPipelineDepthStencilStateCreateInfo will be ignored and must be set dynamically with vkCmdSetDepthBounds before any draws are performed with a pipeline state with VkPipelineDepthStencilStateCreateInfo member depthBoundsTestEnable set to VK_TRUE.
VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK specifies that the compareMask state in VkPipelineDepthStencilStateCreateInfo for both front and back will be ignored and must be set dynamically with vkCmdSetStencilCompareMask before any draws are performed with a pipeline state with VkPipelineDepthStencilStateCreateInfo member stencilTestEnable set to VK_TRUE
VK_DYNAMIC_STATE_STENCIL_WRITE_MASK specifies that the writeMask state in VkPipelineDepthStencilStateCreateInfo for both front and back will be ignored and must be set dynamically with vkCmdSetStencilWriteMask before any draws are performed with a pipeline state with VkPipelineDepthStencilStateCreateInfo member stencilTestEnable set to VK_TRUE
VK_DYNAMIC_STATE_STENCIL_REFERENCE specifies that the reference state in VkPipelineDepthStencilStateCreateInfo for both front and back will be ignored and must be set dynamically with vkCmdSetStencilReference before any draws are performed with a pipeline state with VkPipelineDepthStencilStateCreateInfo member stencilTestEnable set to VK_TRUE
VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV specifies that the pViewportScalings state in VkPipelineViewportWScalingStateCreateInfoNV will be ignored and must be set dynamically with vkCmdSetViewportWScalingNV before any draws are performed with a pipeline state with VkPipelineViewportWScalingStateCreateInfoNV member viewportScalingEnable set to VK_TRUE
VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT specifies that the pDiscardRectangles state in VkPipelineDiscardRectangleStateCreateInfoEXT will be ignored and must be set dynamically with vkCmdSetDiscardRectangleEXT before any draw or clear commands. The VkDiscardRectangleModeEXT and the number of active discard rectangles is still specified by the discardRectangleMode and discardRectangleCount members of VkPipelineDiscardRectangleStateCreateInfoEXT.
VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT specifies that the sampleLocationsInfo state in VkPipelineSampleLocationsStateCreateInfoEXT will be ignored and must be set dynamically with vkCmdSetSampleLocationsEXT before any draw or clear commands. Enabling custom sample locations is still indicated by the sampleLocationsEnable member of VkPipelineSampleLocationsStateCreateInfoEXT.
VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV specifies that the pExclusiveScissors state in VkPipelineViewportExclusiveScissorStateCreateInfoNV will be ignored and must be set dynamically with vkCmdSetExclusiveScissorNV before any draw commands. The number of exclusive scissor rectangles used by a pipeline is still specified by the exclusiveScissorCount member of VkPipelineViewportExclusiveScissorStateCreateInfoNV.
VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV specifies that the pShadingRatePalettes state in VkPipelineViewportShadingRateImageStateCreateInfoNV will be ignored and must be set dynamically with vkCmdSetViewportShadingRatePaletteNV before any draw commands.
VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV specifies that the coarse sample order state in VkPipelineViewportCoarseSampleOrderStateCreateInfoNV will be ignored and must be set dynamically with vkCmdSetCoarseSampleOrderNV before any draw commands.
See Also
VkPipelineDynamicStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDynamicState

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalFenceFeatureFlagBits(3)
Name
VkExternalFenceFeatureFlagBits - Bitfield describing features of an external fence handle type

C Specification
Bits which may be set in VkExternalFenceProperties::externalFenceFeatures, indicating features of a fence external handle type, are:

typedef enum VkExternalFenceFeatureFlagBits {
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 0x00000001,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 0x00000002,
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
    VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalFenceFeatureFlagBits;
or the equivalent

typedef VkExternalFenceFeatureFlagBits VkExternalFenceFeatureFlagBitsKHR;
Description
VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT specifies handles of this type can be exported from Vulkan fence objects.
VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT specifies handles of this type can be imported to Vulkan fence objects.
See Also
VkExternalFenceFeatureFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalFenceFeatureFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalFenceHandleTypeFlagBits(3)
Name
VkExternalFenceHandleTypeFlagBits - Bitmask of valid external fence handle types

C Specification
Bits which may be set in VkPhysicalDeviceExternalFenceInfo::handleType, and in the exportFromImportedHandleTypes and compatibleHandleTypes members of VkExternalFenceProperties, to indicate external fence handle types, are:

typedef enum VkExternalFenceHandleTypeFlagBits {
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000008,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalFenceHandleTypeFlagBits;
or the equivalent

typedef VkExternalFenceHandleTypeFlagBits VkExternalFenceHandleTypeFlagBitsKHR;
Description
VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT specifies a POSIX file descriptor handle that has only limited valid usage outside of Vulkan and other compatible APIs. It must be compatible with the POSIX system calls dup, dup2, close, and the non-standard system call dup3. Additionally, it must be transportable over a socket using an SCM_RIGHTS control message. It owns a reference to the underlying synchronization primitive represented by its Vulkan fence object.
VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT specifies an NT handle that has only limited valid usage outside of Vulkan and other compatible APIs. It must be compatible with the functions DuplicateHandle, CloseHandle, CompareObjectHandles, GetHandleInformation, and SetHandleInformation. It owns a reference to the underlying synchronization primitive represented by its Vulkan fence object.
VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT specifies a global share handle that has only limited valid usage outside of Vulkan and other compatible APIs. It is not compatible with any native APIs. It does not own a reference to the underlying synchronization primitive represented by its Vulkan fence object, and will therefore become invalid when all Vulkan fence objects associated with it are destroyed.
VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT specifies a POSIX file descriptor handle to a Linux Sync File or Android Fence. It can be used with any native API accepting a valid sync file or fence as input. It owns a reference to the underlying synchronization primitive associated with the file descriptor. Implementations which support importing this handle type must accept any type of sync or fence FD supported by the native system they are running on.
Some external fence handle types can only be shared within the same underlying physical device and/or the same driver version, as defined in the following table:

Table 19. External fence handle types compatibility
Handle type
VkPhysicalDeviceIDProperties::driverUUID
VkPhysicalDeviceIDProperties::deviceUUID
VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT
Must match
Must match
VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT
Must match
Must match
VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
Must match
Must match
VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT
No restriction
No restriction
See Also
VkExternalFenceHandleTypeFlags, VkFenceGetFdInfoKHR, VkFenceGetWin32HandleInfoKHR, VkImportFenceFdInfoKHR, VkImportFenceWin32HandleInfoKHR, VkPhysicalDeviceExternalFenceInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalFenceHandleTypeFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalMemoryFeatureFlagBits(3)
Name
VkExternalMemoryFeatureFlagBits - Bitmask specifying features of an external memory handle type

C Specification
Bits which may be set in VkExternalMemoryProperties::externalMemoryFeatures, specifying features of an external memory handle type, are:

typedef enum VkExternalMemoryFeatureFlagBits {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 0x00000001,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 0x00000002,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 0x00000004,
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalMemoryFeatureFlagBits;
or the equivalent

typedef VkExternalMemoryFeatureFlagBits VkExternalMemoryFeatureFlagBitsKHR;
Description
VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT specifies that images or buffers created with the specified parameters and handle type must use the mechanisms defined by VkMemoryDedicatedRequirements and VkMemoryDedicatedAllocateInfo to create (or import) a dedicated allocation for the image or buffer.
VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT specifies that handles of this type can be exported from Vulkan memory objects.
VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT specifies that handles of this type can be imported as Vulkan memory objects.
Because their semantics in external APIs roughly align with that of an image or buffer with a dedicated allocation in Vulkan, implementations are required to report VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT for the following external handle types:

VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT
VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT
VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT
VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID for images only
Implementations must not report VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT for buffers with external handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID.

See Also
VkExternalMemoryFeatureFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalMemoryFeatureFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalMemoryFeatureFlagBitsNV(3)
Name
VkExternalMemoryFeatureFlagBitsNV - Bitmask specifying external memory features

C Specification
Bits which can be set in VkExternalImageFormatPropertiesNV::externalMemoryFeatures, indicating properties of the external memory handle type, are:

typedef enum VkExternalMemoryFeatureFlagBitsNV {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x00000001,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x00000002,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x00000004,
    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkExternalMemoryFeatureFlagBitsNV;
Description
VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV specifies that external memory of the specified type must be created as a dedicated allocation when used in the manner specified.
VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV specifies that the implementation supports exporting handles of the specified type.
VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV specifies that the implementation supports importing handles of the specified type.
See Also
VkExternalImageFormatPropertiesNV, VkExternalMemoryFeatureFlagsNV, vkGetPhysicalDeviceExternalImageFormatPropertiesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalMemoryFeatureFlagBitsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalMemoryHandleTypeFlagBits(3)
Name
VkExternalMemoryHandleTypeFlagBits - Bit specifying external memory handle types

C Specification
Possible values of VkPhysicalDeviceExternalImageFormatInfo::handleType, specifying an external memory handle type, are:

typedef enum VkExternalMemoryHandleTypeFlagBits {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 0x00000008,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 0x00000010,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 0x00000020,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 0x00000400,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalMemoryHandleTypeFlagBits;
or the equivalent

typedef VkExternalMemoryHandleTypeFlagBits VkExternalMemoryHandleTypeFlagBitsKHR;
Description
VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT specifies a POSIX file descriptor handle that has only limited valid usage outside of Vulkan and other compatible APIs. It must be compatible with the POSIX system calls dup, dup2, close, and the non-standard system call dup3. Additionally, it must be transportable over a socket using an SCM_RIGHTS control message. It owns a reference to the underlying memory resource represented by its Vulkan memory object.
VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT specifies an NT handle that has only limited valid usage outside of Vulkan and other compatible APIs. It must be compatible with the functions DuplicateHandle, CloseHandle, CompareObjectHandles, GetHandleInformation, and SetHandleInformation. It owns a reference to the underlying memory resource represented by its Vulkan memory object.
VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT specifies a global share handle that has only limited valid usage outside of Vulkan and other compatible APIs. It is not compatible with any native APIs. It does not own a reference to the underlying memory resource represented its Vulkan memory object, and will therefore become invalid when all Vulkan memory objects associated with it are destroyed.
VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT specifies an NT handle returned by IDXGIResource1::CreateSharedHandle referring to a Direct3D 10 or 11 texture resource. It owns a reference to the memory used by the Direct3D resource.
VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT specifies a global share handle returned by IDXGIResource::GetSharedHandle referring to a Direct3D 10 or 11 texture resource. It does not own a reference to the underlying Direct3D resource, and will therefore become invalid when all Vulkan memory objects and Direct3D resources associated with it are destroyed.
VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT specifies an NT handle returned by ID3D12Device::CreateSharedHandle referring to a Direct3D 12 heap resource. It owns a reference to the resources used by the Direct3D heap.
VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT specifies an NT handle returned by ID3D12Device::CreateSharedHandle referring to a Direct3D 12 committed resource. It owns a reference to the memory used by the Direct3D resource.
VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT specifies a host pointer returned by a host memory allocation command. It does not own a reference to the underlying memory resource, and will therefore become invalid if the host memory is freed.
VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT specifies a host pointer to host mapped foreign memory. It does not own a reference to the underlying memory resource, and will therefore become invalid if the foreign memory is unmapped or otherwise becomes no longer available.
VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT is a file descriptor for a Linux dma_buf. It owns a reference to the underlying memory resource represented by its Vulkan memory object.
VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID specifies an AHardwareBuffer object defined by the Android NDK. See Android Hardware Buffers for more details of this handle type.
Some external memory handle types can only be shared within the same underlying physical device and/or the same driver version, as defined in the following table:

Table 20. External memory handle types compatibility
Handle type
VkPhysicalDeviceIDProperties::driverUUID
VkPhysicalDeviceIDProperties::deviceUUID
VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT
Must match
Must match
VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT
Must match
Must match
VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
Must match
Must match
VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT
Must match
Must match
VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT
Must match
Must match
VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT
Must match
Must match
VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT
Must match
Must match
VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT
No restriction
No restriction
VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT
No restriction
No restriction
VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT
No restriction
No restriction
VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID
No restriction
No restriction
Note
The above table does not restrict the drivers and devices with which VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT and VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT may be shared, as these handle types inherently mean memory that does not come from the same device, as they import memory from the host or a foreign device, respectively.
Note
Even though the above table does not restrict the drivers and devices with which VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT may be shared, query mechanisms exist in the Vulkan API that prevent the import of incompatible dma-bufs (such as vkGetMemoryFdPropertiesKHR) and that prevent incompatible usage of dma-bufs (such as VkPhysicalDeviceExternalBufferInfoKHR and VkPhysicalDeviceExternalImageFormatInfoKHR).
See Also
VkExternalMemoryHandleTypeFlags, VkImportMemoryFdInfoKHR, VkImportMemoryHostPointerInfoEXT, VkImportMemoryWin32HandleInfoKHR, VkMemoryGetFdInfoKHR, VkMemoryGetWin32HandleInfoKHR, VkPhysicalDeviceExternalBufferInfo, VkPhysicalDeviceExternalImageFormatInfo, vkGetMemoryFdPropertiesKHR, vkGetMemoryHostPointerPropertiesEXT, vkGetMemoryWin32HandlePropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalMemoryHandleTypeFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalMemoryHandleTypeFlagBitsNV(3)
Name
VkExternalMemoryHandleTypeFlagBitsNV - Bitmask specifying external memory handle types

C Specification
Possible values of VkImportMemoryWin32HandleInfoNV::handleType, specifying the type of an external memory handle, are:

typedef enum VkExternalMemoryHandleTypeFlagBitsNV {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x00000001,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x00000002,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x00000004,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x00000008,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkExternalMemoryHandleTypeFlagBitsNV;
Description
VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV specifies a handle to memory returned by vkGetMemoryWin32HandleNV.
VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV specifies a handle to memory returned by vkGetMemoryWin32HandleNV, or one duplicated from such a handle using DuplicateHandle().
VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV specifies a valid NT handle to memory returned by IDXGIResource1::CreateSharedHandle, or a handle duplicated from such a handle using DuplicateHandle().
VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV specifies a handle to memory returned by IDXGIResource::GetSharedHandle().
editing-note
(Jon) If additional (non-Win32) bits are added to the possible memory types, this type should move to the html/vkspec.html#VK_NV_external_memory_capabilities section, and each bit would then be protected by ifdefs for the extension it’s defined by.
See Also
VkExternalMemoryHandleTypeFlagsNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalMemoryHandleTypeFlagBitsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalSemaphoreFeatureFlagBits(3)
Name
VkExternalSemaphoreFeatureFlagBits - Bitfield describing features of an external semaphore handle type

C Specification
Possible values of VkExternalSemaphoreProperties::externalSemaphoreFeatures, specifying the features of an external semaphore handle type, are:

typedef enum VkExternalSemaphoreFeatureFlagBits {
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 0x00000001,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 0x00000002,
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
    VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalSemaphoreFeatureFlagBits;
or the equivalent

typedef VkExternalSemaphoreFeatureFlagBits VkExternalSemaphoreFeatureFlagBitsKHR;
Description
VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT specifies that handles of this type can be exported from Vulkan semaphore objects.
VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT specifies that handles of this type can be imported as Vulkan semaphore objects.
See Also
VkExternalSemaphoreFeatureFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalSemaphoreFeatureFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalSemaphoreHandleTypeFlagBits(3)
Name
VkExternalSemaphoreHandleTypeFlagBits - Bitmask of valid external semaphore handle types

C Specification
Bits which may be set in VkPhysicalDeviceExternalSemaphoreInfo::handleType, specifying an external semaphore handle type, are:

typedef enum VkExternalSemaphoreHandleTypeFlagBits {
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x00000001,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x00000002,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x00000004,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x00000008,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x00000010,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkExternalSemaphoreHandleTypeFlagBits;
or the equivalent

typedef VkExternalSemaphoreHandleTypeFlagBits VkExternalSemaphoreHandleTypeFlagBitsKHR;
Description
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT specifies a POSIX file descriptor handle that has only limited valid usage outside of Vulkan and other compatible APIs. It must be compatible with the POSIX system calls dup, dup2, close, and the non-standard system call dup3. Additionally, it must be transportable over a socket using an SCM_RIGHTS control message. It owns a reference to the underlying synchronization primitive represented by its Vulkan semaphore object.
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT specifies an NT handle that has only limited valid usage outside of Vulkan and other compatible APIs. It must be compatible with the functions DuplicateHandle, CloseHandle, CompareObjectHandles, GetHandleInformation, and SetHandleInformation. It owns a reference to the underlying synchronization primitive represented by its Vulkan semaphore object.
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT specifies a global share handle that has only limited valid usage outside of Vulkan and other compatible APIs. It is not compatible with any native APIs. It does not own a reference to the underlying synchronization primitive represented its Vulkan semaphore object, and will therefore become invalid when all Vulkan semaphore objects associated with it are destroyed.
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT specifies an NT handle returned by ID3D12Device::CreateSharedHandle referring to a Direct3D 12 fence. It owns a reference to the underlying synchronization primitive associated with the Direct3D fence.
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT specifies a POSIX file descriptor handle to a Linux Sync File or Android Fence object. It can be used with any native API accepting a valid sync file or fence as input. It owns a reference to the underlying synchronization primitive associated with the file descriptor. Implementations which support importing this handle type must accept any type of sync or fence FD supported by the native system they are running on.
Note
Handles of type VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT generated by the implementation may represent either Linux Sync Files or Android Fences at the implementation’s discretion. Applications should only use operations defined for both types of file descriptors, unless they know via means external to Vulkan the type of the file descriptor, or are prepared to deal with the system-defined operation failures resulting from using the wrong type.
Some external semaphore handle types can only be shared within the same underlying physical device and/or the same driver version, as defined in the following table:

Table 21. External semaphore handle types compatibility
Handle type
VkPhysicalDeviceIDProperties::driverUUID
VkPhysicalDeviceIDProperties::deviceUUID
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT
Must match
Must match
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT
Must match
Must match
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT
Must match
Must match
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT
Must match
Must match
VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT
No restriction
No restriction
See Also
VkExternalSemaphoreHandleTypeFlags, VkImportSemaphoreFdInfoKHR, VkImportSemaphoreWin32HandleInfoKHR, VkPhysicalDeviceExternalSemaphoreInfo, VkSemaphoreGetFdInfoKHR, VkSemaphoreGetWin32HandleInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalSemaphoreHandleTypeFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFenceCreateFlagBits(3)
Name
VkFenceCreateFlagBits - Bitmask specifying initial state and behavior of a fence

C Specification
typedef enum VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT = 0x00000001,
    VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFenceCreateFlagBits;
Description
VK_FENCE_CREATE_SIGNALED_BIT specifies that the fence object is created in the signaled state. Otherwise, it is created in the unsignaled state.
See Also
VkFenceCreateFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFenceCreateFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFenceImportFlagBits(3)
Name
VkFenceImportFlagBits - Bitmask specifying additional parameters of fence payload import

C Specification
Bits which can be set in VkImportFenceWin32HandleInfoKHR::flags and VkImportFenceFdInfoKHR::flags specifying additional parameters of a fence import operation are:

typedef enum VkFenceImportFlagBits {
    VK_FENCE_IMPORT_TEMPORARY_BIT = 0x00000001,
    VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = VK_FENCE_IMPORT_TEMPORARY_BIT,
    VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFenceImportFlagBits;
or the equivalent

typedef VkFenceImportFlagBits VkFenceImportFlagBitsKHR;
Description
VK_FENCE_IMPORT_TEMPORARY_BIT specifies that the fence payload will be imported only temporarily, as described in Importing Fence Payloads, regardless of the permanence of handleType.
See Also
VkFenceImportFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFenceImportFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFilter(3)
Name
VkFilter - Specify filters used for texture lookups

C Specification
Possible values of the VkSamplerCreateInfo::magFilter and minFilter parameters, specifying filters used for texture lookups, are:

typedef enum VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000,
    VK_FILTER_CUBIC_EXT = VK_FILTER_CUBIC_IMG,
    VK_FILTER_MAX_ENUM = 0x7FFFFFFF
} VkFilter;
Description
VK_FILTER_NEAREST specifies nearest filtering.
VK_FILTER_LINEAR specifies linear filtering.
VK_FILTER_CUBIC_EXT specifies cubic filtering.
These filters are described in detail in Texel Filtering.

See Also
VkSamplerCreateInfo, VkSamplerYcbcrConversionCreateInfo, vkCmdBlitImage

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFilter

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFormat(3)
Name
VkFormat - Available image formats

C Specification
The following image formats can be passed to, and may be returned from Vulkan commands. The memory required to store each format is discussed with that format, and also summarized in the Representation and Texel Block Size section and the Compatible formats table.

typedef enum VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
    VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
    VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
    VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
    VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
    VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    VK_FORMAT_G8B8G8R8_422_UNORM_KHR = VK_FORMAT_G8B8G8R8_422_UNORM,
    VK_FORMAT_B8G8R8G8_422_UNORM_KHR = VK_FORMAT_B8G8R8G8_422_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
    VK_FORMAT_R10X6_UNORM_PACK16_KHR = VK_FORMAT_R10X6_UNORM_PACK16,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
    VK_FORMAT_R12X4_UNORM_PACK16_KHR = VK_FORMAT_R12X4_UNORM_PACK16,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
    VK_FORMAT_G16B16G16R16_422_UNORM_KHR = VK_FORMAT_G16B16G16R16_422_UNORM,
    VK_FORMAT_B16G16R16G16_422_UNORM_KHR = VK_FORMAT_B16G16R16G16_422_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
    VK_FORMAT_MAX_ENUM = 0x7FFFFFFF
} VkFormat;
Description
VK_FORMAT_UNDEFINED specifies that the format is not specified.
VK_FORMAT_R4G4_UNORM_PACK8 specifies a two-component, 8-bit packed unsigned normalized format that has a 4-bit R component in bits 4..7, and a 4-bit G component in bits 0..3.
VK_FORMAT_R4G4B4A4_UNORM_PACK16 specifies a four-component, 16-bit packed unsigned normalized format that has a 4-bit R component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit B component in bits 4..7, and a 4-bit A component in bits 0..3.
VK_FORMAT_B4G4R4A4_UNORM_PACK16 specifies a four-component, 16-bit packed unsigned normalized format that has a 4-bit B component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit R component in bits 4..7, and a 4-bit A component in bits 0..3.
VK_FORMAT_R5G6B5_UNORM_PACK16 specifies a three-component, 16-bit packed unsigned normalized format that has a 5-bit R component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit B component in bits 0..4.
VK_FORMAT_B5G6R5_UNORM_PACK16 specifies a three-component, 16-bit packed unsigned normalized format that has a 5-bit B component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit R component in bits 0..4.
VK_FORMAT_R5G5B5A1_UNORM_PACK16 specifies a four-component, 16-bit packed unsigned normalized format that has a 5-bit R component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit B component in bits 1..5, and a 1-bit A component in bit 0.
VK_FORMAT_B5G5R5A1_UNORM_PACK16 specifies a four-component, 16-bit packed unsigned normalized format that has a 5-bit B component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit R component in bits 1..5, and a 1-bit A component in bit 0.
VK_FORMAT_A1R5G5B5_UNORM_PACK16 specifies a four-component, 16-bit packed unsigned normalized format that has a 1-bit A component in bit 15, a 5-bit R component in bits 10..14, a 5-bit G component in bits 5..9, and a 5-bit B component in bits 0..4.
VK_FORMAT_R8_UNORM specifies a one-component, 8-bit unsigned normalized format that has a single 8-bit R component.
VK_FORMAT_R8_SNORM specifies a one-component, 8-bit signed normalized format that has a single 8-bit R component.
VK_FORMAT_R8_USCALED specifies a one-component, 8-bit unsigned scaled integer format that has a single 8-bit R component.
VK_FORMAT_R8_SSCALED specifies a one-component, 8-bit signed scaled integer format that has a single 8-bit R component.
VK_FORMAT_R8_UINT specifies a one-component, 8-bit unsigned integer format that has a single 8-bit R component.
VK_FORMAT_R8_SINT specifies a one-component, 8-bit signed integer format that has a single 8-bit R component.
VK_FORMAT_R8_SRGB specifies a one-component, 8-bit unsigned normalized format that has a single 8-bit R component stored with sRGB nonlinear encoding.
VK_FORMAT_R8G8_UNORM specifies a two-component, 16-bit unsigned normalized format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.
VK_FORMAT_R8G8_SNORM specifies a two-component, 16-bit signed normalized format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.
VK_FORMAT_R8G8_USCALED specifies a two-component, 16-bit unsigned scaled integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.
VK_FORMAT_R8G8_SSCALED specifies a two-component, 16-bit signed scaled integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.
VK_FORMAT_R8G8_UINT specifies a two-component, 16-bit unsigned integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.
VK_FORMAT_R8G8_SINT specifies a two-component, 16-bit signed integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.
VK_FORMAT_R8G8_SRGB specifies a two-component, 16-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, and an 8-bit G component stored with sRGB nonlinear encoding in byte 1.
VK_FORMAT_R8G8B8_UNORM specifies a three-component, 24-bit unsigned normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
VK_FORMAT_R8G8B8_SNORM specifies a three-component, 24-bit signed normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
VK_FORMAT_R8G8B8_USCALED specifies a three-component, 24-bit unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
VK_FORMAT_R8G8B8_SSCALED specifies a three-component, 24-bit signed scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
VK_FORMAT_R8G8B8_UINT specifies a three-component, 24-bit unsigned integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
VK_FORMAT_R8G8B8_SINT specifies a three-component, 24-bit signed integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.
VK_FORMAT_R8G8B8_SRGB specifies a three-component, 24-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and an 8-bit B component stored with sRGB nonlinear encoding in byte 2.
VK_FORMAT_B8G8R8_UNORM specifies a three-component, 24-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
VK_FORMAT_B8G8R8_SNORM specifies a three-component, 24-bit signed normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
VK_FORMAT_B8G8R8_USCALED specifies a three-component, 24-bit unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
VK_FORMAT_B8G8R8_SSCALED specifies a three-component, 24-bit signed scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
VK_FORMAT_B8G8R8_UINT specifies a three-component, 24-bit unsigned integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
VK_FORMAT_B8G8R8_SINT specifies a three-component, 24-bit signed integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.
VK_FORMAT_B8G8R8_SRGB specifies a three-component, 24-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and an 8-bit R component stored with sRGB nonlinear encoding in byte 2.
VK_FORMAT_R8G8B8A8_UNORM specifies a four-component, 32-bit unsigned normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_R8G8B8A8_SNORM specifies a four-component, 32-bit signed normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_R8G8B8A8_USCALED specifies a four-component, 32-bit unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_R8G8B8A8_SSCALED specifies a four-component, 32-bit signed scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_R8G8B8A8_UINT specifies a four-component, 32-bit unsigned integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_R8G8B8A8_SINT specifies a four-component, 32-bit signed integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_R8G8B8A8_SRGB specifies a four-component, 32-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit B component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_B8G8R8A8_UNORM specifies a four-component, 32-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_B8G8R8A8_SNORM specifies a four-component, 32-bit signed normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_B8G8R8A8_USCALED specifies a four-component, 32-bit unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_B8G8R8A8_SSCALED specifies a four-component, 32-bit signed scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_B8G8R8A8_UINT specifies a four-component, 32-bit unsigned integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_B8G8R8A8_SINT specifies a four-component, 32-bit signed integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_B8G8R8A8_SRGB specifies a four-component, 32-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit R component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.
VK_FORMAT_A8B8G8R8_UNORM_PACK32 specifies a four-component, 32-bit packed unsigned normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
VK_FORMAT_A8B8G8R8_SNORM_PACK32 specifies a four-component, 32-bit packed signed normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
VK_FORMAT_A8B8G8R8_USCALED_PACK32 specifies a four-component, 32-bit packed unsigned scaled integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
VK_FORMAT_A8B8G8R8_SSCALED_PACK32 specifies a four-component, 32-bit packed signed scaled integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
VK_FORMAT_A8B8G8R8_UINT_PACK32 specifies a four-component, 32-bit packed unsigned integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
VK_FORMAT_A8B8G8R8_SINT_PACK32 specifies a four-component, 32-bit packed signed integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.
VK_FORMAT_A8B8G8R8_SRGB_PACK32 specifies a four-component, 32-bit packed unsigned normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component stored with sRGB nonlinear encoding in bits 16..23, an 8-bit G component stored with sRGB nonlinear encoding in bits 8..15, and an 8-bit R component stored with sRGB nonlinear encoding in bits 0..7.
VK_FORMAT_A2R10G10B10_UNORM_PACK32 specifies a four-component, 32-bit packed unsigned normalized format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
VK_FORMAT_A2R10G10B10_SNORM_PACK32 specifies a four-component, 32-bit packed signed normalized format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
VK_FORMAT_A2R10G10B10_USCALED_PACK32 specifies a four-component, 32-bit packed unsigned scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
VK_FORMAT_A2R10G10B10_SSCALED_PACK32 specifies a four-component, 32-bit packed signed scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
VK_FORMAT_A2R10G10B10_UINT_PACK32 specifies a four-component, 32-bit packed unsigned integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
VK_FORMAT_A2R10G10B10_SINT_PACK32 specifies a four-component, 32-bit packed signed integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.
VK_FORMAT_A2B10G10R10_UNORM_PACK32 specifies a four-component, 32-bit packed unsigned normalized format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
VK_FORMAT_A2B10G10R10_SNORM_PACK32 specifies a four-component, 32-bit packed signed normalized format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
VK_FORMAT_A2B10G10R10_USCALED_PACK32 specifies a four-component, 32-bit packed unsigned scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
VK_FORMAT_A2B10G10R10_SSCALED_PACK32 specifies a four-component, 32-bit packed signed scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
VK_FORMAT_A2B10G10R10_UINT_PACK32 specifies a four-component, 32-bit packed unsigned integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
VK_FORMAT_A2B10G10R10_SINT_PACK32 specifies a four-component, 32-bit packed signed integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.
VK_FORMAT_R16_UNORM specifies a one-component, 16-bit unsigned normalized format that has a single 16-bit R component.
VK_FORMAT_R16_SNORM specifies a one-component, 16-bit signed normalized format that has a single 16-bit R component.
VK_FORMAT_R16_USCALED specifies a one-component, 16-bit unsigned scaled integer format that has a single 16-bit R component.
VK_FORMAT_R16_SSCALED specifies a one-component, 16-bit signed scaled integer format that has a single 16-bit R component.
VK_FORMAT_R16_UINT specifies a one-component, 16-bit unsigned integer format that has a single 16-bit R component.
VK_FORMAT_R16_SINT specifies a one-component, 16-bit signed integer format that has a single 16-bit R component.
VK_FORMAT_R16_SFLOAT specifies a one-component, 16-bit signed floating-point format that has a single 16-bit R component.
VK_FORMAT_R16G16_UNORM specifies a two-component, 32-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
VK_FORMAT_R16G16_SNORM specifies a two-component, 32-bit signed normalized format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
VK_FORMAT_R16G16_USCALED specifies a two-component, 32-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
VK_FORMAT_R16G16_SSCALED specifies a two-component, 32-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
VK_FORMAT_R16G16_UINT specifies a two-component, 32-bit unsigned integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
VK_FORMAT_R16G16_SINT specifies a two-component, 32-bit signed integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
VK_FORMAT_R16G16_SFLOAT specifies a two-component, 32-bit signed floating-point format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.
VK_FORMAT_R16G16B16_UNORM specifies a three-component, 48-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
VK_FORMAT_R16G16B16_SNORM specifies a three-component, 48-bit signed normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
VK_FORMAT_R16G16B16_USCALED specifies a three-component, 48-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
VK_FORMAT_R16G16B16_SSCALED specifies a three-component, 48-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
VK_FORMAT_R16G16B16_UINT specifies a three-component, 48-bit unsigned integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
VK_FORMAT_R16G16B16_SINT specifies a three-component, 48-bit signed integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
VK_FORMAT_R16G16B16_SFLOAT specifies a three-component, 48-bit signed floating-point format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.
VK_FORMAT_R16G16B16A16_UNORM specifies a four-component, 64-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
VK_FORMAT_R16G16B16A16_SNORM specifies a four-component, 64-bit signed normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
VK_FORMAT_R16G16B16A16_USCALED specifies a four-component, 64-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
VK_FORMAT_R16G16B16A16_SSCALED specifies a four-component, 64-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
VK_FORMAT_R16G16B16A16_UINT specifies a four-component, 64-bit unsigned integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
VK_FORMAT_R16G16B16A16_SINT specifies a four-component, 64-bit signed integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
VK_FORMAT_R16G16B16A16_SFLOAT specifies a four-component, 64-bit signed floating-point format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.
VK_FORMAT_R32_UINT specifies a one-component, 32-bit unsigned integer format that has a single 32-bit R component.
VK_FORMAT_R32_SINT specifies a one-component, 32-bit signed integer format that has a single 32-bit R component.
VK_FORMAT_R32_SFLOAT specifies a one-component, 32-bit signed floating-point format that has a single 32-bit R component.
VK_FORMAT_R32G32_UINT specifies a two-component, 64-bit unsigned integer format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.
VK_FORMAT_R32G32_SINT specifies a two-component, 64-bit signed integer format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.
VK_FORMAT_R32G32_SFLOAT specifies a two-component, 64-bit signed floating-point format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.
VK_FORMAT_R32G32B32_UINT specifies a three-component, 96-bit unsigned integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.
VK_FORMAT_R32G32B32_SINT specifies a three-component, 96-bit signed integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.
VK_FORMAT_R32G32B32_SFLOAT specifies a three-component, 96-bit signed floating-point format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.
VK_FORMAT_R32G32B32A32_UINT specifies a four-component, 128-bit unsigned integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.
VK_FORMAT_R32G32B32A32_SINT specifies a four-component, 128-bit signed integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.
VK_FORMAT_R32G32B32A32_SFLOAT specifies a four-component, 128-bit signed floating-point format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.
VK_FORMAT_R64_UINT specifies a one-component, 64-bit unsigned integer format that has a single 64-bit R component.
VK_FORMAT_R64_SINT specifies a one-component, 64-bit signed integer format that has a single 64-bit R component.
VK_FORMAT_R64_SFLOAT specifies a one-component, 64-bit signed floating-point format that has a single 64-bit R component.
VK_FORMAT_R64G64_UINT specifies a two-component, 128-bit unsigned integer format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.
VK_FORMAT_R64G64_SINT specifies a two-component, 128-bit signed integer format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.
VK_FORMAT_R64G64_SFLOAT specifies a two-component, 128-bit signed floating-point format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.
VK_FORMAT_R64G64B64_UINT specifies a three-component, 192-bit unsigned integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.
VK_FORMAT_R64G64B64_SINT specifies a three-component, 192-bit signed integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.
VK_FORMAT_R64G64B64_SFLOAT specifies a three-component, 192-bit signed floating-point format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.
VK_FORMAT_R64G64B64A64_UINT specifies a four-component, 256-bit unsigned integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.
VK_FORMAT_R64G64B64A64_SINT specifies a four-component, 256-bit signed integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.
VK_FORMAT_R64G64B64A64_SFLOAT specifies a four-component, 256-bit signed floating-point format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.
VK_FORMAT_B10G11R11_UFLOAT_PACK32 specifies a three-component, 32-bit packed unsigned floating-point format that has a 10-bit B component in bits 22..31, an 11-bit G component in bits 11..21, an 11-bit R component in bits 0..10. See html/vkspec.html#fundamentals-fp10 and html/vkspec.html#fundamentals-fp11.
VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 specifies a three-component, 32-bit packed unsigned floating-point format that has a 5-bit shared exponent in bits 27..31, a 9-bit B component mantissa in bits 18..26, a 9-bit G component mantissa in bits 9..17, and a 9-bit R component mantissa in bits 0..8.
VK_FORMAT_D16_UNORM specifies a one-component, 16-bit unsigned normalized format that has a single 16-bit depth component.
VK_FORMAT_X8_D24_UNORM_PACK32 specifies a two-component, 32-bit format that has 24 unsigned normalized bits in the depth component and, optionally:, 8 bits that are unused.
VK_FORMAT_D32_SFLOAT specifies a one-component, 32-bit signed floating-point format that has 32-bits in the depth component.
VK_FORMAT_S8_UINT specifies a one-component, 8-bit unsigned integer format that has 8-bits in the stencil component.
VK_FORMAT_D16_UNORM_S8_UINT specifies a two-component, 24-bit format that has 16 unsigned normalized bits in the depth component and 8 unsigned integer bits in the stencil component.
VK_FORMAT_D24_UNORM_S8_UINT specifies a two-component, 32-bit packed format that has 8 unsigned integer bits in the stencil component, and 24 unsigned normalized bits in the depth component.
VK_FORMAT_D32_SFLOAT_S8_UINT specifies a two-component format that has 32 signed float bits in the depth component and 8 unsigned integer bits in the stencil component. There are optionally: 24-bits that are unused.
VK_FORMAT_BC1_RGB_UNORM_BLOCK specifies a three-component, block-compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data. This format has no alpha and is considered opaque.
VK_FORMAT_BC1_RGB_SRGB_BLOCK specifies a three-component, block-compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding. This format has no alpha and is considered opaque.
VK_FORMAT_BC1_RGBA_UNORM_BLOCK specifies a four-component, block-compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data, and provides 1 bit of alpha.
VK_FORMAT_BC1_RGBA_SRGB_BLOCK specifies a four-component, block-compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding, and provides 1 bit of alpha.
VK_FORMAT_BC2_UNORM_BLOCK specifies a four-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.
VK_FORMAT_BC2_SRGB_BLOCK specifies a four-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding.
VK_FORMAT_BC3_UNORM_BLOCK specifies a four-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.
VK_FORMAT_BC3_SRGB_BLOCK specifies a four-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding.
VK_FORMAT_BC4_UNORM_BLOCK specifies a one-component, block-compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized red texel data.
VK_FORMAT_BC4_SNORM_BLOCK specifies a one-component, block-compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of signed normalized red texel data.
VK_FORMAT_BC5_UNORM_BLOCK specifies a two-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.
VK_FORMAT_BC5_SNORM_BLOCK specifies a two-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of signed normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.
VK_FORMAT_BC6H_UFLOAT_BLOCK specifies a three-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned floating-point RGB texel data.
VK_FORMAT_BC6H_SFLOAT_BLOCK specifies a three-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of signed floating-point RGB texel data.
VK_FORMAT_BC7_UNORM_BLOCK specifies a four-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_BC7_SRGB_BLOCK specifies a four-component, block-compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK specifies a three-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data. This format has no alpha and is considered opaque.
VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK specifies a three-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding. This format has no alpha and is considered opaque.
VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK specifies a four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data, and provides 1 bit of alpha.
VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK specifies a four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding, and provides 1 bit of alpha.
VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK specifies a four-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.
VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK specifies a four-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding applied.
VK_FORMAT_EAC_R11_UNORM_BLOCK specifies a one-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized red texel data.
VK_FORMAT_EAC_R11_SNORM_BLOCK specifies a one-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4×4 rectangle of signed normalized red texel data.
VK_FORMAT_EAC_R11G11_UNORM_BLOCK specifies a two-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.
VK_FORMAT_EAC_R11G11_SNORM_BLOCK specifies a two-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of signed normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.
VK_FORMAT_ASTC_4x4_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_4x4_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 4×4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ASTC_5x4_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5×4 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_5x4_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5×4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ASTC_5x5_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5×5 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_5x5_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5×5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ASTC_6x5_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6×5 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_6x5_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6×5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ASTC_6x6_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6×6 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_6x6_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6×6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ASTC_8x5_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8×5 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_8x5_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8×5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ASTC_8x6_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8×6 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_8x6_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8×6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ASTC_8x8_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8×8 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_8x8_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8×8 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ASTC_10x5_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×5 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_10x5_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ASTC_10x6_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×6 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_10x6_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ASTC_10x8_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×8 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_10x8_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×8 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ASTC_10x10_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×10 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_10x10_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10×10 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ASTC_12x10_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12×10 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_12x10_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12×10 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_ASTC_12x12_UNORM_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12×12 rectangle of unsigned normalized RGBA texel data.
VK_FORMAT_ASTC_12x12_SRGB_BLOCK specifies a four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12×12 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.
VK_FORMAT_G8B8G8R8_422_UNORM specifies a four-component, 32-bit format containing a pair of G components, an R component, and a B component, collectively encoding a 2×1 rectangle of unsigned normalized RGB texel data. One G value is present at each i coordinate, with the B and R values shared across both G values and thus recorded at half the horizontal resolution of the image. This format has an 8-bit G component for the even i coordinate in byte 0, an 8-bit B component in byte 1, an 8-bit G component for the odd i coordinate in byte 2, and an 8-bit R component in byte 3. Images in this format must be defined with a width that is a multiple of two. For the purposes of the constraints on copy extents, this format is treated as a compressed format with a 2×1 compressed texel block.
VK_FORMAT_B8G8R8G8_422_UNORM specifies a four-component, 32-bit format containing a pair of G components, an R component, and a B component, collectively encoding a 2×1 rectangle of unsigned normalized RGB texel data. One G value is present at each i coordinate, with the B and R values shared across both G values and thus recorded at half the horizontal resolution of the image. This format has an 8-bit B component in byte 0, an 8-bit G component for the even i coordinate in byte 1, an 8-bit R component in byte 2, and an 8-bit G component for the odd i coordinate in byte 3. Images in this format must be defined with a width that is a multiple of two. For the purposes of the constraints on copy extents, this format is treated as a compressed format with a 2×1 compressed texel block.
VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM specifies an unsigned normalized multi-planar format that has an 8-bit G component in plane 0, an 8-bit B component in plane 1, and an 8-bit R component in plane 2. The horizontal and vertical dimensions of the R and B planes are halved relative to the image dimensions, and each R and B component is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\) and \(\lfloor j_G \times 0.5 \rfloor = j_B = j_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane. Images in this format must be defined with a width and height that is a multiple of two.
VK_FORMAT_G8_B8R8_2PLANE_420_UNORM specifies an unsigned normalized multi-planar format that has an 8-bit G component in plane 0, and a two-component, 16-bit BR plane 1 consisting of an 8-bit B component in byte 0 and an 8-bit R component in byte 1. The horizontal and vertical dimensions of the BR plane is halved relative to the image dimensions, and each R and B value is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\) and \(\lfloor j_G \times 0.5 \rfloor = j_B = j_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane. Images in this format must be defined with a width and height that is a multiple of two.
VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM specifies an unsigned normalized multi-planar format that has an 8-bit G component in plane 0, an 8-bit B component in plane 1, and an 8-bit R component in plane 2. The horizontal dimension of the R and B plane is halved relative to the image dimensions, and each R and B value is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane. Images in this format must be defined with a width that is a multiple of two.
VK_FORMAT_G8_B8R8_2PLANE_422_UNORM specifies an unsigned normalized multi-planar format that has an 8-bit G component in plane 0, and a two-component, 16-bit BR plane 1 consisting of an 8-bit B component in byte 0 and an 8-bit R component in byte 1. The horizontal dimensions of the BR plane is halved relative to the image dimensions, and each R and B value is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane. Images in this format must be defined with a width that is a multiple of two.
VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM specifies an unsigned normalized multi-planar format that has an 8-bit G component in plane 0, an 8-bit B component in plane 1, and an 8-bit R component in plane 2. Each plane has the same dimensions and each R, G and B component contributes to a single texel. The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
VK_FORMAT_R10X6_UNORM_PACK16 specifies a one-component, 16-bit unsigned normalized format that has a single 10-bit R component in the top 10 bits of a 16-bit word, with the bottom 6 bits set to 0.
VK_FORMAT_R10X6G10X6_UNORM_2PACK16 specifies a two-component, 32-bit unsigned normalized format that has a 10-bit R component in the top 10 bits of the word in bytes 0..1, and a 10-bit G component in the top 10 bits of the word in bytes 2..3, with the bottom 6 bits of each word set to 0.
VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 specifies a four-component, 64-bit unsigned normalized format that has a 10-bit R component in the top 10 bits of the word in bytes 0..1, a 10-bit G component in the top 10 bits of the word in bytes 2..3, a 10-bit B component in the top 10 bits of the word in bytes 4..5, and a 10-bit A component in the top 10 bits of the word in bytes 6..7, with the bottom 6 bits of each word set to 0.
VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 specifies a four-component, 64-bit format containing a pair of G components, an R component, and a B component, collectively encoding a 2×1 rectangle of unsigned normalized RGB texel data. One G value is present at each i coordinate, with the B and R values shared across both G values and thus recorded at half the horizontal resolution of the image. This format has a 10-bit G component for the even i coordinate in the top 10 bits of the word in bytes 0..1, a 10-bit B component in the top 10 bits of the word in bytes 2..3, a 10-bit G component for the odd i coordinate in the top 10 bits of the word in bytes 4..5, and a 10-bit R component in the top 10 bits of the word in bytes 6..7, with the bottom 6 bits of each word set to 0. Images in this format must be defined with a width that is a multiple of two. For the purposes of the constraints on copy extents, this format is treated as a compressed format with a 2×1 compressed texel block.
VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 specifies a four-component, 64-bit format containing a pair of G components, an R component, and a B component, collectively encoding a 2×1 rectangle of unsigned normalized RGB texel data. One G value is present at each i coordinate, with the B and R values shared across both G values and thus recorded at half the horizontal resolution of the image. This format has a 10-bit B component in the top 10 bits of the word in bytes 0..1, a 10-bit G component for the even i coordinate in the top 10 bits of the word in bytes 2..3, a 10-bit R component in the top 10 bits of the word in bytes 4..5, and a 10-bit G component for the odd i coordinate in the top 10 bits of the word in bytes 6..7, with the bottom 6 bits of each word set to 0. Images in this format must be defined with a width that is a multiple of two. For the purposes of the constraints on copy extents, this format is treated as a compressed format with a 2×1 compressed texel block.
VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 specifies an unsigned normalized multi-planar format that has a 10-bit G component in the top 10 bits of each 16-bit word of plane 0, a 10-bit B component in the top 10 bits of each 16-bit word of plane 1, and a 10-bit R component in the top 10 bits of each 16-bit word of plane 2, with the bottom 6 bits of each word set to 0. The horizontal and vertical dimensions of the R and B planes are halved relative to the image dimensions, and each R and B component is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\) and \(\lfloor j_G \times 0.5 \rfloor = j_B = j_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane. Images in this format must be defined with a width and height that is a multiple of two.
VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 specifies an unsigned normalized multi-planar format that has a 10-bit G component in the top 10 bits of each 16-bit word of plane 0, and a two-component, 32-bit BR plane 1 consisting of a 10-bit B component in the top 10 bits of the word in bytes 0..1, and a 10-bit R component in the top 10 bits of the word in bytes 2..3, the bottom 6 bits of each word set to 0. The horizontal and vertical dimensions of the BR plane is halved relative to the image dimensions, and each R and B value is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\) and \(\lfloor j_G \times 0.5 \rfloor = j_B = j_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane. Images in this format must be defined with a width and height that is a multiple of two.
VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 specifies an unsigned normalized multi-planar format that has a 10-bit G component in the top 10 bits of each 16-bit word of plane 0, a 10-bit B component in the top 10 bits of each 16-bit word of plane 1, and a 10-bit R component in the top 10 bits of each 16-bit word of plane 2, with the bottom 6 bits of each word set to 0. The horizontal dimension of the R and B plane is halved relative to the image dimensions, and each R and B value is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane. Images in this format must be defined with a width that is a multiple of two.
VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 specifies an unsigned normalized multi-planar format that has a 10-bit G component in the top 10 bits of each 16-bit word of plane 0, and a two-component, 32-bit BR plane 1 consisting of a 10-bit B component in the top 10 bits of the word in bytes 0..1, and a 10-bit R component in the top 10 bits of the word in bytes 2..3, the bottom 6 bits of each word set to 0. The horizontal dimensions of the BR plane is halved relative to the image dimensions, and each R and B value is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane. Images in this format must be defined with a width that is a multiple of two.
VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 specifies an unsigned normalized multi-planar format that has a 10-bit G component in the top 10 bits of each 16-bit word of plane 0, a 10-bit B component in the top 10 bits of each 16-bit word of plane 1, and a 10-bit R component in the top 10 bits of each 16-bit word of plane 2, with the bottom 6 bits of each word set to 0. Each plane has the same dimensions and each R, G and B component contributes to a single texel. The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
VK_FORMAT_R12X4_UNORM_PACK16 specifies a one-component, 16-bit unsigned normalized format that has a single 12-bit R component in the top 12 bits of a 16-bit word, with the bottom 4 bits set to 0.
VK_FORMAT_R12X4G12X4_UNORM_2PACK16 specifies a two-component, 32-bit unsigned normalized format that has a 12-bit R component in the top 12 bits of the word in bytes 0..1, and a 12-bit G component in the top 12 bits of the word in bytes 2..3, with the bottom 4 bits of each word set to 0.
VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 specifies a four-component, 64-bit unsigned normalized format that has a 12-bit R component in the top 12 bits of the word in bytes 0..1, a 12-bit G component in the top 12 bits of the word in bytes 2..3, a 12-bit B component in the top 12 bits of the word in bytes 4..5, and a 12-bit A component in the top 12 bits of the word in bytes 6..7, with the bottom 4 bits of each word set to 0.
VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 specifies a four-component, 64-bit format containing a pair of G components, an R component, and a B component, collectively encoding a 2×1 rectangle of unsigned normalized RGB texel data. One G value is present at each i coordinate, with the B and R values shared across both G values and thus recorded at half the horizontal resolution of the image. This format has a 12-bit G component for the even i coordinate in the top 12 bits of the word in bytes 0..1, a 12-bit B component in the top 12 bits of the word in bytes 2..3, a 12-bit G component for the odd i coordinate in the top 12 bits of the word in bytes 4..5, and a 12-bit R component in the top 12 bits of the word in bytes 6..7, with the bottom 4 bits of each word set to 0. Images in this format must be defined with a width that is a multiple of two. For the purposes of the constraints on copy extents, this format is treated as a compressed format with a 2×1 compressed texel block.
VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 specifies a four-component, 64-bit format containing a pair of G components, an R component, and a B component, collectively encoding a 2×1 rectangle of unsigned normalized RGB texel data. One G value is present at each i coordinate, with the B and R values shared across both G values and thus recorded at half the horizontal resolution of the image. This format has a 12-bit B component in the top 12 bits of the word in bytes 0..1, a 12-bit G component for the even i coordinate in the top 12 bits of the word in bytes 2..3, a 12-bit R component in the top 12 bits of the word in bytes 4..5, and a 12-bit G component for the odd i coordinate in the top 12 bits of the word in bytes 6..7, with the bottom 4 bits of each word set to 0. Images in this format must be defined with a width that is a multiple of two. For the purposes of the constraints on copy extents, this format is treated as a compressed format with a 2×1 compressed texel block.
VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 specifies an unsigned normalized multi-planar format that has a 12-bit G component in the top 12 bits of each 16-bit word of plane 0, a 12-bit B component in the top 12 bits of each 16-bit word of plane 1, and a 12-bit R component in the top 12 bits of each 16-bit word of plane 2, with the bottom 4 bits of each word set to 0. The horizontal and vertical dimensions of the R and B planes are halved relative to the image dimensions, and each R and B component is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\) and \(\lfloor j_G \times 0.5 \rfloor = j_B = j_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane. Images in this format must be defined with a width and height that is a multiple of two.
VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 specifies an unsigned normalized multi-planar format that has a 12-bit G component in the top 12 bits of each 16-bit word of plane 0, and a two-component, 32-bit BR plane 1 consisting of a 12-bit B component in the top 12 bits of the word in bytes 0..1, and a 12-bit R component in the top 12 bits of the word in bytes 2..3, the bottom 4 bits of each word set to 0. The horizontal and vertical dimensions of the BR plane is halved relative to the image dimensions, and each R and B value is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\) and \(\lfloor j_G \times 0.5 \rfloor = j_B = j_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane. Images in this format must be defined with a width and height that is a multiple of two.
VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 specifies an unsigned normalized multi-planar format that has a 12-bit G component in the top 12 bits of each 16-bit word of plane 0, a 12-bit B component in the top 12 bits of each 16-bit word of plane 1, and a 12-bit R component in the top 12 bits of each 16-bit word of plane 2, with the bottom 4 bits of each word set to 0. The horizontal dimension of the R and B plane is halved relative to the image dimensions, and each R and B value is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane. Images in this format must be defined with a width that is a multiple of two.
VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 specifies an unsigned normalized multi-planar format that has a 12-bit G component in the top 12 bits of each 16-bit word of plane 0, and a two-component, 32-bit BR plane 1 consisting of a 12-bit B component in the top 12 bits of the word in bytes 0..1, and a 12-bit R component in the top 12 bits of the word in bytes 2..3, the bottom 4 bits of each word set to 0. The horizontal dimensions of the BR plane is halved relative to the image dimensions, and each R and B value is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane. Images in this format must be defined with a width that is a multiple of two.
VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 specifies an unsigned normalized multi-planar format that has a 12-bit G component in the top 12 bits of each 16-bit word of plane 0, a 12-bit B component in the top 12 bits of each 16-bit word of plane 1, and a 12-bit R component in the top 12 bits of each 16-bit word of plane 2, with the bottom 4 bits of each word set to 0. Each plane has the same dimensions and each R, G and B component contributes to a single texel. The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
VK_FORMAT_G16B16G16R16_422_UNORM specifies a four-component, 64-bit format containing a pair of G components, an R component, and a B component, collectively encoding a 2×1 rectangle of unsigned normalized RGB texel data. One G value is present at each i coordinate, with the B and R values shared across both G values and thus recorded at half the horizontal resolution of the image. This format has a 16-bit G component for the even i coordinate in the word in bytes 0..1, a 16-bit B component in the word in bytes 2..3, a 16-bit G component for the odd i coordinate in the word in bytes 4..5, and a 16-bit R component in the word in bytes 6..7. Images in this format must be defined with a width that is a multiple of two. For the purposes of the constraints on copy extents, this format is treated as a compressed format with a 2×1 compressed texel block.
VK_FORMAT_B16G16R16G16_422_UNORM specifies a four-component, 64-bit format containing a pair of G components, an R component, and a B component, collectively encoding a 2×1 rectangle of unsigned normalized RGB texel data. One G value is present at each i coordinate, with the B and R values shared across both G values and thus recorded at half the horizontal resolution of the image. This format has a 16-bit B component in the word in bytes 0..1, a 16-bit G component for the even i coordinate in the word in bytes 2..3, a 16-bit R component in the word in bytes 4..5, and a 16-bit G component for the odd i coordinate in the word in bytes 6..7. Images in this format must be defined with a width that is a multiple of two. For the purposes of the constraints on copy extents, this format is treated as a compressed format with a 2×1 compressed texel block.
VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM specifies an unsigned normalized multi-planar format that has a 16-bit G component in each 16-bit word of plane 0, a 16-bit B component in each 16-bit word of plane 1, and a 16-bit R component in each 16-bit word of plane 2. The horizontal and vertical dimensions of the R and B planes are halved relative to the image dimensions, and each R and B component is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\) and \(\lfloor j_G \times 0.5 \rfloor = j_B = j_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane. Images in this format must be defined with a width and height that is a multiple of two.
VK_FORMAT_G16_B16R16_2PLANE_420_UNORM specifies an unsigned normalized multi-planar format that has a 16-bit G component in each 16-bit word of plane 0, and a two-component, 32-bit BR plane 1 consisting of a 16-bit B component in the word in bytes 0..1, and a 16-bit R component in the word in bytes 2..3. The horizontal and vertical dimensions of the BR plane is halved relative to the image dimensions, and each R and B value is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\) and \(\lfloor j_G \times 0.5 \rfloor = j_B = j_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane. Images in this format must be defined with a width and height that is a multiple of two.
VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM specifies an unsigned normalized multi-planar format that has a 16-bit G component in each 16-bit word of plane 0, a 16-bit B component in each 16-bit word of plane 1, and a 16-bit R component in each 16-bit word of plane 2. The horizontal dimension of the R and B plane is halved relative to the image dimensions, and each R and B value is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane. Images in this format must be defined with a width that is a multiple of two.
VK_FORMAT_G16_B16R16_2PLANE_422_UNORM specifies an unsigned normalized multi-planar format that has a 16-bit G component in each 16-bit word of plane 0, and a two-component, 32-bit BR plane 1 consisting of a 16-bit B component in the word in bytes 0..1, and a 16-bit R component in the word in bytes 2..3. The horizontal dimensions of the BR plane is halved relative to the image dimensions, and each R and B value is shared with the G components for which \(\lfloor i_G \times 0.5 \rfloor = i_B = i_R\). The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, and VK_IMAGE_ASPECT_PLANE_1_BIT for the BR plane. Images in this format must be defined with a width that is a multiple of two.
VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM specifies an unsigned normalized multi-planar format that has a 16-bit G component in each 16-bit word of plane 0, a 16-bit B component in each 16-bit word of plane 1, and a 16-bit R component in each 16-bit word of plane 2. Each plane has the same dimensions and each R, G and B component contributes to a single texel. The location of each plane when this image is in linear layout can be determined via vkGetImageSubresourceLayout, using VK_IMAGE_ASPECT_PLANE_0_BIT for the G plane, VK_IMAGE_ASPECT_PLANE_1_BIT for the B plane, and VK_IMAGE_ASPECT_PLANE_2_BIT for the R plane.
See Also
VkAndroidHardwareBufferFormatPropertiesANDROID, VkAttachmentDescription, VkAttachmentDescription2KHR, VkBufferViewCreateInfo, VkGeometryTrianglesNV, VkImageCreateInfo, VkImageFormatListCreateInfoKHR, VkImageViewASTCDecodeModeEXT, VkImageViewCreateInfo, VkPhysicalDeviceImageFormatInfo2, VkPhysicalDeviceSparseImageFormatInfo2, VkSamplerYcbcrConversionCreateInfo, VkSurfaceFormatKHR, VkSwapchainCreateInfoKHR, VkVertexInputAttributeDescription, vkGetPhysicalDeviceExternalImageFormatPropertiesNV, vkGetPhysicalDeviceFormatProperties, vkGetPhysicalDeviceFormatProperties2, vkGetPhysicalDeviceFormatProperties2KHR, vkGetPhysicalDeviceImageFormatProperties, vkGetPhysicalDeviceSparseImageFormatProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFormat

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFormatFeatureFlagBits(3)
Name
VkFormatFeatureFlagBits - Bitmask specifying features supported by a buffer

C Specification
Bits which can be set in the VkFormatProperties features linearTilingFeatures, optimalTilingFeatures, drmFormatModifierTilingFeatures, and bufferFeatures are:

typedef enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x00000001,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x00000002,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x00000004,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000008,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x00000010,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x00000020,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x00000040,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x00000080,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x00000100,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000200,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x00000400,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x00000800,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x00001000,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x00004000,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 0x00008000,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x00020000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x00040000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x00080000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x00100000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x00200000,
    VK_FORMAT_FEATURE_DISJOINT_BIT = 0x00400000,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x00800000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 0x00002000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = 0x00010000,
    VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x01000000,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    VK_FORMAT_FEATURE_DISJOINT_BIT_KHR = VK_FORMAT_FEATURE_DISJOINT_BIT,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG,
    VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkFormatFeatureFlagBits;
Description
The following bits may be set in linearTilingFeatures, optimalTilingFeatures, and drmFormatModifierTilingFeatures, specifying that the features are supported by images or image views created with the queried vkGetPhysicalDeviceFormatProperties::format:

VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT specifies that an image view can be sampled from.
VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT specifies that an image view can be used as a storage images.
VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT specifies that an image view can be used as storage image that supports atomic operations.
VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT specifies that an image view can be used as a framebuffer color attachment and as an input attachment.
VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT specifies that an image view can be used as a framebuffer color attachment that supports blending and as an input attachment.
VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT specifies that an image view can be used as a framebuffer depth/stencil attachment and as an input attachment.
VK_FORMAT_FEATURE_BLIT_SRC_BIT specifies that an image can be used as srcImage for the vkCmdBlitImage command.
VK_FORMAT_FEATURE_BLIT_DST_BIT specifies that an image can be used as dstImage for the vkCmdBlitImage command.
VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT specifies that if VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT is also set, an image view can be used with a sampler that has either of magFilter or minFilter set to VK_FILTER_LINEAR, or mipmapMode set to VK_SAMPLER_MIPMAP_MODE_LINEAR. If VK_FORMAT_FEATURE_BLIT_SRC_BIT is also set, an image can be used as the srcImage to vkCmdBlitImage with a filter of VK_FILTER_LINEAR. This bit must only be exposed for formats that also support the VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT or VK_FORMAT_FEATURE_BLIT_SRC_BIT.
If the format being queried is a depth/stencil format, this bit only specifies that the depth aspect (not the stencil aspect) of an image of this format supports linear filtering, and that linear filtering of the depth aspect is supported whether depth compare is enabled in the sampler or not. If this bit is not present, linear filtering with depth compare disabled is unsupported and linear filtering with depth compare enabled is supported, but may compute the filtered value in an implementation-dependent manner which differs from the normal rules of linear filtering. The resulting value must be in the range [0,1] and should be proportional to, or a weighted average of, the number of comparison passes or failures.
VK_FORMAT_FEATURE_TRANSFER_SRC_BIT specifies that an image can be used as a source image for copy commands.
VK_FORMAT_FEATURE_TRANSFER_DST_BIT specifies that an image can be used as a destination image for copy commands and clear commands.
VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT specifies VkImage can be used as a sampled image with a min or max VkSamplerReductionModeEXT. This bit must only be exposed for formats that also support the VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT.
VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT specifies that VkImage can be used with a sampler that has either of magFilter or minFilter set to VK_FILTER_CUBIC_EXT, or be the source image for a blit with filter set to VK_FILTER_CUBIC_EXT. This bit must only be exposed for formats that also support the VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT. If the format being queried is a depth/stencil format, this only specifies that the depth aspect is cubic filterable.
VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT specifies that an application can define a sampler Y’CBCR conversion using this format as a source, and that an image of this format can be used with a VkSamplerYcbcrConversionCreateInfo xChromaOffset and/or yChromaOffset of VK_CHROMA_LOCATION_MIDPOINT. Otherwise both xChromaOffset and yChromaOffset must be VK_CHROMA_LOCATION_COSITED_EVEN. If a format does not incorporate chroma downsampling (it is not a “422” or “420” format) but the implementation supports sampler Y’CBCR conversion for this format, the implementation must set VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT.
VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT specifies that an application can define a sampler Y’CBCR conversion using this format as a source, and that an image of this format can be used with a VkSamplerYcbcrConversionCreateInfo xChromaOffset and/or yChromaOffset of VK_CHROMA_LOCATION_COSITED_EVEN. Otherwise both xChromaOffset and yChromaOffset must be VK_CHROMA_LOCATION_MIDPOINT. If neither VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT nor VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT is set, the application must not define a sampler Y’CBCR conversion using this format as a source.
VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT specifies that the format can do linear sampler filtering (min/magFilter) whilst sampler Y’CBCR conversion is enabled.
VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT specifies that the format can have different chroma, min, and mag filters.
VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT specifies that reconstruction is explicit, as described in html/vkspec.html#textures-chroma-reconstruction. If this bit is not present, reconstruction is implicit by default.
VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT specifies that reconstruction can be forcibly made explicit by setting VkSamplerYcbcrConversionCreateInfo::forceExplicitReconstruction to VK_TRUE.
VK_FORMAT_FEATURE_DISJOINT_BIT specifies that a multi-planar image can have the VK_IMAGE_CREATE_DISJOINT_BIT set during image creation. An implementation must not set VK_FORMAT_FEATURE_DISJOINT_BIT for single-plane formats.
VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT specifies that an image view can be used as a fragment density map attachment.
The following bits may be set in bufferFeatures, specifying that the features are supported by buffers or buffer views created with the queried vkGetPhysicalDeviceProperties::format:

VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT specifies that the format can be used to create a buffer view that can be bound to a VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER descriptor.
VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT specifies that the format can be used to create a buffer view that can be bound to a VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor.
VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT specifies that atomic operations are supported on VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER with this format.
VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT specifies that the format can be used as a vertex attribute format (VkVertexInputAttributeDescription::format).
See Also
VkFormatFeatureFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFormatFeatureFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFrontFace(3)
Name
VkFrontFace - Interpret polygon front-facing orientation

C Specification
The first step of polygon rasterization is to determine whether the triangle is back-facing or front-facing. This determination is made based on the sign of the (clipped or unclipped) polygon’s area computed in framebuffer coordinates. One way to compute this area is:

\[a = -{1 \over 2}\sum_{i=0}^{n-1} x_f^i y_f^{i \oplus 1} - x_f^{i \oplus 1} y_f^i\]
where \(x_f^i\) and \(y_f^i\) are the x and y framebuffer coordinates of the ith vertex of the n-vertex polygon (vertices are numbered starting at zero for the purposes of this computation) and i ⊕ 1 is (i + 1) mod n.

The interpretation of the sign of a is determined by the VkPipelineRasterizationStateCreateInfo::frontFace property of the currently active pipeline. Possible values are:

typedef enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    VK_FRONT_FACE_MAX_ENUM = 0x7FFFFFFF
} VkFrontFace;
Description
VK_FRONT_FACE_COUNTER_CLOCKWISE specifies that a triangle with positive area is considered front-facing.
VK_FRONT_FACE_CLOCKWISE specifies that a triangle with negative area is considered front-facing.
Any triangle which is not front-facing is back-facing, including zero-area triangles.

See Also
VkPipelineRasterizationStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFrontFace

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFullScreenExclusiveEXT(3)
Name
VkFullScreenExclusiveEXT - Hint values an application can specify affecting full-screen transition behavior

C Specification
Possible values of VkSurfaceFullScreenExclusiveInfoEXT::fullScreenExclusive are:

typedef enum VkFullScreenExclusiveEXT {
    VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = 0,
    VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = 1,
    VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = 2,
    VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = 3,
    VK_FULL_SCREEN_EXCLUSIVE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkFullScreenExclusiveEXT;
Description
VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT indicates the implementation should determine the appropriate full-screen method by whatever means it deems appropriate.
VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT indicates the implementation may use full-screen exclusive mechanisms when available. Such mechanisms may result in better performance and/or the availability of different presentation capabilities, but may require a more disruptive transition during swapchain initialization, first presentation and/or destruction.
VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT indicates the implementation should avoid using full-screen mechanisms which rely on disruptive transitions.
VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT indicates the application will manage full-screen exclusive mode by using the vkAcquireFullScreenExclusiveModeEXT and vkReleaseFullScreenExclusiveModeEXT commands.
See Also
VkSurfaceFullScreenExclusiveInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFullScreenExclusiveEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkGeometryFlagBitsNV(3)
Name
VkGeometryFlagBitsNV - Bitmask specifying additional parameters for a geometry

C Specification
Bits which can be set in VkGeometryNV::flags, specifying additional parameters for acceleration structure builds, are:

typedef enum VkGeometryFlagBitsNV {
    VK_GEOMETRY_OPAQUE_BIT_NV = 0x00000001,
    VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = 0x00000002,
    VK_GEOMETRY_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkGeometryFlagBitsNV;
Description
VK_GEOMETRY_OPAQUE_BIT_NV indicates that this geometry does not invoke the any-hit shaders even if present in a hit group.
VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV indicates that the implementation must only call the any-hit shader a single time for each primitive in this geometry. If this bit is absent an implementation may invoke the any-hit shader more than once for this geometry.
See Also
VkGeometryFlagsNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkGeometryFlagBitsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkGeometryInstanceFlagBitsNV(3)
Name
VkGeometryInstanceFlagBitsNV - Instance flag bits

C Specification
Possible values of flags in the instance modifying the behavior of that instance are:,

typedef enum VkGeometryInstanceFlagBitsNV {
    VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV = 0x00000001,
    VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = 0x00000002,
    VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV = 0x00000004,
    VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV = 0x00000008,
    VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_NV = 0x7FFFFFFF
} VkGeometryInstanceFlagBitsNV;
Description
VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV disables face culling for this instance.
VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV indicates that the front face of the triangle for culling purposes is the face that is counter clockwise in object space relative to the ray origin. Because the facing is determined in object space, an instance transform matrix does not change the winding, but a geometry transform does.
VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV causes this instance to act as though VK_GEOMETRY_OPAQUE_BIT_NV were specified on all geometries referenced by this instance. This behavior can be overridden by the ray flag gl_RayFlagsNoOpaqueNV.
VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV causes this instance to act as though VK_GEOMETRY_OPAQUE_BIT_NV were not specified on all geometries referenced by this instance. This behavior can be overridden by the ray flag gl_RayFlagsOpaqueNV.
VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV and VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV must not be used in the same flag.

See Also
VkGeometryInstanceFlagsNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkGeometryInstanceFlagBitsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkGeometryTypeNV(3)
Name
VkGeometryTypeNV - Enum specifying which type of geometry is provided

C Specification
Geometry types are specified by VkGeometryTypeNV, which takes values:

typedef enum VkGeometryTypeNV {
    VK_GEOMETRY_TYPE_TRIANGLES_NV = 0,
    VK_GEOMETRY_TYPE_AABBS_NV = 1,
    VK_GEOMETRY_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
} VkGeometryTypeNV;
Description
VK_GEOMETRY_TYPE_TRIANGLES_NV indicates that the triangles of VkGeometryDataNV contains valid data.
VK_GEOMETRY_TYPE_AABBS_NV indicates that the aabbs of VkGeometryDataNV contains valid data.
See Also
VkGeometryNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkGeometryTypeNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageAspectFlagBits(3)
Name
VkImageAspectFlagBits - Bitmask specifying which aspects of an image are included in a view

C Specification
Bits which can be set in an aspect mask to specify aspects of an image for purposes such as identifying a subresource, are:

typedef enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 0x00000001,
    VK_IMAGE_ASPECT_DEPTH_BIT = 0x00000002,
    VK_IMAGE_ASPECT_STENCIL_BIT = 0x00000004,
    VK_IMAGE_ASPECT_METADATA_BIT = 0x00000008,
    VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
    VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
    VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
    VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
    VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
    VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
    VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageAspectFlagBits;
Description
VK_IMAGE_ASPECT_COLOR_BIT specifies the color aspect.
VK_IMAGE_ASPECT_DEPTH_BIT specifies the depth aspect.
VK_IMAGE_ASPECT_STENCIL_BIT specifies the stencil aspect.
VK_IMAGE_ASPECT_METADATA_BIT specifies the metadata aspect, used for sparse sparse resource operations.
See Also
VkBindImagePlaneMemoryInfo, VkImageAspectFlags, VkImagePlaneMemoryRequirementsInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageAspectFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageCreateFlagBits(3)
Name
VkImageCreateFlagBits - Bitmask specifying additional parameters of an image

C Specification
Bits which can be set in VkImageCreateInfo::flags, specifying additional parameters of an image, are:

typedef enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x00000001,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x00000002,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x00000004,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x00000008,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x00000010,
    VK_IMAGE_CREATE_ALIAS_BIT = 0x00000400,
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x00000040,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x00000020,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x00000080,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x00000100,
    VK_IMAGE_CREATE_PROTECTED_BIT = 0x00000800,
    VK_IMAGE_CREATE_DISJOINT_BIT = 0x00000200,
    VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x00002000,
    VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000,
    VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x00004000,
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    VK_IMAGE_CREATE_DISJOINT_BIT_KHR = VK_IMAGE_CREATE_DISJOINT_BIT,
    VK_IMAGE_CREATE_ALIAS_BIT_KHR = VK_IMAGE_CREATE_ALIAS_BIT,
    VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageCreateFlagBits;
Description
VK_IMAGE_CREATE_SPARSE_BINDING_BIT specifies that the image will be backed using sparse memory binding.
VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT specifies that the image can be partially backed using sparse memory binding. Images created with this flag must also be created with the VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag.
VK_IMAGE_CREATE_SPARSE_ALIASED_BIT specifies that the image will be backed using sparse memory binding with memory ranges that might also simultaneously be backing another image (or another portion of the same image). Images created with this flag must also be created with the VK_IMAGE_CREATE_SPARSE_BINDING_BIT flag
VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT specifies that the image can be used to create a VkImageView with a different format from the image. For multi-planar formats, VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT specifies that a VkImageView can be created of a plane of the image.
VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT specifies that the image can be used to create a VkImageView of type VK_IMAGE_VIEW_TYPE_CUBE or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY.
VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT specifies that the image can be used to create a VkImageView of type VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY.
VK_IMAGE_CREATE_PROTECTED_BIT specifies that the image is a protected image.
VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT specifies that the image can be used with a non-zero value of the splitInstanceBindRegionCount member of a VkBindImageMemoryDeviceGroupInfo structure passed into vkBindImageMemory2. This flag also has the effect of making the image use the standard sparse image block dimensions.
VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT specifies that the image having a compressed format can be used to create a VkImageView with an uncompressed format where each texel in the image view corresponds to a compressed texel block of the image.
VK_IMAGE_CREATE_EXTENDED_USAGE_BIT specifies that the image can be created with usage flags that are not supported for the format the image is created with but are supported for at least one format a VkImageView created from the image can have.
VK_IMAGE_CREATE_DISJOINT_BIT specifies that an image with a multi-planar format must have each plane separately bound to memory, rather than having a single memory binding for the whole image; the presence of this bit distinguishes a disjoint image from an image without this bit set.
VK_IMAGE_CREATE_ALIAS_BIT specifies that two images created with the same creation parameters and aliased to the same memory can interpret the contents of the memory consistently with each other, subject to the rules described in the Memory Aliasing section. This flag further specifies that each plane of a disjoint image can share an in-memory non-linear representation with single-plane images, and that a single-plane image can share an in-memory non-linear representation with a plane of a multi-planar disjoint image, according to the rules in html/vkspec.html#formats-compatible-planes. If the pNext chain includes a VkExternalMemoryImageCreateInfo or VkExternalMemoryImageCreateInfoNV structure whose handleTypes member is not 0, it is as if VK_IMAGE_CREATE_ALIAS_BIT is set.
VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT specifies that an image with a depth or depth/stencil format can be used with custom sample locations when used as a depth/stencil attachment.
VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV specifies that the image is a corner-sampled image.
VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT specifies that an image can be in a subsampled format which may be more optimal when written as an attachment by a render pass that has a fragment density map attachment. Accessing a subsampled image has additional considerations:
Image data read as an image sampler is undefined if the sampler was not created with flags containing VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT or was not sampled through the use of a combined image sampler with an immutable sampler in VkDescriptorSetLayoutBinding.
Image data read with an input attachment is undefined if the contents were not written as an attachment in an earlier subpass of the same render pass.
Image data read with load operations may be resampled to the fragment density of the render pass.
Image contents outside of the render area become undefined if the image is stored as a render pass attachment.
See Sparse Resource Features and Sparse Physical Device Features for more details.

See Also
VkImageCreateFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageCreateFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageLayout(3)
Name
VkImageLayout - Layout of image and image subresources

C Specification
The set of image layouts consists of:

typedef enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
    VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = 1000164003,
    VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
    VK_IMAGE_LAYOUT_MAX_ENUM = 0x7FFFFFFF
} VkImageLayout;
Description
The type(s) of device access supported by each layout are:

VK_IMAGE_LAYOUT_UNDEFINED does not support device access. This layout must only be used as the initialLayout member of VkImageCreateInfo or VkAttachmentDescription, or as the oldLayout in an image transition. When transitioning out of this layout, the contents of the memory are not guaranteed to be preserved.
VK_IMAGE_LAYOUT_PREINITIALIZED does not support device access. This layout must only be used as the initialLayout member of VkImageCreateInfo or VkAttachmentDescription, or as the oldLayout in an image transition. When transitioning out of this layout, the contents of the memory are preserved. This layout is intended to be used as the initial layout for an image whose contents are written by the host, and hence the data can be written to memory immediately, without first executing a layout transition. Currently, VK_IMAGE_LAYOUT_PREINITIALIZED is only useful with linear images because there is not a standard layout defined for VK_IMAGE_TILING_OPTIMAL images.
VK_IMAGE_LAYOUT_GENERAL supports all types of device access.
VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL must only be used as a color or resolve attachment in a VkFramebuffer. This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT usage bit enabled.
VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL must only be used as a depth/stencil or depth/stencil resolve attachment in a VkFramebuffer. This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bit enabled.
VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL must only be used as a read-only depth/stencil attachment in a VkFramebuffer and/or as a read-only image in a shader (which can be read as a sampled image, combined image/sampler and/or input attachment). This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bit enabled. Only image views created with a usage value including VK_IMAGE_USAGE_SAMPLED_BIT can be used as a sampled image or combined image/sampler in a shader. Similarly, only image views created with a usage value including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT can be used as input attachments.
VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: must only be used as a depth/stencil attachment in a VkFramebuffer, where the depth aspect is read-only, and/or as a read-only image in a shader (which can be read as a sampled image, combined image/sampler and/or input attachment) where only the depth aspect is accessed. This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bit enabled. Only image views created with a usage value including VK_IMAGE_USAGE_SAMPLED_BIT can be used as a sampled image or combined image/sampler in a shader. Similarly, only image views created with a usage value including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT can be used as input attachments.
VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: must only be used as a depth/stencil attachment in a VkFramebuffer, where the stencil aspect is read-only, and/or as a read-only image in a shader (which can be read as a sampled image, combined image/sampler and/or input attachment) where only the stencil aspect is accessed. This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bit enabled. Only image views created with a usage value including VK_IMAGE_USAGE_SAMPLED_BIT can be used as a sampled image or combined image/sampler in a shader. Similarly, only image views created with a usage value including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT can be used as input attachments.
VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL must only be used as a read-only image in a shader (which can be read as a sampled image, combined image/sampler and/or input attachment). This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT usage bit enabled.
VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL must only be used as a source image of a transfer command (see the definition of VK_PIPELINE_STAGE_TRANSFER_BIT). This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage bit enabled.
VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL must only be used as a destination image of a transfer command. This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_TRANSFER_DST_BIT usage bit enabled.
VK_IMAGE_LAYOUT_PRESENT_SRC_KHR must only be used for presenting a presentable image for display. A swapchain’s image must be transitioned to this layout before calling vkQueuePresentKHR, and must be transitioned away from this layout after calling vkAcquireNextImageKHR.
VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR is valid only for shared presentable images, and must be used for any usage the image supports.
VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV must only be used as a read-only shading-rate-image. This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV usage bit enabled.
VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT must only be used as a fragment density map attachment in a VkRenderPass. This layout is valid only for image subresources of images created with the VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT usage bit enabled.
The layout of each image subresource is not a state of the image subresource itself, but is rather a property of how the data in memory is organized, and thus for each mechanism of accessing an image in the API the application must specify a parameter or structure member that indicates which image layout the image subresource(s) are considered to be in when the image will be accessed. For transfer commands, this is a parameter to the command (see html/vkspec.html#clears and html/vkspec.html#copies). For use as a framebuffer attachment, this is a member in the substructures of the VkRenderPassCreateInfo (see Render Pass). For use in a descriptor set, this is a member in the VkDescriptorImageInfo structure (see html/vkspec.html#descriptorsets-updates).

See Also
VkAttachmentDescription, VkAttachmentDescription2KHR, VkAttachmentReference, VkAttachmentReference2KHR, VkDescriptorImageInfo, VkImageCreateInfo, VkImageMemoryBarrier, vkCmdBindShadingRateImageNV, vkCmdBlitImage, vkCmdClearColorImage, vkCmdClearDepthStencilImage, vkCmdCopyBufferToImage, vkCmdCopyImage, vkCmdCopyImageToBuffer, vkCmdResolveImage

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageLayout

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageTiling(3)
Name
VkImageTiling - Specifies the tiling arrangement of data in an image

C Specification
Possible values of VkImageCreateInfo::tiling, specifying the tiling arrangement of texel blocks in an image, are:

typedef enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
    VK_IMAGE_TILING_MAX_ENUM = 0x7FFFFFFF
} VkImageTiling;
Description
VK_IMAGE_TILING_OPTIMAL specifies optimal tiling (texels are laid out in an implementation-dependent arrangement, for more optimal memory access).
VK_IMAGE_TILING_LINEAR specifies linear tiling (texels are laid out in memory in row-major order, possibly with some padding on each row).
VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT indicates that the image’s tiling is defined by a Linux DRM format modifier. The modifier is specified at image creation with VkImageDrmFormatModifierListCreateInfoEXT or VkImageDrmFormatModifierExplicitCreateInfoEXT, and can be queried with vkGetImageDrmFormatModifierPropertiesEXT.
See Also
VkImageCreateInfo, VkPhysicalDeviceImageFormatInfo2, VkPhysicalDeviceSparseImageFormatInfo2, vkGetPhysicalDeviceExternalImageFormatPropertiesNV, vkGetPhysicalDeviceImageFormatProperties, vkGetPhysicalDeviceSparseImageFormatProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageTiling

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageType(3)
Name
VkImageType - Specifies the type of an image object

C Specification
Possible values of VkImageCreateInfo::imageType, specifying the basic dimensionality of an image, are:

typedef enum VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    VK_IMAGE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageType;
Description
VK_IMAGE_TYPE_1D specifies a one-dimensional image.
VK_IMAGE_TYPE_2D specifies a two-dimensional image.
VK_IMAGE_TYPE_3D specifies a three-dimensional image.
See Also
VkImageCreateInfo, VkPhysicalDeviceImageFormatInfo2, VkPhysicalDeviceSparseImageFormatInfo2, vkGetPhysicalDeviceExternalImageFormatPropertiesNV, vkGetPhysicalDeviceImageFormatProperties, vkGetPhysicalDeviceSparseImageFormatProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageType

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageUsageFlagBits(3)
Name
VkImageUsageFlagBits - Bitmask specifying intended usage of an image

C Specification
Bits which can be set in VkImageCreateInfo::usage, specifying intended usage of an image, are:

typedef enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002,
    VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004,
    VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080,
    VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = 0x00000100,
    VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x00000200,
    VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageUsageFlagBits;
Description
VK_IMAGE_USAGE_TRANSFER_SRC_BIT specifies that the image can be used as the source of a transfer command.
VK_IMAGE_USAGE_TRANSFER_DST_BIT specifies that the image can be used as the destination of a transfer command.
VK_IMAGE_USAGE_SAMPLED_BIT specifies that the image can be used to create a VkImageView suitable for occupying a VkDescriptorSet slot either of type VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and be sampled by a shader.
VK_IMAGE_USAGE_STORAGE_BIT specifies that the image can be used to create a VkImageView suitable for occupying a VkDescriptorSet slot of type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.
VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT specifies that the image can be used to create a VkImageView suitable for use as a color or resolve attachment in a VkFramebuffer.
VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT specifies that the image can be used to create a VkImageView suitable for use as a depth/stencil or depth/stencil resolve attachment in a VkFramebuffer.
VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT specifies that the memory bound to this image will have been allocated with the VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT (see html/vkspec.html#memory for more detail). This bit can be set for any image that can be used to create a VkImageView suitable for use as a color, resolve, depth/stencil, or input attachment.
VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT specifies that the image can be used to create a VkImageView suitable for occupying VkDescriptorSet slot of type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT; be read from a shader as an input attachment; and be used as an input attachment in a framebuffer.
VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV specifies that the image can be used to create a VkImageView suitable for use as a shading rate image.
See Also
VkImageUsageFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageUsageFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageViewCreateFlagBits(3)
Name
VkImageViewCreateFlagBits - Bitmask specifying additional parameters of an image view

C Specification
Bits which can be set in VkImageViewCreateInfo::flags, specifying additional parameters of an image, are:

typedef enum VkImageViewCreateFlagBits {
    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x00000001,
    VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkImageViewCreateFlagBits;
Description
VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT prohibits the implementation from accessing the fragment density map by the host during vkCmdBeginRenderPass as the contents are expected to change after recording
See Also
VkImageViewCreateFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageViewCreateFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageViewType(3)
Name
VkImageViewType - Image view types

C Specification
The types of image views that can be created are:

typedef enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    VK_IMAGE_VIEW_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkImageViewType;
Description
The exact image view type is partially implicit, based on the image’s type and sample count, as well as the view creation parameters as described in the image view compatibility table for vkCreateImageView. This table also shows which SPIR-V OpTypeImage Dim and Arrayed parameters correspond to each image view type.

See Also
VkImageViewCreateInfo, VkPhysicalDeviceImageViewImageFormatInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageViewType

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkIndexType(3)
Name
VkIndexType - Type of index buffer indices

C Specification
Possible values of vkCmdBindIndexBuffer::indexType, specifying the size of indices, are:

typedef enum VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_NONE_NV = 1000165000,
    VK_INDEX_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkIndexType;
Description
VK_INDEX_TYPE_UINT16 specifies that indices are 16-bit unsigned integer values.
VK_INDEX_TYPE_UINT32 specifies that indices are 32-bit unsigned integer values.
VK_INDEX_TYPE_NONE_NV specifies that no indices are provided.
See Also
VkGeometryTrianglesNV, VkObjectTableIndexBufferEntryNVX, vkCmdBindIndexBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkIndexType

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkIndirectCommandsLayoutUsageFlagBitsNVX(3)
Name
VkIndirectCommandsLayoutUsageFlagBitsNVX - Bitmask specifying allowed usage of an indirect commands layout

C Specification
Bits which can be set in VkIndirectCommandsLayoutCreateInfoNVX::flags, specifying usage hints of an indirect command layout, are:

typedef enum VkIndirectCommandsLayoutUsageFlagBitsNVX {
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX = 0x00000001,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX = 0x00000002,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX = 0x00000004,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX = 0x00000008,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX = 0x7FFFFFFF
} VkIndirectCommandsLayoutUsageFlagBitsNVX;
Description
VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX specifies that the processing of sequences can happen at an implementation-dependent order, which is not guaranteed to be coherent across multiple invocations.
VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX specifies that there is likely a high difference between allocated number of sequences and actually used.
VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX specifies that there are likely many draw or dispatch calls that are zero-sized (zero grid dimension, no primitives to render).
VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX specifies that the input data for the sequences is not implicitly indexed from 0..sequencesUsed but a user provided VkBuffer encoding the index is provided.
See Also
VkIndirectCommandsLayoutUsageFlagsNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkIndirectCommandsLayoutUsageFlagBitsNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkIndirectCommandsTokenTypeNVX(3)
Name
VkIndirectCommandsTokenTypeNVX - Enum specifying

C Specification
Possible values of those elements of the VkIndirectCommandsLayoutCreateInfoNVX::pTokens array which specify command tokens (other elements of the array specify command parameters) are:

typedef enum VkIndirectCommandsTokenTypeNVX {
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX = 0,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX = 1,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX = 2,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX = 3,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX = 4,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX = 5,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX = 6,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX = 7,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX = 0x7FFFFFFF
} VkIndirectCommandsTokenTypeNVX;
Description
Table 22. Supported indirect command tokens
Token type	Equivalent command
VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX
vkCmdBindPipeline
VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX
vkCmdBindDescriptorSets
VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX
vkCmdBindIndexBuffer
VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX
vkCmdBindVertexBuffers
VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX
vkCmdPushConstants
VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX
vkCmdDrawIndexedIndirect
VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX
vkCmdDrawIndirect
VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX
vkCmdDispatchIndirect
See Also
VkIndirectCommandsLayoutTokenNVX, VkIndirectCommandsTokenNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkIndirectCommandsTokenTypeNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkInternalAllocationType(3)
Name
VkInternalAllocationType - Allocation type

C Specification
The allocationType parameter to the pfnInternalAllocation and pfnInternalFree functions may be one of the following values:

typedef enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkInternalAllocationType;
Description
VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE specifies that the allocation is intended for execution by the host.
See Also
PFN_vkInternalAllocationNotification, PFN_vkInternalFreeNotification

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkInternalAllocationType

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkLogicOp(3)
Name
VkLogicOp - Framebuffer logical operations

C Specification
Logical operations are controlled by the logicOpEnable and logicOp members of VkPipelineColorBlendStateCreateInfo. If logicOpEnable is VK_TRUE, then a logical operation selected by logicOp is applied between each color attachment and the fragment’s corresponding output value, and blending of all attachments is treated as if it were disabled. Any attachments using color formats for which logical operations are not supported simply pass through the color values unmodified. The logical operation is applied independently for each of the red, green, blue, and alpha components. The logicOp is selected from the following operations:

typedef enum VkLogicOp {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    VK_LOGIC_OP_MAX_ENUM = 0x7FFFFFFF
} VkLogicOp;
Description
The logical operations supported by Vulkan are summarized in the following table in which

¬ is bitwise invert,
∧ is bitwise and,
∨ is bitwise or,
⊕ is bitwise exclusive or,
s is the fragment’s Rs0, Gs0, Bs0 or As0 component value for the fragment output corresponding to the color attachment being updated, and
d is the color attachment’s R, G, B or A component value:
Table 23. Logical Operations
Mode	Operation
VK_LOGIC_OP_CLEAR
0
VK_LOGIC_OP_AND
s ∧ d
VK_LOGIC_OP_AND_REVERSE
s ∧ ¬ d
VK_LOGIC_OP_COPY
s
VK_LOGIC_OP_AND_INVERTED
¬ s ∧ d
VK_LOGIC_OP_NO_OP
d
VK_LOGIC_OP_XOR
s ⊕ d
VK_LOGIC_OP_OR
s ∨ d
VK_LOGIC_OP_NOR
¬ (s ∨ d)
VK_LOGIC_OP_EQUIVALENT
¬ (s ⊕ d)
VK_LOGIC_OP_INVERT
¬ d
VK_LOGIC_OP_OR_REVERSE
s ∨ ¬ d
VK_LOGIC_OP_COPY_INVERTED
¬ s
VK_LOGIC_OP_OR_INVERTED
¬ s ∨ d
VK_LOGIC_OP_NAND
¬ (s ∧ d)
VK_LOGIC_OP_SET
all 1s
The result of the logical operation is then written to the color attachment as controlled by the component write mask, described in Blend Operations.

See Also
VkPipelineColorBlendStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkLogicOp

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryAllocateFlagBits(3)
Name
VkMemoryAllocateFlagBits - Bitmask specifying flags for a device memory allocation

C Specification
Bits which can be set in VkMemoryAllocateFlagsInfo::flags, controlling device memory allocation, are:

typedef enum VkMemoryAllocateFlagBits {
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 0x00000001,
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
    VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryAllocateFlagBits;
or the equivalent

typedef VkMemoryAllocateFlagBits VkMemoryAllocateFlagBitsKHR;
Description
VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT specifies that memory will be allocated for the devices in VkMemoryAllocateFlagsInfo::deviceMask.
See Also
VkMemoryAllocateFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryAllocateFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryHeapFlagBits(3)
Name
VkMemoryHeapFlagBits - Bitmask specifying attribute flags for a heap

C Specification
Bits which may be set in VkMemoryHeap::flags, indicating attribute flags for the heap, are:

typedef enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x00000002,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
    VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryHeapFlagBits;
Description
VK_MEMORY_HEAP_DEVICE_LOCAL_BIT specifies that the heap corresponds to device local memory. Device local memory may have different performance characteristics than host local memory, and may support different memory property flags.
VK_MEMORY_HEAP_MULTI_INSTANCE_BIT specifies that in a logical device representing more than one physical device, there is a per-physical device instance of the heap memory. By default, an allocation from such a heap will be replicated to each physical device’s instance of the heap.
See Also
VkMemoryHeapFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryHeapFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryOverallocationBehaviorAMD(3)
Name
VkMemoryOverallocationBehaviorAMD - Specify memory overallocation behavior

C Specification
Possible values for VkDeviceMemoryOverallocationCreateInfoAMD::overallocationBehavior include:

typedef enum VkMemoryOverallocationBehaviorAMD {
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0,
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1,
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2,
    VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD = 0x7FFFFFFF
} VkMemoryOverallocationBehaviorAMD;
Description
VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD lets the implementation decide if overallocation should be allowed.
VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD specifies overallocation is allowed if platform permits.
VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD specifies the application is not allowed to allocate device memory beyond the heap sizes reported by VkPhysicalDeviceMemoryProperties. Allocations that are not explicitly made by the application within the scope of the Vulkan instance are not accounted for.
See Also
VkDeviceMemoryOverallocationCreateInfoAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryOverallocationBehaviorAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryPropertyFlagBits(3)
Name
VkMemoryPropertyFlagBits - Bitmask specifying properties for a memory type

C Specification
Bits which may be set in VkMemoryType::propertyFlags, indicating properties of a memory heap, are:

typedef enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
    VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020,
    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkMemoryPropertyFlagBits;
Description
VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT bit specifies that memory allocated with this type is the most efficient for device access. This property will be set if and only if the memory type belongs to a heap with the VK_MEMORY_HEAP_DEVICE_LOCAL_BIT set.
VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT bit specifies that memory allocated with this type can be mapped for host access using vkMapMemory.
VK_MEMORY_PROPERTY_HOST_COHERENT_BIT bit specifies that the host cache management commands vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges are not needed to flush host writes to the device or make device writes visible to the host, respectively.
VK_MEMORY_PROPERTY_HOST_CACHED_BIT bit specifies that memory allocated with this type is cached on the host. Host memory accesses to uncached memory are slower than to cached memory, however uncached memory is always host coherent.
VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit specifies that the memory type only allows device access to the memory. Memory types must not have both VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT and VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT set. Additionally, the object’s backing memory may be provided by the implementation lazily as specified in Lazily Allocated Memory.
VK_MEMORY_PROPERTY_PROTECTED_BIT bit specifies that the memory type only allows device access to the memory, and allows protected queue operations to access the memory. Memory types must not have VK_MEMORY_PROPERTY_PROTECTED_BIT set and any of VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT set, or VK_MEMORY_PROPERTY_HOST_COHERENT_BIT set, or VK_MEMORY_PROPERTY_HOST_CACHED_BIT set.
See Also
VkMemoryPropertyFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryPropertyFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkObjectEntryTypeNVX(3)
Name
VkObjectEntryTypeNVX - Enum specifying object table entry type

C Specification
Possible values of elements of the VkObjectTableCreateInfoNVX::pObjectEntryTypes array, specifying the entry type of a configuration, are:

typedef enum VkObjectEntryTypeNVX {
    VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX = 0,
    VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX = 1,
    VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX = 2,
    VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX = 3,
    VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX = 4,
    VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX = 0x7FFFFFFF
} VkObjectEntryTypeNVX;
Description
VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX specifies a VkDescriptorSet resource entry that is registered via VkObjectTableDescriptorSetEntryNVX.
VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX specifies a VkPipeline resource entry that is registered via VkObjectTablePipelineEntryNVX.
VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX specifies a VkBuffer resource entry that is registered via VkObjectTableIndexBufferEntryNVX.
VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX specifies a VkBuffer resource entry that is registered via VkObjectTableVertexBufferEntryNVX.
VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX specifies the resource entry is registered via VkObjectTablePushConstantEntryNVX.
See Also
VkObjectTableCreateInfoNVX, VkObjectTableDescriptorSetEntryNVX, VkObjectTableEntryNVX, VkObjectTableIndexBufferEntryNVX, VkObjectTablePipelineEntryNVX, VkObjectTablePushConstantEntryNVX, VkObjectTableVertexBufferEntryNVX, vkUnregisterObjectsNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkObjectEntryTypeNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkObjectEntryUsageFlagBitsNVX(3)
Name
VkObjectEntryUsageFlagBitsNVX - Bitmask specifying allowed usage of an object entry

C Specification
Bits which can be set in elements of the VkObjectTableCreateInfoNVX::pObjectEntryUsageFlags array, specifying binding usage of an entry, are:

typedef enum VkObjectEntryUsageFlagBitsNVX {
    VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX = 0x00000001,
    VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX = 0x00000002,
    VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX = 0x7FFFFFFF
} VkObjectEntryUsageFlagBitsNVX;
Description
VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX specifies that the resource is bound to VK_PIPELINE_BIND_POINT_GRAPHICS
VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX specifies that the resource is bound to VK_PIPELINE_BIND_POINT_COMPUTE
See Also
VkObjectEntryUsageFlagsNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkObjectEntryUsageFlagBitsNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkObjectType(3)
Name
VkObjectType - Specify an enumeration to track object handle types

C Specification
The VkObjectType enumeration defines values, each of which corresponds to a specific Vulkan handle type. These values can be used to associate debug information with a particular type of object through one or more extensions.

typedef enum VkObjectType {
    VK_OBJECT_TYPE_UNKNOWN = 0,
    VK_OBJECT_TYPE_INSTANCE = 1,
    VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
    VK_OBJECT_TYPE_DEVICE = 3,
    VK_OBJECT_TYPE_QUEUE = 4,
    VK_OBJECT_TYPE_SEMAPHORE = 5,
    VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
    VK_OBJECT_TYPE_FENCE = 7,
    VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
    VK_OBJECT_TYPE_BUFFER = 9,
    VK_OBJECT_TYPE_IMAGE = 10,
    VK_OBJECT_TYPE_EVENT = 11,
    VK_OBJECT_TYPE_QUERY_POOL = 12,
    VK_OBJECT_TYPE_BUFFER_VIEW = 13,
    VK_OBJECT_TYPE_IMAGE_VIEW = 14,
    VK_OBJECT_TYPE_SHADER_MODULE = 15,
    VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
    VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
    VK_OBJECT_TYPE_RENDER_PASS = 18,
    VK_OBJECT_TYPE_PIPELINE = 19,
    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
    VK_OBJECT_TYPE_SAMPLER = 21,
    VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
    VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
    VK_OBJECT_TYPE_FRAMEBUFFER = 24,
    VK_OBJECT_TYPE_COMMAND_POOL = 25,
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
    VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
    VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
    VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
    VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
    VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
    VK_OBJECT_TYPE_OBJECT_TABLE_NVX = 1000086000,
    VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX = 1000086001,
    VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
    VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
    VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
    VK_OBJECT_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkObjectType;
Description
Table 24. VkObjectType and Vulkan Handle Relationship
VkObjectType	Vulkan Handle Type
VK_OBJECT_TYPE_UNKNOWN
Unknown/Undefined Handle
VK_OBJECT_TYPE_INSTANCE
VkInstance
VK_OBJECT_TYPE_PHYSICAL_DEVICE
VkPhysicalDevice
VK_OBJECT_TYPE_DEVICE
VkDevice
VK_OBJECT_TYPE_QUEUE
VkQueue
VK_OBJECT_TYPE_SEMAPHORE
VkSemaphore
VK_OBJECT_TYPE_COMMAND_BUFFER
VkCommandBuffer
VK_OBJECT_TYPE_FENCE
VkFence
VK_OBJECT_TYPE_DEVICE_MEMORY
VkDeviceMemory
VK_OBJECT_TYPE_BUFFER
VkBuffer
VK_OBJECT_TYPE_IMAGE
VkImage
VK_OBJECT_TYPE_EVENT
VkEvent
VK_OBJECT_TYPE_QUERY_POOL
VkQueryPool
VK_OBJECT_TYPE_BUFFER_VIEW
VkBufferView
VK_OBJECT_TYPE_IMAGE_VIEW
VkImageView
VK_OBJECT_TYPE_SHADER_MODULE
VkShaderModule
VK_OBJECT_TYPE_PIPELINE_CACHE
VkPipelineCache
VK_OBJECT_TYPE_PIPELINE_LAYOUT
VkPipelineLayout
VK_OBJECT_TYPE_RENDER_PASS
VkRenderPass
VK_OBJECT_TYPE_PIPELINE
VkPipeline
VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT
VkDescriptorSetLayout
VK_OBJECT_TYPE_SAMPLER
VkSampler
VK_OBJECT_TYPE_DESCRIPTOR_POOL
VkDescriptorPool
VK_OBJECT_TYPE_DESCRIPTOR_SET
VkDescriptorSet
VK_OBJECT_TYPE_FRAMEBUFFER
VkFramebuffer
VK_OBJECT_TYPE_COMMAND_POOL
VkCommandPool
VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION
VkSamplerYcbcrConversion
VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE
VkDescriptorUpdateTemplate
VK_OBJECT_TYPE_SURFACE_KHR
VkSurfaceKHR
VK_OBJECT_TYPE_SWAPCHAIN_KHR
VkSwapchainKHR
VK_OBJECT_TYPE_DISPLAY_KHR
VkDisplayKHR
VK_OBJECT_TYPE_DISPLAY_MODE_KHR
VkDisplayModeKHR
VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT
VkDebugReportCallbackEXT
VK_OBJECT_TYPE_OBJECT_TABLE_NVX
VkObjectTableNVX
VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX
VkIndirectCommandsLayoutNVX
VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT
VkDebugUtilsMessengerEXT
VK_OBJECT_TYPE_VALIDATION_CACHE_EXT
VkValidationCacheEXT
VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV
VkAccelerationStructureNV
See Also
VkDebugUtilsObjectNameInfoEXT, VkDebugUtilsObjectTagInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkObjectType

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPeerMemoryFeatureFlagBits(3)
Name
VkPeerMemoryFeatureFlagBits - Bitmask specifying supported peer memory features

C Specification
Bits which may be set in the value returned for vkGetDeviceGroupPeerMemoryFeatures::pPeerMemoryFeatures, indicating the supported peer memory features, are:

typedef enum VkPeerMemoryFeatureFlagBits {
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 0x00000001,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 0x00000002,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 0x00000004,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 0x00000008,
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
    VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPeerMemoryFeatureFlagBits;
or the equivalent

typedef VkPeerMemoryFeatureFlagBits VkPeerMemoryFeatureFlagBitsKHR;
Description
VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT specifies that the memory can be accessed as the source of a vkCmdCopyBuffer, vkCmdCopyImage, vkCmdCopyBufferToImage, or vkCmdCopyImageToBuffer command.
VK_PEER_MEMORY_FEATURE_COPY_DST_BIT specifies that the memory can be accessed as the destination of a vkCmdCopyBuffer, vkCmdCopyImage, vkCmdCopyBufferToImage, or vkCmdCopyImageToBuffer command.
VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT specifies that the memory can be read as any memory access type.
VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT specifies that the memory can be written as any memory access type. Shader atomics are considered to be writes.
Note
The peer memory features of a memory heap also apply to any accesses that may be performed during image layout transitions.
VK_PEER_MEMORY_FEATURE_COPY_DST_BIT must be supported for all host local heaps and for at least one device local heap.

If a device does not support a peer memory feature, it is still valid to use a resource that includes both local and peer memory bindings with the corresponding access type as long as only the local bindings are actually accessed. For example, an application doing split-frame rendering would use framebuffer attachments that include both local and peer memory bindings, but would scissor the rendering to only update local memory.

See Also
VkPeerMemoryFeatureFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPeerMemoryFeatureFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPhysicalDeviceType(3)
Name
VkPhysicalDeviceType - Supported physical device types

C Specification
The physical device types which may be returned in VkPhysicalDeviceProperties::deviceType are:

typedef enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkPhysicalDeviceType;
Description
VK_PHYSICAL_DEVICE_TYPE_OTHER - the device does not match any other available types.
VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU - the device is typically one embedded in or tightly coupled with the host.
VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU - the device is typically a separate processor connected to the host via an interlink.
VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU - the device is typically a virtual node in a virtualization environment.
VK_PHYSICAL_DEVICE_TYPE_CPU - the device is typically running on the same processors as the host.
The physical device type is advertised for informational purposes only, and does not directly affect the operation of the system. However, the device type may correlate with other advertised properties or capabilities of the system, such as how many memory heaps there are.

See Also
VkPhysicalDeviceProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPhysicalDeviceType

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineBindPoint(3)
Name
VkPipelineBindPoint - Specify the bind point of a pipeline object to a command buffer

C Specification
Possible values of vkCmdBindPipeline::pipelineBindPoint, specifying the bind point of a pipeline object, are:

typedef enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_RAY_TRACING_NV = 1000165000,
    VK_PIPELINE_BIND_POINT_MAX_ENUM = 0x7FFFFFFF
} VkPipelineBindPoint;
Description
VK_PIPELINE_BIND_POINT_COMPUTE specifies binding as a compute pipeline.
VK_PIPELINE_BIND_POINT_GRAPHICS specifies binding as a graphics pipeline.
VK_PIPELINE_BIND_POINT_RAY_TRACING_NV specifies binding as a ray tracing pipeline.
See Also
VkDescriptorUpdateTemplateCreateInfo, VkIndirectCommandsLayoutCreateInfoNVX, VkSubpassDescription, VkSubpassDescription2KHR, vkCmdBindDescriptorSets, vkCmdBindPipeline, vkCmdPushDescriptorSetKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineBindPoint

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCacheHeaderVersion(3)
Name
VkPipelineCacheHeaderVersion - Encode pipeline cache version

C Specification
Possible values of the second group of four bytes in the header returned by vkGetPipelineCacheData, encoding the pipeline cache version, are:

typedef enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCacheHeaderVersion;
Description
VK_PIPELINE_CACHE_HEADER_VERSION_ONE specifies version one of the pipeline cache.
See Also
vkCreatePipelineCache, vkGetPipelineCacheData

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCacheHeaderVersion

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCreateFlagBits(3)
Name
VkPipelineCreateFlagBits - Bitmask controlling how a pipeline is created

C Specification
Possible values of the flags member of VkGraphicsPipelineCreateInfo, VkComputePipelineCreateInfo, and VkRayTracingPipelineCreateInfoNV, specifying how a pipeline is created, are:

typedef enum VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x00000001,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x00000002,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x00000004,
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x00000008,
    VK_PIPELINE_CREATE_DISPATCH_BASE = 0x00000010,
    VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x00000020,
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
    VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE,
    VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineCreateFlagBits;
Description
VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT specifies that the created pipeline will not be optimized. Using this flag may reduce the time taken to create the pipeline.
VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT specifies that the pipeline to be created is allowed to be the parent of a pipeline that will be created in a subsequent call to vkCreateGraphicsPipelines or vkCreateComputePipelines.
VK_PIPELINE_CREATE_DERIVATIVE_BIT specifies that the pipeline to be created will be a child of a previously created parent pipeline.
VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT specifies that any shader input variables decorated as ViewIndex will be assigned values as if they were decorated as DeviceIndex.
VK_PIPELINE_CREATE_DISPATCH_BASE specifies that a compute pipeline can be used with vkCmdDispatchBase with a non-zero base workgroup.
VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV specifies that a pipeline is created with all shaders in the deferred state. Before using the pipeline the application must call vkCompileDeferredNV exactly once on each shader in the pipeline before using the pipeline.
It is valid to set both VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT and VK_PIPELINE_CREATE_DERIVATIVE_BIT. This allows a pipeline to be both a parent and possibly a child in a pipeline hierarchy. See Pipeline Derivatives for more information.

See Also
VkPipelineCreateFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCreateFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCreationFeedbackFlagBitsEXT(3)
Name
VkPipelineCreationFeedbackFlagBitsEXT - Bitmask specifying pipeline or pipeline stage creation feedback

C Specification
Possible values of the flags member of VkPipelineCreationFeedbackEXT are:

typedef enum VkPipelineCreationFeedbackFlagBitsEXT {
    VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = 0x00000001,
    VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = 0x00000002,
    VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = 0x00000004,
    VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkPipelineCreationFeedbackFlagBitsEXT;
Description
VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT indicates that the feedback information is valid.
VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT indicates that a readily usable pipeline or pipeline stage was found in the pipelineCache specified by the application in the pipeline creation command.
An implementation should set the VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT bit if it was able to avoid the large majority of pipeline or pipeline stage creation work by using the pipelineCache parameter of vkCreateGraphicsPipelines, vkCreateRayTracingPipelinesNV, or vkCreateComputePipelines. When an implementation sets this bit for the entire pipeline, it may leave it unset for any stage.
Note
Implementations are encouraged to provide a meaningful signal to applications using this bit. The intention is to communicate to the application that the pipeline or pipeline stage was created "as fast as it gets" using the pipeline cache provided by the application. If an implementation uses an internal cache, it is discouraged from setting this bit as the feedback would be unactionable.
VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT indicates that the base pipeline specified by the basePipelineHandle or basePipelineIndex member of the Vk*PipelineCreateInfo structure was used to accelerate the creation of the pipeline.
An implementation should set the VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT bit if it was able to avoid a significant amount of work by using the base pipeline.
Note
While "significant amount of work" is subjective, implementations are encouraged to provide a meaningful signal to applications using this bit. For example, a 1% reduction in duration may not warrant setting this bit, while a 50% reduction would.
See Also
VkPipelineCreationFeedbackCreateInfoEXT, VkPipelineCreationFeedbackEXT, VkPipelineCreationFeedbackFlagsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCreationFeedbackFlagBitsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineStageFlagBits(3)
Name
VkPipelineStageFlagBits - Bitmask specifying pipeline stages

C Specification
Several of the synchronization commands include pipeline stage parameters, restricting the synchronization scopes for that command to just those stages. This allows fine grained control over the exact execution dependencies and accesses performed by action commands. Implementations should use these pipeline stages to avoid unnecessary stalls or cache flushing.

Bits which can be set, specifying pipeline stages, are:

typedef enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000,
    VK_PIPELINE_STAGE_HOST_BIT = 0x00004000,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000,
    VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000,
    VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000,
    VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX = 0x00020000,
    VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = 0x00400000,
    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = 0x00200000,
    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 0x02000000,
    VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = 0x00080000,
    VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = 0x00100000,
    VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000,
    VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkPipelineStageFlagBits;
Description
VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT specifies the stage of the pipeline where any commands are initially received by the queue.
VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT specifies the stage of the pipeline where Draw/DispatchIndirect data structures are consumed. This stage also includes reading commands written by vkCmdProcessCommandsNVX.
VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV specifies the task shader stage.
VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV specifies the mesh shader stage.
VK_PIPELINE_STAGE_VERTEX_INPUT_BIT specifies the stage of the pipeline where vertex and index buffers are consumed.
VK_PIPELINE_STAGE_VERTEX_SHADER_BIT specifies the vertex shader stage.
VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT specifies the tessellation control shader stage.
VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT specifies the tessellation evaluation shader stage.
VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT specifies the geometry shader stage.
VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT specifies the fragment shader stage.
VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT specifies the stage of the pipeline where early fragment tests (depth and stencil tests before fragment shading) are performed. This stage also includes subpass load operations for framebuffer attachments with a depth/stencil format.
VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT specifies the stage of the pipeline where late fragment tests (depth and stencil tests after fragment shading) are performed. This stage also includes subpass store operations for framebuffer attachments with a depth/stencil format.
VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT specifies the stage of the pipeline after blending where the final color values are output from the pipeline. This stage also includes subpass load and store operations and multisample resolve operations for framebuffer attachments with a color or depth/stencil format.
VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT specifies the execution of a compute shader.
VK_PIPELINE_STAGE_TRANSFER_BIT specifies the execution of copy commands. This includes the operations resulting from all copy commands, clear commands (with the exception of vkCmdClearAttachments), and vkCmdCopyQueryPoolResults.
VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT specifies the final stage in the pipeline where operations generated by all commands complete execution.
VK_PIPELINE_STAGE_HOST_BIT specifies a pseudo-stage indicating execution on the host of reads/writes of device memory. This stage is not invoked by any commands recorded in a command buffer.
VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV specifies the execution of the ray tracing shader stages.
VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV specifies the execution of vkCmdBuildAccelerationStructureNV, vkCmdCopyAccelerationStructureNV, and vkCmdWriteAccelerationStructuresPropertiesNV.
VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT specifies the execution of all graphics pipeline stages, and is equivalent to the logical OR of:
VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT
VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT
VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV
VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV
VK_PIPELINE_STAGE_VERTEX_INPUT_BIT
VK_PIPELINE_STAGE_VERTEX_SHADER_BIT
VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT
VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT
VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT
VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT
VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT
VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT
VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT
VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT
VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT
VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV
VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT
VK_PIPELINE_STAGE_ALL_COMMANDS_BIT is equivalent to the logical OR of every other pipeline stage flag that is supported on the queue it is used with.
VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT specifies the stage of the pipeline where the predicate of conditional rendering is consumed.
VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT specifies the stage of the pipeline where vertex attribute output values are written to the transform feedback buffers.
VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX specifies the stage of the pipeline where device-side generation of commands via vkCmdProcessCommandsNVX is handled.
VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV specifies the stage of the pipeline where the shading rate image is read to determine the shading rate for portions of a rasterized primitive.
VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT specifies the stage of the pipeline where the fragment density map is read to generate the fragment areas.
Note
An execution dependency with only VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT in the destination stage mask will only prevent that stage from executing in subsequently submitted commands. As this stage does not perform any actual execution, this is not observable - in effect, it does not delay processing of subsequent commands. Similarly an execution dependency with only VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT in the source stage mask will effectively not wait for any prior commands to complete.

When defining a memory dependency, using only VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT or VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT would never make any accesses available and/or visible because these stages do not access memory.

VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT and VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT are useful for accomplishing layout transitions and queue ownership operations when the required execution dependency is satisfied by other means - for example, semaphore operations between queues.
See Also
VkCheckpointDataNV, VkPipelineStageFlags, vkCmdWriteBufferMarkerAMD, vkCmdWriteTimestamp

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineStageFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPointClippingBehavior(3)
Name
VkPointClippingBehavior - Enum specifying the point clipping behavior

C Specification
Possible values of VkPhysicalDevicePointClippingProperties::pointClippingBehavior, specifying clipping behavior of a point primitive whose vertex lies outside the clip volume, are:

typedef enum VkPointClippingBehavior {
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM = 0x7FFFFFFF
} VkPointClippingBehavior;
or the equivalent

typedef VkPointClippingBehavior VkPointClippingBehaviorKHR;
Description
VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES specifies that the primitive is discarded if the vertex lies outside any clip plane, including the planes bounding the view volume.
VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY specifies that the primitive is discarded only if the vertex lies outside any user clip plane.
See Also
VkPhysicalDevicePointClippingProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPointClippingBehavior

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPolygonMode(3)
Name
VkPolygonMode - Control polygon rasterization mode

C Specification
Possible values of the VkPipelineRasterizationStateCreateInfo::polygonMode property of the currently active pipeline, specifying the method of rasterization for polygons, are:

typedef enum VkPolygonMode {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
    VK_POLYGON_MODE_MAX_ENUM = 0x7FFFFFFF
} VkPolygonMode;
Description
VK_POLYGON_MODE_POINT specifies that polygon vertices are drawn as points.
VK_POLYGON_MODE_LINE specifies that polygon edges are drawn as line segments.
VK_POLYGON_MODE_FILL specifies that polygons are rendered using the polygon rasterization rules in this section.
VK_POLYGON_MODE_FILL_RECTANGLE_NV specifies that polygons are rendered using polygon rasterization rules, modified to consider a sample within the primitive if the sample location is inside the axis-aligned bounding box of the triangle after projection. Note that the barycentric weights used in attribute interpolation can extend outside the range [0,1] when these primitives are shaded. Special treatment is given to a sample position on the boundary edge of the bounding box. In such a case, if two rectangles lie on either side of a common edge (with identical endpoints) on which a sample position lies, then exactly one of the triangles must produce a fragment that covers that sample during rasterization.
Polygons rendered in VK_POLYGON_MODE_FILL_RECTANGLE_NV mode may be clipped by the frustum or by user clip planes. If clipping is applied, the triangle is culled rather than clipped.
Area calculation and facingness are determined for VK_POLYGON_MODE_FILL_RECTANGLE_NV mode using the triangle’s vertices.
These modes affect only the final rasterization of polygons: in particular, a polygon’s vertices are shaded and the polygon is clipped and possibly culled before these modes are applied.

See Also
VkPipelineRasterizationStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPolygonMode

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPresentModeKHR(3)
Name
VkPresentModeKHR - presentation mode supported for a surface

C Specification
Possible values of elements of the vkGetPhysicalDeviceSurfacePresentModesKHR::pPresentModes array, indicating the supported presentation modes for a surface, are:

typedef enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
    VK_PRESENT_MODE_MAX_ENUM_KHR = 0x7FFFFFFF
} VkPresentModeKHR;
Description
VK_PRESENT_MODE_IMMEDIATE_KHR specifies that the presentation engine does not wait for a vertical blanking period to update the current image, meaning this mode may result in visible tearing. No internal queuing of presentation requests is needed, as the requests are applied immediately.
VK_PRESENT_MODE_MAILBOX_KHR specifies that the presentation engine waits for the next vertical blanking period to update the current image. Tearing cannot be observed. An internal single-entry queue is used to hold pending presentation requests. If the queue is full when a new presentation request is received, the new request replaces the existing entry, and any images associated with the prior entry become available for re-use by the application. One request is removed from the queue and processed during each vertical blanking period in which the queue is non-empty.
VK_PRESENT_MODE_FIFO_KHR specifies that the presentation engine waits for the next vertical blanking period to update the current image. Tearing cannot be observed. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during each vertical blanking period in which the queue is non-empty. This is the only value of presentMode that is required to be supported.
VK_PRESENT_MODE_FIFO_RELAXED_KHR specifies that the presentation engine generally waits for the next vertical blanking period to update the current image. If a vertical blanking period has already passed since the last update of the current image then the presentation engine does not wait for another vertical blanking period for the update, meaning this mode may result in visible tearing in this case. This mode is useful for reducing visual stutter with an application that will mostly present a new image before the next vertical blanking period, but may occasionally be late, and present a new image just after the next vertical blanking period. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during or after each vertical blanking period in which the queue is non-empty.
VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR specifies that the presentation engine and application have concurrent access to a single image, which is referred to as a shared presentable image. The presentation engine is only required to update the current image after a new presentation request is received. Therefore the application must make a presentation request whenever an update is required. However, the presentation engine may update the current image at any point, meaning this mode may result in visible tearing.
VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR specifies that the presentation engine and application have concurrent access to a single image, which is referred to as a shared presentable image. The presentation engine periodically updates the current image on its regular refresh cycle. The application is only required to make one initial presentation request, after which the presentation engine must update the current image without any need for further presentation requests. The application can indicate the image contents have been updated by making a presentation request, but this does not guarantee the timing of when it will be updated. This mode may result in visible tearing if rendering to the image is not timed correctly.
The supported VkImageUsageFlagBits of the presentable images of a swapchain created for a surface may differ depending on the presentation mode, and can be determined as per the table below:

Table 25. Presentable image usage queries
Presentation mode	Image usage flags
VK_PRESENT_MODE_IMMEDIATE_KHR
VkSurfaceCapabilitiesKHR::supportedUsageFlags
VK_PRESENT_MODE_MAILBOX_KHR
VkSurfaceCapabilitiesKHR::supportedUsageFlags
VK_PRESENT_MODE_FIFO_KHR
VkSurfaceCapabilitiesKHR::supportedUsageFlags
VK_PRESENT_MODE_FIFO_RELAXED_KHR
VkSurfaceCapabilitiesKHR::supportedUsageFlags
VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR
VkSharedPresentSurfaceCapabilitiesKHR::sharedPresentSupportedUsageFlags
VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR
VkSharedPresentSurfaceCapabilitiesKHR::sharedPresentSupportedUsageFlags
Note
For reference, the mode indicated by VK_PRESENT_MODE_FIFO_KHR is equivalent to the behavior of {wgl|glX|egl}SwapBuffers with a swap interval of 1, while the mode indicated by VK_PRESENT_MODE_FIFO_RELAXED_KHR is equivalent to the behavior of {wgl|glX}SwapBuffers with a swap interval of -1 (from the {WGL|GLX}_EXT_swap_control_tear extensions).
See Also
VkSwapchainCreateInfoKHR, vkGetPhysicalDeviceSurfacePresentModes2EXT, vkGetPhysicalDeviceSurfacePresentModesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPresentModeKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPrimitiveTopology(3)
Name
VkPrimitiveTopology - Supported primitive topologies

C Specification
The primitive topologies defined by VkPrimitiveTopology are:

typedef enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 0x7FFFFFFF
} VkPrimitiveTopology;
Description
VK_PRIMITIVE_TOPOLOGY_POINT_LIST specifies a series of separate point primitives.
VK_PRIMITIVE_TOPOLOGY_LINE_LIST specifies a series of separate line primitives.
VK_PRIMITIVE_TOPOLOGY_LINE_STRIP specifies a series of connected line primitives with consecutive lines sharing a vertex.
VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST specifies a series of separate triangle primitives.
VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP specifies a series of connected triangle primitives with consecutive triangles sharing an edge.
VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN specifies a series of connected triangle primitives with all triangles sharing a common vertex.
VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY specifies a series separate line primitives with adjacency.
VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY specifies a series connected line primitives with adjacency, with consecutive primitives sharing three vertices.
VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY specifies a series separate triangle primitives with adjacency.
VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY specifies connected triangle primitives with adjacency, with consecutive triangles sharing an edge.
VK_PRIMITIVE_TOPOLOGY_PATCH_LIST specifies separate patch primitives.
Each primitive topology, and its construction from a list of vertices, is described in detail below with a supporting diagram, according to the following key:

primitive topology key vertex
Vertex
A point in 3-dimensional space. Positions chosen within the diagrams are arbitrary and for illustration only.
primitive topology key vertex number
Vertex Number
Sequence position of a vertex within the provided vertex data.
primitive topology key provoking vertex
Provoking Vertex
Provoking vertex within the main primitive. The arrow points along an edge of the relevant primitive, following winding order. Used in flat shading.
primitive topology key edge
Primitive Edge
An edge connecting the points of a main primitive.
primitive topology key adjacency edge
Adjacency Edge
Points connected by these lines do not contribute to a main primitive, and are only accessible in a geometry shader.
primitive topology key winding order
Winding Order
The relative order in which vertices are defined within a primitive, used in the facing determination. This ordering has no specific start or end point.
The diagrams are supported with mathematical definitions where the vertices and primitives are numbered starting from 0; vertex0 is the first vertex in the provided data and primitive0 is the first primitive in the set of primitives defined by the vertices and topology.

See Also
VkPipelineInputAssemblyStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPrimitiveTopology

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueryControlFlagBits(3)
Name
VkQueryControlFlagBits - Bitmask specifying constraints on a query

C Specification
Bits which can be set in vkCmdBeginQuery::flags, specifying constraints on the types of queries that can be performed, are:

typedef enum VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT = 0x00000001,
    VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryControlFlagBits;
Description
VK_QUERY_CONTROL_PRECISE_BIT specifies the precision of occlusion queries.
See Also
VkQueryControlFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueryControlFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueryPipelineStatisticFlagBits(3)
Name
VkQueryPipelineStatisticFlagBits - Bitmask specifying queried pipeline statistics

C Specification
Bits which can be set to individually enable pipeline statistics counters for query pools with VkQueryPoolCreateInfo::pipelineStatistics, and for secondary command buffers with VkCommandBufferInheritanceInfo::pipelineStatistics, are:

typedef enum VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x00000001,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x00000002,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x00000004,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x00000008,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x00000010,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x00000020,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x00000040,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x00000080,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x00000100,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x00000200,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x00000400,
    VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryPipelineStatisticFlagBits;
Description
VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT specifies that queries managed by the pool will count the number of vertices processed by the input assembly stage. Vertices corresponding to incomplete primitives may contribute to the count.
VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT specifies that queries managed by the pool will count the number of primitives processed by the input assembly stage. If primitive restart is enabled, restarting the primitive topology has no effect on the count. Incomplete primitives may be counted.
VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of vertex shader invocations. This counter’s value is incremented each time a vertex shader is invoked.
VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of geometry shader invocations. This counter’s value is incremented each time a geometry shader is invoked. In the case of instanced geometry shaders, the geometry shader invocations count is incremented for each separate instanced invocation.
VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT specifies that queries managed by the pool will count the number of primitives generated by geometry shader invocations. The counter’s value is incremented each time the geometry shader emits a primitive. Restarting primitive topology using the SPIR-V instructions OpEndPrimitive or OpEndStreamPrimitive has no effect on the geometry shader output primitives count.
VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of primitives processed by the Primitive Clipping stage of the pipeline. The counter’s value is incremented each time a primitive reaches the primitive clipping stage.
VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT specifies that queries managed by the pool will count the number of primitives output by the Primitive Clipping stage of the pipeline. The counter’s value is incremented each time a primitive passes the primitive clipping stage. The actual number of primitives output by the primitive clipping stage for a particular input primitive is implementation-dependent but must satisfy the following conditions:
If at least one vertex of the input primitive lies inside the clipping volume, the counter is incremented by one or more.
Otherwise, the counter is incremented by zero or more.
VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of fragment shader invocations. The counter’s value is incremented each time the fragment shader is invoked.
VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT specifies that queries managed by the pool will count the number of patches processed by the tessellation control shader. The counter’s value is incremented once for each patch for which a tessellation control shader is invoked.
VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of invocations of the tessellation evaluation shader. The counter’s value is incremented each time the tessellation evaluation shader is invoked.
VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT specifies that queries managed by the pool will count the number of compute shader invocations. The counter’s value is incremented every time the compute shader is invoked. Implementations may skip the execution of certain compute shader invocations or execute additional compute shader invocations for implementation-dependent reasons as long as the results of rendering otherwise remain unchanged.
These values are intended to measure relative statistics on one implementation. Various device architectures will count these values differently. Any or all counters may be affected by the issues described in Query Operation.

Note
For example, tile-based rendering devices may need to replay the scene multiple times, affecting some of the counts.
If a pipeline has rasterizerDiscardEnable enabled, implementations may discard primitives after the final vertex processing stage. As a result, if rasterizerDiscardEnable is enabled, the clipping input and output primitives counters may not be incremented.

When a pipeline statistics query finishes, the result for that query is marked as available. The application can copy the result to a buffer (via vkCmdCopyQueryPoolResults), or request it be put into host memory (via vkGetQueryPoolResults).

See Also
VkQueryPipelineStatisticFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueryPipelineStatisticFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueryResultFlagBits(3)
Name
VkQueryResultFlagBits - Bitmask specifying how and when query results are returned

C Specification
Bits which can be set in vkGetQueryPoolResults::flags and vkCmdCopyQueryPoolResults::flags, specifying how and when results are returned, are:

typedef enum VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT = 0x00000001,
    VK_QUERY_RESULT_WAIT_BIT = 0x00000002,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x00000004,
    VK_QUERY_RESULT_PARTIAL_BIT = 0x00000008,
    VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueryResultFlagBits;
Description
VK_QUERY_RESULT_64_BIT specifies the results will be written as an array of 64-bit unsigned integer values. If this bit is not set, the results will be written as an array of 32-bit unsigned integer values.
VK_QUERY_RESULT_WAIT_BIT specifies that Vulkan will wait for each query’s status to become available before retrieving its results.
VK_QUERY_RESULT_WITH_AVAILABILITY_BIT specifies that the availability status accompanies the results.
VK_QUERY_RESULT_PARTIAL_BIT specifies that returning partial results is acceptable.
See Also
VkQueryResultFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueryResultFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueryType(3)
Name
VkQueryType - Specify the type of queries managed by a query pool

C Specification
Possible values of VkQueryPoolCreateInfo::queryType, specifying the type of queries managed by the pool, are:

typedef enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
    VK_QUERY_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkQueryType;
Description
VK_QUERY_TYPE_OCCLUSION specifies an occlusion query.
VK_QUERY_TYPE_PIPELINE_STATISTICS specifies a pipeline statistics query.
VK_QUERY_TYPE_TIMESTAMP specifies a timestamp query.
VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT specifies a transform feedback query.
See Also
VkQueryPoolCreateInfo, vkCmdWriteAccelerationStructuresPropertiesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueryType

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueueFlagBits(3)
Name
VkQueueFlagBits - Bitmask specifying capabilities of queues in a queue family

C Specification
Bits which may be set in VkQueueFamilyProperties::queueFlags indicating capabilities of queues in a queue family are:

typedef enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
    VK_QUEUE_COMPUTE_BIT = 0x00000002,
    VK_QUEUE_TRANSFER_BIT = 0x00000004,
    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
    VK_QUEUE_PROTECTED_BIT = 0x00000010,
    VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueueFlagBits;
Description
VK_QUEUE_GRAPHICS_BIT specifies that queues in this queue family support graphics operations.
VK_QUEUE_COMPUTE_BIT specifies that queues in this queue family support compute operations.
VK_QUEUE_TRANSFER_BIT specifies that queues in this queue family support transfer operations.
VK_QUEUE_SPARSE_BINDING_BIT specifies that queues in this queue family support sparse memory management operations (see Sparse Resources). If any of the sparse resource features are enabled, then at least one queue family must support this bit.
if VK_QUEUE_PROTECTED_BIT is set, then the queues in this queue family support the VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT bit. (see Protected Memory). If the protected memory physical device feature is supported, then at least one queue family of at least one physical device exposed by the implementation must support this bit.
If an implementation exposes any queue family that supports graphics operations, at least one queue family of at least one physical device exposed by the implementation must support both graphics and compute operations.

Furthermore, if the protected memory physical device feature is supported, then at least one queue family of at least one physical device exposed by the implementation must support graphics operations, compute operations, and protected memory operations.

Note
All commands that are allowed on a queue that supports transfer operations are also allowed on a queue that supports either graphics or compute operations. Thus, if the capabilities of a queue family include VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT, then reporting the VK_QUEUE_TRANSFER_BIT capability separately for that queue family is optional.
For further details see Queues.

See Also
VkQueueFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueueFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueueGlobalPriorityEXT(3)
Name
VkQueueGlobalPriorityEXT - Values specifying a system-wide queue priority

C Specification
Possible values of VkDeviceQueueGlobalPriorityCreateInfoEXT::globalPriority, specifying a system-wide priority level are:

typedef enum VkQueueGlobalPriorityEXT {
    VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = 128,
    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = 256,
    VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = 512,
    VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = 1024,
    VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT = 0x7FFFFFFF
} VkQueueGlobalPriorityEXT;
Description
Priority values are sorted in ascending order. A comparison operation on the enum values can be used to determine the priority order.

VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT is below the system default. Useful for non-interactive tasks.
VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT is the system default priority.
VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT is above the system default.
VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT is the highest priority. Useful for critical tasks.
See Also
VkDeviceQueueGlobalPriorityCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueueGlobalPriorityEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRasterizationOrderAMD(3)
Name
VkRasterizationOrderAMD - Specify rasterization order for a graphics pipeline

C Specification
Possible values of VkPipelineRasterizationStateRasterizationOrderAMD::rasterizationOrder, specifying the primitive rasterization order, are:

typedef enum VkRasterizationOrderAMD {
    VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
    VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
    VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 0x7FFFFFFF
} VkRasterizationOrderAMD;
Description
VK_RASTERIZATION_ORDER_STRICT_AMD specifies that operations for each primitive in a subpass must occur in primitive order.
VK_RASTERIZATION_ORDER_RELAXED_AMD specifies that operations for each primitive in a subpass may not occur in primitive order.
See Also
VkPipelineRasterizationStateRasterizationOrderAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRasterizationOrderAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRayTracingShaderGroupTypeNV(3)
Name
VkRayTracingShaderGroupTypeNV - Shader group types

C Specification
Possible values of type in VkRayTracingShaderGroupCreateInfoNV are:

typedef enum VkRayTracingShaderGroupTypeNV {
    VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV = 0,
    VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV = 1,
    VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV = 2,
    VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_NV = 0x7FFFFFFF
} VkRayTracingShaderGroupTypeNV;
Description
VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV indicates a shader group with a single VK_SHADER_STAGE_RAYGEN_BIT_NV, VK_SHADER_STAGE_MISS_BIT_NV, or VK_SHADER_STAGE_CALLABLE_BIT_NV shader in it.
VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV specifies a shader group that only hits triangles and must not contain an intersection shader, only closest hit and any-hit.
VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV specifies a shader group that only intersects with custom geometry and must contain an intersection shader and may contain closest hit and any-hit shaders.
Note
For current group types, the hit group type could be inferred from the presence or absence of the intersection shader, but we provide the type explicitly for future hit groups that do not have that property.
See Also
VkRayTracingShaderGroupCreateInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRayTracingShaderGroupTypeNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkResolveModeFlagBitsKHR(3)
Name
VkResolveModeFlagBitsKHR - Bitmask indicating supported depth and stencil resolve modes

C Specification
Possible values of VkSubpassDescriptionDepthStencilResolveKHR::depthResolveMode and stencilResolveMode, specifying the depth and stencil resolve modes, are:

typedef enum VkResolveModeFlagBitsKHR {
    VK_RESOLVE_MODE_NONE_KHR = 0,
    VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR = 0x00000001,
    VK_RESOLVE_MODE_AVERAGE_BIT_KHR = 0x00000002,
    VK_RESOLVE_MODE_MIN_BIT_KHR = 0x00000004,
    VK_RESOLVE_MODE_MAX_BIT_KHR = 0x00000008,
    VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkResolveModeFlagBitsKHR;
Description
VK_RESOLVE_MODE_NONE_KHR indicates that no resolve operation is done.
VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR indicates that result of the resolve operation is equal to the value of sample 0.
VK_RESOLVE_MODE_AVERAGE_BIT_KHR indicates that result of the resolve operation is the average of the sample values.
VK_RESOLVE_MODE_MIN_BIT_KHR indicates that result of the resolve operation is the minimum of the sample values.
VK_RESOLVE_MODE_MAX_BIT_KHR indicates that result of the resolve operation is the maximum of the sample values.
See Also
VkResolveModeFlagsKHR, VkSubpassDescriptionDepthStencilResolveKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkResolveModeFlagBitsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkResult(3)
Name
VkResult - Vulkan command return codes

C Specification
While the core Vulkan API is not designed to capture incorrect usage, some circumstances still require return codes. Commands in Vulkan return their status via return codes that are in one of two categories:

Successful completion codes are returned when a command needs to communicate success or status information. All successful completion codes are non-negative values.
Run time error codes are returned when a command needs to communicate a failure that could only be detected at run time. All run time error codes are negative values.
All return codes in Vulkan are reported via VkResult return values. The possible codes are:

typedef enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
    VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
    VK_ERROR_FRAGMENTATION_EXT = -1000161000,
    VK_ERROR_NOT_PERMITTED_EXT = -1000174001,
    VK_ERROR_INVALID_DEVICE_ADDRESS_EXT = -1000244000,
    VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
    VK_ERROR_OUT_OF_POOL_MEMORY_KHR = VK_ERROR_OUT_OF_POOL_MEMORY,
    VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = VK_ERROR_INVALID_EXTERNAL_HANDLE,
    VK_RESULT_MAX_ENUM = 0x7FFFFFFF
} VkResult;
Description
Success Codes
VK_SUCCESS Command successfully completed
VK_NOT_READY A fence or query has not yet completed
VK_TIMEOUT A wait operation has not completed in the specified time
VK_EVENT_SET An event is signaled
VK_EVENT_RESET An event is unsignaled
VK_INCOMPLETE A return array was too small for the result
VK_SUBOPTIMAL_KHR A swapchain no longer matches the surface properties exactly, but can still be used to present to the surface successfully.
Error codes
VK_ERROR_OUT_OF_HOST_MEMORY A host memory allocation has failed.
VK_ERROR_OUT_OF_DEVICE_MEMORY A device memory allocation has failed.
VK_ERROR_INITIALIZATION_FAILED Initialization of an object could not be completed for implementation-specific reasons.
VK_ERROR_DEVICE_LOST The logical or physical device has been lost. See Lost Device
VK_ERROR_MEMORY_MAP_FAILED Mapping of a memory object has failed.
VK_ERROR_LAYER_NOT_PRESENT A requested layer is not present or could not be loaded.
VK_ERROR_EXTENSION_NOT_PRESENT A requested extension is not supported.
VK_ERROR_FEATURE_NOT_PRESENT A requested feature is not supported.
VK_ERROR_INCOMPATIBLE_DRIVER The requested version of Vulkan is not supported by the driver or is otherwise incompatible for implementation-specific reasons.
VK_ERROR_TOO_MANY_OBJECTS Too many objects of the type have already been created.
VK_ERROR_FORMAT_NOT_SUPPORTED A requested format is not supported on this device.
VK_ERROR_FRAGMENTED_POOL A pool allocation has failed due to fragmentation of the pool’s memory. This must only be returned if no attempt to allocate host or device memory was made to accommodate the new allocation. This should be returned in preference to VK_ERROR_OUT_OF_POOL_MEMORY, but only if the implementation is certain that the pool allocation failure was due to fragmentation.
VK_ERROR_SURFACE_LOST_KHR A surface is no longer available.
VK_ERROR_NATIVE_WINDOW_IN_USE_KHR The requested window is already in use by Vulkan or another API in a manner which prevents it from being used again.
VK_ERROR_OUT_OF_DATE_KHR A surface has changed in such a way that it is no longer compatible with the swapchain, and further presentation requests using the swapchain will fail. Applications must query the new surface properties and recreate their swapchain if they wish to continue presenting to the surface.
VK_ERROR_INCOMPATIBLE_DISPLAY_KHR The display used by a swapchain does not use the same presentable image layout, or is incompatible in a way that prevents sharing an image.
VK_ERROR_INVALID_SHADER_NV One or more shaders failed to compile or link. More details are reported back to the application via html/vkspec.html#VK_EXT_debug_report if enabled.
VK_ERROR_OUT_OF_POOL_MEMORY A pool memory allocation has failed. This must only be returned if no attempt to allocate host or device memory was made to accommodate the new allocation. If the failure was definitely due to fragmentation of the pool, VK_ERROR_FRAGMENTED_POOL should be returned instead.
VK_ERROR_INVALID_EXTERNAL_HANDLE An external handle is not a valid handle of the specified type.
VK_ERROR_FRAGMENTATION_EXT A descriptor pool creation has failed due to fragmentation.
VK_ERROR_INVALID_DEVICE_ADDRESS_EXT A buffer creation failed because the requested address is not available.
VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT An operation on a swapchain created with VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT failed as it did not have exlusive full-screen access. This may occur due to implementation-dependent reasons, outside of the application’s control.
If a command returns a run time error, unless otherwise specified any output parameters will have undefined contents, except that if the output parameter is a structure with sType and pNext fields, those fields will be unmodified. Any structures chained from pNext will also have undefined contents, except that sType and pNext will be unmodified.

Out of memory errors do not damage any currently existing Vulkan objects. Objects that have already been successfully created can still be used by the application.

Performance-critical commands generally do not have return codes. If a run time error occurs in such commands, the implementation will defer reporting the error until a specified point. For commands that record into command buffers (vkCmd*) run time errors are reported by vkEndCommandBuffer.

See Also
VkPresentInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkResult

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSampleCountFlagBits(3)
Name
VkSampleCountFlagBits - Bitmask specifying sample counts supported for an image used for storage operations

C Specification
Bits which may be set in the sample count limits returned by VkPhysicalDeviceLimits, as well as in other queries and structures representing image sample counts, are:

typedef enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 0x00000001,
    VK_SAMPLE_COUNT_2_BIT = 0x00000002,
    VK_SAMPLE_COUNT_4_BIT = 0x00000004,
    VK_SAMPLE_COUNT_8_BIT = 0x00000008,
    VK_SAMPLE_COUNT_16_BIT = 0x00000010,
    VK_SAMPLE_COUNT_32_BIT = 0x00000020,
    VK_SAMPLE_COUNT_64_BIT = 0x00000040,
    VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSampleCountFlagBits;
Description
VK_SAMPLE_COUNT_1_BIT specifies an image with one sample per pixel.
VK_SAMPLE_COUNT_2_BIT specifies an image with 2 samples per pixel.
VK_SAMPLE_COUNT_4_BIT specifies an image with 4 samples per pixel.
VK_SAMPLE_COUNT_8_BIT specifies an image with 8 samples per pixel.
VK_SAMPLE_COUNT_16_BIT specifies an image with 16 samples per pixel.
VK_SAMPLE_COUNT_32_BIT specifies an image with 32 samples per pixel.
VK_SAMPLE_COUNT_64_BIT specifies an image with 64 samples per pixel.
See Also
VkAttachmentDescription, VkAttachmentDescription2KHR, VkImageCreateInfo, VkPhysicalDeviceSparseImageFormatInfo2, VkPipelineMultisampleStateCreateInfo, VkSampleCountFlags, VkSampleLocationsInfoEXT, vkGetPhysicalDeviceMultisamplePropertiesEXT, vkGetPhysicalDeviceSparseImageFormatProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSampleCountFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSamplerAddressMode(3)
Name
VkSamplerAddressMode - Specify behavior of sampling with texture coordinates outside an image

C Specification
Possible values of the VkSamplerCreateInfo::addressMode* parameters, specifying the behavior of sampling with coordinates outside the range [0,1] for the respective u, v, or w coordinate as defined in the Wrapping Operation section, are:

typedef enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerAddressMode;
Description
VK_SAMPLER_ADDRESS_MODE_REPEAT specifies that the repeat wrap mode will be used.
VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT specifies that the mirrored repeat wrap mode will be used.
VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE specifies that the clamp to edge wrap mode will be used.
VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER specifies that the clamp to border wrap mode will be used.
VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE specifies that the mirror clamp to edge wrap mode will be used. This is only valid if the html/vkspec.html#VK_KHR_sampler_mirror_clamp_to_edge extension is enabled.
See Also
VkSamplerCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerAddressMode

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSamplerCreateFlagBits(3)
Name
VkSamplerCreateFlagBits - Bitmask specifying additional parameters of sampler

C Specification
Bits which can be set in VkSamplerCreateInfo::flags, specifying additional parameters of a sampler, are:

typedef enum VkSamplerCreateFlagBits {
    VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x00000001,
    VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x00000002,
    VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSamplerCreateFlagBits;
Description
VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT specifies that the sampler will read from an image created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT.
VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT specifies that the implementation may use approximations when reconstructing a full color value for texture access from a subsampled image.
Note
The approximations used when VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT is specified are implementation defined. Some implementations may interpolate between fragment density levels in a subsampled image. In that case, this bit may be used to decide whether the interpolation factors are calculated per fragment or at a coarser granularity.
See Also
VkSamplerCreateFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerCreateFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSamplerMipmapMode(3)
Name
VkSamplerMipmapMode - Specify mipmap mode used for texture lookups

C Specification
Possible values of the VkSamplerCreateInfo::mipmapMode, specifying the mipmap mode used for texture lookups, are:

typedef enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerMipmapMode;
Description
VK_SAMPLER_MIPMAP_MODE_NEAREST specifies nearest filtering.
VK_SAMPLER_MIPMAP_MODE_LINEAR specifies linear filtering.
These modes are described in detail in Texel Filtering.

See Also
VkSamplerCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerMipmapMode

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSamplerReductionModeEXT(3)
Name
VkSamplerReductionModeEXT - Specify reduction mode for texture filtering

C Specification
Reduction modes are specified by VkSamplerReductionModeEXT, which takes values:

typedef enum VkSamplerReductionModeEXT {
    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = 0,
    VK_SAMPLER_REDUCTION_MODE_MIN_EXT = 1,
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT = 2,
    VK_SAMPLER_REDUCTION_MODE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkSamplerReductionModeEXT;
Description
VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT specifies that texel values are combined by computing a weighted average of values in the footprint, using weights as specified in the image operations chapter.
VK_SAMPLER_REDUCTION_MODE_MIN_EXT specifies that texel values are combined by taking the component-wise minimum of values in the footprint with non-zero weights.
VK_SAMPLER_REDUCTION_MODE_MAX_EXT specifies that texel values are combined by taking the component-wise maximum of values in the footprint with non-zero weights.
See Also
VkSamplerReductionModeCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerReductionModeEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSamplerYcbcrModelConversion(3)
Name
VkSamplerYcbcrModelConversion - Color model component of a color space

C Specification
VkSamplerYcbcrModelConversion defines the conversion from the source color model to the shader color model. Possible values are:

typedef enum VkSamplerYcbcrModelConversion {
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = 0x7FFFFFFF
} VkSamplerYcbcrModelConversion;
or the equivalent

typedef VkSamplerYcbcrModelConversion VkSamplerYcbcrModelConversionKHR;
Description
VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY specifies that the input values to the conversion are unmodified.
VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY specifies no model conversion but the inputs are range expanded as for Y’CBCR.
VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 specifies the color model conversion from Y’CBCR to R’G’B' defined in BT.709 and described in the “BT.709 Y’CBCR conversion” section of the Khronos Data Format Specification.
VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 specifies the color model conversion from Y’CBCR to R’G’B' defined in BT.601 and described in the “BT.601 Y’CBCR conversion” section of the Khronos Data Format Specification.
VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 specifies the color model conversion from Y’CBCR to R’G’B' defined in BT.2020 and described in the “BT.2020 Y’CBCR conversion” section of the Khronos Data Format Specification.
In the VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_* color models, for the input to the sampler Y’CBCR range expansion and model conversion:

the Y (Y' luma) channel corresponds to the G channel of an RGB image.
the CB (CB or “U” blue color difference) channel corresponds to the B channel of an RGB image.
the CR (CR or “V” red color difference) channel corresponds to the R channel of an RGB image.
the alpha channel, if present, is not modified by color model conversion.
These rules reflect the mapping of channels after the channel swizzle operation (controlled by VkSamplerYcbcrConversionCreateInfo::components).

Note
For example, an “YUVA” 32-bit format comprising four 8-bit channels can be implemented as VK_FORMAT_R8G8B8A8_UNORM with a component mapping:

components.a = VK_COMPONENT_SWIZZLE_IDENTITY
components.r = VK_COMPONENT_SWIZZLE_B
components.g = VK_COMPONENT_SWIZZLE_R
components.b = VK_COMPONENT_SWIZZLE_G
See Also
VkAndroidHardwareBufferFormatPropertiesANDROID, VkSamplerYcbcrConversionCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerYcbcrModelConversion

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSamplerYcbcrRange(3)
Name
VkSamplerYcbcrRange - Range of encoded values in a color space

C Specification
The VkSamplerYcbcrRange enum describes whether color channels are encoded using the full range of numerical values or whether values are reserved for headroom and foot room. VkSamplerYcbcrRange is defined as:

typedef enum VkSamplerYcbcrRange {
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    VK_SAMPLER_YCBCR_RANGE_MAX_ENUM = 0x7FFFFFFF
} VkSamplerYcbcrRange;
or the equivalent

typedef VkSamplerYcbcrRange VkSamplerYcbcrRangeKHR;
Description
VK_SAMPLER_YCBCR_RANGE_ITU_FULL specifies that the full range of the encoded values are valid and interpreted according to the ITU “full range” quantization rules.
VK_SAMPLER_YCBCR_RANGE_ITU_NARROW specifies that headroom and foot room are reserved in the numerical range of encoded values, and the remaining values are expanded according to the ITU “narrow range” quantization rules.
The formulae for these conversions is described in the Sampler Y’CBCR Range Expansion section of the Image Operations chapter.

No range modification takes place if ycbcrModel is VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY; the ycbcrRange field of VkSamplerYcbcrConversionCreateInfo is ignored in this case.

See Also
VkAndroidHardwareBufferFormatPropertiesANDROID, VkSamplerYcbcrConversionCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerYcbcrRange

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkScopeNV(3)
Name
VkScopeNV - Specify SPIR-V scope

C Specification
Possible values for VkScopeNV include:

typedef enum VkScopeNV {
    VK_SCOPE_DEVICE_NV = 1,
    VK_SCOPE_WORKGROUP_NV = 2,
    VK_SCOPE_SUBGROUP_NV = 3,
    VK_SCOPE_QUEUE_FAMILY_NV = 5,
    VK_SCOPE_MAX_ENUM_NV = 0x7FFFFFFF
} VkScopeNV;
Description
VK_SCOPE_DEVICE_NV corresponds to SPIR-V Device scope.
VK_SCOPE_WORKGROUP_NV corresponds to SPIR-V Workgroup scope.
VK_SCOPE_SUBGROUP_NV corresponds to SPIR-V Subgroup scope.
VK_SCOPE_QUEUE_FAMILY_NV corresponds to SPIR-V QueueFamilyKHR scope.
All enum values match the corresponding SPIR-V value.

See Also
VkCooperativeMatrixPropertiesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkScopeNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSemaphoreImportFlagBits(3)
Name
VkSemaphoreImportFlagBits - Bitmask specifying additional parameters of semaphore payload import

C Specification
Additional parameters of a semaphore import operation are specified by VkImportSemaphoreWin32HandleInfoKHR::flags or VkImportSemaphoreFdInfoKHR::flags . Bits which can be set include:

typedef enum VkSemaphoreImportFlagBits {
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 0x00000001,
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
    VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSemaphoreImportFlagBits;
or the equivalent

typedef VkSemaphoreImportFlagBits VkSemaphoreImportFlagBitsKHR;
Description
These bits have the following meanings:

VK_SEMAPHORE_IMPORT_TEMPORARY_BIT specifies that the semaphore payload will be imported only temporarily, as described in Importing Semaphore Payloads, regardless of the permanence of handleType.
See Also
VkSemaphoreImportFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSemaphoreImportFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkShaderInfoTypeAMD(3)
Name
VkShaderInfoTypeAMD - Enum specifying which type of shader info to query

C Specification
Possible values of vkGetShaderInfoAMD::infoType, specifying the information being queried from a shader, are:

typedef enum VkShaderInfoTypeAMD {
    VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
    VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
    VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
    VK_SHADER_INFO_TYPE_MAX_ENUM_AMD = 0x7FFFFFFF
} VkShaderInfoTypeAMD;
Description
VK_SHADER_INFO_TYPE_STATISTICS_AMD specifies that device resources used by a shader will be queried.
VK_SHADER_INFO_TYPE_BINARY_AMD specifies that implementation-specific information will be queried.
VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD specifies that human-readable dissassembly of a shader.
See Also
vkGetShaderInfoAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkShaderInfoTypeAMD

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkShaderStageFlagBits(3)
Name
VkShaderStageFlagBits - Bitmask specifying a pipeline stage

C Specification
Commands and structures which need to specify one or more shader stages do so using a bitmask whose bits correspond to stages. Bits which can be set to specify shader stages are:

typedef enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 0x00000001,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004,
    VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008,
    VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010,
    VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020,
    VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
    VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
    VK_SHADER_STAGE_RAYGEN_BIT_NV = 0x00000100,
    VK_SHADER_STAGE_ANY_HIT_BIT_NV = 0x00000200,
    VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = 0x00000400,
    VK_SHADER_STAGE_MISS_BIT_NV = 0x00000800,
    VK_SHADER_STAGE_INTERSECTION_BIT_NV = 0x00001000,
    VK_SHADER_STAGE_CALLABLE_BIT_NV = 0x00002000,
    VK_SHADER_STAGE_TASK_BIT_NV = 0x00000040,
    VK_SHADER_STAGE_MESH_BIT_NV = 0x00000080,
    VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkShaderStageFlagBits;
Description
VK_SHADER_STAGE_VERTEX_BIT specifies the vertex stage.
VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT specifies the tessellation control stage.
VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT specifies the tessellation evaluation stage.
VK_SHADER_STAGE_GEOMETRY_BIT specifies the geometry stage.
VK_SHADER_STAGE_FRAGMENT_BIT specifies the fragment stage.
VK_SHADER_STAGE_COMPUTE_BIT specifies the compute stage.
VK_SHADER_STAGE_TASK_BIT_NV specifies the task stage.
VK_SHADER_STAGE_MESH_BIT_NV specifies the mesh stage.
VK_SHADER_STAGE_ALL_GRAPHICS is a combination of bits used as shorthand to specify all graphics stages defined above (excluding the compute stage).
VK_SHADER_STAGE_ALL is a combination of bits used as shorthand to specify all shader stages supported by the device, including all additional stages which are introduced by extensions.
VK_SHADER_STAGE_RAYGEN_BIT_NV specifies the ray generation stage.
VK_SHADER_STAGE_ANY_HIT_BIT_NV specifies the any-hit stage.
VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV specifies the closest hit stage.
VK_SHADER_STAGE_MISS_BIT_NV specifies the miss stage.
VK_SHADER_STAGE_INTERSECTION_BIT_NV specifies the intersection stage.
VK_SHADER_STAGE_CALLABLE_BIT_NV specifies the callable stage.
Note
VK_SHADER_STAGE_ALL_GRAPHICS only includes the original five graphics stages included in Vulkan 1.0, and not any stages added by extensions. Thus, it may not have the desired effect in all cases.
See Also
VkPipelineShaderStageCreateInfo, VkShaderStageFlags, vkGetShaderInfoAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkShaderStageFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkShadingRatePaletteEntryNV(3)
Name
VkShadingRatePaletteEntryNV - Shading rate image palette entry types

C Specification
The supported shading rate image palette entries are defined by VkShadingRatePaletteEntryNV:

typedef enum VkShadingRatePaletteEntryNV {
    VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0,
    VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1,
    VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2,
    VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3,
    VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10,
    VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11,
    VK_SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV = 0x7FFFFFFF
} VkShadingRatePaletteEntryNV;
Description
The following table indicates the width and height (in pixels) of each fragment generated using the indicated shading rate, as well as the maximum number of fragment shader invocations launched for each fragment. When processing regions of a primitive that have a shading rate of VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV, no fragments will be generated in that region.

Shading Rate	Width	Height	Invocations
VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV
0
0
0
VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV
1
1
16
VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV
1
1
8
VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV
1
1
4
VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV
1
1
2
VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV
1
1
1
VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV
2
1
1
VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV
1
2
1
VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV
2
2
1
VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV
4
2
1
VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV
2
4
1
VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV
4
4
1
See Also
VkCoarseSampleOrderCustomNV, VkShadingRatePaletteNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkShadingRatePaletteEntryNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSharingMode(3)
Name
VkSharingMode - Buffer and image sharing modes

C Specification
Buffer and image objects are created with a sharing mode controlling how they can be accessed from queues. The supported sharing modes are:

typedef enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    VK_SHARING_MODE_MAX_ENUM = 0x7FFFFFFF
} VkSharingMode;
Description
VK_SHARING_MODE_EXCLUSIVE specifies that access to any range or image subresource of the object will be exclusive to a single queue family at a time.
VK_SHARING_MODE_CONCURRENT specifies that concurrent access to any range or image subresource of the object from multiple queue families is supported.
Note
VK_SHARING_MODE_CONCURRENT may result in lower performance access to the buffer or image than VK_SHARING_MODE_EXCLUSIVE.
Ranges of buffers and image subresources of image objects created using VK_SHARING_MODE_EXCLUSIVE must only be accessed by queues in the queue family that has ownership of the resource. Upon creation, such resources are not owned by any queue family; ownership is implicitly acquired upon first use within a queue. Once a resource using VK_SHARING_MODE_EXCLUSIVE is owned by some queue family, the application must perform a queue family ownership transfer to make the memory contents of a range or image subresource accessible to a different queue family.

Note
Images still require a layout transition from VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED before being used on the first queue.
A queue family can take ownership of an image subresource or buffer range of a resource created with VK_SHARING_MODE_EXCLUSIVE, without an ownership transfer, in the same way as for a resource that was just created; however, taking ownership in this way has the effect that the contents of the image subresource or buffer range are undefined.

Ranges of buffers and image subresources of image objects created using VK_SHARING_MODE_CONCURRENT must only be accessed by queues from the queue families specified through the queueFamilyIndexCount and pQueueFamilyIndices members of the corresponding create info structures.

See Also
VkBufferCreateInfo, VkImageCreateInfo, VkPhysicalDeviceImageDrmFormatModifierInfoEXT, VkSwapchainCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSharingMode

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSparseImageFormatFlagBits(3)
Name
VkSparseImageFormatFlagBits - Bitmask specifying additional information about a sparse image resource

C Specification
Bits which may be set in VkSparseImageFormatProperties::flags, specifying additional information about the sparse resource, are:

typedef enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x00000001,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x00000002,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
    VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseImageFormatFlagBits;
Description
VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT specifies that the image uses a single mip tail region for all array layers.
VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT specifies that the first mip level whose dimensions are not integer multiples of the corresponding dimensions of the sparse image block begins the mip tail region.
VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT specifies that the image uses non-standard sparse image block dimensions, and the imageGranularity values do not match the standard sparse image block dimensions for the given format.
See Also
VkSparseImageFormatFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSparseImageFormatFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSparseMemoryBindFlagBits(3)
Name
VkSparseMemoryBindFlagBits - Bitmask specifying usage of a sparse memory binding operation

C Specification
Bits which can be set in VkSparseMemoryBind::flags, specifying usage of a sparse memory binding operation, are:

typedef enum VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x00000001,
    VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSparseMemoryBindFlagBits;
Description
VK_SPARSE_MEMORY_BIND_METADATA_BIT specifies that the memory being bound is only for the metadata aspect.
See Also
VkSparseMemoryBindFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSparseMemoryBindFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkStencilFaceFlagBits(3)
Name
VkStencilFaceFlagBits - Bitmask specifying sets of stencil state for which to update the compare mask

C Specification
Bits which can be set in the vkCmdSetStencilCompareMask::faceMask parameter, and similar parameters of other commands specifying which stencil state to update stencil masks for, are:

typedef enum VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT = 0x00000001,
    VK_STENCIL_FACE_BACK_BIT = 0x00000002,
    VK_STENCIL_FRONT_AND_BACK = 0x00000003,
    VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkStencilFaceFlagBits;
Description
VK_STENCIL_FACE_FRONT_BIT specifies that only the front set of stencil state is updated.
VK_STENCIL_FACE_BACK_BIT specifies that only the back set of stencil state is updated.
VK_STENCIL_FRONT_AND_BACK is the combination of VK_STENCIL_FACE_FRONT_BIT and VK_STENCIL_FACE_BACK_BIT, and specifies that both sets of stencil state are updated.
See Also
VkStencilFaceFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkStencilFaceFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkStencilOp(3)
Name
VkStencilOp - Stencil comparison function

C Specification
Possible values of the failOp, passOp, and depthFailOp members of VkStencilOpState, specifying what happens to the stored stencil value if this or certain subsequent tests fail or pass, are:

typedef enum VkStencilOp {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    VK_STENCIL_OP_MAX_ENUM = 0x7FFFFFFF
} VkStencilOp;
Description
VK_STENCIL_OP_KEEP keeps the current value.
VK_STENCIL_OP_ZERO sets the value to 0.
VK_STENCIL_OP_REPLACE sets the value to reference.
VK_STENCIL_OP_INCREMENT_AND_CLAMP increments the current value and clamps to the maximum representable unsigned value.
VK_STENCIL_OP_DECREMENT_AND_CLAMP decrements the current value and clamps to 0.
VK_STENCIL_OP_INVERT bitwise-inverts the current value.
VK_STENCIL_OP_INCREMENT_AND_WRAP increments the current value and wraps to 0 when the maximum value would have been exceeded.
VK_STENCIL_OP_DECREMENT_AND_WRAP decrements the current value and wraps to the maximum possible value when the value would go below 0.
For purposes of increment and decrement, the stencil bits are considered as an unsigned integer.

If the stencil test fails, the sample’s coverage bit is cleared in the fragment. If there is no stencil framebuffer attachment, stencil modification cannot occur, and it is as if the stencil tests always pass.

If the stencil test passes, the writeMask member of the VkStencilOpState structures controls how the updated stencil value is written to the stencil framebuffer attachment.

The least significant s bits of writeMask, where s is the number of bits in the stencil framebuffer attachment, specify an integer mask. Where a 1 appears in this mask, the corresponding bit in the stencil value in the depth/stencil attachment is written; where a 0 appears, the bit is not written. The writeMask value uses either the front-facing or back-facing state based on the facingness of the fragment. Fragments generated by front-facing primitives use the front mask and fragments generated by back-facing primitives use the back mask.

See Also
VkStencilOpState

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkStencilOp

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkStructureType(3)
Name
VkStructureType - Vulkan structure types (stype)

C Specification
Structure types supported by the Vulkan API include:

typedef enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
    VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
    VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
    VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
    VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
    VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
    VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
    VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = 1000082000,
    VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
    VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX = 1000086000,
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = 1000086001,
    VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX = 1000086002,
    VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = 1000086003,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX = 1000086004,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX = 1000086005,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
    VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
    VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
    VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
    VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
    VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
    VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
    VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = 1000109000,
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = 1000109001,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = 1000109002,
    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = 1000109003,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = 1000109004,
    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = 1000109005,
    VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = 1000109006,
    VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
    VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
    VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
    VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
    VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
    VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
    VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000,
    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003,
    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
    VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
    VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
    VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = 1000147000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
    VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
    VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = 1000161000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = 1000161001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = 1000161002,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = 1000161003,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = 1000161004,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
    VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
    VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
    VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
    VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
    VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
    VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = 1000177000,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
    VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = 1000180000,
    VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
    VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002,
    VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
    VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = 1000196000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = 1000197000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = 1000199000,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = 1000199001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = 1000211000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
    VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
    VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
    VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
    VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
    VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = 1000221000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
    VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
    VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = 1000244001,
    VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = 1000246000,
    VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
    VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
    VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = 1000261000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
    VK_STRUCTURE_TYPE_MAX_ENUM = 0x7FFFFFFF
} VkStructureType;
Description
Each value corresponds to a particular structure with a sType member with a matching name. As a general rule, the name of each VkStructureType value is obtained by taking the name of the structure, stripping the leading Vk, prefixing each capital letter with _, converting the entire resulting string to upper case, and prefixing it with VK_STRUCTURE_TYPE_. For example, structures of type VkImageCreateInfo correspond to a VkStructureType of VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, and thus its sType member must equal that when it is passed to the API.

The values VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO and VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO are reserved for internal use by the loader, and do not have corresponding Vulkan structures in this Specification.

See Also
VkAccelerationStructureCreateInfoNV, VkAccelerationStructureInfoNV, VkAccelerationStructureMemoryRequirementsInfoNV, VkAcquireNextImageInfoKHR, VkAndroidHardwareBufferFormatPropertiesANDROID, VkAndroidHardwareBufferPropertiesANDROID, VkAndroidHardwareBufferUsageANDROID, VkAndroidSurfaceCreateInfoKHR, VkApplicationInfo, VkAttachmentDescription2KHR, VkAttachmentReference2KHR, VkBaseInStructure, VkBaseOutStructure, VkBindAccelerationStructureMemoryInfoNV, VkBindBufferMemoryDeviceGroupInfo, VkBindBufferMemoryInfo, VkBindImageMemoryDeviceGroupInfo, VkBindImageMemoryInfo, VkBindImageMemorySwapchainInfoKHR, VkBindImagePlaneMemoryInfo, VkBindSparseInfo, VkBufferCreateInfo, VkBufferDeviceAddressCreateInfoEXT, VkBufferDeviceAddressInfoEXT, VkBufferMemoryBarrier, VkBufferMemoryRequirementsInfo2, VkBufferViewCreateInfo, VkCalibratedTimestampInfoEXT, VkCheckpointDataNV, VkCmdProcessCommandsInfoNVX, VkCmdReserveSpaceForCommandsInfoNVX, VkCommandBufferAllocateInfo, VkCommandBufferBeginInfo, VkCommandBufferInheritanceConditionalRenderingInfoEXT, VkCommandBufferInheritanceInfo, VkCommandPoolCreateInfo, VkComputePipelineCreateInfo, VkConditionalRenderingBeginInfoEXT, VkCooperativeMatrixPropertiesNV, VkCopyDescriptorSet, VkD3D12FenceSubmitInfoKHR, VkDebugMarkerMarkerInfoEXT, VkDebugMarkerObjectNameInfoEXT, VkDebugMarkerObjectTagInfoEXT, VkDebugReportCallbackCreateInfoEXT, VkDebugUtilsLabelEXT, VkDebugUtilsMessengerCallbackDataEXT, VkDebugUtilsMessengerCreateInfoEXT, VkDebugUtilsObjectNameInfoEXT, VkDebugUtilsObjectTagInfoEXT, VkDedicatedAllocationBufferCreateInfoNV, VkDedicatedAllocationImageCreateInfoNV, VkDedicatedAllocationMemoryAllocateInfoNV, VkDescriptorPoolCreateInfo, VkDescriptorPoolInlineUniformBlockCreateInfoEXT, VkDescriptorSetAllocateInfo, VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, VkDescriptorSetLayoutCreateInfo, VkDescriptorSetLayoutSupport, VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, VkDescriptorSetVariableDescriptorCountLayoutSupportEXT, VkDescriptorUpdateTemplateCreateInfo, VkDeviceCreateInfo, VkDeviceEventInfoEXT, VkDeviceGeneratedCommandsFeaturesNVX, VkDeviceGeneratedCommandsLimitsNVX, VkDeviceGroupBindSparseInfo, VkDeviceGroupCommandBufferBeginInfo, VkDeviceGroupDeviceCreateInfo, VkDeviceGroupPresentCapabilitiesKHR, VkDeviceGroupPresentInfoKHR, VkDeviceGroupRenderPassBeginInfo, VkDeviceGroupSubmitInfo, VkDeviceGroupSwapchainCreateInfoKHR, VkDeviceMemoryOverallocationCreateInfoAMD, VkDeviceQueueCreateInfo, VkDeviceQueueGlobalPriorityCreateInfoEXT, VkDeviceQueueInfo2, VkDisplayEventInfoEXT, VkDisplayModeCreateInfoKHR, VkDisplayModeProperties2KHR, VkDisplayNativeHdrSurfaceCapabilitiesAMD, VkDisplayPlaneCapabilities2KHR, VkDisplayPlaneInfo2KHR, VkDisplayPlaneProperties2KHR, VkDisplayPowerInfoEXT, VkDisplayPresentInfoKHR, VkDisplayProperties2KHR, VkDisplaySurfaceCreateInfoKHR, VkDrmFormatModifierPropertiesListEXT, VkEventCreateInfo, VkExportFenceCreateInfo, VkExportFenceWin32HandleInfoKHR, VkExportMemoryAllocateInfo, VkExportMemoryAllocateInfoNV, VkExportMemoryWin32HandleInfoKHR, VkExportMemoryWin32HandleInfoNV, VkExportSemaphoreCreateInfo, VkExportSemaphoreWin32HandleInfoKHR, VkExternalBufferProperties, VkExternalFenceProperties, VkExternalFormatANDROID, VkExternalImageFormatProperties, VkExternalMemoryBufferCreateInfo, VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfoNV, VkExternalSemaphoreProperties, VkFenceCreateInfo, VkFenceGetFdInfoKHR, VkFenceGetWin32HandleInfoKHR, VkFilterCubicImageViewImageFormatPropertiesEXT, VkFormatProperties2, VkFramebufferCreateInfo, VkGeometryAABBNV, VkGeometryNV, VkGeometryTrianglesNV, VkGraphicsPipelineCreateInfo, VkHdrMetadataEXT, VkIOSSurfaceCreateInfoMVK, VkImageCreateInfo, VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT, VkImageDrmFormatModifierPropertiesEXT, VkImageFormatListCreateInfoKHR, VkImageFormatProperties2, VkImageMemoryBarrier, VkImageMemoryRequirementsInfo2, VkImagePipeSurfaceCreateInfoFUCHSIA, VkImagePlaneMemoryRequirementsInfo, VkImageSparseMemoryRequirementsInfo2, VkImageStencilUsageCreateInfoEXT, VkImageSwapchainCreateInfoKHR, VkImageViewASTCDecodeModeEXT, VkImageViewCreateInfo, VkImageViewHandleInfoNVX, VkImageViewUsageCreateInfo, VkImportAndroidHardwareBufferInfoANDROID, VkImportFenceFdInfoKHR, VkImportFenceWin32HandleInfoKHR, VkImportMemoryFdInfoKHR, VkImportMemoryHostPointerInfoEXT, VkImportMemoryWin32HandleInfoKHR, VkImportMemoryWin32HandleInfoNV, VkImportSemaphoreFdInfoKHR, VkImportSemaphoreWin32HandleInfoKHR, VkIndirectCommandsLayoutCreateInfoNVX, VkInstanceCreateInfo, VkMacOSSurfaceCreateInfoMVK, VkMappedMemoryRange, VkMemoryAllocateFlagsInfo, VkMemoryAllocateInfo, VkMemoryBarrier, VkMemoryDedicatedAllocateInfo, VkMemoryDedicatedRequirements, VkMemoryFdPropertiesKHR, VkMemoryGetAndroidHardwareBufferInfoANDROID, VkMemoryGetFdInfoKHR, VkMemoryGetWin32HandleInfoKHR, VkMemoryHostPointerPropertiesEXT, VkMemoryPriorityAllocateInfoEXT, VkMemoryRequirements2, VkMemoryWin32HandlePropertiesKHR, VkMetalSurfaceCreateInfoEXT, VkMultisamplePropertiesEXT, VkObjectTableCreateInfoNVX, VkPhysicalDevice16BitStorageFeatures, VkPhysicalDevice8BitStorageFeaturesKHR, VkPhysicalDeviceASTCDecodeFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, VkPhysicalDeviceConditionalRenderingFeaturesEXT, VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPhysicalDeviceCooperativeMatrixFeaturesNV, VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkPhysicalDeviceCornerSampledImageFeaturesNV, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, VkPhysicalDeviceDepthClipEnableFeaturesEXT, VkPhysicalDeviceDepthStencilResolvePropertiesKHR, VkPhysicalDeviceDescriptorIndexingFeaturesEXT, VkPhysicalDeviceDescriptorIndexingPropertiesEXT, VkPhysicalDeviceDiscardRectanglePropertiesEXT, VkPhysicalDeviceDriverPropertiesKHR, VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPhysicalDeviceExternalBufferInfo, VkPhysicalDeviceExternalFenceInfo, VkPhysicalDeviceExternalImageFormatInfo, VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceExternalSemaphoreInfo, VkPhysicalDeviceFeatures2, VkPhysicalDeviceFloat16Int8FeaturesKHR, VkPhysicalDeviceFloatControlsPropertiesKHR, VkPhysicalDeviceFragmentDensityMapFeaturesEXT, VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, VkPhysicalDeviceGroupProperties, VkPhysicalDeviceHostQueryResetFeaturesEXT, VkPhysicalDeviceIDProperties, VkPhysicalDeviceImageDrmFormatModifierInfoEXT, VkPhysicalDeviceImageFormatInfo2, VkPhysicalDeviceImageViewImageFormatInfoEXT, VkPhysicalDeviceInlineUniformBlockFeaturesEXT, VkPhysicalDeviceInlineUniformBlockPropertiesEXT, VkPhysicalDeviceMaintenance3Properties, VkPhysicalDeviceMemoryBudgetPropertiesEXT, VkPhysicalDeviceMemoryPriorityFeaturesEXT, VkPhysicalDeviceMemoryProperties2, VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMeshShaderPropertiesNV, VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, VkPhysicalDeviceMultiviewProperties, VkPhysicalDevicePCIBusInfoPropertiesEXT, VkPhysicalDevicePointClippingProperties, VkPhysicalDeviceProperties2, VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceProtectedMemoryProperties, VkPhysicalDevicePushDescriptorPropertiesKHR, VkPhysicalDeviceRayTracingPropertiesNV, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, VkPhysicalDeviceSamplerYcbcrConversionFeatures, VkPhysicalDeviceScalarBlockLayoutFeaturesEXT, VkPhysicalDeviceShaderAtomicInt64FeaturesKHR, VkPhysicalDeviceShaderCorePropertiesAMD, VkPhysicalDeviceShaderDrawParametersFeatures, VkPhysicalDeviceShaderImageFootprintFeaturesNV, VkPhysicalDeviceShadingRateImageFeaturesNV, VkPhysicalDeviceShadingRateImagePropertiesNV, VkPhysicalDeviceSparseImageFormatInfo2, VkPhysicalDeviceSubgroupProperties, VkPhysicalDeviceSurfaceInfo2KHR, VkPhysicalDeviceTransformFeedbackFeaturesEXT, VkPhysicalDeviceTransformFeedbackPropertiesEXT, VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, VkPipelineCacheCreateInfo, VkPipelineColorBlendAdvancedStateCreateInfoEXT, VkPipelineColorBlendStateCreateInfo, VkPipelineCoverageModulationStateCreateInfoNV, VkPipelineCoverageToColorStateCreateInfoNV, VkPipelineCreationFeedbackCreateInfoEXT, VkPipelineDepthStencilStateCreateInfo, VkPipelineDiscardRectangleStateCreateInfoEXT, VkPipelineDynamicStateCreateInfo, VkPipelineInputAssemblyStateCreateInfo, VkPipelineLayoutCreateInfo, VkPipelineMultisampleStateCreateInfo, VkPipelineRasterizationConservativeStateCreateInfoEXT, VkPipelineRasterizationDepthClipStateCreateInfoEXT, VkPipelineRasterizationStateCreateInfo, VkPipelineRasterizationStateRasterizationOrderAMD, VkPipelineRasterizationStateStreamCreateInfoEXT, VkPipelineRepresentativeFragmentTestStateCreateInfoNV, VkPipelineSampleLocationsStateCreateInfoEXT, VkPipelineShaderStageCreateInfo, VkPipelineTessellationDomainOriginStateCreateInfo, VkPipelineTessellationStateCreateInfo, VkPipelineVertexInputDivisorStateCreateInfoEXT, VkPipelineVertexInputStateCreateInfo, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, VkPipelineViewportExclusiveScissorStateCreateInfoNV, VkPipelineViewportShadingRateImageStateCreateInfoNV, VkPipelineViewportStateCreateInfo, VkPipelineViewportSwizzleStateCreateInfoNV, VkPipelineViewportWScalingStateCreateInfoNV, VkPresentFrameTokenGGP, VkPresentInfoKHR, VkPresentRegionsKHR, VkPresentTimesInfoGOOGLE, VkProtectedSubmitInfo, VkQueryPoolCreateInfo, VkQueueFamilyCheckpointPropertiesNV, VkQueueFamilyProperties2, VkRayTracingPipelineCreateInfoNV, VkRayTracingShaderGroupCreateInfoNV, VkRenderPassBeginInfo, VkRenderPassCreateInfo, VkRenderPassCreateInfo2KHR, VkRenderPassFragmentDensityMapCreateInfoEXT, VkRenderPassInputAttachmentAspectCreateInfo, VkRenderPassMultiviewCreateInfo, VkRenderPassSampleLocationsBeginInfoEXT, VkSampleLocationsInfoEXT, VkSamplerCreateInfo, VkSamplerReductionModeCreateInfoEXT, VkSamplerYcbcrConversionCreateInfo, VkSamplerYcbcrConversionImageFormatProperties, VkSamplerYcbcrConversionInfo, VkSemaphoreCreateInfo, VkSemaphoreGetFdInfoKHR, VkSemaphoreGetWin32HandleInfoKHR, VkShaderModuleCreateInfo, VkShaderModuleValidationCacheCreateInfoEXT, VkSharedPresentSurfaceCapabilitiesKHR, VkSparseImageFormatProperties2, VkSparseImageMemoryRequirements2, VkStreamDescriptorSurfaceCreateInfoGGP, VkSubmitInfo, VkSubpassBeginInfoKHR, VkSubpassDependency2KHR, VkSubpassDescription2KHR, VkSubpassDescriptionDepthStencilResolveKHR, VkSubpassEndInfoKHR, VkSurfaceCapabilities2EXT, VkSurfaceCapabilities2KHR, VkSurfaceCapabilitiesFullScreenExclusiveEXT, VkSurfaceFormat2KHR, VkSurfaceFullScreenExclusiveInfoEXT, VkSurfaceFullScreenExclusiveWin32InfoEXT, VkSurfaceProtectedCapabilitiesKHR, VkSwapchainCounterCreateInfoEXT, VkSwapchainCreateInfoKHR, VkSwapchainDisplayNativeHdrCreateInfoAMD, VkTextureLODGatherFormatPropertiesAMD, VkValidationCacheCreateInfoEXT, VkValidationFeaturesEXT, VkValidationFlagsEXT, VkViSurfaceCreateInfoNN, VkWaylandSurfaceCreateInfoKHR, VkWin32KeyedMutexAcquireReleaseInfoKHR, VkWin32KeyedMutexAcquireReleaseInfoNV, VkWin32SurfaceCreateInfoKHR, VkWriteDescriptorSet, VkWriteDescriptorSetAccelerationStructureNV, VkWriteDescriptorSetInlineUniformBlockEXT, VkXcbSurfaceCreateInfoKHR, VkXlibSurfaceCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkStructureType

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubgroupFeatureFlagBits(3)
Name
VkSubgroupFeatureFlagBits - Enum describing what subgroup operations are supported

C Specification
Bits which can be set in VkPhysicalDeviceSubgroupProperties::supportedOperations to specify supported subgroup operations are:

typedef enum VkSubgroupFeatureFlagBits {
    VK_SUBGROUP_FEATURE_BASIC_BIT = 0x00000001,
    VK_SUBGROUP_FEATURE_VOTE_BIT = 0x00000002,
    VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 0x00000004,
    VK_SUBGROUP_FEATURE_BALLOT_BIT = 0x00000008,
    VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 0x00000010,
    VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x00000020,
    VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 0x00000040,
    VK_SUBGROUP_FEATURE_QUAD_BIT = 0x00000080,
    VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x00000100,
    VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSubgroupFeatureFlagBits;
Description
VK_SUBGROUP_FEATURE_BASIC_BIT specifies the device will accept SPIR-V shader modules that contain the GroupNonUniform capability.
VK_SUBGROUP_FEATURE_VOTE_BIT specifies the device will accept SPIR-V shader modules that contain the GroupNonUniformVote capability.
VK_SUBGROUP_FEATURE_ARITHMETIC_BIT specifies the device will accept SPIR-V shader modules that contain the GroupNonUniformArithmetic capability.
VK_SUBGROUP_FEATURE_BALLOT_BIT specifies the device will accept SPIR-V shader modules that contain the GroupNonUniformBallot capability.
VK_SUBGROUP_FEATURE_SHUFFLE_BIT specifies the device will accept SPIR-V shader modules that contain the GroupNonUniformShuffle capability.
VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT specifies the device will accept SPIR-V shader modules that contain the GroupNonUniformShuffleRelative capability.
VK_SUBGROUP_FEATURE_CLUSTERED_BIT specifies the device will accept SPIR-V shader modules that contain the GroupNonUniformClustered capability.
VK_SUBGROUP_FEATURE_QUAD_BIT specifies the device will accept SPIR-V shader modules that contain the GroupNonUniformQuad capability.
VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV specifies the device will accept SPIR-V shader modules that contain the GroupNonUniformPartitionedNV capability.
See Also
VkSubgroupFeatureFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubgroupFeatureFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubpassContents(3)
Name
VkSubpassContents - Specify how commands in the first subpass of a render pass are provided

C Specification
Possible values of vkCmdBeginRenderPass::contents, specifying how the commands in the first subpass will be provided, are:

typedef enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    VK_SUBPASS_CONTENTS_MAX_ENUM = 0x7FFFFFFF
} VkSubpassContents;
Description
VK_SUBPASS_CONTENTS_INLINE specifies that the contents of the subpass will be recorded inline in the primary command buffer, and secondary command buffers must not be executed within the subpass.
VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS specifies that the contents are recorded in secondary command buffers that will be called from the primary command buffer, and vkCmdExecuteCommands is the only valid command on the command buffer until vkCmdNextSubpass or vkCmdEndRenderPass.
See Also
VkSubpassBeginInfoKHR, vkCmdBeginRenderPass, vkCmdNextSubpass

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubpassContents

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubpassDescriptionFlagBits(3)
Name
VkSubpassDescriptionFlagBits - Bitmask specifying usage of a subpass

C Specification
Bits which can be set in VkSubpassDescription::flags, specifying usage of the subpass, are:

typedef enum VkSubpassDescriptionFlagBits {
    VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x00000001,
    VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x00000002,
    VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkSubpassDescriptionFlagBits;
Description
VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX specifies that shaders compiled for this subpass write the attributes for all views in a single invocation of each vertex processing stage. All pipelines compiled against a subpass that includes this bit must write per-view attributes to the *PerViewNV[] shader outputs, in addition to the non-per-view (e.g. Position) outputs.
VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX specifies that shaders compiled for this subpass use per-view positions which only differ in value in the x component. Per-view viewport mask can also be used.
See Also
VkSubpassDescriptionFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubpassDescriptionFlagBits

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceCounterFlagBitsEXT(3)
Name
VkSurfaceCounterFlagBitsEXT - Surface-relative counter types

C Specification
Bits which can be set in VkSurfaceCapabilities2EXT::supportedSurfaceCounters, indicating supported surface counter types, are:

typedef enum VkSurfaceCounterFlagBitsEXT {
    VK_SURFACE_COUNTER_VBLANK_EXT = 0x00000001,
    VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = 0x7FFFFFFF
} VkSurfaceCounterFlagBitsEXT;
Description
VK_SURFACE_COUNTER_VBLANK_EXT specifies a counter incrementing once every time a vertical blanking period occurs on the display associated with the surface.
See Also
VkSurfaceCounterFlagsEXT, vkGetSwapchainCounterEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceCounterFlagBitsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceTransformFlagBitsKHR(3)
Name
VkSurfaceTransformFlagBitsKHR - presentation transforms supported on a device

C Specification
Bits which may be set in VkSurfaceCapabilitiesKHR::supportedTransforms indicating the presentation transforms supported for the surface on the specified device, and possible values of VkSurfaceCapabilitiesKHR::currentTransform is indicating the surface’s current transform relative to the presentation engine’s natural orientation, are:

typedef enum VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x00000001,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x00000002,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x00000004,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x00000008,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x00000010,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x00000020,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x00000040,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x00000080,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x00000100,
    VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkSurfaceTransformFlagBitsKHR;
Description
VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR specifies that image content is presented without being transformed.
VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR specifies that image content is rotated 90 degrees clockwise.
VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR specifies that image content is rotated 180 degrees clockwise.
VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR specifies that image content is rotated 270 degrees clockwise.
VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR specifies that image content is mirrored horizontally.
VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR specifies that image content is mirrored horizontally, then rotated 90 degrees clockwise.
VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR specifies that image content is mirrored horizontally, then rotated 180 degrees clockwise.
VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR specifies that image content is mirrored horizontally, then rotated 270 degrees clockwise.
VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR specifies that the presentation transform is not specified, and is instead determined by platform-specific considerations and mechanisms outside Vulkan.
See Also
VkDisplaySurfaceCreateInfoKHR, VkSurfaceCapabilities2EXT, VkSurfaceCapabilitiesKHR, VkSurfaceTransformFlagsKHR, VkSwapchainCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceTransformFlagBitsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSwapchainCreateFlagBitsKHR(3)
Name
VkSwapchainCreateFlagBitsKHR - Bitmask controlling swapchain creation

C Specification
Bits which can be set in VkSwapchainCreateInfoKHR::flags, specifying parameters of swapchain creation, are:

typedef enum VkSwapchainCreateFlagBitsKHR {
    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x00000001,
    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 0x00000002,
    VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 0x00000004,
    VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = 0x7FFFFFFF
} VkSwapchainCreateFlagBitsKHR;
Description
VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR specifies that images created from the swapchain (i.e. with the swapchain member of VkImageSwapchainCreateInfoKHR set to this swapchain’s handle) must use VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT.
VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR specifies that images created from the swapchain are protected images.
VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR specifies that the images of the swapchain can be used to create a VkImageView with a different format than what the swapchain was created with. The list of allowed image view formats are specified by chaining an instance of the VkImageFormatListCreateInfoKHR structure to the pNext chain of VkSwapchainCreateInfoKHR. In addition, this flag also specifies that the swapchain can be created with usage flags that are not supported for the format the swapchain is created with but are supported for at least one of the allowed image view formats.
See Also
VkSwapchainCreateFlagsKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSwapchainCreateFlagBitsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSystemAllocationScope(3)
Name
VkSystemAllocationScope - Allocation scope

C Specification
Each allocation has an allocation scope which defines its lifetime and which object it is associated with. Possible values passed to the allocationScope parameter of the callback functions specified by VkAllocationCallbacks, indicating the allocation scope, are:

typedef enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 0x7FFFFFFF
} VkSystemAllocationScope;
Description
VK_SYSTEM_ALLOCATION_SCOPE_COMMAND specifies that the allocation is scoped to the duration of the Vulkan command.
VK_SYSTEM_ALLOCATION_SCOPE_OBJECT specifies that the allocation is scoped to the lifetime of the Vulkan object that is being created or used.
VK_SYSTEM_ALLOCATION_SCOPE_CACHE specifies that the allocation is scoped to the lifetime of a VkPipelineCache or VkValidationCacheEXT object.
VK_SYSTEM_ALLOCATION_SCOPE_DEVICE specifies that the allocation is scoped to the lifetime of the Vulkan device.
VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE specifies that the allocation is scoped to the lifetime of the Vulkan instance.
Most Vulkan commands operate on a single object, or there is a sole object that is being created or manipulated. When an allocation uses an allocation scope of VK_SYSTEM_ALLOCATION_SCOPE_OBJECT or VK_SYSTEM_ALLOCATION_SCOPE_CACHE, the allocation is scoped to the object being created or manipulated.

When an implementation requires host memory, it will make callbacks to the application using the most specific allocator and allocation scope available:

If an allocation is scoped to the duration of a command, the allocator will use the VK_SYSTEM_ALLOCATION_SCOPE_COMMAND allocation scope. The most specific allocator available is used: if the object being created or manipulated has an allocator, that object’s allocator will be used, else if the parent VkDevice has an allocator it will be used, else if the parent VkInstance has an allocator it will be used. Else,
If an allocation is associated with an object of type VkValidationCacheEXT or VkPipelineCache, the allocator will use the VK_SYSTEM_ALLOCATION_SCOPE_CACHE allocation scope. The most specific allocator available is used (cache, else device, else instance). Else,
If an allocation is scoped to the lifetime of an object, that object is being created or manipulated by the command, and that object’s type is not VkDevice or VkInstance, the allocator will use an allocation scope of VK_SYSTEM_ALLOCATION_SCOPE_OBJECT. The most specific allocator available is used (object, else device, else instance). Else,
If an allocation is scoped to the lifetime of a device, the allocator will use an allocation scope of VK_SYSTEM_ALLOCATION_SCOPE_DEVICE. The most specific allocator available is used (device, else instance). Else,
If the allocation is scoped to the lifetime of an instance and the instance has an allocator, its allocator will be used with an allocation scope of VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE.
Otherwise an implementation will allocate memory through an alternative mechanism that is unspecified.
See Also
VkAllocationCallbacks

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSystemAllocationScope

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkTessellationDomainOrigin(3)
Name
VkTessellationDomainOrigin - Enum describing tessellation domain origin

C Specification
The possible tessellation domain origins are specified by the VkTessellationDomainOrigin enumeration:

typedef enum VkTessellationDomainOrigin {
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = 0x7FFFFFFF
} VkTessellationDomainOrigin;
or the equivalent

typedef VkTessellationDomainOrigin VkTessellationDomainOriginKHR;
Description
VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT specifies that the origin of the domain space is in the upper left corner, as shown in figure html/vkspec.html#img-tessellation-topology-ul.
VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT specifies that the origin of the domain space is in the lower left corner, as shown in figure html/vkspec.html#img-tessellation-topology-ll.
This enum affects how the VertexOrderCw and VertexOrderCcw tessellation execution modes are interpreted, since the winding is defined relative to the orientation of the domain.

See Also
VkPipelineTessellationDomainOriginStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkTessellationDomainOrigin

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkTimeDomainEXT(3)
Name
VkTimeDomainEXT - Supported time domains

C Specification
The set of supported time domains consists of:

typedef enum VkTimeDomainEXT {
    VK_TIME_DOMAIN_DEVICE_EXT = 0,
    VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT = 1,
    VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = 2,
    VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = 3,
    VK_TIME_DOMAIN_MAX_ENUM_EXT = 0x7FFFFFFF
} VkTimeDomainEXT;
Description
VK_TIME_DOMAIN_DEVICE_EXT specifies the device time domain. Timestamp values in this time domain are comparable with device timestamp values captured using vkCmdWriteTimestamp and are defined to be incrementing according to the timestampPeriod of the device.
VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT specifies the CLOCK_MONOTONIC time domain available on POSIX platforms.
VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT specifies the CLOCK_MONOTONIC_RAW time domain available on POSIX platforms.
VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT specifies the performance counter (QPC) time domain available on Windows.
See Also
VkCalibratedTimestampInfoEXT, vkGetPhysicalDeviceCalibrateableTimeDomainsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkTimeDomainEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkValidationCacheHeaderVersionEXT(3)
Name
VkValidationCacheHeaderVersionEXT - Encode validation cache version

C Specification
Possible values of the second group of four bytes in the header returned by vkGetValidationCacheDataEXT, encoding the validation cache version, are:

typedef enum VkValidationCacheHeaderVersionEXT {
    VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
    VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT = 0x7FFFFFFF
} VkValidationCacheHeaderVersionEXT;
Description
VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT specifies version one of the validation cache.
See Also
vkCreateValidationCacheEXT, vkGetValidationCacheDataEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkValidationCacheHeaderVersionEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkValidationCheckEXT(3)
Name
VkValidationCheckEXT - Specify validation checks to disable

C Specification
Possible values of elements of the VkValidationFlagsEXT::pDisabledValidationChecks array, specifying validation checks to be disabled, are:

typedef enum VkValidationCheckEXT {
    VK_VALIDATION_CHECK_ALL_EXT = 0,
    VK_VALIDATION_CHECK_SHADERS_EXT = 1,
    VK_VALIDATION_CHECK_MAX_ENUM_EXT = 0x7FFFFFFF
} VkValidationCheckEXT;
Description
VK_VALIDATION_CHECK_ALL_EXT specifies that all validation checks are disabled.
VK_VALIDATION_CHECK_SHADERS_EXT specifies that shader validation is disabled.
See Also
VkValidationFlagsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkValidationCheckEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkValidationFeatureDisableEXT(3)
Name
VkValidationFeatureDisableEXT - Specify validation features to disable

C Specification
Possible values of elements of the VkValidationFeaturesEXT::pDisabledValidationFeatures array, specifying validation features to be disabled, are:

typedef enum VkValidationFeatureDisableEXT {
    VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
    VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
    VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
    VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
    VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
    VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
    VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6,
    VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkValidationFeatureDisableEXT;
Description
VK_VALIDATION_FEATURE_DISABLE_ALL_EXT specifies that all validation checks are disabled.
VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT specifies that shader validation is disabled. This feature is enabled by default.
VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT specifies that thread safety validation is disabled. This feature is enabled by default.
VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT specifies that stateless parameter validation is disabled. This feature is enabled by default.
VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT specifies that object lifetime validation is disabled. This feature is enabled by default.
VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT specifies that core validation checks are disabled. This feature is enabled by default. If this feature is disabled, the shader validation and GPU-assisted validation features are also disabled.
VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT specifies that protection against duplicate non-dispatchable object handles is disabled. This feature is enabled by default.
See Also
VkValidationFeaturesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkValidationFeatureDisableEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkValidationFeatureEnableEXT(3)
Name
VkValidationFeatureEnableEXT - Specify validation features to enable

C Specification
Possible values of elements of the VkValidationFeaturesEXT::pEnabledValidationFeatures array, specifying validation features to be enabled, are:

typedef enum VkValidationFeatureEnableEXT {
    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
    VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT = 0x7FFFFFFF
} VkValidationFeatureEnableEXT;
Description
VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT specifies that GPU-assisted validation is enabled. Activating this feature instruments shader programs to generate additional diagnostic data. This feature is disabled by default.
VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT specifies that the validation layers reserve a descriptor set binding slot for their own use. The layer reports a value for VkPhysicalDeviceLimits::maxBoundDescriptorSets that is one less than the value reported by the device. If the device supports the binding of only one descriptor set, the validation layer does not perform GPU-assisted validation. This feature is disabled by default. The GPU-assisted validation feature must be enabled in order to use this feature.
See Also
VkValidationFeaturesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkValidationFeatureEnableEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkVendorId(3)
Name
VkVendorId - Khronos vendor IDs

C Specification
Khronos vendor IDs which may be returned in VkPhysicalDeviceProperties::vendorID are:

typedef enum VkVendorId {
    VK_VENDOR_ID_VIV = 0x10001,
    VK_VENDOR_ID_VSI = 0x10002,
    VK_VENDOR_ID_KAZAN = 0x10003,
    VK_VENDOR_ID_MAX_ENUM = 0x7FFFFFFF
} VkVendorId;
Description
Note
Khronos vendor IDs may be allocated by vendors at any time. Only the latest canonical versions of this Specification, of the corresponding vk.xml API Registry, and of the corresponding vulkan_core.h header file must contain all reserved Khronos vendor IDs.

Only Khronos vendor IDs are given symbolic names at present. PCI vendor IDs returned by the implementation can be looked up in the PCI-SIG database.
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkVendorId

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkVertexInputRate(3)
Name
VkVertexInputRate - Specify rate at which vertex attributes are pulled from buffers

C Specification
Possible values of VkVertexInputBindingDescription::inputRate, specifying the rate at which vertex attributes are pulled from buffers, are:

typedef enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    VK_VERTEX_INPUT_RATE_MAX_ENUM = 0x7FFFFFFF
} VkVertexInputRate;
Description
VK_VERTEX_INPUT_RATE_VERTEX specifies that vertex attribute addressing is a function of the vertex index.
VK_VERTEX_INPUT_RATE_INSTANCE specifies that vertex attribute addressing is a function of the instance index.
See Also
VkVertexInputBindingDescription

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkVertexInputRate

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkViewportCoordinateSwizzleNV(3)
Name
VkViewportCoordinateSwizzleNV - Specify how a viewport coordinate is swizzled

C Specification
Possible values of the VkViewportSwizzleNV::x, y, z, and w members, specifying swizzling of the corresponding components of primitives, are:

typedef enum VkViewportCoordinateSwizzleNV {
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
    VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = 0x7FFFFFFF
} VkViewportCoordinateSwizzleNV;
Description
These values are described in detail in Viewport Swizzle.

See Also
VkViewportSwizzleNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkViewportCoordinateSwizzleNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Flags
VkAccessFlags(3)
Name
VkAccessFlags - Bitmask of VkAccessFlagBits

C Specification
typedef VkFlags VkAccessFlags;
Description
VkAccessFlags is a bitmask type for setting a mask of zero or more VkAccessFlagBits.

See Also
VkAccessFlagBits, VkBufferMemoryBarrier, VkImageMemoryBarrier, VkMemoryBarrier, VkSubpassDependency, VkSubpassDependency2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAccessFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Unresolved directive in apispec.txt - include::VkAndroidSurfaceCreateFlagsKHR.txt[]

VkAttachmentDescriptionFlags(3)
Name
VkAttachmentDescriptionFlags - Bitmask of VkAttachmentDescriptionFlagBits

C Specification
typedef VkFlags VkAttachmentDescriptionFlags;
Description
VkAttachmentDescriptionFlags is a bitmask type for setting a mask of zero or more VkAttachmentDescriptionFlagBits.

See Also
VkAttachmentDescription, VkAttachmentDescription2KHR, VkAttachmentDescriptionFlagBits

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkAttachmentDescriptionFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferCreateFlags(3)
Name
VkBufferCreateFlags - Bitmask of VkBufferCreateFlagBits

C Specification
typedef VkFlags VkBufferCreateFlags;
Description
VkBufferCreateFlags is a bitmask type for setting a mask of zero or more VkBufferCreateFlagBits.

See Also
VkBufferCreateFlagBits, VkBufferCreateInfo, VkPhysicalDeviceExternalBufferInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferUsageFlags(3)
Name
VkBufferUsageFlags - Bitmask of VkBufferUsageFlagBits

C Specification
typedef VkFlags VkBufferUsageFlags;
Description
VkBufferUsageFlags is a bitmask type for setting a mask of zero or more VkBufferUsageFlagBits.

See Also
VkBufferCreateInfo, VkBufferUsageFlagBits, VkPhysicalDeviceExternalBufferInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferUsageFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBufferViewCreateFlags(3)
Name
VkBufferViewCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkBufferViewCreateFlags;
Description
VkBufferViewCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkBufferViewCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBufferViewCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkBuildAccelerationStructureFlagsNV(3)
Name
VkBuildAccelerationStructureFlagsNV - Bitmask of VkBuildAccelerationStructureFlagBitsNV

C Specification
typedef VkFlags VkBuildAccelerationStructureFlagsNV;
Description
VkBuildAccelerationStructureFlagsNV is a bitmask type for setting a mask of zero or more VkBuildAccelerationStructureFlagBitsNV.

See Also
VkAccelerationStructureInfoNV, VkBuildAccelerationStructureFlagBitsNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBuildAccelerationStructureFlagsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkColorComponentFlags(3)
Name
VkColorComponentFlags - Bitmask of VkColorComponentFlagBits

C Specification
typedef VkFlags VkColorComponentFlags;
Description
VkColorComponentFlags is a bitmask type for setting a mask of zero or more VkColorComponentFlagBits.

See Also
VkColorComponentFlagBits, VkPipelineColorBlendAttachmentState

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkColorComponentFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandBufferResetFlags(3)
Name
VkCommandBufferResetFlags - Bitmask of VkCommandBufferResetFlagBits

C Specification
typedef VkFlags VkCommandBufferResetFlags;
Description
VkCommandBufferResetFlags is a bitmask type for setting a mask of zero or more VkCommandBufferResetFlagBits.

See Also
VkCommandBufferResetFlagBits, vkResetCommandBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandBufferResetFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandBufferUsageFlags(3)
Name
VkCommandBufferUsageFlags - Bitmask of VkCommandBufferUsageFlagBits

C Specification
typedef VkFlags VkCommandBufferUsageFlags;
Description
VkCommandBufferUsageFlags is a bitmask type for setting a mask of zero or more VkCommandBufferUsageFlagBits.

See Also
VkCommandBufferBeginInfo, VkCommandBufferUsageFlagBits

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandBufferUsageFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandPoolCreateFlags(3)
Name
VkCommandPoolCreateFlags - Bitmask of VkCommandPoolCreateFlagBits

C Specification
typedef VkFlags VkCommandPoolCreateFlags;
Description
VkCommandPoolCreateFlags is a bitmask type for setting a mask of zero or more VkCommandPoolCreateFlagBits.

See Also
VkCommandPoolCreateFlagBits, VkCommandPoolCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandPoolCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandPoolResetFlags(3)
Name
VkCommandPoolResetFlags - Bitmask of VkCommandPoolResetFlagBits

C Specification
typedef VkFlags VkCommandPoolResetFlags;
Description
VkCommandPoolResetFlags is a bitmask type for setting a mask of zero or more VkCommandPoolResetFlagBits.

See Also
VkCommandPoolResetFlagBits, vkResetCommandPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandPoolResetFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCommandPoolTrimFlags(3)
Name
VkCommandPoolTrimFlags - Reserved for future use

C Specification
typedef VkFlags VkCommandPoolTrimFlags;
or the equivalent

typedef VkCommandPoolTrimFlags VkCommandPoolTrimFlagsKHR;
Description
VkCommandPoolTrimFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
vkTrimCommandPool, vkTrimCommandPoolKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCommandPoolTrimFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCompositeAlphaFlagsKHR(3)
Name
VkCompositeAlphaFlagsKHR - Bitmask of VkCompositeAlphaFlagBitsKHR

C Specification
typedef VkFlags VkCompositeAlphaFlagsKHR;
Description
VkCompositeAlphaFlagsKHR is a bitmask type for setting a mask of zero or more VkCompositeAlphaFlagBitsKHR.

See Also
VkCompositeAlphaFlagBitsKHR, VkSurfaceCapabilities2EXT, VkSurfaceCapabilitiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCompositeAlphaFlagsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkConditionalRenderingFlagsEXT(3)
Name
VkConditionalRenderingFlagsEXT - Bitmask of VkConditionalRenderingFlagBitsEXT

C Specification
typedef VkFlags VkConditionalRenderingFlagsEXT;
Description
VkConditionalRenderingFlagsEXT is a bitmask type for setting a mask of zero or more VkConditionalRenderingFlagBitsEXT.

See Also
VkConditionalRenderingBeginInfoEXT, VkConditionalRenderingFlagBitsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkConditionalRenderingFlagsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkCullModeFlags(3)
Name
VkCullModeFlags - Bitmask of VkCullModeFlagBits

C Specification
typedef VkFlags VkCullModeFlags;
Description
VkCullModeFlags is a bitmask type for setting a mask of zero or more VkCullModeFlagBits.

See Also
VkCullModeFlagBits, VkPipelineRasterizationStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkCullModeFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugReportFlagsEXT(3)
Name
VkDebugReportFlagsEXT - Bitmask of VkDebugReportFlagBitsEXT

C Specification
typedef VkFlags VkDebugReportFlagsEXT;
Description
VkDebugReportFlagsEXT is a bitmask type for setting a mask of zero or more VkDebugReportFlagBitsEXT.

See Also
VkDebugReportCallbackCreateInfoEXT, VkDebugReportFlagBitsEXT, vkDebugReportMessageEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugReportFlagsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugUtilsMessageSeverityFlagsEXT(3)
Name
VkDebugUtilsMessageSeverityFlagsEXT - Bitmask of VkDebugUtilsMessageSeverityFlagBitsEXT

C Specification
typedef VkFlags VkDebugUtilsMessageSeverityFlagsEXT;
Description
VkDebugUtilsMessageSeverityFlagsEXT is a bitmask type for setting a mask of zero or more VkDebugUtilsMessageSeverityFlagBitsEXT.

See Also
VkDebugUtilsMessageSeverityFlagBitsEXT, VkDebugUtilsMessengerCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugUtilsMessageSeverityFlagsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDebugUtilsMessageTypeFlagsEXT(3)
Name
VkDebugUtilsMessageTypeFlagsEXT - Bitmask of VkDebugUtilsMessageTypeFlagBitsEXT

C Specification
typedef VkFlags VkDebugUtilsMessageTypeFlagsEXT;
Description
VkDebugUtilsMessageTypeFlagsEXT is a bitmask type for setting a mask of zero or more VkDebugUtilsMessageTypeFlagBitsEXT.

See Also
VkDebugUtilsMessageTypeFlagBitsEXT, VkDebugUtilsMessengerCreateInfoEXT, vkSubmitDebugUtilsMessageEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDebugUtilsMessageTypeFlagsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Unresolved directive in apispec.txt - include::VkDebugUtilsMessengerCallbackDataFlagsEXT.txt[] Unresolved directive in apispec.txt - include::VkDebugUtilsMessengerCreateFlagsEXT.txt[]

VkDependencyFlags(3)
Name
VkDependencyFlags - Bitmask of VkDependencyFlagBits

C Specification
typedef VkFlags VkDependencyFlags;
Description
VkDependencyFlags is a bitmask type for setting a mask of zero or more VkDependencyFlagBits.

See Also
VkDependencyFlagBits, VkSubpassDependency, VkSubpassDependency2KHR, vkCmdPipelineBarrier

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDependencyFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorBindingFlagsEXT(3)
Name
VkDescriptorBindingFlagsEXT - Bitmask of VkDescriptorBindingFlagBitsEXT

C Specification
typedef VkFlags VkDescriptorBindingFlagsEXT;
Description
VkDescriptorBindingFlagsEXT is a bitmask type for setting a mask of zero or more VkDescriptorBindingFlagBitsEXT.

See Also
VkDescriptorBindingFlagBitsEXT, VkDescriptorSetLayoutBindingFlagsCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorBindingFlagsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorPoolCreateFlags(3)
Name
VkDescriptorPoolCreateFlags - Bitmask of VkDescriptorPoolCreateFlagBits

C Specification
typedef VkFlags VkDescriptorPoolCreateFlags;
Description
VkDescriptorPoolCreateFlags is a bitmask type for setting a mask of zero or more VkDescriptorPoolCreateFlagBits.

See Also
VkDescriptorPoolCreateFlagBits, VkDescriptorPoolCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorPoolCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorPoolResetFlags(3)
Name
VkDescriptorPoolResetFlags - Reserved for future use

C Specification
typedef VkFlags VkDescriptorPoolResetFlags;
Description
VkDescriptorPoolResetFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
vkResetDescriptorPool

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorPoolResetFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorSetLayoutCreateFlags(3)
Name
VkDescriptorSetLayoutCreateFlags - Bitmask of VkDescriptorSetLayoutCreateFlagBits

C Specification
typedef VkFlags VkDescriptorSetLayoutCreateFlags;
Description
VkDescriptorSetLayoutCreateFlags is a bitmask type for setting a mask of zero or more VkDescriptorSetLayoutCreateFlagBits.

See Also
VkDescriptorSetLayoutCreateFlagBits, VkDescriptorSetLayoutCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorSetLayoutCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDescriptorUpdateTemplateCreateFlags(3)
Name
VkDescriptorUpdateTemplateCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkDescriptorUpdateTemplateCreateFlags;
or the equivalent

typedef VkDescriptorUpdateTemplateCreateFlags VkDescriptorUpdateTemplateCreateFlagsKHR;
Description
VkDescriptorUpdateTemplateCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkDescriptorUpdateTemplateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDescriptorUpdateTemplateCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceCreateFlags(3)
Name
VkDeviceCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkDeviceCreateFlags;
Description
VkDeviceCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkDeviceCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceGroupPresentModeFlagsKHR(3)
Name
VkDeviceGroupPresentModeFlagsKHR - Bitmask of VkDeviceGroupPresentModeFlagBitsKHR

C Specification
typedef VkFlags VkDeviceGroupPresentModeFlagsKHR;
Description
VkDeviceGroupPresentModeFlagsKHR is a bitmask type for setting a mask of zero or more VkDeviceGroupPresentModeFlagBitsKHR.

See Also
VkDeviceGroupPresentCapabilitiesKHR, VkDeviceGroupPresentModeFlagBitsKHR, VkDeviceGroupSwapchainCreateInfoKHR, vkGetDeviceGroupSurfacePresentModes2EXT, vkGetDeviceGroupSurfacePresentModesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceGroupPresentModeFlagsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceQueueCreateFlags(3)
Name
VkDeviceQueueCreateFlags - Bitmask of VkDeviceQueueCreateFlagBits

C Specification
typedef VkFlags VkDeviceQueueCreateFlags;
Description
VkDeviceQueueCreateFlags is a bitmask type for setting a mask of zero or more VkDeviceQueueCreateFlagBits.

See Also
VkDeviceQueueCreateFlagBits, VkDeviceQueueCreateInfo, VkDeviceQueueInfo2

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceQueueCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Unresolved directive in apispec.txt - include::VkDisplayModeCreateFlagsKHR.txt[]

VkDisplayPlaneAlphaFlagsKHR(3)
Name
VkDisplayPlaneAlphaFlagsKHR - Bitmask of VkDisplayPlaneAlphaFlagBitsKHR

C Specification
typedef VkFlags VkDisplayPlaneAlphaFlagsKHR;
Description
VkDisplayPlaneAlphaFlagsKHR is a bitmask type for setting a mask of zero or more VkDisplayPlaneAlphaFlagBitsKHR.

See Also
VkDisplayPlaneAlphaFlagBitsKHR, VkDisplayPlaneCapabilitiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDisplayPlaneAlphaFlagsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Unresolved directive in apispec.txt - include::VkDisplaySurfaceCreateFlagsKHR.txt[]

VkEventCreateFlags(3)
Name
VkEventCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkEventCreateFlags;
Description
VkEventCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkEventCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkEventCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalFenceFeatureFlags(3)
Name
VkExternalFenceFeatureFlags - Bitmask of VkExternalFenceFeatureFlagBits

C Specification
typedef VkFlags VkExternalFenceFeatureFlags;
or the equivalent

typedef VkExternalFenceFeatureFlags VkExternalFenceFeatureFlagsKHR;
Description
VkExternalFenceFeatureFlags is a bitmask type for setting a mask of zero or more VkExternalFenceFeatureFlagBits.

See Also
VkExternalFenceFeatureFlagBits, VkExternalFenceProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalFenceFeatureFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalFenceHandleTypeFlags(3)
Name
VkExternalFenceHandleTypeFlags - Bitmask of VkExternalFenceHandleTypeFlagBits

C Specification
typedef VkFlags VkExternalFenceHandleTypeFlags;
or the equivalent

typedef VkExternalFenceHandleTypeFlags VkExternalFenceHandleTypeFlagsKHR;
Description
VkExternalFenceHandleTypeFlags is a bitmask type for setting a mask of zero or more VkExternalFenceHandleTypeFlagBits.

See Also
VkExportFenceCreateInfo, VkExternalFenceHandleTypeFlagBits, VkExternalFenceProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalFenceHandleTypeFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalMemoryFeatureFlags(3)
Name
VkExternalMemoryFeatureFlags - Bitmask of VkExternalMemoryFeatureFlagBits

C Specification
typedef VkFlags VkExternalMemoryFeatureFlags;
or the equivalent

typedef VkExternalMemoryFeatureFlags VkExternalMemoryFeatureFlagsKHR;
Description
VkExternalMemoryFeatureFlags is a bitmask type for setting a mask of zero or more VkExternalMemoryFeatureFlagBits.

See Also
VkExternalMemoryFeatureFlagBits, VkExternalMemoryProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalMemoryFeatureFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalMemoryFeatureFlagsNV(3)
Name
VkExternalMemoryFeatureFlagsNV - Bitmask of VkExternalMemoryFeatureFlagBitsNV

C Specification
typedef VkFlags VkExternalMemoryFeatureFlagsNV;
Description
VkExternalMemoryFeatureFlagsNV is a bitmask type for setting a mask of zero or more VkExternalMemoryFeatureFlagBitsNV.

See Also
VkExternalImageFormatPropertiesNV, VkExternalMemoryFeatureFlagBitsNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalMemoryFeatureFlagsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalMemoryHandleTypeFlags(3)
Name
VkExternalMemoryHandleTypeFlags - Bitmask of VkExternalMemoryHandleTypeFlagBits

C Specification
typedef VkFlags VkExternalMemoryHandleTypeFlags;
or the equivalent

typedef VkExternalMemoryHandleTypeFlags VkExternalMemoryHandleTypeFlagsKHR;
Description
VkExternalMemoryHandleTypeFlags is a bitmask type for setting a mask of zero or more VkExternalMemoryHandleTypeFlagBits.

See Also
VkExportMemoryAllocateInfo, VkExternalMemoryBufferCreateInfo, VkExternalMemoryHandleTypeFlagBits, VkExternalMemoryImageCreateInfo, VkExternalMemoryProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalMemoryHandleTypeFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalMemoryHandleTypeFlagsNV(3)
Name
VkExternalMemoryHandleTypeFlagsNV - Bitmask of VkExternalMemoryHandleTypeFlagBitsNV

C Specification
typedef VkFlags VkExternalMemoryHandleTypeFlagsNV;
Description
VkExternalMemoryHandleTypeFlagsNV is a bitmask type for setting a mask of zero or more VkExternalMemoryHandleTypeFlagBitsNV.

See Also
VkExportMemoryAllocateInfoNV, VkExternalImageFormatPropertiesNV, VkExternalMemoryHandleTypeFlagBitsNV, VkExternalMemoryImageCreateInfoNV, VkImportMemoryWin32HandleInfoNV, vkGetMemoryWin32HandleNV, vkGetPhysicalDeviceExternalImageFormatPropertiesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalMemoryHandleTypeFlagsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalSemaphoreFeatureFlags(3)
Name
VkExternalSemaphoreFeatureFlags - Bitmask of VkExternalSemaphoreFeatureFlagBitsKHR

C Specification
typedef VkFlags VkExternalSemaphoreFeatureFlags;
or the equivalent

typedef VkExternalSemaphoreFeatureFlags VkExternalSemaphoreFeatureFlagsKHR;
Description
VkExternalSemaphoreFeatureFlags is a bitmask type for setting a mask of zero or more VkExternalSemaphoreFeatureFlagBits.

See Also
VkExternalSemaphoreFeatureFlagBits, VkExternalSemaphoreProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalSemaphoreFeatureFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkExternalSemaphoreHandleTypeFlags(3)
Name
VkExternalSemaphoreHandleTypeFlags - Bitmask of VkExternalSemaphoreHandleTypeFlagBits

C Specification
typedef VkFlags VkExternalSemaphoreHandleTypeFlags;
or the equivalent

typedef VkExternalSemaphoreHandleTypeFlags VkExternalSemaphoreHandleTypeFlagsKHR;
Description
VkExternalSemaphoreHandleTypeFlags is a bitmask type for setting a mask of zero or more VkExternalSemaphoreHandleTypeFlagBits.

See Also
VkExportSemaphoreCreateInfo, VkExternalSemaphoreHandleTypeFlagBits, VkExternalSemaphoreProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkExternalSemaphoreHandleTypeFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFenceCreateFlags(3)
Name
VkFenceCreateFlags - Bitmask of VkFenceCreateFlagBits

C Specification
typedef VkFlags VkFenceCreateFlags;
Description
VkFenceCreateFlags is a bitmask type for setting a mask of zero or more VkFenceCreateFlagBits.

See Also
VkFenceCreateFlagBits, VkFenceCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFenceCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFenceImportFlags(3)
Name
VkFenceImportFlags - Bitmask of VkFenceImportFlagBits

C Specification
typedef VkFlags VkFenceImportFlags;
or the equivalent

typedef VkFenceImportFlags VkFenceImportFlagsKHR;
Description
VkFenceImportFlags is a bitmask type for setting a mask of zero or more VkFenceImportFlagBits.

See Also
VkFenceImportFlagBits, VkImportFenceFdInfoKHR, VkImportFenceWin32HandleInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFenceImportFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFormatFeatureFlags(3)
Name
VkFormatFeatureFlags - Bitmask of VkFormatFeatureFlagBits

C Specification
typedef VkFlags VkFormatFeatureFlags;
Description
VkFormatFeatureFlags is a bitmask type for setting a mask of zero or more VkFormatFeatureFlagBits.

See Also
VkAndroidHardwareBufferFormatPropertiesANDROID, VkDrmFormatModifierPropertiesEXT, VkFormatFeatureFlagBits, VkFormatProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFormatFeatureFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFramebufferCreateFlags(3)
Name
VkFramebufferCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkFramebufferCreateFlags;
Description
VkFramebufferCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkFramebufferCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFramebufferCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkGeometryFlagsNV(3)
Name
VkGeometryFlagsNV - Bitmask of VkGeometryFlagBitsNV

C Specification
typedef VkFlags VkGeometryFlagsNV;
Description
VkGeometryFlagsNV is a bitmask type for setting a mask of zero or more VkGeometryFlagBitsNV.

See Also
VkGeometryFlagBitsNV, VkGeometryNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkGeometryFlagsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkGeometryInstanceFlagsNV(3)
Name
VkGeometryInstanceFlagsNV - Bitmask of VkGeometryInstanceFlagBitsNV

C Specification
typedef VkFlags VkGeometryInstanceFlagsNV;
Description
VkGeometryInstanceFlagsNV is a bitmask type for setting a mask of zero or more VkGeometryInstanceFlagBitsNV.

See Also
VkGeometryInstanceFlagBitsNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkGeometryInstanceFlagsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Unresolved directive in apispec.txt - include::VkIOSSurfaceCreateFlagsMVK.txt[]

VkImageAspectFlags(3)
Name
VkImageAspectFlags - Bitmask of VkImageAspectFlagBits

C Specification
typedef VkFlags VkImageAspectFlags;
Description
VkImageAspectFlags is a bitmask type for setting a mask of zero or more VkImageAspectFlagBits.

See Also
VkAttachmentReference2KHR, VkClearAttachment, VkImageAspectFlagBits, VkImageSubresource, VkImageSubresourceLayers, VkImageSubresourceRange, VkInputAttachmentAspectReference, VkSparseImageFormatProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageAspectFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageCreateFlags(3)
Name
VkImageCreateFlags - Bitmask of VkImageCreateFlagBits

C Specification
typedef VkFlags VkImageCreateFlags;
Description
VkImageCreateFlags is a bitmask type for setting a mask of zero or more VkImageCreateFlagBits.

See Also
VkImageCreateFlagBits, VkImageCreateInfo, VkPhysicalDeviceImageFormatInfo2, vkGetPhysicalDeviceExternalImageFormatPropertiesNV, vkGetPhysicalDeviceImageFormatProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Unresolved directive in apispec.txt - include::VkImagePipeSurfaceCreateFlagsFUCHSIA.txt[]

VkImageUsageFlags(3)
Name
VkImageUsageFlags - Bitmask of VkImageUsageFlagBits

C Specification
typedef VkFlags VkImageUsageFlags;
Description
VkImageUsageFlags is a bitmask type for setting a mask of zero or more VkImageUsageFlagBits.

See Also
VkImageCreateInfo, VkImageStencilUsageCreateInfoEXT, VkImageUsageFlagBits, VkImageViewUsageCreateInfo, VkPhysicalDeviceImageFormatInfo2, VkPhysicalDeviceSparseImageFormatInfo2, VkSharedPresentSurfaceCapabilitiesKHR, VkSurfaceCapabilities2EXT, VkSurfaceCapabilitiesKHR, VkSwapchainCreateInfoKHR, vkGetPhysicalDeviceExternalImageFormatPropertiesNV, vkGetPhysicalDeviceImageFormatProperties, vkGetPhysicalDeviceSparseImageFormatProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageUsageFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkImageViewCreateFlags(3)
Name
VkImageViewCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkImageViewCreateFlags;
Description
VkImageViewCreateFlags is a bitmask type for setting a mask of zero or more VkImageViewCreateFlagBits.

See Also
VkImageViewCreateFlagBits, VkImageViewCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkImageViewCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkIndirectCommandsLayoutUsageFlagsNVX(3)
Name
VkIndirectCommandsLayoutUsageFlagsNVX - Bitmask of VkIndirectCommandsLayoutUsageFlagBitsNVX

C Specification
typedef VkFlags VkIndirectCommandsLayoutUsageFlagsNVX;
Description
VkIndirectCommandsLayoutUsageFlagsNVX is a bitmask type for setting a mask of zero or more VkIndirectCommandsLayoutUsageFlagBitsNVX.

See Also
VkIndirectCommandsLayoutCreateInfoNVX, VkIndirectCommandsLayoutUsageFlagBitsNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkIndirectCommandsLayoutUsageFlagsNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkInstanceCreateFlags(3)
Name
VkInstanceCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkInstanceCreateFlags;
Description
VkInstanceCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkInstanceCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkInstanceCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Unresolved directive in apispec.txt - include::VkMacOSSurfaceCreateFlagsMVK.txt[]

VkMemoryAllocateFlags(3)
Name
VkMemoryAllocateFlags - Bitmask of VkMemoryAllocateFlagBits

C Specification
typedef VkFlags VkMemoryAllocateFlags;
or the equivalent

typedef VkMemoryAllocateFlags VkMemoryAllocateFlagsKHR;
Description
VkMemoryAllocateFlags is a bitmask type for setting a mask of zero or more VkMemoryAllocateFlagBits.

See Also
VkMemoryAllocateFlagBits, VkMemoryAllocateFlagsInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryAllocateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryHeapFlags(3)
Name
VkMemoryHeapFlags - Bitmask of VkMemoryHeapFlagBits

C Specification
typedef VkFlags VkMemoryHeapFlags;
Description
VkMemoryHeapFlags is a bitmask type for setting a mask of zero or more VkMemoryHeapFlagBits.

See Also
VkMemoryHeap, VkMemoryHeapFlagBits

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryHeapFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryMapFlags(3)
Name
VkMemoryMapFlags - Reserved for future use

C Specification
typedef VkFlags VkMemoryMapFlags;
Description
VkMemoryMapFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
vkMapMemory

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryMapFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkMemoryPropertyFlags(3)
Name
VkMemoryPropertyFlags - Bitmask of VkMemoryPropertyFlagBits

C Specification
typedef VkFlags VkMemoryPropertyFlags;
Description
VkMemoryPropertyFlags is a bitmask type for setting a mask of zero or more VkMemoryPropertyFlagBits.

See Also
VkMemoryPropertyFlagBits, VkMemoryType

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkMemoryPropertyFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Unresolved directive in apispec.txt - include::VkMetalSurfaceCreateFlagsEXT.txt[]

VkObjectEntryUsageFlagsNVX(3)
Name
VkObjectEntryUsageFlagsNVX - Bitmask of VkObjectEntryUsageFlagBitsNVX

C Specification
typedef VkFlags VkObjectEntryUsageFlagsNVX;
Description
VkObjectEntryUsageFlagsNVX is a bitmask type for setting a mask of zero or more VkObjectEntryUsageFlagBitsNVX.

See Also
VkObjectEntryUsageFlagBitsNVX, VkObjectTableCreateInfoNVX, VkObjectTableDescriptorSetEntryNVX, VkObjectTableEntryNVX, VkObjectTableIndexBufferEntryNVX, VkObjectTablePipelineEntryNVX, VkObjectTablePushConstantEntryNVX, VkObjectTableVertexBufferEntryNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkObjectEntryUsageFlagsNVX

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPeerMemoryFeatureFlags(3)
Name
VkPeerMemoryFeatureFlags - Bitmask of VkPeerMemoryFeatureFlagBits

C Specification
typedef VkFlags VkPeerMemoryFeatureFlags;
or the equivalent

typedef VkPeerMemoryFeatureFlags VkPeerMemoryFeatureFlagsKHR;
Description
VkPeerMemoryFeatureFlags is a bitmask type for setting a mask of zero or more VkPeerMemoryFeatureFlagBits.

See Also
VkPeerMemoryFeatureFlagBits, vkGetDeviceGroupPeerMemoryFeatures, vkGetDeviceGroupPeerMemoryFeaturesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPeerMemoryFeatureFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCacheCreateFlags(3)
Name
VkPipelineCacheCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkPipelineCacheCreateFlags;
Description
VkPipelineCacheCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineCacheCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCacheCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineColorBlendStateCreateFlags(3)
Name
VkPipelineColorBlendStateCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkPipelineColorBlendStateCreateFlags;
Description
VkPipelineColorBlendStateCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineColorBlendStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineColorBlendStateCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCoverageModulationStateCreateFlagsNV(3)
Name
VkPipelineCoverageModulationStateCreateFlagsNV - Reserved for future use

C Specification
typedef VkFlags VkPipelineCoverageModulationStateCreateFlagsNV;
Description
VkPipelineCoverageModulationStateCreateFlagsNV is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineCoverageModulationStateCreateInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCoverageModulationStateCreateFlagsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCoverageToColorStateCreateFlagsNV(3)
Name
VkPipelineCoverageToColorStateCreateFlagsNV - Reserved for future use

C Specification
typedef VkFlags VkPipelineCoverageToColorStateCreateFlagsNV;
Description
VkPipelineCoverageToColorStateCreateFlagsNV is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineCoverageToColorStateCreateInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCoverageToColorStateCreateFlagsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCreateFlags(3)
Name
VkPipelineCreateFlags - Bitmask of VkPipelineCreateFlagBits

C Specification
typedef VkFlags VkPipelineCreateFlags;
Description
VkPipelineCreateFlags is a bitmask type for setting a mask of zero or more VkPipelineCreateFlagBits.

See Also
VkComputePipelineCreateInfo, VkGraphicsPipelineCreateInfo, VkPipelineCreateFlagBits, VkRayTracingPipelineCreateInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineCreationFeedbackFlagsEXT(3)
Name
VkPipelineCreationFeedbackFlagsEXT - Bitmask of VkPipelineCreationFeedbackFlagBitsEXT

C Specification
typedef VkFlags VkPipelineCreationFeedbackFlagsEXT;
Description
VkPipelineCreationFeedbackFlagsEXT is a bitmask type for providing zero or more VkPipelineCreationFeedbackFlagBitsEXT.

See Also
VkPipelineCreationFeedbackEXT, VkPipelineCreationFeedbackFlagBitsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineCreationFeedbackFlagsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineDepthStencilStateCreateFlags(3)
Name
VkPipelineDepthStencilStateCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkPipelineDepthStencilStateCreateFlags;
Description
VkPipelineDepthStencilStateCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineDepthStencilStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineDepthStencilStateCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineDiscardRectangleStateCreateFlagsEXT(3)
Name
VkPipelineDiscardRectangleStateCreateFlagsEXT - Reserved for future use

C Specification
typedef VkFlags VkPipelineDiscardRectangleStateCreateFlagsEXT;
Description
VkPipelineDiscardRectangleStateCreateFlagsEXT is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineDiscardRectangleStateCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineDiscardRectangleStateCreateFlagsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineDynamicStateCreateFlags(3)
Name
VkPipelineDynamicStateCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkPipelineDynamicStateCreateFlags;
Description
VkPipelineDynamicStateCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineDynamicStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineDynamicStateCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineInputAssemblyStateCreateFlags(3)
Name
VkPipelineInputAssemblyStateCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkPipelineInputAssemblyStateCreateFlags;
Description
VkPipelineInputAssemblyStateCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineInputAssemblyStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineInputAssemblyStateCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineLayoutCreateFlags(3)
Name
VkPipelineLayoutCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkPipelineLayoutCreateFlags;
Description
VkPipelineLayoutCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineLayoutCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineLayoutCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineMultisampleStateCreateFlags(3)
Name
VkPipelineMultisampleStateCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkPipelineMultisampleStateCreateFlags;
Description
VkPipelineMultisampleStateCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineMultisampleStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineMultisampleStateCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineRasterizationConservativeStateCreateFlagsEXT(3)
Name
VkPipelineRasterizationConservativeStateCreateFlagsEXT - Reserved for future use

C Specification
typedef VkFlags VkPipelineRasterizationConservativeStateCreateFlagsEXT;
Description
VkPipelineRasterizationConservativeStateCreateFlagsEXT is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineRasterizationConservativeStateCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineRasterizationConservativeStateCreateFlagsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineRasterizationDepthClipStateCreateFlagsEXT(3)
Name
VkPipelineRasterizationDepthClipStateCreateFlagsEXT - Reserved for future use

C Specification
typedef VkFlags VkPipelineRasterizationDepthClipStateCreateFlagsEXT;
Description
VkPipelineRasterizationDepthClipStateCreateFlagsEXT is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineRasterizationDepthClipStateCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineRasterizationDepthClipStateCreateFlagsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineRasterizationStateCreateFlags(3)
Name
VkPipelineRasterizationStateCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkPipelineRasterizationStateCreateFlags;
Description
VkPipelineRasterizationStateCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineRasterizationStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineRasterizationStateCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineRasterizationStateStreamCreateFlagsEXT(3)
Name
VkPipelineRasterizationStateStreamCreateFlagsEXT - Reserved for future use

C Specification
typedef VkFlags VkPipelineRasterizationStateStreamCreateFlagsEXT;
Description
VkPipelineRasterizationStateStreamCreateFlagsEXT is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineRasterizationStateStreamCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineRasterizationStateStreamCreateFlagsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineShaderStageCreateFlags(3)
Name
VkPipelineShaderStageCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkPipelineShaderStageCreateFlags;
Description
VkPipelineShaderStageCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineShaderStageCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineShaderStageCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineStageFlags(3)
Name
VkPipelineStageFlags - Bitmask of VkPipelineStageFlagBits

C Specification
typedef VkFlags VkPipelineStageFlags;
Description
VkPipelineStageFlags is a bitmask type for setting a mask of zero or more VkPipelineStageFlagBits.

See Also
VkPipelineStageFlagBits, VkQueueFamilyCheckpointPropertiesNV, VkSubmitInfo, VkSubpassDependency, VkSubpassDependency2KHR, vkCmdPipelineBarrier, vkCmdResetEvent, vkCmdSetEvent, vkCmdWaitEvents

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineStageFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineTessellationStateCreateFlags(3)
Name
VkPipelineTessellationStateCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkPipelineTessellationStateCreateFlags;
Description
VkPipelineTessellationStateCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineTessellationStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineTessellationStateCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineVertexInputStateCreateFlags(3)
Name
VkPipelineVertexInputStateCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkPipelineVertexInputStateCreateFlags;
Description
VkPipelineVertexInputStateCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineVertexInputStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineVertexInputStateCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineViewportStateCreateFlags(3)
Name
VkPipelineViewportStateCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkPipelineViewportStateCreateFlags;
Description
VkPipelineViewportStateCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineViewportStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineViewportStateCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkPipelineViewportSwizzleStateCreateFlagsNV(3)
Name
VkPipelineViewportSwizzleStateCreateFlagsNV - Reserved for future use

C Specification
typedef VkFlags VkPipelineViewportSwizzleStateCreateFlagsNV;
Description
VkPipelineViewportSwizzleStateCreateFlagsNV is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkPipelineViewportSwizzleStateCreateInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkPipelineViewportSwizzleStateCreateFlagsNV

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueryControlFlags(3)
Name
VkQueryControlFlags - Bitmask of VkQueryControlFlagBits

C Specification
typedef VkFlags VkQueryControlFlags;
Description
VkQueryControlFlags is a bitmask type for setting a mask of zero or more VkQueryControlFlagBits.

See Also
VkCommandBufferInheritanceInfo, VkQueryControlFlagBits, vkCmdBeginQuery, vkCmdBeginQueryIndexedEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueryControlFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueryPipelineStatisticFlags(3)
Name
VkQueryPipelineStatisticFlags - Bitmask of VkQueryPipelineStatisticFlagBits

C Specification
typedef VkFlags VkQueryPipelineStatisticFlags;
Description
VkQueryPipelineStatisticFlags is a bitmask type for setting a mask of zero or more VkQueryPipelineStatisticFlagBits.

See Also
VkCommandBufferInheritanceInfo, VkQueryPipelineStatisticFlagBits, VkQueryPoolCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueryPipelineStatisticFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueryPoolCreateFlags(3)
Name
VkQueryPoolCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkQueryPoolCreateFlags;
Description
VkQueryPoolCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkQueryPoolCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueryPoolCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueryResultFlags(3)
Name
VkQueryResultFlags - Bitmask of VkQueryResultFlagBits

C Specification
typedef VkFlags VkQueryResultFlags;
Description
VkQueryResultFlags is a bitmask type for setting a mask of zero or more VkQueryResultFlagBits.

See Also
VkQueryResultFlagBits, vkCmdCopyQueryPoolResults, vkGetQueryPoolResults

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueryResultFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkQueueFlags(3)
Name
VkQueueFlags - Bitmask of VkQueueFlagBits

C Specification
typedef VkFlags VkQueueFlags;
Description
VkQueueFlags is a bitmask type for setting a mask of zero or more VkQueueFlagBits.

See Also
VkQueueFamilyProperties, VkQueueFlagBits

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkQueueFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkRenderPassCreateFlags(3)
Name
VkRenderPassCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkRenderPassCreateFlags;
Description
VkRenderPassCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkRenderPassCreateInfo, VkRenderPassCreateInfo2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkRenderPassCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkResolveModeFlagsKHR(3)
Name
VkResolveModeFlagsKHR - Bitmask of VkResolveModeFlagBitsKHR

C Specification
typedef VkFlags VkResolveModeFlagsKHR;
Description
VkResolveModeFlagsKHR is a bitmask type for setting a mask of zero or more VkResolveModeFlagBitsKHR.

See Also
VkPhysicalDeviceDepthStencilResolvePropertiesKHR, VkResolveModeFlagBitsKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkResolveModeFlagsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSampleCountFlags(3)
Name
VkSampleCountFlags - Bitmask of VkSampleCountFlagBits

C Specification
typedef VkFlags VkSampleCountFlags;
Description
VkSampleCountFlags is a bitmask type for setting a mask of zero or more VkSampleCountFlagBits.

See Also
VkImageFormatProperties, VkPhysicalDeviceLimits, VkPhysicalDeviceSampleLocationsPropertiesEXT, VkSampleCountFlagBits

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSampleCountFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSamplerCreateFlags(3)
Name
VkSamplerCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkSamplerCreateFlags;
Description
VkSamplerCreateFlags is a bitmask type for setting a mask of zero or more VkSamplerCreateFlagBits.

See Also
VkSamplerCreateFlagBits, VkSamplerCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSemaphoreCreateFlags(3)
Name
VkSemaphoreCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkSemaphoreCreateFlags;
Description
VkSemaphoreCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkSemaphoreCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSemaphoreCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSemaphoreImportFlags(3)
Name
VkSemaphoreImportFlags - Bitmask of VkSemaphoreImportFlagBits

C Specification
typedef VkFlags VkSemaphoreImportFlags;
or the equivalent

typedef VkSemaphoreImportFlags VkSemaphoreImportFlagsKHR;
Description
VkSemaphoreImportFlags is a bitmask type for setting a mask of zero or more VkSemaphoreImportFlagBits.

See Also
VkImportSemaphoreFdInfoKHR, VkImportSemaphoreWin32HandleInfoKHR, VkSemaphoreImportFlagBits

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSemaphoreImportFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkShaderModuleCreateFlags(3)
Name
VkShaderModuleCreateFlags - Reserved for future use

C Specification
typedef VkFlags VkShaderModuleCreateFlags;
Description
VkShaderModuleCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkShaderModuleCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkShaderModuleCreateFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkShaderStageFlags(3)
Name
VkShaderStageFlags - Bitmask of VkShaderStageFlagBits

C Specification
typedef VkFlags VkShaderStageFlags;
Description
VkShaderStageFlags is a bitmask type for setting a mask of zero or more VkShaderStageFlagBits.

See Also
VkDescriptorSetLayoutBinding, VkObjectTablePushConstantEntryNVX, VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkPhysicalDeviceSubgroupProperties, VkPushConstantRange, VkShaderStageFlagBits, VkShaderStatisticsInfoAMD, vkCmdPushConstants

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkShaderStageFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSparseImageFormatFlags(3)
Name
VkSparseImageFormatFlags - Bitmask of VkSparseImageFormatFlagBits

C Specification
typedef VkFlags VkSparseImageFormatFlags;
Description
VkSparseImageFormatFlags is a bitmask type for setting a mask of zero or more VkSparseImageFormatFlagBits.

See Also
VkSparseImageFormatFlagBits, VkSparseImageFormatProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSparseImageFormatFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSparseMemoryBindFlags(3)
Name
VkSparseMemoryBindFlags - Bitmask of VkSparseMemoryBindFlagBits

C Specification
typedef VkFlags VkSparseMemoryBindFlags;
Description
VkSparseMemoryBindFlags is a bitmask type for setting a mask of zero or more VkSparseMemoryBindFlagBits.

See Also
VkSparseImageMemoryBind, VkSparseMemoryBind, VkSparseMemoryBindFlagBits

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSparseMemoryBindFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkStencilFaceFlags(3)
Name
VkStencilFaceFlags - Bitmask of VkStencilFaceFlagBits

C Specification
typedef VkFlags VkStencilFaceFlags;
Description
VkStencilFaceFlags is a bitmask type for setting a mask of zero or more VkStencilFaceFlagBits.

See Also
VkStencilFaceFlagBits, vkCmdSetStencilCompareMask, vkCmdSetStencilReference, vkCmdSetStencilWriteMask

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkStencilFaceFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Unresolved directive in apispec.txt - include::VkStreamDescriptorSurfaceCreateFlagsGGP.txt[]

VkSubgroupFeatureFlags(3)
Name
VkSubgroupFeatureFlags - Bitmask of VkSubgroupFeatureFlagBits

C Specification
typedef VkFlags VkSubgroupFeatureFlags;
Description
VkSubgroupFeatureFlags is a bitmask type for setting a mask of zero or more VkSubgroupFeatureFlagBits.

See Also
VkPhysicalDeviceSubgroupProperties, VkSubgroupFeatureFlagBits

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubgroupFeatureFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSubpassDescriptionFlags(3)
Name
VkSubpassDescriptionFlags - Bitmask of VkSubpassDescriptionFlagBits

C Specification
typedef VkFlags VkSubpassDescriptionFlags;
Description
VkSubpassDescriptionFlags is a bitmask type for setting a mask of zero or more VkSubpassDescriptionFlagBits.

See Also
VkSubpassDescription, VkSubpassDescription2KHR, VkSubpassDescriptionFlagBits

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSubpassDescriptionFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceCounterFlagsEXT(3)
Name
VkSurfaceCounterFlagsEXT - Bitmask of VkSurfaceCounterFlagBitsEXT

C Specification
typedef VkFlags VkSurfaceCounterFlagsEXT;
Description
VkSurfaceCounterFlagsEXT is a bitmask type for setting a mask of zero or more VkSurfaceCounterFlagBitsEXT.

See Also
VkSurfaceCapabilities2EXT, VkSurfaceCounterFlagBitsEXT, VkSwapchainCounterCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceCounterFlagsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSurfaceTransformFlagsKHR(3)
Name
VkSurfaceTransformFlagsKHR - Bitmask of VkSurfaceTransformFlagBitsKHR

C Specification
typedef VkFlags VkSurfaceTransformFlagsKHR;
Description
VkSurfaceTransformFlagsKHR is a bitmask type for setting a mask of zero or more VkSurfaceTransformFlagBitsKHR.

See Also
VkDisplayPropertiesKHR, VkSurfaceCapabilities2EXT, VkSurfaceCapabilitiesKHR, VkSurfaceTransformFlagBitsKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSurfaceTransformFlagsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSwapchainCreateFlagsKHR(3)
Name
VkSwapchainCreateFlagsKHR - Bitmask of VkSwapchainCreateFlagBitsKHR

C Specification
typedef VkFlags VkSwapchainCreateFlagsKHR;
Description
VkSwapchainCreateFlagsKHR is a bitmask type for setting a mask of zero or more VkSwapchainCreateFlagBitsKHR.

See Also
VkSwapchainCreateFlagBitsKHR, VkSwapchainCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSwapchainCreateFlagsKHR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkValidationCacheCreateFlagsEXT(3)
Name
VkValidationCacheCreateFlagsEXT - Reserved for future use

C Specification
typedef VkFlags VkValidationCacheCreateFlagsEXT;
Description
VkValidationCacheCreateFlagsEXT is a bitmask type for setting a mask, but is currently reserved for future use.

See Also
VkValidationCacheCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkValidationCacheCreateFlagsEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Unresolved directive in apispec.txt - include::VkViSurfaceCreateFlagsNN.txt[] Unresolved directive in apispec.txt - include::VkWaylandSurfaceCreateFlagsKHR.txt[] Unresolved directive in apispec.txt - include::VkWin32SurfaceCreateFlagsKHR.txt[] Unresolved directive in apispec.txt - include::VkXcbSurfaceCreateFlagsKHR.txt[] Unresolved directive in apispec.txt - include::VkXlibSurfaceCreateFlagsKHR.txt[]

Function Pointer Types
PFN_vkAllocationFunction(3)
Name
PFN_vkAllocationFunction - Application-defined memory allocation function

C Specification
The type of pfnAllocation is:

typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);
Parameters
pUserData is the value specified for VkAllocationCallbacks::pUserData in the allocator specified by the application.
size is the size in bytes of the requested allocation.
alignment is the requested alignment of the allocation in bytes and must be a power of two.
allocationScope is a VkSystemAllocationScope value specifying the allocation scope of the lifetime of the allocation, as described here.
Description
If pfnAllocation is unable to allocate the requested memory, it must return NULL. If the allocation was successful, it must return a valid pointer to memory allocation containing at least size bytes, and with the pointer value being a multiple of alignment.

Note
Correct Vulkan operation cannot be assumed if the application does not follow these rules.

For example, pfnAllocation (or pfnReallocation) could cause termination of running Vulkan instance(s) on a failed allocation for debugging purposes, either directly or indirectly. In these circumstances, it cannot be assumed that any part of any affected VkInstance objects are going to operate correctly (even vkDestroyInstance), and the application must ensure it cleans up properly via other means (e.g. process termination).
If pfnAllocation returns NULL, and if the implementation is unable to continue correct processing of the current command without the requested allocation, it must treat this as a run-time error, and generate VK_ERROR_OUT_OF_HOST_MEMORY at the appropriate time for the command in which the condition was detected, as described in Return Codes.

If the implementation is able to continue correct processing of the current command without the requested allocation, then it may do so, and must not generate VK_ERROR_OUT_OF_HOST_MEMORY as a result of this failed allocation.

See Also
VkAllocationCallbacks

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#PFN_vkAllocationFunction

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

PFN_vkDebugReportCallbackEXT(3)
Name
PFN_vkDebugReportCallbackEXT - Application-defined debug report callback function

C Specification
The prototype for the VkDebugReportCallbackCreateInfoEXT::pfnCallback function implemented by the application is:

typedef VkBool32 (VKAPI_PTR *PFN_vkDebugReportCallbackEXT)(
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    const char*                                 pLayerPrefix,
    const char*                                 pMessage,
    void*                                       pUserData);
Parameters
flags specifies the VkDebugReportFlagBitsEXT that triggered this callback.
objectType is a VkDebugReportObjectTypeEXT value specifying the type of object being used or created at the time the event was triggered.
object is the object where the issue was detected. If objectType is VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT, object is undefined.
location is a component (layer, driver, loader) defined value that specifies the location of the trigger. This is an optional value.
messageCode is a layer-defined value indicating what test triggered this callback.
pLayerPrefix is a null-terminated string that is an abbreviation of the name of the component making the callback. pLayerPrefix is only valid for the duration of the callback.
pMessage is a null-terminated string detailing the trigger conditions. pMessage is only valid for the duration of the callback.
pUserData is the user data given when the VkDebugReportCallbackEXT was created.
Description
The callback must not call vkDestroyDebugReportCallbackEXT.

The callback returns a VkBool32, which is interpreted in a layer-specified manner. The application should always return VK_FALSE. The VK_TRUE value is reserved for use in layer development.

object must be a Vulkan object or VK_NULL_HANDLE. If objectType is not VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT and object is not VK_NULL_HANDLE, object must be a Vulkan object of the corresponding type associated with objectType as defined in html/vkspec.html#debug-report-object-types.

See Also
VkDebugReportCallbackCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#PFN_vkDebugReportCallbackEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

PFN_vkDebugUtilsMessengerCallbackEXT(3)
Name
PFN_vkDebugUtilsMessengerCallbackEXT - Application-defined debug messenger callback function

C Specification
The prototype for the VkDebugUtilsMessengerCreateInfoEXT::pfnUserCallback function implemented by the application is:

typedef VkBool32 (VKAPI_PTR *PFN_vkDebugUtilsMessengerCallbackEXT)(
    VkDebugUtilsMessageSeverityFlagBitsEXT           messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT                  messageTypes,
    const VkDebugUtilsMessengerCallbackDataEXT*      pCallbackData,
    void*                                            pUserData);
Parameters
messageSeverity specifies the VkDebugUtilsMessageSeverityFlagBitsEXT that triggered this callback.
messageTypes is a bitmask of VkDebugUtilsMessageTypeFlagBitsEXT specifying which type of event(s) triggered this callback.
pCallbackData contains all the callback related data in the VkDebugUtilsMessengerCallbackDataEXT structure.
pUserData is the user data provided when the VkDebugUtilsMessengerEXT was created.
Description
The callback must not call vkDestroyDebugUtilsMessengerEXT.

The callback returns a VkBool32, which is interpreted in a layer-specified manner. The application should always return VK_FALSE. The VK_TRUE value is reserved for use in layer development.

See Also
VkDebugUtilsMessengerCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#PFN_vkDebugUtilsMessengerCallbackEXT

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

PFN_vkFreeFunction(3)
Name
PFN_vkFreeFunction - Application-defined memory free function

C Specification
The type of pfnFree is:

typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory);
Parameters
pUserData is the value specified for VkAllocationCallbacks::pUserData in the allocator specified by the application.
pMemory is the allocation to be freed.
Description
pMemory may be NULL, which the callback must handle safely. If pMemory is non-NULL, it must be a pointer previously allocated by pfnAllocation or pfnReallocation. The application should free this memory.

See Also
VkAllocationCallbacks

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#PFN_vkFreeFunction

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

PFN_vkInternalAllocationNotification(3)
Name
PFN_vkInternalAllocationNotification - Application-defined memory allocation notification function

C Specification
The type of pfnInternalAllocation is:

typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);
Parameters
pUserData is the value specified for VkAllocationCallbacks::pUserData in the allocator specified by the application.
size is the requested size of an allocation.
allocationType is a VkInternalAllocationType value specifying the requested type of an allocation.
allocationScope is a VkSystemAllocationScope value specifying the allocation scope of the lifetime of the allocation, as described here.
Description
This is a purely informational callback.

See Also
VkAllocationCallbacks

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#PFN_vkInternalAllocationNotification

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

PFN_vkInternalFreeNotification(3)
Name
PFN_vkInternalFreeNotification - Application-defined memory free notification function

C Specification
The type of pfnInternalFree is:

typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    VkInternalAllocationType                    allocationType,
    VkSystemAllocationScope                     allocationScope);
Parameters
pUserData is the value specified for VkAllocationCallbacks::pUserData in the allocator specified by the application.
size is the requested size of an allocation.
allocationType is a VkInternalAllocationType value specifying the requested type of an allocation.
allocationScope is a VkSystemAllocationScope value specifying the allocation scope of the lifetime of the allocation, as described here.
Description
See Also
VkAllocationCallbacks

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#PFN_vkInternalFreeNotification

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

PFN_vkReallocationFunction(3)
Name
PFN_vkReallocationFunction - Application-defined memory reallocation function

C Specification
The type of pfnReallocation is:

typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    VkSystemAllocationScope                     allocationScope);
Parameters
pUserData is the value specified for VkAllocationCallbacks::pUserData in the allocator specified by the application.
pOriginal must be either NULL or a pointer previously returned by pfnReallocation or pfnAllocation of the same allocator.
size is the size in bytes of the requested allocation.
alignment is the requested alignment of the allocation in bytes and must be a power of two.
allocationScope is a VkSystemAllocationScope value specifying the allocation scope of the lifetime of the allocation, as described here.
Description
pfnReallocation must return an allocation with enough space for size bytes, and the contents of the original allocation from bytes zero to min(original size, new size) - 1 must be preserved in the returned allocation. If size is larger than the old size, the contents of the additional space are undefined. If satisfying these requirements involves creating a new allocation, then the old allocation should be freed.

If pOriginal is NULL, then pfnReallocation must behave equivalently to a call to PFN_vkAllocationFunction with the same parameter values (without pOriginal).

If size is zero, then pfnReallocation must behave equivalently to a call to PFN_vkFreeFunction with the same pUserData parameter value, and pMemory equal to pOriginal.

If pOriginal is non-NULL, the implementation must ensure that alignment is equal to the alignment used to originally allocate pOriginal.

If this function fails and pOriginal is non-NULL the application must not free the old allocation.

pfnReallocation must follow the same rules for return values as PFN_vkAllocationFunction.

See Also
VkAllocationCallbacks

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#PFN_vkReallocationFunction

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

PFN_vkVoidFunction(3)
Name
PFN_vkVoidFunction - Dummy function pointer type returned by queries

C Specification
The definition of PFN_vkVoidFunction is:

typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void);
Parameters
Description
See Also
vkGetDeviceProcAddr, vkGetInstanceProcAddr

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#PFN_vkVoidFunction

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Vulkan Scalar types
VkBool32(3)
Name
VkBool32 - Vulkan boolean type

C Specification
VkBool32 represents boolean True and False values, since C does not have a sufficiently portable built-in boolean type:

typedef uint32_t VkBool32;
Description
VK_TRUE represents a boolean True (integer 1) value, and VK_FALSE a boolean False (integer 0) value.

All values returned from a Vulkan implementation in a VkBool32 will be either VK_TRUE or VK_FALSE.

Applications must not pass any other values than VK_TRUE or VK_FALSE into a Vulkan implementation where a VkBool32 is expected.

See Also
VkCommandBufferInheritanceConditionalRenderingInfoEXT, VkCommandBufferInheritanceInfo, VkDedicatedAllocationBufferCreateInfoNV, VkDedicatedAllocationImageCreateInfoNV, VkDescriptorSetLayoutSupport, VkDeviceGeneratedCommandsFeaturesNVX, VkDisplayNativeHdrSurfaceCapabilitiesAMD, VkDisplayPresentInfoKHR, VkDisplayPropertiesKHR, VkFilterCubicImageViewImageFormatPropertiesEXT, VkMemoryDedicatedRequirements, VkPhysicalDevice16BitStorageFeatures, VkPhysicalDevice8BitStorageFeaturesKHR, VkPhysicalDeviceASTCDecodeFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, VkPhysicalDeviceConditionalRenderingFeaturesEXT, VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPhysicalDeviceCooperativeMatrixFeaturesNV, VkPhysicalDeviceCornerSampledImageFeaturesNV, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, VkPhysicalDeviceDepthClipEnableFeaturesEXT, VkPhysicalDeviceDepthStencilResolvePropertiesKHR, VkPhysicalDeviceDescriptorIndexingFeaturesEXT, VkPhysicalDeviceDescriptorIndexingPropertiesEXT, VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPhysicalDeviceFeatures, VkPhysicalDeviceFloat16Int8FeaturesKHR, VkPhysicalDeviceFloatControlsPropertiesKHR, VkPhysicalDeviceFragmentDensityMapFeaturesEXT, VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, VkPhysicalDeviceGroupProperties, VkPhysicalDeviceHostQueryResetFeaturesEXT, VkPhysicalDeviceIDProperties, VkPhysicalDeviceInlineUniformBlockFeaturesEXT, VkPhysicalDeviceLimits, VkPhysicalDeviceMemoryPriorityFeaturesEXT, VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceProtectedMemoryProperties, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, VkPhysicalDeviceSamplerYcbcrConversionFeatures, VkPhysicalDeviceScalarBlockLayoutFeaturesEXT, VkPhysicalDeviceShaderAtomicInt64FeaturesKHR, VkPhysicalDeviceShaderDrawParametersFeatures, VkPhysicalDeviceShaderImageFootprintFeaturesNV, VkPhysicalDeviceShadingRateImageFeaturesNV, VkPhysicalDeviceSparseProperties, VkPhysicalDeviceSubgroupProperties, VkPhysicalDeviceTransformFeedbackFeaturesEXT, VkPhysicalDeviceTransformFeedbackPropertiesEXT, VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, VkPipelineColorBlendAdvancedStateCreateInfoEXT, VkPipelineColorBlendAttachmentState, VkPipelineColorBlendStateCreateInfo, VkPipelineCoverageModulationStateCreateInfoNV, VkPipelineCoverageToColorStateCreateInfoNV, VkPipelineDepthStencilStateCreateInfo, VkPipelineInputAssemblyStateCreateInfo, VkPipelineMultisampleStateCreateInfo, VkPipelineRasterizationDepthClipStateCreateInfoEXT, VkPipelineRasterizationStateCreateInfo, VkPipelineRepresentativeFragmentTestStateCreateInfoNV, VkPipelineSampleLocationsStateCreateInfoEXT, VkPipelineViewportShadingRateImageStateCreateInfoNV, VkPipelineViewportWScalingStateCreateInfoNV, VkProtectedSubmitInfo, VkSamplerCreateInfo, VkSamplerYcbcrConversionCreateInfo, VkSurfaceCapabilitiesFullScreenExclusiveEXT, VkSurfaceProtectedCapabilitiesKHR, VkSwapchainCreateInfoKHR, VkSwapchainDisplayNativeHdrCreateInfoAMD, VkTextureLODGatherFormatPropertiesAMD, vkCmdBuildAccelerationStructureNV, vkGetPhysicalDeviceSurfaceSupportKHR, vkSetLocalDimmingAMD, vkWaitForFences

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkBool32

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceAddress(3)
Name
VkDeviceAddress - Vulkan device address type

C Specification
VkDeviceAddress represents device buffer address values:

typedef uint64_t VkDeviceAddress;
Description
See Also
VkBufferDeviceAddressCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceAddress

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkDeviceSize(3)
Name
VkDeviceSize - Vulkan device memory size and offsets

C Specification
VkDeviceSize represents device memory size and offset values:

typedef uint64_t VkDeviceSize;
Description
See Also
VkAccelerationStructureCreateInfoNV, VkAndroidHardwareBufferPropertiesANDROID, VkBindAccelerationStructureMemoryInfoNV, VkBindBufferMemoryInfo, VkBindImageMemoryInfo, VkBufferCopy, VkBufferCreateInfo, VkBufferImageCopy, VkBufferMemoryBarrier, VkBufferViewCreateInfo, VkCmdProcessCommandsInfoNVX, VkConditionalRenderingBeginInfoEXT, VkDescriptorBufferInfo, VkGeometryAABBNV, VkGeometryTrianglesNV, VkImageFormatProperties, VkIndirectCommandsTokenNVX, VkMappedMemoryRange, VkMemoryAllocateInfo, VkMemoryHeap, VkMemoryRequirements, VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceLimits, VkPhysicalDeviceMaintenance3Properties, VkPhysicalDeviceMemoryBudgetPropertiesEXT, VkPhysicalDeviceTransformFeedbackPropertiesEXT, VkSparseImageMemoryBind, VkSparseImageMemoryRequirements, VkSparseMemoryBind, VkSubresourceLayout, vkBindBufferMemory, vkBindImageMemory, vkCmdBeginTransformFeedbackEXT, vkCmdBindIndexBuffer, vkCmdBindTransformFeedbackBuffersEXT, vkCmdBindVertexBuffers, vkCmdBuildAccelerationStructureNV, vkCmdCopyQueryPoolResults, vkCmdDispatchIndirect, vkCmdDrawIndexedIndirect, vkCmdDrawIndexedIndirectCountAMD, vkCmdDrawIndexedIndirectCountKHR, vkCmdDrawIndirect, vkCmdDrawIndirectByteCountEXT, vkCmdDrawIndirectCountAMD, vkCmdDrawIndirectCountKHR, vkCmdDrawMeshTasksIndirectCountNV, vkCmdDrawMeshTasksIndirectNV, vkCmdEndTransformFeedbackEXT, vkCmdFillBuffer, vkCmdTraceRaysNV, vkCmdUpdateBuffer, vkCmdWriteBufferMarkerAMD, vkGetDeviceMemoryCommitment, vkGetQueryPoolResults, vkMapMemory

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkDeviceSize

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkFlags(3)
Name
VkFlags - Vulkan bitmasks

C Specification
A collection of flags is represented by a bitmask using the type VkFlags:

typedef uint32_t VkFlags;
Description
Bitmasks are passed to many commands and structures to compactly represent options, but VkFlags is not used directly in the API. Instead, a Vk*Flags type which is an alias of VkFlags, and whose name matches the corresponding Vk*FlagBits that are valid for that type, is used.

See Also
VkColorComponentFlags

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkFlags

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VkSampleMask(3)
Name
VkSampleMask - Mask of sample coverage information

C Specification
The elements of the sample mask array are of type VkSampleMask, each representing 32 bits of coverage information:

typedef uint32_t VkSampleMask;
Description
See Also
VkPipelineMultisampleStateCreateInfo

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSampleMask

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

C Macro Definitions
AHardwareBuffer(3)
Name
AHardwareBuffer - Android hardware buffer type

C Specification
To remove an unnecessary compile-time dependency, an incomplete type definition of AHardwareBuffer is provided in the Vulkan headers:

struct AHardwareBuffer;
Description
The actual AHardwareBuffer type is defined in Android NDK headers.

See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#AHardwareBuffer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

ANativeWindow(3)
Name
ANativeWindow - Android native window type

C Specification
To remove an unnecessary compile-time dependency, an incomplete type definition of ANativeWindow is provided in the Vulkan headers:

struct ANativeWindow;
Description
The actual ANativeWindow type is defined in Android NDK headers.

See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#ANativeWindow

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

CAMetalLayer(3)
Name
CAMetalLayer - CoreAnimation native layer type for Metal

C Specification
To remove an unnecessary compile-time dependency, an incomplete type definition of CAMetalLayer is provided in the Vulkan headers:

#ifdef __OBJC__
@class CAMetalLayer;
#else
typedef void CAMetalLayer;
#endif
Description
The actual CAMetalLayer type is defined in the QuartzCore framework.

See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#CAMetalLayer

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VK_API_VERSION(3)
Name
VK_API_VERSION - Deprecated version number macro

C Specification
VK_API_VERSION is now commented out of vulkan_core.h and cannot be used.

// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
//#define VK_API_VERSION VK_MAKE_VERSION(1, 0, 0) // Patch version should always be set to 0
Description
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_API_VERSION

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VK_API_VERSION_1_0(3)
Name
VK_API_VERSION_1_0 - Return API version number for Vulkan 1.0

C Specification
VK_API_VERSION_1_0 returns the API version number for Vulkan 1.0.0.

// Vulkan 1.0 version number
#define VK_API_VERSION_1_0 VK_MAKE_VERSION(1, 0, 0)// Patch version should always be set to 0
Description
See Also
vkCreateInstance, vkGetPhysicalDeviceProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_API_VERSION_1_0

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VK_API_VERSION_1_1(3)
Name
VK_API_VERSION_1_1 - Return API version number for Vulkan 1.1

C Specification
VK_API_VERSION_1_1 returns the API version number for Vulkan 1.1.0.

// Vulkan 1.1 version number
#define VK_API_VERSION_1_1 VK_MAKE_VERSION(1, 1, 0)// Patch version should always be set to 0
Description
See Also
vkCreateInstance, vkGetPhysicalDeviceProperties

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_API_VERSION_1_1

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VK_DEFINE_HANDLE(3)
Name
VK_DEFINE_HANDLE - Declare a dispatchable object handle

C Specification
VK_DEFINE_HANDLE defines a dispatchable handle type.

#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;
Description
object is the name of the resulting C type.
The only dispatchable handle types are those related to device and instance management, such as VkDevice.

See Also
VkCommandBuffer, VkDevice, VkInstance, VkPhysicalDevice, VkQueue

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_DEFINE_HANDLE

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VK_DEFINE_NON_DISPATCHABLE_HANDLE(3)
Name
VK_DEFINE_NON_DISPATCHABLE_HANDLE - Declare a non-dispatchable object handle

C Specification
VK_DEFINE_NON_DISPATCHABLE_HANDLE defines a non-dispatchable handle type.

#if !defined(VK_DEFINE_NON_DISPATCHABLE_HANDLE)
#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
#endif
Description
object is the name of the resulting C type.
Most Vulkan handle types, such as VkBuffer, are non-dispatchable.

Note
The vulkan_core.h header allows the VK_DEFINE_NON_DISPATCHABLE_HANDLE definition to be overridden by the application. If VK_DEFINE_NON_DISPATCHABLE_HANDLE is already defined when vulkan_core.h is compiled, the default definition is skipped. This allows the application to define a binary-compatible custom handle which may provide more type-safety or other features needed by the application. Applications must not define handles in a way that is not binary compatible - where binary compatibility is platform dependent.
See Also
VkBuffer

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_DEFINE_NON_DISPATCHABLE_HANDLE

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VK_HEADER_VERSION(3)
Name
VK_HEADER_VERSION - Vulkan header file version number

C Specification
VK_HEADER_VERSION is the version number of the vulkan_core.h header. This value is kept synchronized with the patch version of the released Specification.

// Version of this file
#define VK_HEADER_VERSION 106
Description
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_HEADER_VERSION

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VK_MAKE_VERSION(3)
Name
VK_MAKE_VERSION - Construct an API version number

C Specification
VK_MAKE_VERSION constructs an API version number.

#define VK_MAKE_VERSION(major, minor, patch) \
    (((major) << 22) | ((minor) << 12) | (patch))
Description
major is the major version number.
minor is the minor version number.
patch is the patch version number.
See Also
VkApplicationInfo, vkCreateInstance

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_MAKE_VERSION

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VK_NULL_HANDLE(3)
Name
VK_NULL_HANDLE - Reserved non-valid object handle

C Specification
VK_NULL_HANDLE is a reserved value representing a non-valid object handle. It may be passed to and returned from Vulkan commands only when specifically allowed.

#define VK_NULL_HANDLE 0
Description
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NULL_HANDLE

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VK_VERSION_MAJOR(3)
Name
VK_VERSION_MAJOR - Extract API major version number

C Specification
VK_VERSION_MAJOR extracts the API major version number from a packed version number:

#define VK_VERSION_MAJOR(version) ((uint32_t)(version) >> 22)
Description
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_VERSION_MAJOR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VK_VERSION_MINOR(3)
Name
VK_VERSION_MINOR - Extract API minor version number

C Specification
VK_VERSION_MINOR extracts the API minor version number from a packed version number:

#define VK_VERSION_MINOR(version) (((uint32_t)(version) >> 12) & 0x3ff)
Description
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_VERSION_MINOR

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

VK_VERSION_PATCH(3)
Name
VK_VERSION_PATCH - Extract API patch version number

C Specification
VK_VERSION_PATCH extracts the API patch version number from a packed version number:

#define VK_VERSION_PATCH(version) ((uint32_t)(version) & 0xfff)
Description
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_VERSION_PATCH

This page is extracted from the Vulkan Specification. Fixes and changes should be made to the Specification, not directly.

Vulkan Extensions
VK_KHR_16bit_storage(3)
Name
VK_KHR_16bit_storage - device extension

Specification
See VK_KHR_16bit_storage in the main specification for complete information.

Registered Extension Number
84

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
Requires [VK_KHR_storage_buffer_storage_class]
Deprecation state
Promoted to Vulkan 1.1
See Also
VkPhysicalDevice16BitStorageFeaturesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_16bit_storage

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_8bit_storage(3)
Name
VK_KHR_8bit_storage - device extension

Specification
See VK_KHR_8bit_storage in the main specification for complete information.

Registered Extension Number
178

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
Requires [VK_KHR_storage_buffer_storage_class]
See Also
VkPhysicalDevice8BitStorageFeaturesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_8bit_storage

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_android_surface(3)
Name
VK_KHR_android_surface - instance extension

Specification
See VK_KHR_android_surface in the main specification for complete information.

Registered Extension Number
9

Revision
6

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
ANativeWindow, VkAndroidSurfaceCreateFlagsKHR, VkAndroidSurfaceCreateInfoKHR, vkCreateAndroidSurfaceKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_android_surface

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_bind_memory2(3)
Name
VK_KHR_bind_memory2 - device extension

Specification
See VK_KHR_bind_memory2 in the main specification for complete information.

Registered Extension Number
158

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Promoted to Vulkan 1.1
See Also
VkBindBufferMemoryInfoKHR, VkBindImageMemoryInfoKHR, vkBindBufferMemory2KHR, vkBindImageMemory2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_bind_memory2

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_create_renderpass2(3)
Name
VK_KHR_create_renderpass2 - device extension

Specification
See VK_KHR_create_renderpass2 in the main specification for complete information.

Registered Extension Number
110

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_multiview]
Requires [VK_KHR_maintenance2]
See Also
vkCmdBeginRenderPass2KHR, vkCmdEndRenderPass2KHR, vkCmdNextSubpass2KHR, vkCreateRenderPass2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_create_renderpass2

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_dedicated_allocation(3)
Name
VK_KHR_dedicated_allocation - device extension

Specification
See VK_KHR_dedicated_allocation in the main specification for complete information.

Registered Extension Number
128

Revision
3

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_memory_requirements2]
Deprecation state
Promoted to Vulkan 1.1
See Also
VkMemoryDedicatedAllocateInfoKHR, VkMemoryDedicatedRequirementsKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_dedicated_allocation

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_depth_stencil_resolve(3)
Name
VK_KHR_depth_stencil_resolve - device extension

Specification
See VK_KHR_depth_stencil_resolve in the main specification for complete information.

Registered Extension Number
200

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_create_renderpass2]
See Also
VkPhysicalDeviceDepthStencilResolvePropertiesKHR, VkResolveModeFlagBitsKHR, VkSubpassDescriptionDepthStencilResolveKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_depth_stencil_resolve

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_descriptor_update_template(3)
Name
VK_KHR_descriptor_update_template - device extension

Specification
See VK_KHR_descriptor_update_template in the main specification for complete information.

Registered Extension Number
86

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Promoted to Vulkan 1.1
See Also
VkDescriptorUpdateTemplateCreateFlagsKHR, VkDescriptorUpdateTemplateCreateInfoKHR, VkDescriptorUpdateTemplateEntryKHR, VkDescriptorUpdateTemplateKHR, VkDescriptorUpdateTemplateTypeKHR, vkCreateDescriptorUpdateTemplateKHR, vkDestroyDescriptorUpdateTemplateKHR, vkUpdateDescriptorSetWithTemplateKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_descriptor_update_template

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_device_group(3)
Name
VK_KHR_device_group - device extension

Specification
See VK_KHR_device_group in the main specification for complete information.

Registered Extension Number
61

Revision
3

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_device_group_creation]
Deprecation state
Promoted to Vulkan 1.1
See Also
VkDeviceGroupBindSparseInfoKHR, VkDeviceGroupCommandBufferBeginInfoKHR, VkDeviceGroupRenderPassBeginInfoKHR, VkDeviceGroupSubmitInfoKHR, VkMemoryAllocateFlagBitsKHR, VkMemoryAllocateFlagsInfoKHR, VkMemoryAllocateFlagsKHR, VkPeerMemoryFeatureFlagBitsKHR, VkPeerMemoryFeatureFlagsKHR, vkCmdDispatchBaseKHR, vkCmdSetDeviceMaskKHR, vkGetDeviceGroupPeerMemoryFeaturesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_device_group

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_device_group_creation(3)
Name
VK_KHR_device_group_creation - instance extension

Specification
See VK_KHR_device_group_creation in the main specification for complete information.

Registered Extension Number
71

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Promoted to Vulkan 1.1
See Also
UNKNOWN:VK_MAX_DEVICE_GROUP_SIZE_KHR, VkDeviceGroupDeviceCreateInfoKHR, VkPhysicalDeviceGroupPropertiesKHR, vkEnumeratePhysicalDeviceGroupsKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_device_group_creation

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_display(3)
Name
VK_KHR_display - instance extension

Specification
See VK_KHR_display in the main specification for complete information.

Registered Extension Number
3

Revision
21

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
VkDisplayModeCreateInfoKHR, VkDisplayModeParametersKHR, VkDisplayModePropertiesKHR, VkDisplayPlaneAlphaFlagBitsKHR, VkDisplayPlaneAlphaFlagsKHR, VkDisplayPlaneCapabilitiesKHR, VkDisplayPlanePropertiesKHR, VkDisplayPropertiesKHR, VkDisplaySurfaceCreateInfoKHR, vkCreateDisplayModeKHR, vkCreateDisplayPlaneSurfaceKHR, vkGetDisplayModePropertiesKHR, vkGetDisplayPlaneCapabilitiesKHR, vkGetDisplayPlaneSupportedDisplaysKHR, vkGetPhysicalDeviceDisplayPlanePropertiesKHR, vkGetPhysicalDeviceDisplayPropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_display

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_display_swapchain(3)
Name
VK_KHR_display_swapchain - device extension

Specification
See VK_KHR_display_swapchain in the main specification for complete information.

Registered Extension Number
4

Revision
9

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_swapchain]
Requires [VK_KHR_display]
See Also
VkDisplayPresentInfoKHR, vkCreateSharedSwapchainsKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_display_swapchain

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_draw_indirect_count(3)
Name
VK_KHR_draw_indirect_count - device extension

Specification
See VK_KHR_draw_indirect_count in the main specification for complete information.

Registered Extension Number
170

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
vkCmdDrawIndexedIndirectCountKHR, vkCmdDrawIndirectCountKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_draw_indirect_count

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_driver_properties(3)
Name
VK_KHR_driver_properties - device extension

Specification
See VK_KHR_driver_properties in the main specification for complete information.

Registered Extension Number
197

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
UNKNOWN:VK_MAX_DRIVER_INFO_SIZE_KHR, UNKNOWN:VK_MAX_DRIVER_NAME_SIZE_KHR, VkConformanceVersionKHR, VkDriverIdKHR, VkPhysicalDeviceDriverPropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_driver_properties

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_external_fence(3)
Name
VK_KHR_external_fence - device extension

Specification
See VK_KHR_external_fence in the main specification for complete information.

Registered Extension Number
114

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_external_fence_capabilities]
Deprecation state
Promoted to Vulkan 1.1
See Also
VkExportFenceCreateInfoKHR, VkFenceImportFlagBitsKHR, VkFenceImportFlagsKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_external_fence

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_external_fence_capabilities(3)
Name
VK_KHR_external_fence_capabilities - instance extension

Specification
See VK_KHR_external_fence_capabilities in the main specification for complete information.

Registered Extension Number
113

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
Deprecation state
Promoted to Vulkan 1.1
See Also
UNKNOWN:VK_LUID_SIZE_KHR, VkExternalFenceFeatureFlagBitsKHR, VkExternalFenceFeatureFlagsKHR, VkExternalFenceHandleTypeFlagBitsKHR, VkExternalFenceHandleTypeFlagsKHR, VkExternalFencePropertiesKHR, VkPhysicalDeviceExternalFenceInfoKHR, VkPhysicalDeviceIDPropertiesKHR, vkGetPhysicalDeviceExternalFencePropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_external_fence_capabilities

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_external_fence_fd(3)
Name
VK_KHR_external_fence_fd - device extension

Specification
See VK_KHR_external_fence_fd in the main specification for complete information.

Registered Extension Number
116

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_external_fence]
See Also
VkFenceGetFdInfoKHR, VkImportFenceFdInfoKHR, vkGetFenceFdKHR, vkImportFenceFdKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_external_fence_fd

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_external_fence_win32(3)
Name
VK_KHR_external_fence_win32 - device extension

Specification
See VK_KHR_external_fence_win32 in the main specification for complete information.

Registered Extension Number
115

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_external_fence]
See Also
VkExportFenceWin32HandleInfoKHR, VkFenceGetWin32HandleInfoKHR, VkImportFenceWin32HandleInfoKHR, vkGetFenceWin32HandleKHR, vkImportFenceWin32HandleKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_external_fence_win32

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_external_memory(3)
Name
VK_KHR_external_memory - device extension

Specification
See VK_KHR_external_memory in the main specification for complete information.

Registered Extension Number
73

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_external_memory_capabilities]
Deprecation state
Promoted to Vulkan 1.1
See Also
UNKNOWN:VK_QUEUE_FAMILY_EXTERNAL_KHR, VkExportMemoryAllocateInfoKHR, VkExternalMemoryBufferCreateInfoKHR, VkExternalMemoryImageCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_external_memory

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_external_memory_capabilities(3)
Name
VK_KHR_external_memory_capabilities - instance extension

Specification
See VK_KHR_external_memory_capabilities in the main specification for complete information.

Registered Extension Number
72

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
Deprecation state
Promoted to Vulkan 1.1
See Also
UNKNOWN:VK_LUID_SIZE_KHR, VkExternalBufferPropertiesKHR, VkExternalImageFormatPropertiesKHR, VkExternalMemoryFeatureFlagBitsKHR, VkExternalMemoryFeatureFlagsKHR, VkExternalMemoryHandleTypeFlagBitsKHR, VkExternalMemoryHandleTypeFlagsKHR, VkExternalMemoryPropertiesKHR, VkPhysicalDeviceExternalBufferInfoKHR, VkPhysicalDeviceExternalImageFormatInfoKHR, VkPhysicalDeviceIDPropertiesKHR, vkGetPhysicalDeviceExternalBufferPropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_external_memory_capabilities

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_external_memory_fd(3)
Name
VK_KHR_external_memory_fd - device extension

Specification
See VK_KHR_external_memory_fd in the main specification for complete information.

Registered Extension Number
75

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_external_memory]
See Also
VkImportMemoryFdInfoKHR, VkMemoryFdPropertiesKHR, VkMemoryGetFdInfoKHR, vkGetMemoryFdKHR, vkGetMemoryFdPropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_external_memory_fd

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_external_memory_win32(3)
Name
VK_KHR_external_memory_win32 - device extension

Specification
See VK_KHR_external_memory_win32 in the main specification for complete information.

Registered Extension Number
74

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_external_memory]
See Also
VkExportMemoryWin32HandleInfoKHR, VkImportMemoryWin32HandleInfoKHR, VkMemoryGetWin32HandleInfoKHR, VkMemoryWin32HandlePropertiesKHR, vkGetMemoryWin32HandleKHR, vkGetMemoryWin32HandlePropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_external_memory_win32

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_external_semaphore(3)
Name
VK_KHR_external_semaphore - device extension

Specification
See VK_KHR_external_semaphore in the main specification for complete information.

Registered Extension Number
78

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_external_semaphore_capabilities]
Deprecation state
Promoted to Vulkan 1.1
See Also
VkExportSemaphoreCreateInfoKHR, VkSemaphoreImportFlagBitsKHR, VkSemaphoreImportFlagsKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_external_semaphore

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_external_semaphore_capabilities(3)
Name
VK_KHR_external_semaphore_capabilities - instance extension

Specification
See VK_KHR_external_semaphore_capabilities in the main specification for complete information.

Registered Extension Number
77

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
Deprecation state
Promoted to Vulkan 1.1
See Also
UNKNOWN:VK_LUID_SIZE_KHR, VkExternalSemaphoreFeatureFlagBitsKHR, VkExternalSemaphoreFeatureFlagsKHR, VkExternalSemaphoreHandleTypeFlagBitsKHR, VkExternalSemaphoreHandleTypeFlagsKHR, VkExternalSemaphorePropertiesKHR, VkPhysicalDeviceExternalSemaphoreInfoKHR, VkPhysicalDeviceIDPropertiesKHR, vkGetPhysicalDeviceExternalSemaphorePropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_external_semaphore_capabilities

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_external_semaphore_fd(3)
Name
VK_KHR_external_semaphore_fd - device extension

Specification
See VK_KHR_external_semaphore_fd in the main specification for complete information.

Registered Extension Number
80

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_external_semaphore]
See Also
VkImportSemaphoreFdInfoKHR, VkSemaphoreGetFdInfoKHR, vkGetSemaphoreFdKHR, vkImportSemaphoreFdKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_external_semaphore_fd

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_external_semaphore_win32(3)
Name
VK_KHR_external_semaphore_win32 - device extension

Specification
See VK_KHR_external_semaphore_win32 in the main specification for complete information.

Registered Extension Number
79

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_external_semaphore]
See Also
VkD3D12FenceSubmitInfoKHR, VkExportSemaphoreWin32HandleInfoKHR, VkImportSemaphoreWin32HandleInfoKHR, VkSemaphoreGetWin32HandleInfoKHR, vkGetSemaphoreWin32HandleKHR, vkImportSemaphoreWin32HandleKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_external_semaphore_win32

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_get_display_properties2(3)
Name
VK_KHR_get_display_properties2 - instance extension

Specification
See VK_KHR_get_display_properties2 in the main specification for complete information.

Registered Extension Number
122

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_display]
See Also
VkDisplayModeProperties2KHR, VkDisplayPlaneCapabilities2KHR, VkDisplayPlaneInfo2KHR, VkDisplayPlaneProperties2KHR, VkDisplayProperties2KHR, vkGetDisplayModeProperties2KHR, vkGetDisplayPlaneCapabilities2KHR, vkGetPhysicalDeviceDisplayPlaneProperties2KHR, vkGetPhysicalDeviceDisplayProperties2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_get_display_properties2

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_get_memory_requirements2(3)
Name
VK_KHR_get_memory_requirements2 - device extension

Specification
See VK_KHR_get_memory_requirements2 in the main specification for complete information.

Registered Extension Number
147

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Promoted to Vulkan 1.1
See Also
VkBufferMemoryRequirementsInfo2KHR, VkImageMemoryRequirementsInfo2KHR, VkImageSparseMemoryRequirementsInfo2KHR, VkMemoryRequirements2KHR, VkSparseImageMemoryRequirements2KHR, vkGetBufferMemoryRequirements2KHR, vkGetImageMemoryRequirements2KHR, vkGetImageSparseMemoryRequirements2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_get_memory_requirements2

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_get_physical_device_properties2(3)
Name
VK_KHR_get_physical_device_properties2 - instance extension

Specification
See VK_KHR_get_physical_device_properties2 in the main specification for complete information.

Registered Extension Number
60

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Promoted to Vulkan 1.1
See Also
VkFormatProperties2KHR, VkImageFormatProperties2KHR, VkPhysicalDeviceFeatures2KHR, VkPhysicalDeviceImageFormatInfo2KHR, VkPhysicalDeviceMemoryProperties2KHR, VkPhysicalDeviceProperties2KHR, VkPhysicalDeviceSparseImageFormatInfo2KHR, VkQueueFamilyProperties2KHR, VkSparseImageFormatProperties2KHR, vkGetPhysicalDeviceFeatures2KHR, vkGetPhysicalDeviceFormatProperties2KHR, vkGetPhysicalDeviceImageFormatProperties2KHR, vkGetPhysicalDeviceMemoryProperties2KHR, vkGetPhysicalDeviceProperties2KHR, vkGetPhysicalDeviceQueueFamilyProperties2KHR, vkGetPhysicalDeviceSparseImageFormatProperties2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_get_physical_device_properties2

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_get_surface_capabilities2(3)
Name
VK_KHR_get_surface_capabilities2 - instance extension

Specification
See VK_KHR_get_surface_capabilities2 in the main specification for complete information.

Registered Extension Number
120

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
VkPhysicalDeviceSurfaceInfo2KHR, VkSurfaceCapabilities2KHR, VkSurfaceFormat2KHR, vkGetPhysicalDeviceSurfaceCapabilities2KHR, vkGetPhysicalDeviceSurfaceFormats2KHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_get_surface_capabilities2

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_image_format_list(3)
Name
VK_KHR_image_format_list - device extension

Specification
See VK_KHR_image_format_list in the main specification for complete information.

Registered Extension Number
148

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkImageFormatListCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_image_format_list

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_incremental_present(3)
Name
VK_KHR_incremental_present - device extension

Specification
See VK_KHR_incremental_present in the main specification for complete information.

Registered Extension Number
85

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_swapchain]
See Also
VkPresentRegionKHR, VkPresentRegionsKHR, VkRectLayerKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_incremental_present

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_maintenance1(3)
Name
VK_KHR_maintenance1 - device extension

Specification
See VK_KHR_maintenance1 in the main specification for complete information.

Registered Extension Number
70

Revision
2

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Promoted to Vulkan 1.1
See Also
VkCommandPoolTrimFlagsKHR, vkTrimCommandPoolKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_maintenance1

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_maintenance2(3)
Name
VK_KHR_maintenance2 - device extension

Specification
See VK_KHR_maintenance2 in the main specification for complete information.

Registered Extension Number
118

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Promoted to Vulkan 1.1
See Also
VkImageViewUsageCreateInfoKHR, VkInputAttachmentAspectReferenceKHR, VkPhysicalDevicePointClippingPropertiesKHR, VkPipelineTessellationDomainOriginStateCreateInfoKHR, VkPointClippingBehaviorKHR, VkRenderPassInputAttachmentAspectCreateInfoKHR, VkTessellationDomainOriginKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_maintenance2

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_maintenance3(3)
Name
VK_KHR_maintenance3 - device extension

Specification
See VK_KHR_maintenance3 in the main specification for complete information.

Registered Extension Number
169

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
Deprecation state
Promoted to Vulkan 1.1
See Also
VkDescriptorSetLayoutSupportKHR, VkPhysicalDeviceMaintenance3PropertiesKHR, vkGetDescriptorSetLayoutSupportKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_maintenance3

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_multiview(3)
Name
VK_KHR_multiview - device extension

Specification
See VK_KHR_multiview in the main specification for complete information.

Registered Extension Number
54

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
Deprecation state
Promoted to Vulkan 1.1
See Also
VkPhysicalDeviceMultiviewFeaturesKHR, VkPhysicalDeviceMultiviewPropertiesKHR, VkRenderPassMultiviewCreateInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_multiview

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_push_descriptor(3)
Name
VK_KHR_push_descriptor - device extension

Specification
See VK_KHR_push_descriptor in the main specification for complete information.

Registered Extension Number
81

Revision
2

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDevicePushDescriptorPropertiesKHR, vkCmdPushDescriptorSetKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_push_descriptor

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_relaxed_block_layout(3)
Name
VK_KHR_relaxed_block_layout - device extension

Specification
See VK_KHR_relaxed_block_layout in the main specification for complete information.

Registered Extension Number
145

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Promoted to Vulkan 1.1
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_relaxed_block_layout

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_sampler_mirror_clamp_to_edge(3)
Name
VK_KHR_sampler_mirror_clamp_to_edge - device extension

Specification
See VK_KHR_sampler_mirror_clamp_to_edge in the main specification for complete information.

Registered Extension Number
15

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_sampler_mirror_clamp_to_edge

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_sampler_ycbcr_conversion(3)
Name
VK_KHR_sampler_ycbcr_conversion - device extension

Specification
See VK_KHR_sampler_ycbcr_conversion in the main specification for complete information.

Registered Extension Number
157

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_maintenance1]
Requires [VK_KHR_bind_memory2]
Requires [VK_KHR_get_memory_requirements2]
Requires [VK_KHR_get_physical_device_properties2]
Deprecation state
Promoted to Vulkan 1.1
See Also
VkBindImagePlaneMemoryInfoKHR, VkChromaLocationKHR, VkImagePlaneMemoryRequirementsInfoKHR, VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR, VkSamplerYcbcrConversionCreateInfoKHR, VkSamplerYcbcrConversionImageFormatPropertiesKHR, VkSamplerYcbcrConversionInfoKHR, VkSamplerYcbcrConversionKHR, VkSamplerYcbcrModelConversionKHR, VkSamplerYcbcrRangeKHR, vkCreateSamplerYcbcrConversionKHR, vkDestroySamplerYcbcrConversionKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_sampler_ycbcr_conversion

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_shader_atomic_int64(3)
Name
VK_KHR_shader_atomic_int64 - device extension

Specification
See VK_KHR_shader_atomic_int64 in the main specification for complete information.

Registered Extension Number
181

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceShaderAtomicInt64FeaturesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_shader_atomic_int64

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_shader_draw_parameters(3)
Name
VK_KHR_shader_draw_parameters - device extension

Specification
See VK_KHR_shader_draw_parameters in the main specification for complete information.

Registered Extension Number
64

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Promoted to Vulkan 1.1
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_shader_draw_parameters

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_shader_float16_int8(3)
Name
VK_KHR_shader_float16_int8 - device extension

Specification
See VK_KHR_shader_float16_int8 in the main specification for complete information.

Registered Extension Number
83

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceFloat16Int8FeaturesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_shader_float16_int8

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_shader_float_controls(3)
Name
VK_KHR_shader_float_controls - device extension

Specification
See VK_KHR_shader_float_controls in the main specification for complete information.

Registered Extension Number
198

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceFloatControlsPropertiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_shader_float_controls

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_shared_presentable_image(3)
Name
VK_KHR_shared_presentable_image - device extension

Specification
See VK_KHR_shared_presentable_image in the main specification for complete information.

Registered Extension Number
112

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_swapchain]
Requires [VK_KHR_get_physical_device_properties2]
Requires [VK_KHR_get_surface_capabilities2]
See Also
VkSharedPresentSurfaceCapabilitiesKHR, vkGetSwapchainStatusKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_shared_presentable_image

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_storage_buffer_storage_class(3)
Name
VK_KHR_storage_buffer_storage_class - device extension

Specification
See VK_KHR_storage_buffer_storage_class in the main specification for complete information.

Registered Extension Number
132

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Promoted to Vulkan 1.1
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_storage_buffer_storage_class

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_surface(3)
Name
VK_KHR_surface - instance extension

Specification
See VK_KHR_surface in the main specification for complete information.

Registered Extension Number
1

Revision
25

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
vkDestroySurfaceKHR, vkGetPhysicalDeviceSurfaceCapabilitiesKHR, vkGetPhysicalDeviceSurfaceFormatsKHR, vkGetPhysicalDeviceSurfacePresentModesKHR, vkGetPhysicalDeviceSurfaceSupportKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_surface

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_surface_protected_capabilities(3)
Name
VK_KHR_surface_protected_capabilities - instance extension

Specification
See VK_KHR_surface_protected_capabilities in the main specification for complete information.

Registered Extension Number
240

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.1
Requires [VK_KHR_get_surface_capabilities2]
See Also
VkSurfaceProtectedCapabilitiesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_surface_protected_capabilities

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_swapchain(3)
Name
VK_KHR_swapchain - device extension

Specification
See VK_KHR_swapchain in the main specification for complete information.

Registered Extension Number
2

Revision
70

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
vkAcquireNextImageKHR, vkCreateSwapchainKHR, vkDestroySwapchainKHR, vkGetSwapchainImagesKHR, vkQueuePresentKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_swapchain

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_swapchain_mutable_format(3)
Name
VK_KHR_swapchain_mutable_format - device extension

Specification
See VK_KHR_swapchain_mutable_format in the main specification for complete information.

Registered Extension Number
201

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_swapchain]
Requires [VK_KHR_maintenance2]
Requires [VK_KHR_image_format_list]
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_swapchain_mutable_format

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_variable_pointers(3)
Name
VK_KHR_variable_pointers - device extension

Specification
See VK_KHR_variable_pointers in the main specification for complete information.

Registered Extension Number
121

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
Requires [VK_KHR_storage_buffer_storage_class]
Deprecation state
Promoted to Vulkan 1.1
See Also
VkPhysicalDeviceVariablePointerFeaturesKHR, VkPhysicalDeviceVariablePointersFeaturesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_variable_pointers

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_vulkan_memory_model(3)
Name
VK_KHR_vulkan_memory_model - device extension

Specification
See VK_KHR_vulkan_memory_model in the main specification for complete information.

Registered Extension Number
212

Revision
3

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkPhysicalDeviceVulkanMemoryModelFeaturesKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_vulkan_memory_model

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_wayland_surface(3)
Name
VK_KHR_wayland_surface - instance extension

Specification
See VK_KHR_wayland_surface in the main specification for complete information.

Registered Extension Number
7

Revision
6

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
VkWaylandSurfaceCreateFlagsKHR, VkWaylandSurfaceCreateInfoKHR, vkCreateWaylandSurfaceKHR, vkGetPhysicalDeviceWaylandPresentationSupportKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_wayland_surface

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_win32_keyed_mutex(3)
Name
VK_KHR_win32_keyed_mutex - device extension

Specification
See VK_KHR_win32_keyed_mutex in the main specification for complete information.

Registered Extension Number
76

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_external_memory_win32]
See Also
VkWin32KeyedMutexAcquireReleaseInfoKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_win32_keyed_mutex

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_win32_surface(3)
Name
VK_KHR_win32_surface - instance extension

Specification
See VK_KHR_win32_surface in the main specification for complete information.

Registered Extension Number
10

Revision
6

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
VkWin32SurfaceCreateFlagsKHR, VkWin32SurfaceCreateInfoKHR, vkCreateWin32SurfaceKHR, vkGetPhysicalDeviceWin32PresentationSupportKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_win32_surface

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_xcb_surface(3)
Name
VK_KHR_xcb_surface - instance extension

Specification
See VK_KHR_xcb_surface in the main specification for complete information.

Registered Extension Number
6

Revision
6

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
VkXcbSurfaceCreateFlagsKHR, VkXcbSurfaceCreateInfoKHR, vkCreateXcbSurfaceKHR, vkGetPhysicalDeviceXcbPresentationSupportKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_xcb_surface

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_KHR_xlib_surface(3)
Name
VK_KHR_xlib_surface - instance extension

Specification
See VK_KHR_xlib_surface in the main specification for complete information.

Registered Extension Number
5

Revision
6

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
VkXlibSurfaceCreateFlagsKHR, VkXlibSurfaceCreateInfoKHR, vkCreateXlibSurfaceKHR, vkGetPhysicalDeviceXlibPresentationSupportKHR

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_xlib_surface

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_acquire_xlib_display(3)
Name
VK_EXT_acquire_xlib_display - instance extension

Specification
See VK_EXT_acquire_xlib_display in the main specification for complete information.

Registered Extension Number
90

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_EXT_direct_mode_display]
See Also
vkAcquireXlibDisplayEXT, vkGetRandROutputDisplayEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_acquire_xlib_display

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_astc_decode_mode(3)
Name
VK_EXT_astc_decode_mode - device extension

Specification
See VK_EXT_astc_decode_mode in the main specification for complete information.

Registered Extension Number
68

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkImageViewASTCDecodeModeEXT, VkPhysicalDeviceASTCDecodeFeaturesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_astc_decode_mode

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_blend_operation_advanced(3)
Name
VK_EXT_blend_operation_advanced - device extension

Specification
See VK_EXT_blend_operation_advanced in the main specification for complete information.

Registered Extension Number
149

Revision
2

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkBlendOverlapEXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPipelineColorBlendAdvancedStateCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_blend_operation_advanced

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_buffer_device_address(3)
Name
VK_EXT_buffer_device_address - device extension

Specification
See VK_EXT_buffer_device_address in the main specification for complete information.

Registered Extension Number
245

Revision
2

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkBufferDeviceAddressCreateInfoEXT, VkBufferDeviceAddressInfoEXT, VkPhysicalDeviceBufferAddressFeaturesEXT, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, vkGetBufferDeviceAddressEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_buffer_device_address

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_calibrated_timestamps(3)
Name
VK_EXT_calibrated_timestamps - device extension

Specification
See VK_EXT_calibrated_timestamps in the main specification for complete information.

Registered Extension Number
185

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkCalibratedTimestampInfoEXT, VkTimeDomainEXT, vkGetCalibratedTimestampsEXT, vkGetPhysicalDeviceCalibrateableTimeDomainsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_calibrated_timestamps

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_conditional_rendering(3)
Name
VK_EXT_conditional_rendering - device extension

Specification
See VK_EXT_conditional_rendering in the main specification for complete information.

Registered Extension Number
82

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkCommandBufferInheritanceConditionalRenderingInfoEXT, VkConditionalRenderingBeginInfoEXT, VkConditionalRenderingFlagBitsEXT, VkConditionalRenderingFlagsEXT, VkPhysicalDeviceConditionalRenderingFeaturesEXT, vkCmdBeginConditionalRenderingEXT, vkCmdEndConditionalRenderingEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_conditional_rendering

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_conservative_rasterization(3)
Name
VK_EXT_conservative_rasterization - device extension

Specification
See VK_EXT_conservative_rasterization in the main specification for complete information.

Registered Extension Number
102

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkConservativeRasterizationModeEXT, VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPipelineRasterizationConservativeStateCreateFlagsEXT, VkPipelineRasterizationConservativeStateCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_conservative_rasterization

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_debug_marker(3)
Name
VK_EXT_debug_marker - device extension

Specification
See VK_EXT_debug_marker in the main specification for complete information.

Registered Extension Number
23

Revision
4

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_EXT_debug_report]
Deprecation state
Promoted to [VK_EXT_debug_utils] extension
See Also
VkDebugMarkerMarkerInfoEXT, VkDebugMarkerObjectNameInfoEXT, VkDebugMarkerObjectTagInfoEXT, VkDebugReportObjectTypeEXT, vkCmdDebugMarkerBeginEXT, vkCmdDebugMarkerEndEXT, vkCmdDebugMarkerInsertEXT, vkDebugMarkerSetObjectNameEXT, vkDebugMarkerSetObjectTagEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_debug_marker

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_debug_report(3)
Name
VK_EXT_debug_report - instance extension

Specification
See VK_EXT_debug_report in the main specification for complete information.

Registered Extension Number
12

Revision
9

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Deprecated by [VK_EXT_debug_utils] extension
See Also
VkDebugReportCallbackCreateInfoEXT, VkDebugReportObjectTypeEXT, vkCreateDebugReportCallbackEXT, vkDebugReportMessageEXT, vkDestroyDebugReportCallbackEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_debug_report

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_debug_utils(3)
Name
VK_EXT_debug_utils - instance extension

Specification
See VK_EXT_debug_utils in the main specification for complete information.

Registered Extension Number
129

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkDebugUtilsLabelEXT, VkDebugUtilsMessengerCallbackDataEXT, VkDebugUtilsMessengerCreateInfoEXT, VkDebugUtilsObjectNameInfoEXT, VkDebugUtilsObjectTagInfoEXT, vkCmdBeginDebugUtilsLabelEXT, vkCmdEndDebugUtilsLabelEXT, vkCmdInsertDebugUtilsLabelEXT, vkCreateDebugUtilsMessengerEXT, vkDestroyDebugUtilsMessengerEXT, vkQueueBeginDebugUtilsLabelEXT, vkQueueEndDebugUtilsLabelEXT, vkQueueInsertDebugUtilsLabelEXT, vkSetDebugUtilsObjectNameEXT, vkSetDebugUtilsObjectTagEXT, vkSubmitDebugUtilsMessageEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_debug_utils

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_depth_clip_enable(3)
Name
VK_EXT_depth_clip_enable - device extension

Specification
See VK_EXT_depth_clip_enable in the main specification for complete information.

Registered Extension Number
103

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkPhysicalDeviceDepthClipEnableFeaturesEXT, VkPipelineRasterizationDepthClipStateCreateFlagsEXT, VkPipelineRasterizationDepthClipStateCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_depth_clip_enable

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_depth_range_unrestricted(3)
Name
VK_EXT_depth_range_unrestricted - device extension

Specification
See VK_EXT_depth_range_unrestricted in the main specification for complete information.

Registered Extension Number
14

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_depth_range_unrestricted

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_descriptor_indexing(3)
Name
VK_EXT_descriptor_indexing - device extension

Specification
See VK_EXT_descriptor_indexing in the main specification for complete information.

Registered Extension Number
162

Revision
2

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
Requires [VK_KHR_maintenance3]
See Also
VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, VkDescriptorSetVariableDescriptorCountLayoutSupportEXT, VkPhysicalDeviceDescriptorIndexingFeaturesEXT, VkPhysicalDeviceDescriptorIndexingPropertiesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_descriptor_indexing

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_direct_mode_display(3)
Name
VK_EXT_direct_mode_display - instance extension

Specification
See VK_EXT_direct_mode_display in the main specification for complete information.

Registered Extension Number
89

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_display]
See Also
vkReleaseDisplayEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_direct_mode_display

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_discard_rectangles(3)
Name
VK_EXT_discard_rectangles - device extension

Specification
See VK_EXT_discard_rectangles in the main specification for complete information.

Registered Extension Number
100

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkDiscardRectangleModeEXT, VkPhysicalDeviceDiscardRectanglePropertiesEXT, VkPipelineDiscardRectangleStateCreateFlagsEXT, VkPipelineDiscardRectangleStateCreateInfoEXT, vkCmdSetDiscardRectangleEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_discard_rectangles

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_display_control(3)
Name
VK_EXT_display_control - device extension

Specification
See VK_EXT_display_control in the main specification for complete information.

Registered Extension Number
92

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_EXT_display_surface_counter]
Requires [VK_KHR_swapchain]
See Also
VkDeviceEventInfoEXT, VkDeviceEventTypeEXT, VkDisplayEventInfoEXT, VkDisplayEventTypeEXT, VkDisplayPowerInfoEXT, VkDisplayPowerStateEXT, VkSwapchainCounterCreateInfoEXT, vkDisplayPowerControlEXT, vkGetSwapchainCounterEXT, vkRegisterDeviceEventEXT, vkRegisterDisplayEventEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_display_control

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_display_surface_counter(3)
Name
VK_EXT_display_surface_counter - instance extension

Specification
See VK_EXT_display_surface_counter in the main specification for complete information.

Registered Extension Number
91

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_display]
See Also
VkSurfaceCapabilities2EXT, VkSurfaceCounterFlagBitsEXT, VkSurfaceCounterFlagsEXT, vkGetPhysicalDeviceSurfaceCapabilities2EXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_display_surface_counter

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_external_memory_dma_buf(3)
Name
VK_EXT_external_memory_dma_buf - device extension

Specification
See VK_EXT_external_memory_dma_buf in the main specification for complete information.

Registered Extension Number
126

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_external_memory_fd]
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_external_memory_dma_buf

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_external_memory_host(3)
Name
VK_EXT_external_memory_host - device extension

Specification
See VK_EXT_external_memory_host in the main specification for complete information.

Registered Extension Number
179

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_external_memory]
See Also
VkExternalMemoryHandleTypeFlagBitsKHR, VkExternalMemoryHandleTypeFlagsKHR, VkImportMemoryHostPointerInfoEXT, VkMemoryHostPointerPropertiesEXT, VkPhysicalDeviceExternalMemoryHostPropertiesEXT, vkGetMemoryHostPointerPropertiesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_external_memory_host

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_filter_cubic(3)
Name
VK_EXT_filter_cubic - device extension

Specification
See VK_EXT_filter_cubic in the main specification for complete information.

Registered Extension Number
171

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_IMG_filter_cubic]
See Also
VkFilterCubicImageViewImageFormatPropertiesEXT, VkPhysicalDeviceImageViewImageFormatInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_filter_cubic

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_fragment_density_map(3)
Name
VK_EXT_fragment_density_map - device extension

Specification
See VK_EXT_fragment_density_map in the main specification for complete information.

Registered Extension Number
219

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceFragmentDensityMapFeaturesEXT, VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkRenderPassFragmentDensityMapCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_fragment_density_map

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_full_screen_exclusive(3)
Name
VK_EXT_full_screen_exclusive - device extension

Specification
See VK_EXT_full_screen_exclusive in the main specification for complete information.

Registered Extension Number
256

Revision
3

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
Requires [VK_KHR_surface]
Requires [VK_KHR_get_surface_capabilities2]
Requires [VK_KHR_swapchain]
See Also
VkFullScreenExclusiveEXT, VkSurfaceCapabilitiesFullScreenExclusiveEXT, VkSurfaceFullScreenExclusiveInfoEXT, vkAcquireFullScreenExclusiveModeEXT, vkGetPhysicalDeviceSurfacePresentModes2EXT, vkReleaseFullScreenExclusiveModeEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_full_screen_exclusive

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_global_priority(3)
Name
VK_EXT_global_priority - device extension

Specification
See VK_EXT_global_priority in the main specification for complete information.

Registered Extension Number
175

Revision
2

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkDeviceQueueGlobalPriorityCreateInfoEXT, VkQueueGlobalPriorityEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_global_priority

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_hdr_metadata(3)
Name
VK_EXT_hdr_metadata - device extension

Specification
See VK_EXT_hdr_metadata in the main specification for complete information.

Registered Extension Number
106

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_swapchain]
See Also
VkHdrMetadataEXT, VkXYColorEXT, vkSetHdrMetadataEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_hdr_metadata

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_host_query_reset(3)
Name
VK_EXT_host_query_reset - device extension

Specification
See VK_EXT_host_query_reset in the main specification for complete information.

Registered Extension Number
262

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceHostQueryResetFeaturesEXT, vkResetQueryPoolEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_host_query_reset

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_image_drm_format_modifier(3)
Name
VK_EXT_image_drm_format_modifier - device extension

Specification
See VK_EXT_image_drm_format_modifier in the main specification for complete information.

Registered Extension Number
159

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_bind_memory2]
Requires [VK_KHR_get_physical_device_properties2]
Requires [VK_KHR_image_format_list]
Requires [VK_KHR_sampler_ycbcr_conversion]
See Also
VkDrmFormatModifierPropertiesEXT, VkDrmFormatModifierPropertiesListEXT, VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT, VkImageDrmFormatModifierPropertiesEXT, VkPhysicalDeviceImageDrmFormatModifierInfoEXT, vkGetImageDrmFormatModifierPropertiesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_image_drm_format_modifier

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_inline_uniform_block(3)
Name
VK_EXT_inline_uniform_block - device extension

Specification
See VK_EXT_inline_uniform_block in the main specification for complete information.

Registered Extension Number
139

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
Requires [VK_KHR_maintenance1]
See Also
VkDescriptorPoolInlineUniformBlockCreateInfoEXT, VkPhysicalDeviceInlineUniformBlockFeaturesEXT, VkPhysicalDeviceInlineUniformBlockPropertiesEXT, VkWriteDescriptorSetInlineUniformBlockEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_inline_uniform_block

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_memory_budget(3)
Name
VK_EXT_memory_budget - device extension

Specification
See VK_EXT_memory_budget in the main specification for complete information.

Registered Extension Number
238

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceMemoryBudgetPropertiesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_memory_budget

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_memory_priority(3)
Name
VK_EXT_memory_priority - device extension

Specification
See VK_EXT_memory_priority in the main specification for complete information.

Registered Extension Number
239

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkMemoryPriorityAllocateInfoEXT, VkPhysicalDeviceMemoryPriorityFeaturesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_memory_priority

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_metal_surface(3)
Name
VK_EXT_metal_surface - instance extension

Specification
See VK_EXT_metal_surface in the main specification for complete information.

Registered Extension Number
218

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
VkMetalSurfaceCreateFlagsEXT, VkMetalSurfaceCreateInfoEXT, vkCreateMetalSurfaceEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_metal_surface

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_pci_bus_info(3)
Name
VK_EXT_pci_bus_info - device extension

Specification
See VK_EXT_pci_bus_info in the main specification for complete information.

Registered Extension Number
213

Revision
2

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDevicePCIBusInfoPropertiesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_pci_bus_info

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_pipeline_creation_feedback(3)
Name
VK_EXT_pipeline_creation_feedback - device extension

Specification
See VK_EXT_pipeline_creation_feedback in the main specification for complete information.

Registered Extension Number
193

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkPipelineCreationFeedbackCreateInfoEXT, VkPipelineCreationFeedbackEXT, VkPipelineCreationFeedbackFlagBitsEXT, VkPipelineCreationFeedbackFlagsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_pipeline_creation_feedback

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_post_depth_coverage(3)
Name
VK_EXT_post_depth_coverage - device extension

Specification
See VK_EXT_post_depth_coverage in the main specification for complete information.

Registered Extension Number
156

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_post_depth_coverage

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_queue_family_foreign(3)
Name
VK_EXT_queue_family_foreign - device extension

Specification
See VK_EXT_queue_family_foreign in the main specification for complete information.

Registered Extension Number
127

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_external_memory]
See Also
UNKNOWN:VK_QUEUE_FAMILY_FOREIGN_EXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_queue_family_foreign

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_sample_locations(3)
Name
VK_EXT_sample_locations - device extension

Specification
See VK_EXT_sample_locations in the main specification for complete information.

Registered Extension Number
144

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkAttachmentSampleLocationsEXT, VkMultisamplePropertiesEXT, VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPipelineSampleLocationsStateCreateInfoEXT, VkRenderPassSampleLocationsBeginInfoEXT, VkSampleLocationEXT, VkSampleLocationsInfoEXT, VkSubpassSampleLocationsEXT, vkCmdSetSampleLocationsEXT, vkGetPhysicalDeviceMultisamplePropertiesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_sample_locations

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_sampler_filter_minmax(3)
Name
VK_EXT_sampler_filter_minmax - device extension

Specification
See VK_EXT_sampler_filter_minmax in the main specification for complete information.

Registered Extension Number
131

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, VkSamplerReductionModeCreateInfoEXT, VkSamplerReductionModeEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_sampler_filter_minmax

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_scalar_block_layout(3)
Name
VK_EXT_scalar_block_layout - device extension

Specification
See VK_EXT_scalar_block_layout in the main specification for complete information.

Registered Extension Number
222

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceScalarBlockLayoutFeaturesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_scalar_block_layout

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_separate_stencil_usage(3)
Name
VK_EXT_separate_stencil_usage - device extension

Specification
See VK_EXT_separate_stencil_usage in the main specification for complete information.

Registered Extension Number
247

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkImageStencilUsageCreateInfoEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_separate_stencil_usage

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_shader_stencil_export(3)
Name
VK_EXT_shader_stencil_export - device extension

Specification
See VK_EXT_shader_stencil_export in the main specification for complete information.

Registered Extension Number
141

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_shader_stencil_export

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_shader_subgroup_ballot(3)
Name
VK_EXT_shader_subgroup_ballot - device extension

Specification
See VK_EXT_shader_subgroup_ballot in the main specification for complete information.

Registered Extension Number
65

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_shader_subgroup_ballot

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_shader_subgroup_vote(3)
Name
VK_EXT_shader_subgroup_vote - device extension

Specification
See VK_EXT_shader_subgroup_vote in the main specification for complete information.

Registered Extension Number
66

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_shader_subgroup_vote

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_shader_viewport_index_layer(3)
Name
VK_EXT_shader_viewport_index_layer - device extension

Specification
See VK_EXT_shader_viewport_index_layer in the main specification for complete information.

Registered Extension Number
163

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_shader_viewport_index_layer

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_swapchain_colorspace(3)
Name
VK_EXT_swapchain_colorspace - instance extension

Specification
See VK_EXT_swapchain_colorspace in the main specification for complete information.

Registered Extension Number
105

Revision
3

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_swapchain_colorspace

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_transform_feedback(3)
Name
VK_EXT_transform_feedback - device extension

Specification
See VK_EXT_transform_feedback in the main specification for complete information.

Registered Extension Number
29

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceTransformFeedbackFeaturesEXT, VkPhysicalDeviceTransformFeedbackPropertiesEXT, VkPipelineRasterizationStateStreamCreateFlagsEXT, VkPipelineRasterizationStateStreamCreateInfoEXT, vkCmdBeginQueryIndexedEXT, vkCmdBeginTransformFeedbackEXT, vkCmdBindTransformFeedbackBuffersEXT, vkCmdDrawIndirectByteCountEXT, vkCmdEndQueryIndexedEXT, vkCmdEndTransformFeedbackEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_transform_feedback

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_validation_cache(3)
Name
VK_EXT_validation_cache - device extension

Specification
See VK_EXT_validation_cache in the main specification for complete information.

Registered Extension Number
161

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkShaderModuleValidationCacheCreateInfoEXT, VkValidationCacheCreateFlagsEXT, VkValidationCacheCreateInfoEXT, VkValidationCacheEXT, VkValidationCacheHeaderVersionEXT, vkCreateValidationCacheEXT, vkDestroyValidationCacheEXT, vkGetValidationCacheDataEXT, vkMergeValidationCachesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_validation_cache

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_validation_features(3)
Name
VK_EXT_validation_features - instance extension

Specification
See VK_EXT_validation_features in the main specification for complete information.

Registered Extension Number
248

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkValidationFeaturesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_validation_features

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_validation_flags(3)
Name
VK_EXT_validation_flags - instance extension

Specification
See VK_EXT_validation_flags in the main specification for complete information.

Registered Extension Number
62

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkValidationFlagsEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_validation_flags

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_vertex_attribute_divisor(3)
Name
VK_EXT_vertex_attribute_divisor - device extension

Specification
See VK_EXT_vertex_attribute_divisor in the main specification for complete information.

Registered Extension Number
191

Revision
3

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, VkPipelineVertexInputDivisorStateCreateInfoEXT, VkVertexInputBindingDivisorDescriptionEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_vertex_attribute_divisor

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_EXT_ycbcr_image_arrays(3)
Name
VK_EXT_ycbcr_image_arrays - device extension

Specification
See VK_EXT_ycbcr_image_arrays in the main specification for complete information.

Registered Extension Number
253

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_sampler_ycbcr_conversion]
See Also
VkPhysicalDeviceYcbcrImageArraysFeaturesEXT

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_ycbcr_image_arrays

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_buffer_marker(3)
Name
VK_AMD_buffer_marker - device extension

Specification
See VK_AMD_buffer_marker in the main specification for complete information.

Registered Extension Number
180

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
vkCmdWriteBufferMarkerAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_buffer_marker

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_display_native_hdr(3)
Name
VK_AMD_display_native_hdr - device extension

Specification
See VK_AMD_display_native_hdr in the main specification for complete information.

Registered Extension Number
214

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
Requires [VK_KHR_get_surface_capabilities2]
Requires [VK_KHR_swapchain]
See Also
VkDisplayNativeHdrSurfaceCapabilitiesAMD, VkSwapchainDisplayNativeHdrCreateInfoAMD, vkSetLocalDimmingAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_display_native_hdr

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_draw_indirect_count(3)
Name
VK_AMD_draw_indirect_count - device extension

Specification
See VK_AMD_draw_indirect_count in the main specification for complete information.

Registered Extension Number
34

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Promoted to [VK_KHR_draw_indirect_count] extension
See Also
vkCmdDrawIndexedIndirectCountAMD, vkCmdDrawIndirectCountAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_draw_indirect_count

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_gcn_shader(3)
Name
VK_AMD_gcn_shader - device extension

Specification
See VK_AMD_gcn_shader in the main specification for complete information.

Registered Extension Number
26

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_gcn_shader

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_gpu_shader_half_float(3)
Name
VK_AMD_gpu_shader_half_float - device extension

Specification
See VK_AMD_gpu_shader_half_float in the main specification for complete information.

Registered Extension Number
37

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_gpu_shader_half_float

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_gpu_shader_int16(3)
Name
VK_AMD_gpu_shader_int16 - device extension

Specification
See VK_AMD_gpu_shader_int16 in the main specification for complete information.

Registered Extension Number
133

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_gpu_shader_int16

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_memory_overallocation_behavior(3)
Name
VK_AMD_memory_overallocation_behavior - device extension

Specification
See VK_AMD_memory_overallocation_behavior in the main specification for complete information.

Registered Extension Number
190

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkDeviceMemoryOverallocationCreateInfoAMD, VkMemoryOverallocationBehaviorAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_memory_overallocation_behavior

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_mixed_attachment_samples(3)
Name
VK_AMD_mixed_attachment_samples - device extension

Specification
See VK_AMD_mixed_attachment_samples in the main specification for complete information.

Registered Extension Number
137

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_mixed_attachment_samples

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_negative_viewport_height(3)
Name
VK_AMD_negative_viewport_height - device extension

Specification
See VK_AMD_negative_viewport_height in the main specification for complete information.

Registered Extension Number
36

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Obsoleted by [VK_KHR_maintenance1] extension
Which in turn was promoted to Vulkan 1.1
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_negative_viewport_height

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_rasterization_order(3)
Name
VK_AMD_rasterization_order - device extension

Specification
See VK_AMD_rasterization_order in the main specification for complete information.

Registered Extension Number
19

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkPipelineRasterizationStateRasterizationOrderAMD, VkRasterizationOrderAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_rasterization_order

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_shader_ballot(3)
Name
VK_AMD_shader_ballot - device extension

Specification
See VK_AMD_shader_ballot in the main specification for complete information.

Registered Extension Number
38

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_shader_ballot

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_shader_core_properties(3)
Name
VK_AMD_shader_core_properties - device extension

Specification
See VK_AMD_shader_core_properties in the main specification for complete information.

Registered Extension Number
186

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceShaderCorePropertiesAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_shader_core_properties

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_shader_explicit_vertex_parameter(3)
Name
VK_AMD_shader_explicit_vertex_parameter - device extension

Specification
See VK_AMD_shader_explicit_vertex_parameter in the main specification for complete information.

Registered Extension Number
22

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_shader_explicit_vertex_parameter

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_shader_fragment_mask(3)
Name
VK_AMD_shader_fragment_mask - device extension

Specification
See VK_AMD_shader_fragment_mask in the main specification for complete information.

Registered Extension Number
138

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_shader_fragment_mask

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_shader_image_load_store_lod(3)
Name
VK_AMD_shader_image_load_store_lod - device extension

Specification
See VK_AMD_shader_image_load_store_lod in the main specification for complete information.

Registered Extension Number
47

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_shader_image_load_store_lod

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_shader_info(3)
Name
VK_AMD_shader_info - device extension

Specification
See VK_AMD_shader_info in the main specification for complete information.

Registered Extension Number
43

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkShaderInfoTypeAMD, VkShaderResourceUsageAMD, VkShaderStatisticsInfoAMD, vkGetShaderInfoAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_shader_info

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_shader_trinary_minmax(3)
Name
VK_AMD_shader_trinary_minmax - device extension

Specification
See VK_AMD_shader_trinary_minmax in the main specification for complete information.

Registered Extension Number
21

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_shader_trinary_minmax

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_AMD_texture_gather_bias_lod(3)
Name
VK_AMD_texture_gather_bias_lod - device extension

Specification
See VK_AMD_texture_gather_bias_lod in the main specification for complete information.

Registered Extension Number
42

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkTextureLODGatherFormatPropertiesAMD

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_AMD_texture_gather_bias_lod

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_ANDROID_external_memory_android_hardware_buffer(3)
Name
VK_ANDROID_external_memory_android_hardware_buffer - device extension

Specification
See VK_ANDROID_external_memory_android_hardware_buffer in the main specification for complete information.

Registered Extension Number
130

Revision
3

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_sampler_ycbcr_conversion]
Requires [VK_KHR_external_memory]
Requires [VK_EXT_queue_family_foreign]
See Also
VkAndroidHardwareBufferFormatPropertiesANDROID, VkAndroidHardwareBufferPropertiesANDROID, VkAndroidHardwareBufferUsageANDROID, VkExternalFormatANDROID, VkImportAndroidHardwareBufferInfoANDROID, VkMemoryGetAndroidHardwareBufferInfoANDROID, vkGetAndroidHardwareBufferPropertiesANDROID, vkGetMemoryAndroidHardwareBufferANDROID

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_ANDROID_external_memory_android_hardware_buffer

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_FUCHSIA_imagepipe_surface(3)
Name
VK_FUCHSIA_imagepipe_surface - instance extension

Specification
See VK_FUCHSIA_imagepipe_surface in the main specification for complete information.

Registered Extension Number
215

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
VkImagePipeSurfaceCreateFlagsFUCHSIA, VkImagePipeSurfaceCreateInfoFUCHSIA, vkCreateImagePipeSurfaceFUCHSIA

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_FUCHSIA_imagepipe_surface

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_GGP_frame_token(3)
Name
VK_GGP_frame_token - device extension

Specification
See VK_GGP_frame_token in the main specification for complete information.

Registered Extension Number
192

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_swapchain]
Requires [VK_GGP_stream_descriptor_surface]
See Also
VkPresentFrameTokenGGP

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_GGP_frame_token

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_GGP_stream_descriptor_surface(3)
Name
VK_GGP_stream_descriptor_surface - instance extension

Specification
See VK_GGP_stream_descriptor_surface in the main specification for complete information.

Registered Extension Number
50

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
VkStreamDescriptorSurfaceCreateFlagsGGP, VkStreamDescriptorSurfaceCreateInfoGGP, vkCreateStreamDescriptorSurfaceGGP

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_GGP_stream_descriptor_surface

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_GOOGLE_decorate_string(3)
Name
VK_GOOGLE_decorate_string - device extension

Specification
See VK_GOOGLE_decorate_string in the main specification for complete information.

Registered Extension Number
225

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_GOOGLE_decorate_string

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_GOOGLE_display_timing(3)
Name
VK_GOOGLE_display_timing - device extension

Specification
See VK_GOOGLE_display_timing in the main specification for complete information.

Registered Extension Number
93

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_swapchain]
See Also
VkPastPresentationTimingGOOGLE, VkPresentTimeGOOGLE, VkPresentTimesInfoGOOGLE, VkRefreshCycleDurationGOOGLE, vkGetPastPresentationTimingGOOGLE, vkGetRefreshCycleDurationGOOGLE

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_GOOGLE_display_timing

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_GOOGLE_hlsl_functionality1(3)
Name
VK_GOOGLE_hlsl_functionality1 - device extension

Specification
See VK_GOOGLE_hlsl_functionality1 in the main specification for complete information.

Registered Extension Number
224

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_GOOGLE_hlsl_functionality1

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_IMG_filter_cubic(3)
Name
VK_IMG_filter_cubic - device extension

Specification
See VK_IMG_filter_cubic in the main specification for complete information.

Registered Extension Number
16

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_IMG_filter_cubic

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_IMG_format_pvrtc(3)
Name
VK_IMG_format_pvrtc - device extension

Specification
See VK_IMG_format_pvrtc in the main specification for complete information.

Registered Extension Number
55

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_IMG_format_pvrtc

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_MVK_ios_surface(3)
Name
VK_MVK_ios_surface - instance extension

Specification
See VK_MVK_ios_surface in the main specification for complete information.

Registered Extension Number
123

Revision
2

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
VkIOSSurfaceCreateFlagsMVK, VkIOSSurfaceCreateInfoMVK, vkCreateIOSSurfaceMVK

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_MVK_ios_surface

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_MVK_macos_surface(3)
Name
VK_MVK_macos_surface - instance extension

Specification
See VK_MVK_macos_surface in the main specification for complete information.

Registered Extension Number
124

Revision
2

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
VkMacOSSurfaceCreateFlagsMVK, VkMacOSSurfaceCreateInfoMVK, vkCreateMacOSSurfaceMVK

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_MVK_macos_surface

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NN_vi_surface(3)
Name
VK_NN_vi_surface - instance extension

Specification
See VK_NN_vi_surface in the main specification for complete information.

Registered Extension Number
63

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_surface]
See Also
VkViSurfaceCreateFlagsNN, VkViSurfaceCreateInfoNN, vkCreateViSurfaceNN

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NN_vi_surface

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NVX_device_generated_commands(3)
Name
VK_NVX_device_generated_commands - device extension

Specification
See VK_NVX_device_generated_commands in the main specification for complete information.

Registered Extension Number
87

Revision
3

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkCmdProcessCommandsInfoNVX, VkCmdReserveSpaceForCommandsInfoNVX, VkDeviceGeneratedCommandsFeaturesNVX, VkDeviceGeneratedCommandsLimitsNVX, VkIndirectCommandsLayoutCreateInfoNVX, VkIndirectCommandsLayoutNVX, VkIndirectCommandsLayoutTokenNVX, VkIndirectCommandsLayoutUsageFlagBitsNVX, VkIndirectCommandsLayoutUsageFlagsNVX, VkIndirectCommandsTokenNVX, VkIndirectCommandsTokenTypeNVX, VkObjectEntryTypeNVX, VkObjectEntryUsageFlagBitsNVX, VkObjectEntryUsageFlagsNVX, VkObjectTableCreateInfoNVX, VkObjectTableDescriptorSetEntryNVX, VkObjectTableEntryNVX, VkObjectTableIndexBufferEntryNVX, VkObjectTableNVX, VkObjectTablePipelineEntryNVX, VkObjectTablePushConstantEntryNVX, VkObjectTableVertexBufferEntryNVX, vkCmdProcessCommandsNVX, vkCmdReserveSpaceForCommandsNVX, vkCreateIndirectCommandsLayoutNVX, vkCreateObjectTableNVX, vkDestroyIndirectCommandsLayoutNVX, vkDestroyObjectTableNVX, vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX, vkRegisterObjectsNVX, vkUnregisterObjectsNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NVX_device_generated_commands

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NVX_image_view_handle(3)
Name
VK_NVX_image_view_handle - device extension

Specification
See VK_NVX_image_view_handle in the main specification for complete information.

Registered Extension Number
31

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkImageViewHandleInfoNVX, vkGetImageViewHandleNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NVX_image_view_handle

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NVX_multiview_per_view_attributes(3)
Name
VK_NVX_multiview_per_view_attributes - device extension

Specification
See VK_NVX_multiview_per_view_attributes in the main specification for complete information.

Registered Extension Number
98

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_multiview]
See Also
VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NVX_multiview_per_view_attributes

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_clip_space_w_scaling(3)
Name
VK_NV_clip_space_w_scaling - device extension

Specification
See VK_NV_clip_space_w_scaling in the main specification for complete information.

Registered Extension Number
88

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkPipelineViewportWScalingStateCreateInfoNV, VkViewportWScalingNV, vkCmdSetViewportWScalingNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_clip_space_w_scaling

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_compute_shader_derivatives(3)
Name
VK_NV_compute_shader_derivatives - device extension

Specification
See VK_NV_compute_shader_derivatives in the main specification for complete information.

Registered Extension Number
202

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceComputeShaderDerivativesFeaturesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_compute_shader_derivatives

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_cooperative_matrix(3)
Name
VK_NV_cooperative_matrix - device extension

Specification
See VK_NV_cooperative_matrix in the main specification for complete information.

Registered Extension Number
250

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkComponentTypeNV, VkCooperativeMatrixPropertiesNV, VkPhysicalDeviceCooperativeMatrixFeaturesNV, VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkScopeNV, vkGetPhysicalDeviceCooperativeMatrixPropertiesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_cooperative_matrix

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_corner_sampled_image(3)
Name
VK_NV_corner_sampled_image - device extension

Specification
See VK_NV_corner_sampled_image in the main specification for complete information.

Registered Extension Number
51

Revision
2

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceCornerSampledImageFeaturesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_corner_sampled_image

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_dedicated_allocation(3)
Name
VK_NV_dedicated_allocation - device extension

Specification
See VK_NV_dedicated_allocation in the main specification for complete information.

Registered Extension Number
27

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Deprecated by [VK_KHR_dedicated_allocation] extension
Which in turn was promoted to Vulkan 1.1
See Also
VkDedicatedAllocationBufferCreateInfoNV, VkDedicatedAllocationImageCreateInfoNV, VkDedicatedAllocationMemoryAllocateInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_dedicated_allocation

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_dedicated_allocation_image_aliasing(3)
Name
VK_NV_dedicated_allocation_image_aliasing - device extension

Specification
See VK_NV_dedicated_allocation_image_aliasing in the main specification for complete information.

Registered Extension Number
241

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_dedicated_allocation]
See Also
VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_dedicated_allocation_image_aliasing

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_device_diagnostic_checkpoints(3)
Name
VK_NV_device_diagnostic_checkpoints - device extension

Specification
See VK_NV_device_diagnostic_checkpoints in the main specification for complete information.

Registered Extension Number
207

Revision
2

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkCheckpointDataNV, VkQueueFamilyCheckpointPropertiesNV, vkCmdSetCheckpointNV, vkGetQueueCheckpointDataNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_device_diagnostic_checkpoints

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_external_memory(3)
Name
VK_NV_external_memory - device extension

Specification
See VK_NV_external_memory in the main specification for complete information.

Registered Extension Number
57

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_NV_external_memory_capabilities]
Deprecation state
Deprecated by [VK_KHR_external_memory] extension
Which in turn was promoted to Vulkan 1.1
See Also
VkExportMemoryAllocateInfoNV, VkExternalMemoryImageCreateInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_external_memory

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_external_memory_capabilities(3)
Name
VK_NV_external_memory_capabilities - instance extension

Specification
See VK_NV_external_memory_capabilities in the main specification for complete information.

Registered Extension Number
56

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Deprecated by [VK_KHR_external_memory_capabilities] extension
Which in turn was promoted to Vulkan 1.1
See Also
VkExternalImageFormatPropertiesNV, VkExternalMemoryFeatureFlagBitsNV, VkExternalMemoryFeatureFlagsNV, VkExternalMemoryHandleTypeFlagBitsNV, VkExternalMemoryHandleTypeFlagsNV, vkGetPhysicalDeviceExternalImageFormatPropertiesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_external_memory_capabilities

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_external_memory_win32(3)
Name
VK_NV_external_memory_win32 - device extension

Specification
See VK_NV_external_memory_win32 in the main specification for complete information.

Registered Extension Number
58

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_NV_external_memory]
Deprecation state
Deprecated by [VK_KHR_external_memory_win32] extension
See Also
VkExportMemoryWin32HandleInfoNV, VkImportMemoryWin32HandleInfoNV, vkGetMemoryWin32HandleNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_external_memory_win32

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_fill_rectangle(3)
Name
VK_NV_fill_rectangle - device extension

Specification
See VK_NV_fill_rectangle in the main specification for complete information.

Registered Extension Number
154

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_fill_rectangle

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_fragment_coverage_to_color(3)
Name
VK_NV_fragment_coverage_to_color - device extension

Specification
See VK_NV_fragment_coverage_to_color in the main specification for complete information.

Registered Extension Number
150

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkPipelineCoverageToColorStateCreateFlagsNV, VkPipelineCoverageToColorStateCreateInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_fragment_coverage_to_color

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_fragment_shader_barycentric(3)
Name
VK_NV_fragment_shader_barycentric - device extension

Specification
See VK_NV_fragment_shader_barycentric in the main specification for complete information.

Registered Extension Number
204

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_fragment_shader_barycentric

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_framebuffer_mixed_samples(3)
Name
VK_NV_framebuffer_mixed_samples - device extension

Specification
See VK_NV_framebuffer_mixed_samples in the main specification for complete information.

Registered Extension Number
153

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkCoverageModulationModeNV, VkPipelineCoverageModulationStateCreateFlagsNV, VkPipelineCoverageModulationStateCreateInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_framebuffer_mixed_samples

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_geometry_shader_passthrough(3)
Name
VK_NV_geometry_shader_passthrough - device extension

Specification
See VK_NV_geometry_shader_passthrough in the main specification for complete information.

Registered Extension Number
96

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_geometry_shader_passthrough

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_glsl_shader(3)
Name
VK_NV_glsl_shader - device extension

Specification
See VK_NV_glsl_shader in the main specification for complete information.

Registered Extension Number
13

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Deprecation state
Deprecated without replacement
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_glsl_shader

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_mesh_shader(3)
Name
VK_NV_mesh_shader - device extension

Specification
See VK_NV_mesh_shader in the main specification for complete information.

Registered Extension Number
203

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkDrawMeshTasksIndirectCommandNV, VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMeshShaderPropertiesNV, vkCmdDrawMeshTasksIndirectCountNV, vkCmdDrawMeshTasksIndirectNV, vkCmdDrawMeshTasksNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_mesh_shader

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_ray_tracing(3)
Name
VK_NV_ray_tracing - device extension

Specification
See VK_NV_ray_tracing in the main specification for complete information.

Registered Extension Number
166

Revision
3

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
Requires [VK_KHR_get_memory_requirements2]
See Also
UNKNOWN:VK_SHADER_UNUSED_NV, VkAccelerationStructureCreateInfoNV, VkAccelerationStructureInfoNV, VkAccelerationStructureMemoryRequirementsInfoNV, VkAccelerationStructureMemoryRequirementsTypeNV, VkAccelerationStructureNV, VkBindAccelerationStructureMemoryInfoNV, VkBuildAccelerationStructureFlagBitsNV, VkBuildAccelerationStructureFlagsNV, VkCopyAccelerationStructureModeNV, VkGeometryAABBNV, VkGeometryDataNV, VkGeometryFlagBitsNV, VkGeometryFlagsNV, VkGeometryInstanceFlagBitsNV, VkGeometryInstanceFlagsNV, VkGeometryNV, VkGeometryTrianglesNV, VkGeometryTypeNV, VkMemoryRequirements2KHR, VkPhysicalDeviceRayTracingPropertiesNV, VkRayTracingPipelineCreateInfoNV, VkRayTracingShaderGroupCreateInfoNV, VkRayTracingShaderGroupTypeNV, VkWriteDescriptorSetAccelerationStructureNV, vkBindAccelerationStructureMemoryNV, vkCmdBuildAccelerationStructureNV, vkCmdCopyAccelerationStructureNV, vkCmdTraceRaysNV, vkCmdWriteAccelerationStructuresPropertiesNV, vkCompileDeferredNV, vkCreateAccelerationStructureNV, vkCreateRayTracingPipelinesNV, vkDestroyAccelerationStructureNV, vkGetAccelerationStructureHandleNV, vkGetAccelerationStructureMemoryRequirementsNV, vkGetRayTracingShaderGroupHandlesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_ray_tracing

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_representative_fragment_test(3)
Name
VK_NV_representative_fragment_test - device extension

Specification
See VK_NV_representative_fragment_test in the main specification for complete information.

Registered Extension Number
167

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, VkPipelineRepresentativeFragmentTestStateCreateInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_representative_fragment_test

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_sample_mask_override_coverage(3)
Name
VK_NV_sample_mask_override_coverage - device extension

Specification
See VK_NV_sample_mask_override_coverage in the main specification for complete information.

Registered Extension Number
95

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_sample_mask_override_coverage

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_scissor_exclusive(3)
Name
VK_NV_scissor_exclusive - device extension

Specification
See VK_NV_scissor_exclusive in the main specification for complete information.

Registered Extension Number
206

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPipelineViewportExclusiveScissorStateCreateInfoNV, vkCmdSetExclusiveScissorNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_scissor_exclusive

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_shader_image_footprint(3)
Name
VK_NV_shader_image_footprint - device extension

Specification
See VK_NV_shader_image_footprint in the main specification for complete information.

Registered Extension Number
205

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkPhysicalDeviceShaderImageFootprintFeaturesNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_shader_image_footprint

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_shader_subgroup_partitioned(3)
Name
VK_NV_shader_subgroup_partitioned - device extension

Specification
See VK_NV_shader_subgroup_partitioned in the main specification for complete information.

Registered Extension Number
199

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.1
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_shader_subgroup_partitioned

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_shading_rate_image(3)
Name
VK_NV_shading_rate_image - device extension

Specification
See VK_NV_shading_rate_image in the main specification for complete information.

Registered Extension Number
165

Revision
3

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_KHR_get_physical_device_properties2]
See Also
VkCoarseSampleLocationNV, VkCoarseSampleOrderCustomNV, VkCoarseSampleOrderTypeNV, VkPhysicalDeviceShadingRateImageFeaturesNV, VkPhysicalDeviceShadingRateImagePropertiesNV, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, VkPipelineViewportShadingRateImageStateCreateInfoNV, VkShadingRatePaletteEntryNV, VkShadingRatePaletteNV, vkCmdBindShadingRateImageNV, vkCmdSetCoarseSampleOrderNV, vkCmdSetViewportShadingRatePaletteNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_shading_rate_image

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_viewport_array2(3)
Name
VK_NV_viewport_array2 - device extension

Specification
See VK_NV_viewport_array2 in the main specification for complete information.

Registered Extension Number
97

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
No cross-references are available

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_viewport_array2

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_viewport_swizzle(3)
Name
VK_NV_viewport_swizzle - device extension

Specification
See VK_NV_viewport_swizzle in the main specification for complete information.

Registered Extension Number
99

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
See Also
VkPipelineViewportSwizzleStateCreateFlagsNV, VkPipelineViewportSwizzleStateCreateInfoNV, VkViewportCoordinateSwizzleNV, VkViewportSwizzleNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_viewport_swizzle

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.

VK_NV_win32_keyed_mutex(3)
Name
VK_NV_win32_keyed_mutex - device extension

Specification
See VK_NV_win32_keyed_mutex in the main specification for complete information.

Registered Extension Number
59

Revision
1

Extension and Version Dependencies
Requires Vulkan 1.0
Requires [VK_NV_external_memory_win32]
Deprecation state
Promoted to [VK_KHR_win32_keyed_mutex] extension
See Also
VkWin32KeyedMutexAcquireReleaseInfoNV

Document Notes
For more information, see the Vulkan Specification at URL

https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_win32_keyed_mutex

This page is a generated document. Fixes and changes should be made to the generator scripts, not directly